using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;
using ReLogic.Utilities;
using Terraria.Audio;
using Terraria.Chat;
using Terraria.DataStructures;
using Terraria.Enums;
using Terraria.GameContent;
using Terraria.GameContent.Achievements;
using Terraria.GameContent.Creative;
using Terraria.GameContent.Drawing;
using Terraria.GameContent.Events;
using Terraria.GameContent.Golf;
using Terraria.GameContent.ItemDropRules;
using Terraria.GameContent.Items;
using Terraria.GameContent.ObjectInteractions;
using Terraria.GameContent.Tile_Entities;
using Terraria.GameContent.UI;
using Terraria.GameInput;
using Terraria.Graphics;
using Terraria.Graphics.Capture;
using Terraria.Graphics.Effects;
using Terraria.Graphics.Shaders;
using Terraria.ID;
using Terraria.IO;
using Terraria.Localization;
using Terraria.ModLoader;
using Terraria.ModLoader.Default;
using Terraria.ModLoader.Exceptions;
using Terraria.ModLoader.IO;
using Terraria.ModLoader.UI;
using Terraria.ObjectData;
using Terraria.Social;
using Terraria.Social.Steam;
using Terraria.UI;
using Terraria.UI.Chat;
using Terraria.UI.Gamepad;
using Terraria.Utilities;
using Terraria.WorldBuilding;

namespace Terraria;

public class Player : Entity, IFixLoadedData, IEntityWithInstances<ModPlayer>
{
	public static class BuilderAccToggleIDs
	{
		public const int RulerLine = 0;

		public const int RulerGrid = 1;

		public const int AutoActuate = 2;

		public const int AutoPaint = 3;

		public const int WireVisibility_Red = 4;

		public const int WireVisibility_Green = 5;

		public const int WireVisibility_Blue = 6;

		public const int WireVisibility_Yellow = 7;

		public const int HideAllWires = 8;

		public const int WireVisibility_Actuators = 9;

		public const int BlockSwap = 10;

		public const int TorchBiome = 11;

		public static readonly int Count = 12;
	}

	public struct DirectionalInputSyncCache
	{
		public bool controlLeft;

		public bool controlRight;

		public bool controlUp;

		public bool controlDown;

		public DirectionalInputSyncCache(Player player)
		{
			controlLeft = player.controlLeft;
			controlRight = player.controlRight;
			controlUp = player.controlUp;
			controlDown = player.controlDown;
		}

		public void ApplyTo(Player player)
		{
			player.controlLeft = controlLeft;
			player.controlRight = controlRight;
			player.controlUp = controlUp;
			player.controlDown = controlDown;
		}
	}

	private struct ChannelCancelKey
	{
		public int ProjectileTypeExpected;

		public int ProjectileIndexExpected;

		public bool Matches(Projectile projectile)
		{
			if (ProjectileTypeExpected == projectile.type)
			{
				return ProjectileIndexExpected == projectile.whoAmI;
			}
			return false;
		}

		public void TryTracking(Projectile projectile)
		{
			if (ProjectileTypeExpected == projectile.type)
			{
				ProjectileIndexExpected = projectile.whoAmI;
			}
		}
	}

	public struct RabbitOrderFrameHelper
	{
		public int DisplayFrame;

		private int _frameCounter;

		private int _aiState;

		private const int AIState_Idle = 0;

		private const int AIState_LookingAtCamera = 1;

		private const int AIState_Resting = 2;

		private const int AIState_EatingCarrot = 3;

		public void Update()
		{
			switch (_aiState)
			{
			case 0:
				UpdateFrame(0, 0, Main.rand.Next(1, 4), Main.rand.Next(180, 3600));
				break;
			case 1:
				UpdateFrame(7, 9, 0, 20);
				break;
			case 2:
			{
				int gameFramesPerDisplayFrame = 8;
				if (DisplayFrame == 13)
				{
					gameFramesPerDisplayFrame = 120;
				}
				UpdateFrame(10, 16, 0, gameFramesPerDisplayFrame);
				break;
			}
			case 3:
				UpdateFrame(17, 26, 0, 4);
				break;
			}
		}

		public void Reset()
		{
			ChangeToAIState(0);
		}

		private void ChangeToAIState(int aiState)
		{
			_aiState = aiState;
			_frameCounter = 0;
			Update();
		}

		private void UpdateFrame(int displayFrameMin, int displayFrameMax, int exitAIState, int gameFramesPerDisplayFrame)
		{
			DisplayFrame = Utils.Clamp(DisplayFrame, displayFrameMin, displayFrameMax);
			if (_frameCounter++ >= gameFramesPerDisplayFrame)
			{
				_frameCounter = 0;
				if (DisplayFrame++ >= displayFrameMax)
				{
					ChangeToAIState(exitAIState);
				}
			}
		}
	}

	public enum CompositeArmStretchAmount
	{
		Full,
		None,
		Quarter,
		ThreeQuarters
	}

	public struct CompositeArmData
	{
		public bool enabled;

		public CompositeArmStretchAmount stretch;

		public float rotation;

		public CompositeArmData(bool enabled, CompositeArmStretchAmount intendedStrech, float rotation)
		{
			this.enabled = enabled;
			stretch = intendedStrech;
			this.rotation = rotation;
		}
	}

	public delegate void DashStartAction(int dashDirection);

	public struct SetMatchRequest
	{
		public int Head;

		public int Body;

		public int Legs;

		public int ArmorSlotRequested;

		public bool Male;
	}

	public struct ItemSpaceStatus
	{
		public readonly bool CanTakeItem;

		public readonly bool ItemIsGoingToVoidVault;

		public bool CanTakeItemToPersonalInventory
		{
			get
			{
				if (CanTakeItem)
				{
					return !ItemIsGoingToVoidVault;
				}
				return false;
			}
		}

		public ItemSpaceStatus(bool CanTakeItem, bool ItemIsGoingToVoidVault = false)
		{
			this.CanTakeItem = CanTakeItem;
			this.ItemIsGoingToVoidVault = ItemIsGoingToVoidVault;
		}
	}

	public struct ItemCheckContext
	{
		public bool SkipItemConsumption;
	}

	private struct SpecialToolUsageSettings
	{
		public delegate bool CanUseToolCondition(Player user, Item item, int targetX, int targetY);

		public delegate void UseToolAction(Player user, Item item, int targetX, int targetY);

		public bool IsAValidTool;

		public CanUseToolCondition UsageCondition;

		public UseToolAction UsageAction;
	}

	public class SavedPlayerDataWithAnnoyingRules
	{
		public bool godmodePowerEnabled;

		public bool farPlacementRangePowerEnabled;

		public float spawnRatePowerSliderValue;
	}

	public class RandomTeleportationAttemptSettings
	{
		public bool mostlySolidFloor;

		public bool avoidLava;

		public bool avoidAnyLiquid;

		public bool avoidHurtTiles;

		public bool avoidWalls;

		public int attemptsBeforeGivingUp;

		public int maximumFallDistanceFromOrignalPoint;
	}

	public static class Hooks
	{
		public static event Action<Player> OnEnterWorld;

		public static void PlayerConnect(int playerIndex)
		{
			PressurePlateHelper.ResetPlayer(playerIndex);
			PlayerLoader.PlayerConnect(playerIndex);
		}

		public static void PlayerDisconnect(int playerIndex)
		{
			PressurePlateHelper.ResetPlayer(playerIndex);
			PlayerLoader.PlayerDisconnect(playerIndex);
		}

		public static void EnterWorld(int playerIndex)
		{
			Logging.Terraria.InfoFormat("Entering world with player: {0}, IsCloud={1}, Width: {2}, Height: {3}, Evil: {4}, GameMode: {5}", new object[6]
			{
				Main.ActivePlayerFileData.Name,
				Main.ActivePlayerFileData.IsCloudSave,
				Main.maxTilesX,
				Main.maxTilesY,
				WorldGen.crimson.ToInt(),
				Main.GameMode
			});
			Interface.ResetData();
			if (Hooks.OnEnterWorld != null)
			{
				Hooks.OnEnterWorld(Main.player[playerIndex]);
			}
			PlayerLoader.OnEnterWorld(playerIndex);
			if (playerIndex == Main.myPlayer)
			{
				Main.ToggleGameplayUpdates(state: true);
				SteamedWraps.BeginPlaytimeTracking();
			}
		}
	}

	public class SmartCursorSettings
	{
		public static bool SmartBlocksEnabled;

		public static bool SmartAxeAfterPickaxe;

		public static bool SmartCursorHoldCanReleaseMidUse;
	}

	public class Settings
	{
		public enum HoverControlMode
		{
			Hold,
			Click
		}

		public static HoverControlMode HoverControl;

		public static void CycleHoverControl()
		{
			switch (HoverControl)
			{
			case HoverControlMode.Hold:
				HoverControl = HoverControlMode.Click;
				break;
			case HoverControlMode.Click:
				HoverControl = HoverControlMode.Hold;
				break;
			}
		}
	}

	public class SelectionRadial
	{
		public enum SelectionMode
		{
			Dpad4,
			RadialCircular,
			RadialQuicks
		}

		private int _SelectedBinding = -1;

		public int RadialCount;

		public int[] Bindings;

		public SelectionMode Mode;

		public int SelectedBinding => _SelectedBinding;

		public int SelectedItem
		{
			get
			{
				if (_SelectedBinding == -1)
				{
					return -1;
				}
				return Bindings[_SelectedBinding];
			}
		}

		public SelectionRadial(SelectionMode mode = SelectionMode.Dpad4)
		{
			Mode = mode;
			int radialCount = 0;
			switch (mode)
			{
			case SelectionMode.Dpad4:
				radialCount = 4;
				break;
			case SelectionMode.RadialCircular:
				radialCount = 10;
				break;
			case SelectionMode.RadialQuicks:
				radialCount = 4;
				break;
			}
			RadialCount = radialCount;
			Bindings = new int[RadialCount];
			for (int i = 0; i < RadialCount; i++)
			{
				Bindings[i] = -1;
			}
		}

		public void Update()
		{
			//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0102: Unknown result type (might be due to invalid IL or missing references)
			//IL_0104: Unknown result type (might be due to invalid IL or missing references)
			//IL_0109: Unknown result type (might be due to invalid IL or missing references)
			//IL_0118: Unknown result type (might be due to invalid IL or missing references)
			//IL_0127: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			//IL_012f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_0146: Unknown result type (might be due to invalid IL or missing references)
			//IL_018f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0190: Unknown result type (might be due to invalid IL or missing references)
			switch (Mode)
			{
			case SelectionMode.Dpad4:
				if (PlayerInput.Triggers.JustPressed.DpadRadial1)
				{
					ChangeSelection(0);
				}
				if (PlayerInput.Triggers.JustPressed.DpadRadial2)
				{
					ChangeSelection(1);
				}
				if (PlayerInput.Triggers.JustPressed.DpadRadial3)
				{
					ChangeSelection(2);
				}
				if (PlayerInput.Triggers.JustPressed.DpadRadial4)
				{
					ChangeSelection(3);
				}
				break;
			case SelectionMode.RadialCircular:
			case SelectionMode.RadialQuicks:
			{
				for (int i = 0; i < RadialCount; i++)
				{
					Bindings[i] = i;
				}
				if ((Mode != SelectionMode.RadialCircular || !PlayerInput.Triggers.Current.RadialHotbar) && (Mode != SelectionMode.RadialQuicks || !PlayerInput.Triggers.Current.RadialQuickbar))
				{
					break;
				}
				bool flag = Mode == SelectionMode.RadialCircular;
				float num = (float)Math.PI * 2f / (float)RadialCount / 2f;
				Vector2 vector = PlayerInput.GamepadThumbstickRight.RotatedBy(-(float)Math.PI / 2f + num);
				if (((Vector2)(ref vector)).Length() == 0f)
				{
					vector = PlayerInput.GamepadThumbstickLeft.RotatedBy(-(float)Math.PI / 2f + num);
				}
				int num2 = -1;
				if (((Vector2)(ref vector)).Length() > 0.3f)
				{
					num2 = (int)((vector.ToRotation() + (float)Math.PI) / ((float)Math.PI * 2f / (float)RadialCount));
					if (num2 >= RadialCount)
					{
						num2 -= RadialCount;
					}
				}
				if ((num2 != -1 || !flag) && _SelectedBinding != num2 && (num2 != -1 || !(vector != Vector2.Zero)))
				{
					ChangeSelection(num2);
				}
				break;
			}
			}
		}

		public void ChangeBinding(int itemSlot)
		{
			if (itemSlot >= 0 && itemSlot < 50 && Mode == SelectionMode.Dpad4)
			{
				if (PlayerInput.Triggers.JustPressed.DpadRadial1)
				{
					Bind(itemSlot, 0);
				}
				if (PlayerInput.Triggers.JustPressed.DpadRadial2)
				{
					Bind(itemSlot, 1);
				}
				if (PlayerInput.Triggers.JustPressed.DpadRadial3)
				{
					Bind(itemSlot, 2);
				}
				if (PlayerInput.Triggers.JustPressed.DpadRadial4)
				{
					Bind(itemSlot, 3);
				}
			}
		}

		public void ChangeSelection(int to)
		{
			if (_SelectedBinding == to)
			{
				_SelectedBinding = -1;
			}
			else
			{
				_SelectedBinding = to;
			}
		}

		private void Bind(int itemslot, int radialslot)
		{
			ChangeSelection(-1);
			if (Bindings[radialslot] == itemslot)
			{
				Bindings[radialslot] = -1;
				return;
			}
			for (int i = 0; i < RadialCount; i++)
			{
				if (Bindings[i] == itemslot)
				{
					Bindings[i] = -1;
				}
			}
			Bindings[radialslot] = itemslot;
		}

		public int GetDrawMode(int itemslot)
		{
			if (SelectedBinding != -1 && Bindings[SelectedBinding] == itemslot)
			{
				return 2;
			}
			for (int i = 0; i < RadialCount; i++)
			{
				if (Bindings[i] == itemslot)
				{
					return 1;
				}
			}
			return 0;
		}

		public void CopyTo(SelectionRadial that)
		{
			that._SelectedBinding = _SelectedBinding;
			that.Mode = Mode;
			that.RadialCount = RadialCount;
			Array.Resize(ref that.Bindings, RadialCount);
			for (int i = 0; i < RadialCount; i++)
			{
				that.Bindings[i] = Bindings[i];
			}
		}
	}

	public struct OverheadMessage
	{
		public string chatText;

		public TextSnippet[] snippets;

		public Vector2 messageSize;

		public int timeLeft;

		public Color color;

		public void NewMessage(string message, int displayTime)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			chatText = message;
			snippets = ChatManager.ParseMessage(chatText, Color.White).ToArray();
			messageSize = ChatManager.GetStringSize(FontAssets.MouseText.Value, snippets, Vector2.One);
			timeLeft = displayTime;
		}
	}

	public struct HurtModifiers
	{
		public delegate void HurtInfoModifier(ref HurtInfo info);

		/// <summary>
		/// Use this to enhance or scale the base damage of the NPC/projectile/hit. <br />
		/// <br />
		/// Not used by vanilla due to lack of proper pvp support. <br />
		/// Use cases are similar to <see cref="F:Terraria.NPC.HitModifiers.SourceDamage" /> <br />
		/// </summary>
		public StatModifier SourceDamage;

		/// <summary>
		/// Use this to reduce damage from certain sources before applying defense. <br />
		/// Used by vanilla for coldResist and banner damage reduction.
		/// </summary>
		public MultipliableFloat IncomingDamageMultiplier;

		/// <summary>
		/// Applied to the final damage result. <br />
		/// Used by <see cref="F:Terraria.Player.endurance" /> to reduce overall incoming damage. <br />
		/// <br />
		/// Multiply to grant damage reduction buffs (eg *0.9f for -10% damage taken). <br />
		/// Add to <see cref="F:Terraria.ModLoader.StatModifier.Base" /> to deal damage which ignores armor, but still respects scaling damage reduction like endurance or paladins shield. <br />
		/// Adding to <see cref="F:Terraria.ModLoader.StatModifier.Flat" /> will ignore all reductions or increases to deal unconditional damage. Not recommended due to potential compatibility issues with accessories like paladin's shield, use <see cref="F:Terraria.ModLoader.StatModifier.Base" /> instead.
		/// </summary>
		public StatModifier FinalDamage;

		/// <summary>
		/// Flat defense reduction. Applies after <see cref="F:Terraria.Player.HurtModifiers.ScalingArmorPenetration" />. <br />
		/// <br />
		/// Consider supplying armorPenetration as an argument to <see cref="M:Terraria.Player.Hurt(Terraria.DataStructures.PlayerDeathReason,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Int32,System.Boolean,System.Single,System.Single,System.Single)" /> instead if possible.<br />
		/// </summary>
		public AddableFloat ArmorPenetration;

		/// <summary>
		/// Used to ignore a fraction of player defense. Applies before flat <see cref="F:Terraria.Player.HurtModifiers.ArmorPenetration" />. <br />
		/// <br />
		/// At 1f, the attack will completely ignore all defense.
		/// </summary>
		public AddableFloat ScalingArmorPenetration;

		private int _damageLimit;

		/// <summary>
		/// Modifiers to apply to the knockback.
		/// Add to <see cref="F:Terraria.ModLoader.StatModifier.Base" /> to increase the knockback of the strike.
		/// Multiply to decrease or increase overall knockback susceptibility.
		/// </summary>
		public StatModifier Knockback;

		/// <summary>
		/// Use this to reduce the effectiveness of <see cref="F:Terraria.Player.noKnockback" /> (cobalt shield accessory). <br />
		/// Eg, *0.8f to reduce knockback to 20% when cobalt shield is equipped. <br />
		/// Defaults to 1f (knockback immunity is 100% effective by default). <br />
		/// Used by vanilla for the ogre's launching attack. <br />
		/// </summary>
		public MultipliableFloat KnockbackImmunityEffectiveness;

		private bool _dustDisabled;

		private bool _soundDisabled;

		/// <summary>
		/// The source of the strike. <br />
		/// Use <see cref="M:Terraria.DataStructures.PlayerDeathReason.TryGetCausingEntity(Terraria.Entity@)" /> to get the source of the strike (only safe to do when the target is the local player).
		/// </summary>
		public PlayerDeathReason DamageSource { get; init; }

		/// <summary>
		/// Whether or not this strike came from another player. <br />
		/// Note that PvP support in Terraria is rudimentary and inconsistent, so careful research and testing may be required.
		/// </summary>
		public bool PvP { get; init; }

		/// <summary>
		/// The <see cref="T:Terraria.ID.ImmunityCooldownID" /> of the strike
		/// </summary>
		public int CooldownCounter { get; init; }

		/// <summary>
		/// Whether or not this strike was dodgeable.
		/// </summary>
		public bool Dodgeable { get; init; }

		/// <summary>
		/// The direction to apply knockback. If 0, no knockback will be applied. <br />
		/// Could potentially be used for directional resistances. <br />
		/// Can be overridden by <see cref="P:Terraria.Player.HurtModifiers.HitDirectionOverride" />
		/// </summary>
		public int HitDirection { get; init; }

		/// <summary>
		/// Overrides the direction to apply knockback. <br />
		/// Will not affect <see cref="P:Terraria.Player.HurtModifiers.HitDirection" />, only the final <see cref="F:Terraria.Player.HurtInfo.HitDirection" /><br />
		/// If set by multiple mods, only the last override will apply. <br />
		/// Intended for use by attacks which want to hit the player towards the source of the attack.
		/// </summary>
		public int? HitDirectionOverride { private get; set; }

		/// <summary>
		/// Use with caution and consider other alternatives first.<br />
		/// Can be used to register a callback to freely modify the <see cref="T:Terraria.Player.HurtInfo" /> produced by <see cref="M:Terraria.Player.HurtModifiers.ToHurtInfo(System.Int32,System.Int32,System.Single,System.Single,System.Boolean)" /> before it is returned<br />
		/// If multiple mods register different callbacks which modify the hurt info in different ways the results could be a mess!
		/// </summary>
		public event HurtInfoModifier ModifyHurtInfo;

		/// <summary>
		/// Sets an inclusive upper bound on the final damage of the hit. <br />
		/// Can be set by multiple mods, in which case the lowest limit will be used. <br />
		/// Cannot be set to less than 1
		/// </summary>
		public void SetMaxDamage(int limit)
		{
			_damageLimit = Math.Min(_damageLimit, Math.Max(limit, 1));
		}

		/// <summary>
		/// Prevents dust from spawning
		/// </summary>
		public void DisableDust()
		{
			_dustDisabled = true;
		}

		/// <summary>
		/// Prevents the hurt sound from playing
		/// </summary>
		public void DisableSound()
		{
			_soundDisabled = true;
		}

		public HurtModifiers()
		{
			DamageSource = null;
			PvP = false;
			CooldownCounter = -1;
			Dodgeable = true;
			HitDirection = 0;
			SourceDamage = new StatModifier();
			IncomingDamageMultiplier = new MultipliableFloat();
			FinalDamage = new StatModifier();
			ArmorPenetration = default(AddableFloat);
			ScalingArmorPenetration = default(AddableFloat);
			_damageLimit = int.MaxValue;
			Knockback = new StatModifier();
			HitDirectionOverride = null;
			KnockbackImmunityEffectiveness = new MultipliableFloat();
			_dustDisabled = false;
			_soundDisabled = false;
			this.ModifyHurtInfo = null;
		}

		public float GetDamage(float baseDamage, float defense, float defenseEffectiveness)
		{
			float damage = SourceDamage.ApplyTo(baseDamage) * IncomingDamageMultiplier.Value;
			float armorPenetration = defense * Math.Clamp(ScalingArmorPenetration.Value, 0f, 1f) + ArmorPenetration.Value;
			defense = Math.Max(defense - armorPenetration, 0f);
			float damageReduction = defense * defenseEffectiveness;
			damage = Math.Max(damage - damageReduction, 1f);
			return Math.Clamp((int)FinalDamage.ApplyTo(damage), 1, _damageLimit);
		}

		public float GetKnockback(float baseKnockback, bool knockbackImmune)
		{
			float knockback = Math.Max(Knockback.ApplyTo(baseKnockback), 0f);
			if (knockbackImmune)
			{
				knockback *= 1f - Math.Clamp(KnockbackImmunityEffectiveness.Value, 0f, 1f);
			}
			return knockback;
		}

		public HurtInfo ToHurtInfo(int damage, int defense, float defenseEffectiveness, float knockback, bool knockbackImmune)
		{
			HurtInfo hurtInfo2 = new HurtInfo();
			hurtInfo2.DamageSource = DamageSource;
			hurtInfo2.PvP = PvP;
			hurtInfo2.CooldownCounter = CooldownCounter;
			hurtInfo2.Dodgeable = Dodgeable;
			hurtInfo2.HitDirection = HitDirectionOverride ?? HitDirection;
			hurtInfo2.SourceDamage = (int)SourceDamage.ApplyTo(damage);
			hurtInfo2.Damage = (int)GetDamage(damage, defense, defenseEffectiveness);
			hurtInfo2.Knockback = GetKnockback(knockback, knockbackImmune);
			hurtInfo2.DustDisabled = _dustDisabled;
			hurtInfo2.SoundDisabled = _soundDisabled;
			HurtInfo hurtInfo = hurtInfo2;
			this.ModifyHurtInfo?.Invoke(ref hurtInfo);
			this.ModifyHurtInfo = null;
			return hurtInfo;
		}
	}

	public struct HurtInfo
	{
		/// <summary>
		/// <inheritdoc cref="P:Terraria.Player.HurtModifiers.DamageSource" />
		/// </summary>
		public PlayerDeathReason DamageSource;

		/// <summary>
		/// <inheritdoc cref="P:Terraria.Player.HurtModifiers.PvP" />
		/// </summary>
		public bool PvP;

		/// <summary>
		/// <inheritdoc cref="P:Terraria.Player.HurtModifiers.CooldownCounter" />
		/// </summary>
		public int CooldownCounter;

		/// <summary>
		/// <inheritdoc cref="P:Terraria.Player.HurtModifiers.Dodgeable" />
		/// </summary>
		public bool Dodgeable;

		private int _sourceDamage;

		private int _damage;

		/// <summary>
		/// <inheritdoc cref="P:Terraria.Player.HurtModifiers.HitDirection" />
		/// </summary>
		public int HitDirection;

		/// <summary>
		/// The amount of knockback to apply. Should always be &gt;= 0.
		/// </summary>
		public float Knockback;

		/// <summary>
		/// If true, dust will not spawn
		/// </summary>
		public bool DustDisabled;

		/// <summary>
		/// If true, sound will not play
		/// </summary>
		public bool SoundDisabled;

		/// <summary>
		/// The amount of damage 'dealt' to the player, before incoming damage multipliers, armor, damage reduction.<br />
		/// Use this to trigger effects which scale based on how 'hard' the player was hit rather than how much life was lost.<br />
		/// Cannot be set to less than 1.<br />
		/// <br />
		/// Using this instead of <see cref="P:Terraria.Player.HurtInfo.Damage" /> can prevent diminishing returns damage mitigation, when adding beneficial effects like retaliatory damage.
		/// </summary>
		public int SourceDamage
		{
			readonly get
			{
				return _sourceDamage;
			}
			set
			{
				_sourceDamage = Math.Max(value, 1);
			}
		}

		/// <summary>
		/// The amount of damage received by the player. How much life the player will lose. <br />
		/// Is NOT capped at the player's current life.<br />
		/// Cannot be set to less than 1.
		/// </summary>
		public int Damage
		{
			readonly get
			{
				return _damage;
			}
			set
			{
				_damage = Math.Max(value, 1);
			}
		}

		public HurtInfo()
		{
			DamageSource = null;
			PvP = false;
			CooldownCounter = -1;
			Dodgeable = true;
			_sourceDamage = 1;
			_damage = 1;
			HitDirection = 0;
			Knockback = 0f;
			DustDisabled = false;
			SoundDisabled = false;
		}
	}

	public struct DefenseStat
	{
		public static DefenseStat Default = new DefenseStat();

		public AddableFloat AdditiveBonus;

		public MultipliableFloat FinalMultiplier;

		public int Positive { get; private set; }

		public int Negative { get; private set; }

		public DefenseStat()
		{
			Positive = 0;
			Negative = 0;
			AdditiveBonus = default(AddableFloat);
			FinalMultiplier = new MultipliableFloat();
		}

		public static DefenseStat operator +(DefenseStat stat, int add)
		{
			if (add >= 0)
			{
				DefenseStat result = stat;
				result.Positive = stat.Positive + add;
				return result;
			}
			return stat - -add;
		}

		public static DefenseStat operator -(DefenseStat stat, int sub)
		{
			if (sub >= 0)
			{
				DefenseStat result = stat;
				result.Negative = stat.Negative + sub;
				return result;
			}
			return stat + -sub;
		}

		public static DefenseStat operator ++(DefenseStat stat)
		{
			return stat + 1;
		}

		public static DefenseStat operator --(DefenseStat stat)
		{
			return stat - 1;
		}

		public static DefenseStat operator *(DefenseStat stat, float mult)
		{
			DefenseStat result = stat;
			result.FinalMultiplier = stat.FinalMultiplier * mult;
			return result;
		}

		public static DefenseStat operator /(DefenseStat stat, float div)
		{
			DefenseStat result = stat;
			result.FinalMultiplier = stat.FinalMultiplier / div;
			return result;
		}

		public static implicit operator int(DefenseStat stat)
		{
			return Math.Max((int)Math.Round(((float)stat.Positive * (1f + stat.AdditiveBonus.Value) - (float)stat.Negative) * stat.FinalMultiplier.Value), 0);
		}

		public override string ToString()
		{
			return ((int)this).ToString();
		}
	}

	public int emoteTime;

	public CreativeUnlocksTracker creativeTracker;

	internal static byte[] ENCRYPTION_KEY = new UnicodeEncoding().GetBytes("h3y_gUyZ");

	public OverheadMessage chatOverhead;

	public SelectionRadial DpadRadial = new SelectionRadial();

	public SelectionRadial CircularRadial = new SelectionRadial(SelectionRadial.SelectionMode.RadialCircular);

	public SelectionRadial QuicksRadial = new SelectionRadial(SelectionRadial.SelectionMode.RadialQuicks);

	public bool alchemyTable;

	public int HotbarOffset;

	public bool GoingDownWithGrapple;

	public byte spelunkerTimer;

	public bool[] hideInfo = new bool[InfoDisplayLoader.InfoDisplayCount];

	public int[] builderAccStatus = new int[BuilderToggleLoader.BuilderToggleCount];

	public long lostCoins;

	public string lostCoinString = "";

	public int soulDrain;

	public float drainBoost;

	public bool dd2Accessory;

	private static bool disabledBlizzardGraphic = false;

	private static bool disabledBlizzardSound = false;

	private static float _blizzardSoundVolume;

	private static SlotId _strongBlizzardSound = SlotId.Invalid;

	private static SlotId _insideBlizzardSound = SlotId.Invalid;

	/// <summary>
	/// This player's displayed name.
	/// <br /> Usually capped at 20 characters.
	/// </summary>
	public string name = "";

	public int taxMoney;

	public double taxTimer;

	public static double taxRate = 3600.0;

	public int numberOfDeathsPVE;

	public int numberOfDeathsPVP;

	public static int crystalLeafDamage = 100;

	public static int crystalLeafKB = 10;

	public float basiliskCharge;

	public Vector2 lastDeathPostion;

	public DateTime lastDeathTime;

	public bool showLastDeath;

	public bool usedAegisCrystal;

	public bool usedAegisFruit;

	public bool usedArcaneCrystal;

	public bool usedGalaxyPearl;

	public bool usedGummyWorm;

	public bool usedAmbrosia;

	public int extraAccessorySlots = 2;

	public bool extraAccessory;

	private bool dontConsumeWand;

	public int tankPet = -1;

	public bool tankPetReset;

	public int stringColor;

	public int counterWeight;

	public bool yoyoString;

	public bool yoyoGlove;

	public int beetleOrbs;

	public float beetleCounter;

	public int beetleCountdown;

	public bool beetleDefense;

	public bool beetleOffense;

	public bool beetleBuff;

	public int solarShields;

	public int solarCounter;

	public const int maxSolarShields = 3;

	public Vector2[] solarShieldPos = (Vector2[])(object)new Vector2[3];

	public Vector2[] solarShieldVel = (Vector2[])(object)new Vector2[3];

	public bool solarDashing;

	public bool solarDashConsumedFlare;

	public const int nebulaMaxLevel = 3;

	public int nebulaLevelLife;

	public int nebulaLevelMana;

	public int nebulaManaCounter;

	public int nebulaLevelDamage;

	public bool manaMagnet;

	public bool lifeMagnet;

	public bool treasureMagnet;

	public bool chiselSpeed;

	public bool lifeForce;

	public bool calmed;

	public bool inferno;

	public float flameRingRot;

	public float flameRingScale = 1f;

	public byte flameRingFrame;

	public byte flameRingAlpha;

	public int netManaTime;

	public int netLifeTime;

	public bool netMana;

	public bool netLife;

	public Vector2[] beetlePos = (Vector2[])(object)new Vector2[3];

	public Vector2[] beetleVel = (Vector2[])(object)new Vector2[3];

	public int beetleFrame;

	public int beetleFrameCounter;

	public static int manaSickTime = 300;

	public static int manaSickTimeMax = 600;

	public static float manaSickLessDmg = 0.25f;

	public float manaSickReduction;

	public bool manaSick;

	public int afkCounter;

	public bool stairFall;

	public int loadStatus;

	public Vector2[] itemFlamePos = (Vector2[])(object)new Vector2[7];

	public int itemFlameCount;

	public bool outOfRange;

	public float lifeSteal = 99999f;

	public float ghostDmg;

	public bool teleporting;

	public float teleportTime;

	public int teleportStyle;

	public bool sloping;

	public bool chilled;

	public bool dazed;

	public bool frozen;

	public bool stoned;

	public bool lastStoned;

	public bool ichor;

	public bool webbed;

	public bool tipsy;

	public bool noBuilding;

	public int ropeCount;

	public int manaRegenBonus;

	public float manaRegenDelayBonus;

	/// <summary>
	/// The current vanilla dash that the player is using.<br />
	/// The following values correspond to vanilla dashes:<br />
	/// 1 =&gt; Tabi / Master Ninja Gear<br />
	/// 2 =&gt; Shield of Cthulhu<br />
	/// 3 =&gt; Solar Flare armor set bonus<br />
	/// 4 =&gt; Unused, though a dash for this value DOES exist<br />
	/// 5 =&gt; Crystal Assassin set bonus<br />
	/// </summary>
	public int dashType;

	/// <summary>
	/// The current vanilla dash that the player is VISIBLY using.<br />
	/// Unlike <see cref="F:Terraria.Player.dashType" />, this does not update if a dash cannot currently be input.<br />
	/// </summary>
	public int dash;

	/// <summary>
	/// The amount of time this player has left, in ticks, to input the second keystroke of a standard dash input (double-tap left/right).<br />
	/// For vanilla dashes, this window is 15 ticks, or a quarter of a second, in total.<br />
	/// </summary>
	public int dashTime;

	/// <summary>
	/// The amount of time that has passed, in ticks, since this player last performed a dash.
	/// </summary>
	public int timeSinceLastDashStarted;

	/// <summary>
	/// The amount of time that has to pass, in ticks, before a new dash input will be registered.<br />
	/// For the first frame of any given dash, this is set to -1. After that frame has passed, it is set to 20 ticks, or 1/3 of a second.<br />
	/// For the Tabi dash, and when dashing into an enemy with the Shield of Cthulhu, this is set to 30 ticks, or 1/2 of a second, instead.<br />
	/// </summary>
	public int dashDelay;

	public int eocDash;

	public int eocHit;

	public float accRunSpeed;

	public bool cordage;

	public int gem = -1;

	public int gemCount;

	public BitsByte ownedLargeGems;

	/// <summary>
	/// The vanilla flask effect which the player currently has active; these affect all melee weapons and whips.<br />
	/// Defaults to 0, which denotes that the player does not currently have a flask active.<br />
	/// The following values correspond to vanilla flasks:<br />
	/// 1 =&gt; Flask of Venom (affected weapons proc Acid Venom on hit)<br />
	/// 2 =&gt; Flask of Cursed Flames (affected weapons proc Cursed Inferno on hit)<br />
	/// 3 =&gt; Flask of Fire (affected weapons proc On Fire! on hit)<br />
	/// 4 =&gt; Flask of Gold (affected weapons proc Midas on hit)<br />
	/// 5 =&gt; Flask of Ichor (affected weapons proc Ichor on hit)<br />
	/// 6 =&gt; Flask of Nanites (affected weapons proc Confused on hit)<br />
	/// 7 =&gt; Flask of Party (affected weapons sometimes release confetti explosions on hit)<br />
	/// 8 =&gt; Flask of Poison (affected weapons proc Poisoned on hit)<br />
	/// </summary>
	public byte meleeEnchant;

	public byte pulleyDir;

	public bool pulley;

	public int pulleyFrame;

	public float pulleyFrameCounter;

	public bool blackBelt;

	public bool sliding;

	public int slideDir;

	public int snowBallLauncherInteractionCooldown;

	public bool iceSkate;

	public bool carpet;

	/// <summary>
	/// Used by the Shoe Spikes and Climbing Claws to allow for holding onto walls (of tiles, not to be confused with actual walls).<br />
	/// Defaults to 0. Any value higher than 0 allows the player to wall-jump.<br />
	/// A value of 1 causes the player to slowly slide down them while holding onto them.<br />
	/// A value of 2 or more doesn't give this limitation, allowing the player to stay holding onto a wall indefinitely.
	/// </summary>
	public int spikedBoots;

	public int carpetFrame = -1;

	public float carpetFrameCounter;

	public bool canCarpet;

	public int carpetTime;

	public int miscCounter;

	public int infernoCounter;

	public int insanityShadowCooldown;

	public int starCloakCooldown;

	private bool _sandStormLogicEnabled;

	public bool crimsonRegen;

	public bool ghostHeal;

	public bool ghostHurt;

	public bool sticky;

	public bool slippy;

	public bool slippy2;

	public bool powerrun;

	public bool runningOnSand;

	public bool flapSound;

	public bool iceBarrier;

	public bool dangerSense;

	public byte luckPotion;

	public byte oldLuckPotion;

	/// <summary>
	/// The percent of damage this player should resist.
	/// <br /> Has a soft cap of <c>1f</c>. Cannot reduce taken damage below <c>1</c>.
	/// </summary>
	public float endurance;

	public float whipRangeMultiplier;

	public bool loveStruck;

	public bool stinky;

	/// <summary>
	/// If <see langword="true" />, this player will take 30% less damage from any NPC with <see cref="F:Terraria.NPC.coldDamage" /> set and any projectile with <see cref="F:Terraria.Projectile.coldDamage" /> set.
	/// </summary>
	public bool resistCold;

	public bool electrified;

	public bool dryadWard;

	public bool panic;

	public Item brainOfConfusionItem;

	public int brainOfConfusionDodgeAnimationCounter;

	public byte iceBarrierFrame;

	public byte iceBarrierFrameCounter;

	public bool shadowDodge;

	public float shadowDodgeCount;

	public bool palladiumRegen;

	public bool onHitDodge;

	public bool onHitRegen;

	public bool onHitPetal;

	public bool onHitTitaniumStorm;

	public int titaniumStormCooldown;

	public bool hasTitaniumStormBuff;

	public int petalTimer;

	public int shadowDodgeTimer;

	public int boneGloveTimer;

	public int phantomPhoneixCounter;

	public int fishingSkill;

	public bool cratePotion;

	public bool sonarPotion;

	/// <summary>
	/// If <see langword="true" />, this player's fishing line will never break.
	/// </summary>
	public bool accFishingLine;

	public bool accFishingBobber;

	public bool accTackleBox;

	public bool accLavaFishing;

	/// <summary>
	/// The maximum value of minions this player can have summoned at once.
	/// <br /> A minion's value is stored as <see cref="F:Terraria.Projectile.minionSlots" />.
	/// </summary>
	public int maxMinions = 1;

	/// <summary>
	/// The current number of minions this player has summoned. Note that <see cref="F:Terraria.Player.slotsMinions" /> is how the minion limit is tracked, not this.
	/// </summary>
	public int numMinions;

	/// <summary>
	/// The current total value of minions this player has summoned. Used to limit active minions to <see cref="F:Terraria.Player.maxMinions" />
	/// <br /> A minion's value is stored as <see cref="F:Terraria.Projectile.minionSlots" />.
	/// </summary>
	public float slotsMinions;

	public bool pygmy;

	public bool raven;

	public bool slime;

	public bool hornetMinion;

	public bool impMinion;

	public bool twinsMinion;

	public bool spiderMinion;

	public int nextCycledSpiderMinionType;

	public bool pirateMinion;

	public bool sharknadoMinion;

	public bool UFOMinion;

	public bool DeadlySphereMinion;

	public bool stardustMinion;

	public bool stardustGuardian;

	public bool stardustDragon;

	public bool batsOfLight;

	public bool babyBird;

	public bool vampireFrog;

	public bool stormTiger;

	public int highestStormTigerGemOriginalDamage;

	public bool smolstar;

	public bool empressBlade;

	public bool flinxMinion;

	public bool abigailMinion;

	public int highestAbigailCounterOriginalDamage;

	public float wingTime;

	public int wings;

	public int wingsLogic;

	public int wingTimeMax;

	public int wingFrame;

	public int wingFrameCounter;

	public int skinVariant;

	public bool ghost;

	public int ghostFrame;

	public int ghostFrameCounter;

	public int miscTimer;

	public int environmentBuffImmunityTimer;

	public int _framesLeftEligibleForDeadmansChestDeathAchievement;

	public bool pvpDeath;

	public BitsByte zone1 = (byte)0;

	public BitsByte zone2 = (byte)0;

	public BitsByte zone3 = (byte)0;

	public BitsByte zone4 = (byte)0;

	public BitsByte zone5 = (byte)0;

	private bool _wasInShimmerZone;

	public bool boneArmor;

	public bool frostArmor;

	public bool honey;

	public bool crystalLeaf;

	public int crystalLeafCooldown;

	public PortableStoolUsage portableStoolInfo;

	public bool preventAllItemPickups;

	public bool dontHurtCritters;

	public bool hasLucyTheAxe;

	public bool dontHurtNature;

	public int[] doubleTapCardinalTimer = new int[4];

	public int[] holdDownCardinalTimer = new int[4];

	public bool defendedByPaladin;

	public bool hasPaladinShield;

	public float[] speedSlice = new float[60];

	/// <summary>
	/// The sum of the <see cref="F:Terraria.NPC.npcSlots" /> of all town NPCs near this player.
	/// <br /> If <c><see cref="F:Terraria.Player.townNPCs" /> &gt; 2f</c>, then this player is in a town.
	/// </summary>
	public float townNPCs;

	public double headFrameCounter;

	public double bodyFrameCounter;

	public double legFrameCounter;

	public int netSkip;

	public int oldSelectItem;

	public bool immune;

	public bool immuneNoBlink;

	public int immuneTime;

	public int immuneAlphaDirection;

	public int immuneAlpha;

	public int team;

	private int _timeSinceLastImmuneGet;

	private int _immuneStrikes;

	public bool hbLocked;

	public static int nameLen = 20;

	public float maxRegenDelay;

	public int sign = -1;

	public bool editedChestName;

	public int reuseDelay;

	public int aggro;

	public float nearbyActiveNPCs;

	public bool creativeInterface;

	public bool mouseInterface;

	public bool lastMouseInterface;

	public int noThrow;

	public int changeItem = -1;

	public int selectedItem;

	public const int SupportedSlotsArmor = 3;

	public const int SupportedSlotsAccs = 7;

	public const int SupportedSlotSets = 10;

	public const int InitialAccSlotCount = 5;

	public const int miscSlotPet = 0;

	public const int miscSlotLight = 1;

	public const int miscSlotCart = 2;

	public const int miscSlotMount = 3;

	public const int miscSlotHook = 4;

	public const int SupportedMiscSlotCount = 5;

	/// <summary>
	/// The player's armor and accessories. Indexes 0-2 hold head, chest, and legs armor while 10-12 hold the respective social armor items. Indexes 3-9 hold the accessories and 13-19 hold the social accessory items. Modded accessory slots are stored separately.<br /><br />
	/// Generally speaking, modders <b>should not be accessing this array</b> to check for specific accessories, that is not how Terraria is designed and is not scalable, especially since modded accessory slots exist and each can have special logic. Modders should be using <see cref="M:Terraria.ModLoader.ModItem.UpdateAccessory(Terraria.Player,System.Boolean)" /> to set fields in a <see cref="T:Terraria.ModLoader.ModPlayer" /> class, then use those values for gameplay effects. <see href="https://github.com/tModLoader/tModLoader/blob/1.4.4/ExampleMod/Old/SimpleModPlayer.cs">SimpleModPlayer.cs</see> shows the proper approach and explains this pattern.<br /><br />
	/// The corresponding dye items are found in <see cref="F:Terraria.Player.dye" />. The player's inventory is <see cref="F:Terraria.Player.inventory" />. For equipment, see <see cref="F:Terraria.Player.miscEquips" /> and <see cref="F:Terraria.Player.miscDyes" />. <see cref="F:Terraria.Player.trashItem" /> is the trash slot.<br /><br />
	/// </summary>
	public Item[] armor = new Item[20];

	public Item[] dye = new Item[10];

	/// <summary>
	/// The player's equipment items. From indexes 0-4: Pet, Light Pet, Minecart, Mount, and Hook.
	/// </summary>
	public Item[] miscEquips = new Item[5];

	public Item[] miscDyes = new Item[5];

	public Item trashItem = new Item();

	public float itemRotation;

	public int itemWidth;

	public int itemHeight;

	public Vector2 itemLocation;

	public bool poundRelease;

	public float ghostFade;

	public float ghostDir = 1f;

	/// <summary>
	/// The <see cref="T:Terraria.ID.BuffID" />s of all buffs this player has active.
	/// <br /> A value of <c>0</c> means that buff slot is empty.
	/// <br /> Buff times are stored with the same index in <see cref="F:Terraria.Player.buffTime" />.
	/// <br /> <see cref="M:Terraria.Player.AddBuff(System.Int32,System.Int32,System.Boolean,System.Boolean)" />, <see cref="M:Terraria.Player.ClearBuff(System.Int32)" />, and <see cref="M:Terraria.Player.DelBuff(System.Int32)" /> should be used to manipulate player buffs.
	/// </summary>
	public int[] buffType = new int[maxBuffs];

	/// <summary>
	/// The remaining durations in ticks of all buffs this player has active.
	/// <br /> A value of <c>0</c> means that buff slot is empty.
	/// <br /> Buff types are stored with the same index in <see cref="F:Terraria.Player.buffType" />.
	/// <br /> <see cref="M:Terraria.Player.AddBuff(System.Int32,System.Int32,System.Boolean,System.Boolean)" />, <see cref="M:Terraria.Player.ClearBuff(System.Int32)" />, and <see cref="M:Terraria.Player.DelBuff(System.Int32)" /> should be used to manipulate player buffs.
	/// </summary>
	public int[] buffTime = new int[maxBuffs];

	/// <summary>
	/// Indexed by <see cref="T:Terraria.ID.BuffID" />. If <see langword="true" /> for a given <see cref="T:Terraria.ID.BuffID" />, then this player cannot be inflicted with that buff.
	/// <br /> Additionally, if the player is inflicted with that buff and becomes immune to it, the buff will be cleared.
	/// <br /> Defaults to <see langword="false" />.
	/// </summary>
	public bool[] buffImmune = new bool[BuffID.Count];

	public int heldProj = -1;

	public int breathCD;

	public int breathMax = 200;

	public int breath = 200;

	public int lavaCD;

	public int lavaMax;

	public int lavaTime;

	public bool ignoreWater;

	public bool armorEffectDrawShadow;

	public bool armorEffectDrawShadowSubtle;

	public bool armorEffectDrawOutlines;

	public bool armorEffectDrawShadowLokis;

	public bool armorEffectDrawShadowBasilisk;

	public bool armorEffectDrawOutlinesForbidden;

	public bool armorEffectDrawShadowEOCShield;

	public bool socialShadowRocketBoots;

	public bool socialGhost;

	public bool shroomiteStealth;

	public bool ashWoodBonus;

	public bool socialIgnoreLight;

	public int stealthTimer;

	public float stealth = 1f;

	public int beardGrowthTimer;

	public bool isDisplayDollOrInanimate;

	public bool isFullbright;

	public bool isHatRackDoll;

	public bool isFirstFractalAfterImage;

	public float firstFractalAfterImageOpacity;

	/// <summary>
	/// The text that is shown on armor (<see cref="F:Terraria.Item.wornArmor" />) with an active set bonus.
	/// </summary>
	public string setBonus = "";

	/// <summary>
	/// The player's normal inventory. Indexes 0-9 hold the hotbar items, 10-49 the rest of the main inventory, 50-53 are coin slots, 54-57 are ammo slots. Index 58 is used to store the mouse item in some situations.<br />
	/// Additional inventories are found in <see cref="F:Terraria.Player.bank" /> (Piggy Bank), <see cref="F:Terraria.Player.bank2" /> (Safe), <see cref="F:Terraria.Player.bank3" /> (Defender's Forge), and <see cref="F:Terraria.Player.bank4" /> (Void Vault).
	/// For armor and accessories, see <see cref="F:Terraria.Player.armor" /> and <see cref="F:Terraria.Player.dye" />. For equipment, see <see cref="F:Terraria.Player.miscEquips" /> and <see cref="F:Terraria.Player.miscDyes" />. <see cref="F:Terraria.Player.trashItem" /> is the trash slot.<br />
	/// </summary>
	public Item[] inventory = new Item[59];

	public bool[] inventoryChestStack = new bool[59];

	public Item lastVisualizedSelectedItem;

	public Chest bank = new Chest(bank: true);

	public Chest bank2 = new Chest(bank: true);

	public Chest bank3 = new Chest(bank: true);

	public Chest bank4 = new Chest(bank: true);

	public BitsByte voidVaultInfo;

	public float headRotation;

	public float bodyRotation;

	public float legRotation;

	public Vector2 headPosition;

	public Vector2 bodyPosition;

	public Vector2 legPosition;

	public Vector2 headVelocity;

	public Vector2 bodyVelocity;

	public Vector2 legVelocity;

	public float fullRotation;

	public Vector2 fullRotationOrigin = Vector2.Zero;

	public int fartKartCloudDelay;

	public const int fartKartCloudDelayMax = 20;

	public int nonTorch = -1;

	/// <summary>
	/// An offset from the actual position of the player that will be added to the draw position. Used to fake the effect of the player smoothly traveling up single block obstacles.
	/// </summary>
	public float gfxOffY;

	public float stepSpeed = 1f;

	public static bool deadForGood = false;

	public bool dead;

	public int respawnTimer;

	public const int respawnTimerMax = 3600;

	public long lastTimePlayerWasSaved;

	public int attackCD;

	public int potionDelay;

	public byte difficulty;

	public byte wetSlime;

	public HitTile hitTile;

	public HitTile hitReplace;

	public int jump;

	public int head = -1;

	public int body = -1;

	public int legs = -1;

	public int handon = -1;

	public int handoff = -1;

	public int back = -1;

	public int front = -1;

	public int shoe = -1;

	public int waist = -1;

	public int shield = -1;

	public int neck = -1;

	public int face = -1;

	public int balloon = -1;

	public int backpack = -1;

	public int tail = -1;

	public int faceHead = -1;

	public int faceFlower = -1;

	public int balloonFront = -1;

	public int beard = -1;

	public bool[] hideVisibleAccessory = new bool[10];

	public BitsByte hideMisc = (byte)0;

	public Rectangle headFrame;

	public Rectangle bodyFrame;

	public Rectangle legFrame;

	public Rectangle hairFrame;

	public DirectionalInputSyncCache LocalInputCache;

	public bool controlLeft;

	public bool controlRight;

	public bool controlUp;

	public bool controlDown;

	public bool controlJump;

	public bool controlUseItem;

	public bool controlUseTile;

	public bool controlThrow;

	public bool controlInv;

	public bool controlHook;

	public bool controlTorch;

	public bool controlMap;

	public bool controlSmart;

	public bool controlMount;

	public bool releaseJump;

	public bool releaseUp;

	public bool releaseUseItem;

	public bool releaseUseTile;

	public bool releaseInventory;

	public bool releaseHook;

	public bool releaseThrow;

	public bool releaseQuickMana;

	public bool releaseQuickHeal;

	public bool releaseLeft;

	public bool releaseRight;

	public bool releaseSmart;

	public bool releaseMount;

	public bool releaseDown;

	public bool controlQuickMana;

	public bool controlQuickHeal;

	public bool controlCreativeMenu;

	public bool releaseCreativeMenu;

	public bool tileInteractionHappened;

	public bool tileInteractAttempted;

	public bool controlDownHold;

	public bool isOperatingAnotherEntity;

	public bool autoReuseAllWeapons;

	public bool isControlledByFilm;

	public bool tryKeepingHoveringDown;

	public bool tryKeepingHoveringUp;

	public int altFunctionUse;

	public bool mapZoomIn;

	public bool mapZoomOut;

	public bool mapAlphaUp;

	public bool mapAlphaDown;

	public bool mapFullScreen;

	public bool mapStyle;

	public bool releaseMapFullscreen;

	public bool releaseMapStyle;

	public int leftTimer;

	public int rightTimer;

	public bool delayUseItem;

	public const int defaultWidth = 20;

	public const int defaultHeight = 42;

	public bool cursorItemIconEnabled;

	public bool cursorItemIconReversed;

	public int cursorItemIconID;

	public int cursorItemIconPush;

	public string cursorItemIconText = "";

	public int runSoundDelay;

	public float opacityForAnimation = 1f;

	public const int shadowMax = 3;

	public Vector2[] shadowPos = (Vector2[])(object)new Vector2[3];

	public float[] shadowRotation = new float[3];

	public Vector2[] shadowOrigin = (Vector2[])(object)new Vector2[3];

	public int[] shadowDirection = new int[3];

	public int shadowCount;

	/// <summary>
	/// The percent of mana actually used when mana is consumed.
	/// <br /> Cannot reduce an item's mana cost below <c>0</c>.
	/// </summary>
	public float manaCost = 1f;

	public bool fireWalk;

	public bool channel;

	public int step = -1;

	private ChannelCancelKey _channelShotCache;

	public bool skipAnimatingValuesInPlayerFrame;

	public RabbitOrderFrameHelper rabbitOrderFrame;

	public bool creativeGodMode;

	private const int MaxAdvancedShadows = 60;

	public int availableAdvancedShadowsCount;

	private EntityShadowInfo[] _advancedShadows = new EntityShadowInfo[60];

	private int _lastAddedAvancedShadow;

	public CompositeArmData compositeFrontArm;

	public CompositeArmData compositeBackArm;

	public int anglerQuestsFinished;

	public int golferScoreAccumulated;

	public int bartenderQuestLog;

	public bool downedDD2EventAnyDifficulty;

	/// <summary>
	/// The defense value of this player.<br />
	/// The <see href="https://terraria.wiki.gg/wiki/Defense#Players">Defense wiki page</see> teaches how player defense affects incoming damage alongside <see cref="F:Terraria.Player.DefenseEffectiveness" />.<br />
	/// The value resets to 0 during <see cref="M:Terraria.Player.ResetEffects" /> and is manipulated throughout <see cref="M:Terraria.Player.Update(System.Int32)" />.<br />
	/// If the final value is needed, <see cref="M:Terraria.ModLoader.ModPlayer.PostUpdate" /> or anytime later is the best place. As such it is not recommended to manipulate the value during PostUpdate or at any time later for compatibility. Failure to follow this guideline will result in inconsistent behavior.<br />
	/// Due to this field being a <see cref="T:Terraria.Player.DefenseStat" />, modders can freely add, subtract, multiply, and divide the value. The final result will properly account for all modifications applied.<br />
	/// </summary>
	public DefenseStat statDefense;

	/// <summary>
	/// Determines how effective the player's <see cref="F:Terraria.Player.statDefense" /> is at reducing incoming damage.<br />
	/// The <see href="https://terraria.wiki.gg/wiki/Defense#Players">Defense wiki page</see> explains the effect, shown in the wiki as "factor".<br />
	/// </summary>
	public MultipliableFloat DefenseEffectiveness;

	/// <summary>
	/// The maximum health this player can have without adjustment.
	/// <br /> You should <strong>not</strong> modify this value. If you need to increase max health for equipment, modify <see cref="F:Terraria.Player.statLifeMax2" />. If you need to increase max health for a permanent stat boost, use <see cref="M:Terraria.ModLoader.ModPlayer.ModifyMaxStats(Terraria.ModLoader.StatModifier@,Terraria.ModLoader.StatModifier@)" />.
	/// </summary>
	public int statLifeMax = 100;

	/// <summary>
	/// The maximum health this player can have, adjusted by buffs and equipment.
	/// </summary>
	public int statLifeMax2 = 100;

	/// <summary>
	/// The current health of this player. Capped at <see cref="F:Terraria.Player.statLifeMax2" />.
	/// <br /> If you increase this value, be sure to respect the cap.
	/// </summary>
	/// <remarks>
	/// If you want to heal the player with the green text effect, use <see cref="M:Terraria.Player.Heal(System.Int32)" />.
	/// <br /> If you want to hurt the player, use <see cref="M:Terraria.Player.Hurt(Terraria.DataStructures.PlayerDeathReason,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Int32,System.Boolean,System.Single,System.Single,System.Single)" />.
	/// </remarks>
	public int statLife = 100;

	/// <summary>
	/// The current mana of this player. Capped at <see cref="F:Terraria.Player.statManaMax2" />.
	/// <br /> If you increase this value, be sure to respect the cap.
	/// </summary>
	/// <remarks>
	/// If you want to use mana, use <see cref="M:Terraria.Player.CheckMana(Terraria.Item,System.Int32,System.Boolean,System.Boolean)" /> or its overload.
	/// </remarks>
	public int statMana;

	/// <summary>
	/// The maximum mana this player can have without adjustment.
	/// <br /> You should <strong>not</strong> modify this value. If you need to increase max mana for equipment, modify <see cref="F:Terraria.Player.statManaMax2" />. If you need to increase max mana for a permanent stat boost, use <see cref="M:Terraria.ModLoader.ModPlayer.ModifyMaxStats(Terraria.ModLoader.StatModifier@,Terraria.ModLoader.StatModifier@)" />.
	/// </summary>
	public int statManaMax;

	/// <summary>
	/// The maximum mana this player can have, adjusted by buffs and equipment.
	/// </summary>
	public int statManaMax2;

	/// <summary>
	/// The rate of this player's life regeneration in health/ticks, divided by <c>120</c>.
	/// <br /> For example, adding <c>10</c> to this value regenerates <c>10 / 120</c> = <c>1/6</c> health per tick, or 5 health per second.
	/// <br /> Life regeneration is accumulated every tick in <see cref="F:Terraria.Player.lifeRegenCount" />.
	/// <br /> This value should be subtracted from in <see cref="M:Terraria.ModLoader.ModPlayer.UpdateBadLifeRegen" /> and added to in <see cref="M:Terraria.ModLoader.ModPlayer.UpdateLifeRegen" />.
	/// </summary>
	public int lifeRegen;

	/// <summary>
	/// This player's accumulated life regeneration.
	/// <br /> If this value reaches or exceeds <c>120</c>, the player gains <c><see cref="F:Terraria.Player.lifeRegenCount" /> / 120</c> health and this value decreases until it no longer exceeds <c>120</c>.
	/// <br /> If this value reaches or exceeds <c>-120</c>, the player loses health in the same way.
	/// </summary>
	public int lifeRegenCount;

	/// <summary>
	/// How effective this player's natural life regeneration should be. Resets whenever the player is hurt, increases over time.
	/// <br /> Certain effects increase this value to increase
	/// </summary>
	/// <remarks>
	/// Use <see cref="M:Terraria.ModLoader.ModPlayer.NaturalLifeRegen(System.Single@)" /> to directly modify natural life regeneration.
	/// </remarks>
	public float lifeRegenTime;

	public int manaRegen;

	public int manaRegenCount;

	public float manaRegenDelay;

	public bool manaRegenBuff;

	public bool noKnockback;

	public bool shimmerImmune;

	public bool spaceGun;

	public float gravDir = 1f;

	public bool chloroAmmoCost80;

	public bool huntressAmmoCost90;

	public bool ammoCost80;

	public bool ammoCost75;

	public int stickyBreak;

	public bool magicQuiver;

	public bool magmaStone;

	public bool lavaRose;

	public bool hasMoltenQuiver;

	public int phantasmTime;

	public bool ammoBox;

	public bool ammoPotion;

	public bool chaosState;

	/// <summary>
	/// If <see langword="true" />, then the bees created by <see cref="F:Terraria.Player.honeyCombItem" /> have a chance to be stronger.
	/// </summary>
	public bool strongBees;

	public bool sporeSac;

	public bool shinyStone;

	public bool empressBrooch;

	public bool volatileGelatin;

	public int volatileGelatinCounter;

	public bool hasMagiluminescence;

	public bool shadowArmor;

	public bool dontStarveShader;

	public bool eyebrellaCloud;

	public int yoraiz0rEye;

	public bool yoraiz0rDarkness;

	public bool hasUnicornHorn;

	public bool hasAngelHalo;

	public bool hasRainbowCursor;

	public bool leinforsHair;

	public bool stardustMonolithShader;

	public bool nebulaMonolithShader;

	public bool vortexMonolithShader;

	public bool solarMonolithShader;

	public bool moonLordMonolithShader;

	public bool bloodMoonMonolithShader;

	public bool shimmerMonolithShader;

	public int overrideFishingBobber = -1;

	public bool unlockedBiomeTorches;

	public bool ateArtisanBread;

	/// <summary>
	/// If <see langword="true" />, then this player has permanently buffed their minecarts. See <see cref="P:Terraria.Player.UsingSuperCart" /> for more info.
	/// </summary>
	public bool unlockedSuperCart;

	/// <summary>
	/// If <see langword="true" />, then this player has the effects of the Super Cart enabled. See <see cref="P:Terraria.Player.UsingSuperCart" /> for more info.
	/// </summary>
	public bool enabledSuperCart = true;

	public bool suspiciouslookingTentacle;

	public bool crimsonHeart;

	public bool lightOrb;

	public bool blueFairy;

	public bool redFairy;

	public bool greenFairy;

	public bool bunny;

	public bool turtle;

	public bool eater;

	public bool penguin;

	public bool HasGardenGnomeNearby;

	public bool magicLantern;

	public bool rabid;

	public bool sunflower;

	public bool wellFed;

	public bool puppy;

	public bool grinch;

	public bool miniMinotaur;

	public bool flowerBoots;

	public bool fairyBoots;

	public bool hellfireTreads;

	public bool moonLordLegs;

	public bool arcticDivingGear;

	public bool coolWhipBuff;

	public bool wearsRobe;

	public bool minecartLeft;

	public bool onWrongGround;

	public bool onTrack;

	public int cartRampTime;

	public bool cartFlip;

	public float trackBoost;

	public Vector2 lastBoost = Vector2.Zero;

	/// <summary>
	/// This player's <see cref="T:Terraria.Mount" />.
	/// <br /> <strong>Do not overwrite this value.</strong> Instead, call <see cref="M:Terraria.Mount.SetMount(System.Int32,Terraria.Player,System.Boolean)" /> or <see cref="M:Terraria.Mount.Dismount(Terraria.Player)" /> on it.
	/// </summary>
	public Mount mount;

	public bool blackCat;

	public bool spider;

	public bool squashling;

	public bool petFlagDD2Gato;

	public bool petFlagDD2Ghost;

	public bool petFlagDD2Dragon;

	public bool petFlagUpbeatStar;

	public bool petFlagSugarGlider;

	public bool petFlagBabyShark;

	public bool petFlagLilHarpy;

	public bool petFlagFennecFox;

	public bool petFlagGlitteryButterfly;

	public bool petFlagBabyImp;

	public bool petFlagBabyRedPanda;

	public bool petFlagPlantero;

	public bool petFlagDynamiteKitten;

	public bool petFlagBabyWerewolf;

	public bool petFlagShadowMimic;

	public bool petFlagVoltBunny;

	public bool petFlagKingSlimePet;

	public bool petFlagEyeOfCthulhuPet;

	public bool petFlagEaterOfWorldsPet;

	public bool petFlagBrainOfCthulhuPet;

	public bool petFlagSkeletronPet;

	public bool petFlagQueenBeePet;

	public bool petFlagDestroyerPet;

	public bool petFlagTwinsPet;

	public bool petFlagSkeletronPrimePet;

	public bool petFlagPlanteraPet;

	public bool petFlagGolemPet;

	public bool petFlagDukeFishronPet;

	public bool petFlagLunaticCultistPet;

	public bool petFlagMoonLordPet;

	public bool petFlagFairyQueenPet;

	public bool petFlagPumpkingPet;

	public bool petFlagEverscreamPet;

	public bool petFlagIceQueenPet;

	public bool petFlagMartianPet;

	public bool petFlagDD2OgrePet;

	public bool petFlagDD2BetsyPet;

	public bool petFlagQueenSlimePet;

	public bool petFlagBerniePet;

	public bool petFlagGlommerPet;

	public bool petFlagDeerclopsPet;

	public bool petFlagPigPet;

	public bool petFlagChesterPet;

	public bool petFlagJunimoPet;

	public bool petFlagBlueChickenPet;

	public bool petFlagSpiffo;

	public bool petFlagCaveling;

	public bool petFlagDirtiestBlock;

	public bool companionCube;

	public bool babyFaceMonster;

	public bool magicCuffs;

	public bool coldDash;

	public bool sailDash;

	public bool desertDash;

	public bool desertBoots;

	public bool eyeSpring;

	public bool snowman;

	public bool scope;

	public bool dino;

	public bool skeletron;

	public bool hornet;

	public bool zephyrfish;

	public bool tiki;

	public bool parrot;

	public bool truffle;

	public bool sapling;

	public bool cSapling;

	public bool wisp;

	public bool lizard;

	public bool archery;

	public bool poisoned;

	public bool venom;

	public bool blind;

	public bool blackout;

	public bool headcovered;

	public bool frostBurn;

	public bool onFrostBurn;

	public bool onFrostBurn2;

	public bool burned;

	public bool shimmering;

	public int timeShimmering;

	public float shimmerTransparency;

	public ShimmerUnstuckHelper shimmerUnstuckHelper;

	public bool suffocating;

	public byte suffocateDelay;

	public bool dripping;

	public bool drippingSlime;

	public bool drippingSparkleSlime;

	public bool onFire;

	public bool onFire2;

	public bool onFire3;

	public bool noItems;

	public bool cursed;

	public bool hungry;

	public bool starving;

	public bool heartyMeal;

	public bool windPushed;

	public bool wereWolf;

	public bool wolfAcc;

	public bool hideMerman;

	public bool hideWolf;

	public bool forceMerman;

	public bool forceWerewolf;

	public bool rulerGrid;

	public bool rulerLine;

	public bool bleed;

	public bool confused;

	public bool accMerman;

	public bool merman;

	public bool trident;

	public bool brokenArmor;

	public bool silence;

	public bool slow;

	public bool gross;

	public bool tongued;

	public bool kbGlove;

	public bool autoReuseGlove;

	public bool meleeScaleGlove;

	public bool kbBuff;

	public bool remoteVisionForDrone;

	public Item starCloakItem;

	public Item starCloakItem_manaCloakOverrideItem;

	public Item starCloakItem_starVeilOverrideItem;

	public Item starCloakItem_beeCloakOverrideItem;

	public bool longInvince;

	public bool pStone;

	public static readonly float PhilosopherStoneDurationMultiplier = 0.75f;

	public bool manaFlower;

	public bool moonLeech;

	public bool vortexDebuff;

	public bool trapDebuffSource;

	public bool witheredArmor;

	public bool witheredWeapon;

	public bool slowOgreSpit;

	public bool parryDamageBuff;

	public bool ballistaPanic;

	public bool JustDroppedAnItem;

	public StatModifier arrowDamage = StatModifier.Default;

	public StatModifier bulletDamage = StatModifier.Default;

	public StatModifier specialistDamage = StatModifier.Default;

	/// <summary>
	/// The multiplier on this player's <see cref="F:Terraria.Player.maxRunSpeed" /> and <see cref="F:Terraria.Player.runAcceleration" />.
	/// </summary>
	public float moveSpeed = 1f;

	public float pickSpeed = 1f;

	public float wallSpeed = 1f;

	public float tileSpeed = 1f;

	public bool autoPaint;

	public bool autoActuator;

	public int SpawnX = -1;

	public int SpawnY = -1;

	public Vector2? PotionOfReturnOriginalUsePosition;

	public Vector2? PotionOfReturnHomePosition;

	public int[] spX = new int[200];

	public int[] spY = new int[200];

	public string[] spN = new string[200];

	public int[] spI = new int[200];

	public static int tileRangeX = 5;

	public static int tileRangeY = 4;

	public int lastTileRangeX;

	public int lastTileRangeY;

	public static int tileTargetX;

	public static int tileTargetY;

	public static float defaultGravity = 0.4f;

	public static int jumpHeight = 15;

	/// <summary>
	/// The speed, in pixels/tick, that this players jumps at.
	/// </summary>
	public static float jumpSpeed = 5.01f;

	public float gravity = defaultGravity;

	public float maxFallSpeed = 10f;

	/// <summary>
	/// The maximum speed, in pixels/tick, that this player can reach by just running.
	/// </summary>
	/// <remarks>To apply a global run speed modifier, use <see cref="F:Terraria.Player.moveSpeed" />.</remarks>
	public float maxRunSpeed = 3f;

	/// <summary>
	/// The acceleration, in pixels/ticks^2, that this player experiences while running.
	/// </summary>
	/// <remarks>To apply a global run speed modifier, use <see cref="F:Terraria.Player.moveSpeed" />.</remarks>
	public float runAcceleration = 0.08f;

	public float runSlowdown = 0.2f;

	public bool adjWater;

	public bool adjHoney;

	public bool adjShimmer;

	public bool adjLava;

	public bool oldAdjWater;

	public bool oldAdjHoney;

	public bool oldAdjLava;

	public bool oldAdjShimmer;

	private bool[] _adjTile = new bool[TileLoader.TileCount];

	private bool[] _oldAdjTile = new bool[TileLoader.TileCount];

	public static int defaultItemGrabRange = 42;

	private static float itemGrabSpeed = 0.45f;

	private static float itemGrabSpeedMax = 4f;

	public int hairDye;

	public Color hairDyeColor = Color.Transparent;

	public float hairDyeVar;

	public int skinDyePacked;

	public Color hairColor = new Color(215, 90, 55);

	public Color skinColor = new Color(255, 125, 90);

	public Color eyeColor = new Color(105, 90, 75);

	public Color shirtColor = new Color(175, 165, 140);

	public Color underShirtColor = new Color(160, 180, 215);

	public Color pantsColor = new Color(255, 230, 175);

	public Color shoeColor = new Color(160, 105, 60);

	public int hair;

	public bool hostile;

	public SoundPlaySet hermesStepSound = new SoundPlaySet();

	public Vector2 instantMovementAccumulatedThisFrame;

	public int accCompass;

	public int accWatch;

	public int accDepthMeter;

	public bool accFishFinder;

	public bool accWeatherRadio;

	public bool accJarOfSouls;

	public bool accCalendar;

	public int lastCreatureHit = -1;

	public bool accThirdEye;

	public byte accThirdEyeCounter;

	public byte accThirdEyeNumber;

	public bool accStopwatch;

	public bool accOreFinder;

	public bool accCritterGuide;

	public byte accCritterGuideCounter;

	public byte accCritterGuideNumber;

	public bool accDreamCatcher;

	public bool hasFootball;

	public bool drawingFootball;

	public bool ActuationRodLock;

	public bool ActuationRodLockSetting;

	public bool InfoAccMechShowWires;

	public DateTime dpsStart;

	public DateTime dpsEnd;

	public DateTime dpsLastHit;

	public int dpsDamage;

	public bool dpsStarted;

	public string displayedFishingInfo = "";

	public bool discountEquipped;

	public bool discountAvailable;

	public bool hasLuckyCoin;

	public Item boneGloveItem;

	public bool goldRing;

	public bool accDivingHelm;

	public bool hasLuck_LuckyCoin;

	public bool hasLuck_LuckyHorseshoe;

	public bool isPerformingPogostickTricks;

	public bool autoJump;

	public bool justJumped;

	/// <summary>
	/// How much to directly increase <see cref="F:Terraria.Player.jumpSpeed" />, in pixels/tick.
	/// </summary>
	public float jumpSpeedBoost;

	/// <summary>
	/// The number of extra tiles this player can fall before they start taking fall damage.
	/// </summary>
	/// <remarks>
	/// If you want to prevent fall damage entirely, use <see cref="F:Terraria.Player.noFallDmg" />.
	/// </remarks>
	public int extraFall;

	public bool canFloatInWater;

	public bool hasFloatingTube;

	public bool frogLegJumpBoost;

	public bool skyStoneEffects;

	public bool spawnMax;

	public int blockRange;

	public int[] grappling = new int[20];

	public int grapCount;

	public int rocketTime;

	public int rocketTimeMax = 7;

	public int rocketDelay;

	public int rocketDelay2;

	public int rocketSoundDelay;

	public bool rocketRelease;

	public bool rocketFrame;

	public int rocketBoots;

	public int vanityRocketBoots;

	public bool canRocket;

	public bool jumpBoost;

	/// <summary>
	/// If <see langword="true" />, this player will take no fall damage.
	/// </summary>
	public bool noFallDmg;

	public int swimTime;

	public bool killGuide;

	public bool killClothier;

	public float equipmentBasedLuckBonus;

	public float lastEquipmentBasedLuckBonus;

	public bool hasCreditsSceneMusicBox;

	public bool lavaImmune;

	public bool gills;

	public bool slowFall;

	public bool findTreasure;

	public bool biomeSight;

	public bool invis;

	public bool detectCreature;

	public bool nightVision;

	public bool enemySpawns;

	public float thorns;

	public bool turtleArmor;

	public bool turtleThorns;

	public bool cactusThorns;

	public bool spiderArmor;

	public bool anglerSetSpawnReduction;

	public bool CanSeeInvisibleBlocks;

	public bool setSolar;

	public bool setVortex;

	public bool setNebula;

	public int nebulaCD;

	public bool setStardust;

	public bool setForbidden;

	public bool setForbiddenCooldownLocked;

	public bool setSquireT3;

	public bool setHuntressT3;

	public bool setApprenticeT3;

	public bool setMonkT3;

	public bool setSquireT2;

	public bool setHuntressT2;

	public bool setApprenticeT2;

	public bool setMonkT2;

	public int maxTurrets = 1;

	public int maxTurretsOld = 1;

	public bool vortexStealthActive;

	public bool waterWalk;

	public bool waterWalk2;

	public int forcedGravity;

	public bool gravControl;

	public bool gravControl2;

	/// <summary>
	/// If not <see langword="null" />, this player will create damaging bee projectiles when taking damage.
	/// </summary>
	public Item honeyCombItem;

	public int wireOperationsCooldown;

	public int lastChest;

	public TrackedProjectileReference piggyBankProjTracker;

	public TrackedProjectileReference voidLensChest;

	/// <summary>
	/// Represents the chest the player currently has open. If -1, the player has no chest open.<br />
	/// Positive values indicate the index of the chest in <see cref="F:Terraria.Main.chest" /> the player currently has open.<br />
	/// Negative values are used to indicate additional inventories: Piggy Bank (-2), Safe (-3), Defender's Forge (-4), Void Vault (-5)
	/// </summary>
	public int chest = -1;

	public int chestX;

	public int chestY;

	public int fallStart;

	public int fallStart2;

	public int potionDelayTime = Item.potionDelay;

	public int restorationDelayTime = Item.restorationDelay;

	public int mushroomDelayTime = Item.mushroomDelay;

	private bool _batbatCanHeal;

	private bool _spawnTentacleSpikes;

	private bool _spawnBloodButcherer;

	private bool _spawnVolcanoExplosion;

	private bool _spawnMuramasaCut;

	public bool isPettingAnimal;

	public bool isTheAnimalBeingPetSmall;

	public PlayerSittingHelper sitting;

	public PlayerSleepingHelper sleeping;

	public PlayerEyeHelper eyeHelper;

	public PlayerInteractionAnchor tileEntityAnchor;

	public DoorOpeningHelper doorHelper;

	public ShoppingSettings currentShoppingSettings = ShoppingSettings.NotInShop;

	/// <summary>The armor shader ID applied to the <see cref="F:Terraria.ModLoader.EquipType.Head" /> equip texture by a dye item (<see cref="F:Terraria.Item.dye" />) in the dye slot.</summary>
	public int cHead;

	/// <summary>The armor shader ID applied to the <see cref="F:Terraria.ModLoader.EquipType.Body" /> equip texture by a dye item (<see cref="F:Terraria.Item.dye" />) in the dye slot.</summary>
	public int cBody;

	/// <summary>The armor shader ID applied to the <see cref="F:Terraria.ModLoader.EquipType.Legs" /> equip texture by a dye item (<see cref="F:Terraria.Item.dye" />) in the dye slot.</summary>
	public int cLegs;

	public int cHandOn;

	public int cHandOff;

	public int cBack;

	public int cFront;

	public int cShoe;

	public int cWaist;

	public int cShield;

	public int cNeck;

	public int cFace;

	public int cFaceHead;

	public int cFaceFlower;

	public int cBalloon;

	public int cBalloonFront;

	public int cWings;

	public int cCarpet;

	public int cFloatingTube;

	public int cBackpack;

	public int cTail;

	public int cShieldFallback;

	/// <summary>The armor shader ID applied to the Hook equipment slot by a dye item (<see cref="F:Terraria.Item.dye" />) in the dye slot.</summary>
	public int cGrapple;

	/// <summary>The armor shader ID applied to the Mount equipment slot by a dye item (<see cref="F:Terraria.Item.dye" />) in the dye slot.</summary>
	public int cMount;

	/// <summary>The armor shader ID applied to the Minecart equipment slot by a dye item (<see cref="F:Terraria.Item.dye" />) in the dye slot.</summary>
	public int cMinecart;

	/// <summary>The armor shader ID applied to the Pet equipment slot by a dye item (<see cref="F:Terraria.Item.dye" />) in the dye slot.</summary>
	public int cPet;

	/// <summary>The armor shader ID applied to the Light Pet equipment slot by a dye item (<see cref="F:Terraria.Item.dye" />) in the dye slot.</summary>
	public int cLight;

	public int cYorai;

	public int cPortableStool;

	public int cUnicornHorn;

	public int cAngelHalo;

	public int cBeard;

	public int cMinion;

	public int cLeinShampoo;

	public int cFlameWaker;

	/// <summary>
	/// Provides efficient access to the number of projectiles of the specified type owned by this player currently active in the game world.<br />
	/// Can be used to prevent spawning additional projectiles when a limit is reached.<br />
	/// Updated each game update right before Player.UpdateBuffs.<br />
	/// For example, <c>return player.ownedProjectileCounts[Item.shoot] &lt; 1;</c> in <see cref="M:Terraria.ModLoader.ModItem.CanUseItem(Terraria.Player)" /> could prevent a player using the item if the projectile the item spawns is already in the game world for the player.
	/// </summary>
	public int[] ownedProjectileCounts = new int[ProjectileID.Count];

	public bool[] npcTypeNoAggro = new bool[NPCID.Count];

	public int lastPortalColorIndex;

	public int _portalPhysicsTime;

	public bool portalPhysicsFlag;

	public int lastTeleportPylonStyleUsed;

	public float MountFishronSpecialCounter;

	public Vector2 MinionRestTargetPoint = Vector2.Zero;

	public int MinionAttackTargetNPC = -1;

	public List<Point> TouchedTiles = new List<Point>();

	public int itemAnimation;

	public int itemAnimationMax;

	public int itemTime;

	public int itemTimeMax;

	public int toolTime;

	public static int BlockInteractionWithProjectiles = 3;

	public const int SafeItemAnimationTimeForPreventingExploits = 20;

	private HashSet<Point> _blackListedTileCoordsForGrappling = new HashSet<Point>();

	private bool makeStrongBee;

	public bool equippedAnyTileRangeAcc;

	public bool equippedAnyTileSpeedAcc;

	public bool equippedAnyWallSpeedAcc;

	private static List<NPC> _hallucinationCandidates = new List<NPC>();

	public bool behindBackWall;

	public int _funkytownAchievementCheckCooldown;

	private float _stormShaderObstruction = 1f;

	private float _shaderObstructionInternalValue = 1f;

	private int graveImmediateTime;

	public static float airLightDecay = 1f;

	public static float solidLightDecay = 1f;

	private float _deerclopsBlizzardSmoothedEffect;

	public const int ChairSittingMaxDistance = 40;

	private static SmartInteractSystem _smartInteractSys = new SmartInteractSystem();

	private int _lastSmartCursorToolStrategy = -1;

	private bool[] nearbyTorch = new bool[TorchID.Count];

	private bool dryCoralTorch;

	private int luckyTorchCounter;

	private int nearbyTorches;

	public float torchLuck;

	private Vector2 _nextTorchLuckCheckCenter;

	public bool happyFunTorchTime;

	private int torchFunTimer;

	private int torchGodCooldown;

	private int numberOfTorchAttacksMade;

	private static int maxTorchAttacks = 200;

	private int[] unlitTorchX = new int[maxTorchAttacks];

	private int[] unlitTorchY = new int[maxTorchAttacks];

	private static int[] _torchAttackPosX = new int[400];

	private static int[] _torchAttackPosY = new int[400];

	public double ladyBugLuckTimeLeft;

	public float luck;

	public float luckMinimumCap = -0.7f;

	public float luckMaximumCap = 1f;

	public float coinLuck;

	public bool luckNeedsSync;

	public int disableVoidBag = -1;

	private int _quickGrappleCooldown;

	public PlayerMovementAccsCache movementAbilitiesCache;

	public float wingAccRunSpeed = -1f;

	public float wingRunAccelerationMult = 1f;

	public const int SHIELD_PARRY_DURATION = 20;

	public const int SHIELD_PARRY_DURATION_DRAWING_TWEAKER = 20;

	public const int SHIELD_PARRY_DAMAGE_BUFF_MULTIPLIER = 5;

	public bool hasRaisableShield;

	public bool shieldRaised;

	public int shieldParryTimeLeft;

	public int shield_parry_cooldown;

	private bool _forceForwardCursor;

	private Point _inputMouseCoordsForward;

	private Point _mainMouseCoordsForward;

	private bool _forceSmartSelectCursor;

	private Point _inputMouseCoordsSmartSelect;

	private Point _mainMouseCoordsSmartSelect;

	private Point _tileTargetSmartSelect;

	private bool botherWithUnaimedMinecartTracks = true;

	private List<int> _projectilesToInteractWith = new List<int>();

	private int _lockTileInteractionsTimer;

	public int[] hurtCooldowns = new int[5];

	public static int FlexibleWandRandomSeed;

	public static int FlexibleWandCycleOffset;

	public static Point FlexibleWandLastPosition;

	public static bool lastPound = true;

	private static Point[] _tentacleSpikesMax5 = (Point[])(object)new Point[5];

	private static Point[] _bloodButchererMax5 = (Point[])(object)new Point[5];

	public int[] meleeNPCHitCooldown = new int[200];

	public static int musicNotes = 6;

	public float musicDist;

	private static List<Projectile> _oldestProjCheckList = new List<Projectile>();

	public EquipmentLoadout[] Loadouts = new EquipmentLoadout[3]
	{
		new EquipmentLoadout(),
		new EquipmentLoadout(),
		new EquipmentLoadout()
	};

	public int CurrentLoadoutIndex;

	public SavedPlayerDataWithAnnoyingRules savedPerPlayerFieldsThatArentInThePlayerClass;

	private const int SaveSlotIndex_MouseItem = 0;

	private const int SaveSlotIndex_CreativeSacrifice = 1;

	private const int SaveSlotIndex_GuideItem = 2;

	private const int SaveSlotIndex_TinkererItem = 3;

	private const int SaveSlotIndexCount = 4;

	internal Item[] _temporaryItemSlots = new Item[4];

	private static readonly PlayerFileData _visualCloneDummyData = new PlayerFileData();

	private static readonly MemoryStream _visualCloneStream = new MemoryStream();

	private static readonly BinaryWriter _visualCloneWriter = new BinaryWriter(_visualCloneStream);

	private static readonly BinaryReader _visualCloneReader = new BinaryReader(_visualCloneStream);

	private Player _clientClone;

	internal IList<string> usedMods;

	internal string modPack;

	internal ModPlayer[] modPlayers = Array.Empty<ModPlayer>();

	public Item equippedWings;

	/// <summary>
	/// Causes <see cref="M:Terraria.Player.SmartSelectLookup" /> to run the next time an item animation is finished, even if <see cref="F:Terraria.Player.controlUseItem" /> is held. <br />
	/// Used internally by tML to when a hotbar key is pressed while using an item.
	/// </summary>
	public bool selectItemOnNextUse;

	private int consumedLifeCrystals;

	/// <summary>
	/// The maximum amount of Life Crystals this player is allowed to consume total
	/// </summary>
	public const int LifeCrystalMax = 15;

	private int consumedLifeFruit;

	/// <summary>
	/// The maximum amount of Life Fruit this player is allowed to consume total
	/// </summary>
	public const int LifeFruitMax = 20;

	private int consumedManaCrystals;

	/// <summary>
	/// The maximum amount of Mana Crystals this player is allowed to consume total
	/// </summary>
	public const int ManaCrystalMax = 9;

	private DamageClassData[] damageData;

	/// <summary>
	/// Stores whether or not the player is in a modbiome using boolean bits.
	/// </summary>
	internal BitArray modBiomeFlags = new BitArray(0);

	private ExtraJumpState[] extraJumps = new ExtraJumpState[ExtraJumpLoader.ExtraJumpCount];

	/// <summary>
	/// When <see langword="true" />, all extra jumps will be blocked, including Flipper usage.<br />
	/// Setting this field to <see langword="true" /> will not stop any currently active extra jumps.
	/// </summary>
	public bool blockExtraJumps;

	public bool sandStorm
	{
		get
		{
			if (_sandStormLogicEnabled)
			{
				return GetJumpState<SandstormInABottleJump>().Active;
			}
			return false;
		}
		set
		{
			_sandStormLogicEnabled = value;
		}
	}

	internal static int maxBuffs => 44 + BuffLoader.extraPlayerBuffCount;

	public static int MaxBuffs => maxBuffs;

	internal ref float armorPenetration => ref GetArmorPenetration(DamageClass.Generic);

	internal ref float allCrit => ref GetCritChance(DamageClass.Generic);

	internal ref float meleeCrit => ref GetCritChance(DamageClass.Melee);

	internal ref float magicCrit => ref GetCritChance(DamageClass.Magic);

	internal ref float rangedCrit => ref GetCritChance(DamageClass.Ranged);

	internal ref StatModifier allDamage => ref GetDamage(DamageClass.Generic);

	internal ref StatModifier meleeDamage => ref GetDamage(DamageClass.Melee);

	internal ref StatModifier magicDamage => ref GetDamage(DamageClass.Magic);

	internal ref StatModifier rangedDamage => ref GetDamage(DamageClass.Ranged);

	private ref StatModifier arrowDamageAdditiveStack => ref arrowDamage;

	internal ref StatModifier minionDamage => ref GetDamage(DamageClass.Summon);

	internal ref StatModifier allKB => ref GetKnockback(DamageClass.Generic);

	internal ref float minionKB => ref GetKnockback(DamageClass.Summon).Base;

	internal ref float meleeSpeed => ref GetAttackSpeed(DamageClass.Melee);

	internal float inverseMeleeSpeed => 1f / GetTotalAttackSpeed(DamageClass.Melee);

	internal ref float summonerWeaponSpeedBonus => ref GetAttackSpeed(DamageClass.SummonMeleeSpeed);

	public bool[] adjTile
	{
		get
		{
			if (_adjTile.Length != TileLoader.TileCount)
			{
				Array.Resize(ref _adjTile, TileLoader.TileCount);
			}
			return _adjTile;
		}
		set
		{
			_adjTile = value;
		}
	}

	public bool[] oldAdjTile
	{
		get
		{
			if (_oldAdjTile.Length != TileLoader.TileCount)
			{
				Array.Resize(ref _oldAdjTile, TileLoader.TileCount);
			}
			return _oldAdjTile;
		}
		set
		{
			_oldAdjTile = value;
		}
	}

	public bool accFlipper
	{
		get
		{
			return GetJumpState<FlipperJump>().Enabled;
		}
		set
		{
			ref ExtraJumpState state = ref GetJumpState<FlipperJump>();
			if (value)
			{
				state.Enable();
				state.Available = true;
			}
			else
			{
				state.Disable();
			}
		}
	}

	internal bool hasJumpOption_Cloud
	{
		set
		{
			if (value)
			{
				GetJumpState<CloudInABottleJump>().Enable();
				return;
			}
			throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement");
		}
	}

	internal bool hasJumpOption_Sandstorm
	{
		set
		{
			if (value)
			{
				GetJumpState<SandstormInABottleJump>().Enable();
				return;
			}
			throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement");
		}
	}

	internal bool hasJumpOption_Blizzard
	{
		set
		{
			if (value)
			{
				GetJumpState<BlizzardInABottleJump>().Enable();
				return;
			}
			throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement");
		}
	}

	internal bool hasJumpOption_Fart
	{
		set
		{
			if (value)
			{
				GetJumpState<FartInAJarJump>().Enable();
				return;
			}
			throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement");
		}
	}

	internal bool hasJumpOption_Sail
	{
		set
		{
			if (value)
			{
				GetJumpState<TsunamiInABottleJump>().Enable();
				return;
			}
			throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement");
		}
	}

	internal bool hasJumpOption_Unicorn
	{
		set
		{
			if (value)
			{
				GetJumpState<UnicornMountJump>().Enable();
				return;
			}
			throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement");
		}
	}

	internal bool hasJumpOption_Santank
	{
		set
		{
			if (value)
			{
				GetJumpState<SantankMountJump>().Enable();
				return;
			}
			throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement");
		}
	}

	internal bool hasJumpOption_WallOfFleshGoat
	{
		set
		{
			if (value)
			{
				GetJumpState<GoatMountJump>().Enable();
				return;
			}
			throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement");
		}
	}

	internal bool hasJumpOption_Basilisk
	{
		set
		{
			if (value)
			{
				GetJumpState<BasiliskMountJump>().Enable();
				return;
			}
			throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement");
		}
	}

	public Vector2 BlehOldPositionFixer => -Vector2.UnitY;

	public float HeightOffsetVisual
	{
		get
		{
			if (mount.Active)
			{
				return mount.PlayerOffset;
			}
			if (portableStoolInfo.IsInUse)
			{
				return portableStoolInfo.VisualYOffset;
			}
			return 0f;
		}
	}

	public float HeightOffsetHitboxCenter
	{
		get
		{
			if (mount.Active)
			{
				return mount.PlayerOffsetHitbox;
			}
			if (portableStoolInfo.IsInUse)
			{
				return portableStoolInfo.HeightBoost - portableStoolInfo.VisualYOffset;
			}
			return 0f;
		}
	}

	public float MountXOffset
	{
		get
		{
			if (mount.Active)
			{
				return mount.PlayerXOFfset;
			}
			return 0f;
		}
	}

	public int HeightOffsetBoost
	{
		get
		{
			if (mount.Active)
			{
				return mount.HeightBoost;
			}
			if (portableStoolInfo.IsInUse)
			{
				return portableStoolInfo.HeightBoost;
			}
			return 0;
		}
	}

	public int HeightMapOffset
	{
		get
		{
			if (mount.Active)
			{
				return mount.PlayerHeadOffset;
			}
			if (portableStoolInfo.IsInUse)
			{
				return portableStoolInfo.HeightBoost;
			}
			return 0;
		}
	}

	public Rectangle HitboxForBestiaryNearbyCheck
	{
		get
		{
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			Rectangle result = default(Rectangle);
			((Rectangle)(ref result))._002Ector((int)position.X, (int)position.Y, width, height);
			((Rectangle)(ref result)).Inflate(300, 200);
			return result;
		}
	}

	public bool IsStandingStillForSpecialEffects
	{
		get
		{
			if ((double)Math.Abs(velocity.X) < 0.05)
			{
				return (double)Math.Abs(velocity.Y) < 0.05;
			}
			return false;
		}
	}

	/// <summary>
	/// Returns the player's center adjusted for mount and step stool usage. Typically used in conjunction with <see cref="M:Terraria.Player.RotatedRelativePoint(Microsoft.Xna.Framework.Vector2,System.Boolean,System.Boolean)" /> to retrieve a suitable position for positioning items and effects originating from the player.
	/// </summary>
	public Vector2 MountedCenter
	{
		get
		{
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			return new Vector2(position.X + (float)(width / 2), position.Y + 21f + HeightOffsetHitboxCenter);
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			position = new Vector2(value.X - (float)(width / 2), value.Y - 21f - HeightOffsetHitboxCenter);
		}
	}

	public bool TileReplacementEnabled => builderAccStatus[10] == 0;

	public override Vector2 VisualPosition => position + new Vector2(0f, gfxOffY);

	/// <summary>
	/// Checks if the player is currently "crowd controlled", meaning the player is <see cref="F:Terraria.Player.frozen" />, <see cref="F:Terraria.Player.webbed" />, or <see cref="F:Terraria.Player.stoned" />. Used in various checks to prevent some player actions that shouldn't be possible while in those states, such as channeling attacks, quick using items, and swapping loadouts.
	/// </summary>
	public bool CCed
	{
		get
		{
			if (!frozen && !webbed)
			{
				return stoned;
			}
			return true;
		}
	}

	public float miscCounterNormalized => (float)miscCounter / 300f;

	public bool Male
	{
		get
		{
			return PlayerVariantID.Sets.Male[skinVariant];
		}
		set
		{
			if (value)
			{
				if (!Male)
				{
					skinVariant = PlayerVariantID.Sets.AltGenderReference[skinVariant];
				}
			}
			else if (Male)
			{
				skinVariant = PlayerVariantID.Sets.AltGenderReference[skinVariant];
			}
		}
	}

	public bool ZoneDungeon
	{
		get
		{
			return zone1[0];
		}
		set
		{
			zone1[0] = value;
		}
	}

	public bool ZoneCorrupt
	{
		get
		{
			return zone1[1];
		}
		set
		{
			zone1[1] = value;
		}
	}

	public bool ZoneHallow
	{
		get
		{
			return zone1[2];
		}
		set
		{
			zone1[2] = value;
		}
	}

	public bool ZoneMeteor
	{
		get
		{
			return zone1[3];
		}
		set
		{
			zone1[3] = value;
		}
	}

	public bool ZoneJungle
	{
		get
		{
			return zone1[4];
		}
		set
		{
			zone1[4] = value;
		}
	}

	public bool ZoneSnow
	{
		get
		{
			return zone1[5];
		}
		set
		{
			zone1[5] = value;
		}
	}

	public bool ZoneCrimson
	{
		get
		{
			return zone1[6];
		}
		set
		{
			zone1[6] = value;
		}
	}

	public bool ZoneWaterCandle
	{
		get
		{
			return zone1[7];
		}
		set
		{
			zone1[7] = value;
		}
	}

	public bool ZonePeaceCandle
	{
		get
		{
			return zone2[0];
		}
		set
		{
			zone2[0] = value;
		}
	}

	public bool ZoneTowerSolar
	{
		get
		{
			return zone2[1];
		}
		set
		{
			zone2[1] = value;
		}
	}

	public bool ZoneTowerVortex
	{
		get
		{
			return zone2[2];
		}
		set
		{
			zone2[2] = value;
		}
	}

	public bool ZoneTowerNebula
	{
		get
		{
			return zone2[3];
		}
		set
		{
			zone2[3] = value;
		}
	}

	public bool ZoneTowerStardust
	{
		get
		{
			return zone2[4];
		}
		set
		{
			zone2[4] = value;
		}
	}

	public bool ZoneDesert
	{
		get
		{
			return zone2[5];
		}
		set
		{
			zone2[5] = value;
		}
	}

	public bool ZoneGlowshroom
	{
		get
		{
			return zone2[6];
		}
		set
		{
			zone2[6] = value;
		}
	}

	public bool ZoneUndergroundDesert
	{
		get
		{
			return zone2[7];
		}
		set
		{
			zone2[7] = value;
		}
	}

	/// <summary>
	/// If <see langword="true" />, then this player is the top 35% of the world.
	/// <br /> <strong>NOTE:</strong> Vanilla uses a lot of different conditions for what counts as space. This flag is never used in vanilla, but the logic behind it is used for NPC shops and enemy spawns.
	/// </summary>
	public bool ZoneSkyHeight
	{
		get
		{
			return zone3[0];
		}
		set
		{
			zone3[0] = value;
		}
	}

	/// <summary>
	/// If <see langword="true" />, then this player is above ground (<see cref="F:Terraria.Main.worldSurface" />) but not in space (<see cref="P:Terraria.Player.ZoneSkyHeight" />).
	/// </summary>
	public bool ZoneOverworldHeight
	{
		get
		{
			return zone3[1];
		}
		set
		{
			zone3[1] = value;
		}
	}

	/// <summary>
	/// If <see langword="true" />, then this player is underground (<see cref="F:Terraria.Main.worldSurface" />) but above the Caverns layer (<see cref="F:Terraria.Main.rockLayer" />).
	/// </summary>
	public bool ZoneDirtLayerHeight
	{
		get
		{
			return zone3[2];
		}
		set
		{
			zone3[2] = value;
		}
	}

	/// <summary>
	/// If <see langword="true" />, then this player is in the Caverns layer (<see cref="F:Terraria.Main.rockLayer" />) but not in the Underworld (<see cref="P:Terraria.Main.UnderworldLayer" />).
	/// </summary>
	public bool ZoneRockLayerHeight
	{
		get
		{
			return zone3[3];
		}
		set
		{
			zone3[3] = value;
		}
	}

	/// <summary>
	/// If <see langword="true" />, then this player is in the Underworld (<see cref="P:Terraria.Main.UnderworldLayer" />).
	/// </summary>
	public bool ZoneUnderworldHeight
	{
		get
		{
			return zone3[4];
		}
		set
		{
			zone3[4] = value;
		}
	}

	public bool ZoneBeach
	{
		get
		{
			return zone3[5];
		}
		set
		{
			zone3[5] = value;
		}
	}

	public bool ZoneRain
	{
		get
		{
			return zone3[6];
		}
		set
		{
			zone3[6] = value;
		}
	}

	public bool ZoneSandstorm
	{
		get
		{
			return zone3[7];
		}
		set
		{
			zone3[7] = value;
		}
	}

	public bool ZoneOldOneArmy
	{
		get
		{
			return zone4[0];
		}
		set
		{
			zone4[0] = value;
		}
	}

	public bool ZoneGranite
	{
		get
		{
			return zone4[1];
		}
		set
		{
			zone4[1] = value;
		}
	}

	public bool ZoneMarble
	{
		get
		{
			return zone4[2];
		}
		set
		{
			zone4[2] = value;
		}
	}

	public bool ZoneHive
	{
		get
		{
			return zone4[3];
		}
		set
		{
			zone4[3] = value;
		}
	}

	public bool ZoneGemCave
	{
		get
		{
			return zone4[4];
		}
		set
		{
			zone4[4] = value;
		}
	}

	public bool ZoneLihzhardTemple
	{
		get
		{
			return zone4[5];
		}
		set
		{
			zone4[5] = value;
		}
	}

	public bool ZoneGraveyard
	{
		get
		{
			return zone4[6];
		}
		set
		{
			zone4[6] = value;
		}
	}

	public bool ZoneShadowCandle
	{
		get
		{
			return zone4[7];
		}
		set
		{
			zone4[7] = value;
		}
	}

	public bool ZoneShimmer
	{
		get
		{
			return zone5[0];
		}
		set
		{
			zone5[0] = value;
		}
	}

	public bool ShoppingZone_AnyBiome
	{
		get
		{
			if (!ZoneDungeon && !ZoneCorrupt && !ZoneCrimson && !ZoneGlowshroom && !ZoneHallow && !ZoneJungle && !ZoneSnow && !ZoneBeach)
			{
				return ZoneDesert;
			}
			return true;
		}
	}

	public bool ShoppingZone_BelowSurface => (double)position.Y > Main.worldSurface * 16.0;

	public bool ShoppingZone_Forest
	{
		get
		{
			if (ShoppingZone_AnyBiome || ShoppingZone_BelowSurface)
			{
				return false;
			}
			return true;
		}
	}

	public Vector2 Directions => new Vector2((float)direction, gravDir);

	public Item HeldItem => inventory[selectedItem];

	public int breathCDMax
	{
		get
		{
			int num = 7;
			if (inventory[selectedItem].type == 186 && itemAnimation == 0)
			{
				num *= 2;
			}
			if (accDivingHelm)
			{
				num *= 6;
			}
			return num;
		}
	}

	public bool ShouldFloatInWater
	{
		get
		{
			if (canFloatInWater && !controlDown)
			{
				if (mount.Active)
				{
					return mount.Type == 37;
				}
				return true;
			}
			return false;
		}
	}

	public bool CanBeTalkedTo
	{
		get
		{
			if (active && !dead && !ShouldNotDraw)
			{
				return stealth == 1f;
			}
			return false;
		}
	}

	public bool IsVoidVaultEnabled
	{
		get
		{
			return voidVaultInfo[0];
		}
		set
		{
			voidVaultInfo[0] = value;
		}
	}

	public bool DeadOrGhost
	{
		get
		{
			if (!dead)
			{
				return ghost;
			}
			return true;
		}
	}

	public bool TryingToHoverUp
	{
		get
		{
			if (!controlUp)
			{
				return tryKeepingHoveringUp;
			}
			return true;
		}
	}

	public bool TryingToHoverDown
	{
		get
		{
			if (!controlDown)
			{
				return tryKeepingHoveringDown;
			}
			return true;
		}
	}

	public Vector2 DefaultSize => new Vector2(20f, 42f);

	public bool UsingBiomeTorches
	{
		get
		{
			if (!unlockedBiomeTorches)
			{
				return false;
			}
			return builderAccStatus[11] == 0;
		}
		set
		{
			builderAccStatus[11] = ((!value) ? 1 : 0);
		}
	}

	/// <summary>
	/// If <see langword="true" />, then any minecart (<see cref="F:Terraria.ID.MountID.Sets.Cart" />) this player rides in will be significantly faster and fire lasers.
	/// <br /> Cannot be <see langword="true" /> if <see cref="F:Terraria.Player.unlockedSuperCart" /> is <see langword="false" />.
	/// </summary>
	public bool UsingSuperCart
	{
		get
		{
			if (!unlockedSuperCart)
			{
				return false;
			}
			return enabledSuperCart;
		}
		set
		{
			enabledSuperCart = value;
		}
	}

	public bool ShouldNotDraw
	{
		get
		{
			if (invis && itemAnimation == 0)
			{
				if (!isDisplayDollOrInanimate)
				{
					return !isHatRackDoll;
				}
				return false;
			}
			return false;
		}
	}

	public int talkNPC { get; private set; }

	/// <summary>
	/// The NPC instance the player is talking to, or null if <see cref="P:Terraria.Player.talkNPC" /> is -1
	/// </summary>
	public NPC TalkNPC
	{
		get
		{
			if (talkNPC < 0)
			{
				return null;
			}
			return Main.npc[talkNPC];
		}
	}

	public bool isLockedToATile
	{
		get
		{
			if (!sitting.isSitting)
			{
				return sleeping.isSleeping;
			}
			return true;
		}
	}

	public bool PortalPhysicsEnabled
	{
		get
		{
			if (_portalPhysicsTime > 0)
			{
				return !mount.Active;
			}
			return false;
		}
	}

	public bool MountFishronSpecial
	{
		get
		{
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			if (statLife >= statLifeMax2 / 2 && (!wet || lavaWet || honeyWet) && !dripping && !(MountFishronSpecialCounter > 0f))
			{
				if (Main.raining)
				{
					return WorldGen.InAPlaceWithWind(position, width, height);
				}
				return false;
			}
			return true;
		}
	}

	public bool HasMinionRestTarget => MinionRestTargetPoint != Vector2.Zero;

	public bool HasMinionAttackTargetNPC => MinionAttackTargetNPC != -1;

	public bool ItemTimeIsZero => itemTime == 0;

	/// <summary>
	/// Returns true if the item animation is in its first frame.
	/// </summary>
	public bool ItemAnimationJustStarted
	{
		get
		{
			if (itemAnimation == itemAnimationMax)
			{
				return itemAnimation > 0;
			}
			return false;
		}
	}

	public float NormalizedLuck
	{
		get
		{
			float value = 0f;
			if (luck > 0f)
			{
				value = luck / luckMaximumCap;
			}
			else if (luck < 0f)
			{
				value = 0f - luck / luckMinimumCap;
			}
			return MathHelper.Clamp(value, -1f, 1f);
		}
	}

	public bool SlimeDontHyperJump
	{
		get
		{
			if (mount.Active && mount.IsConsideredASlimeMount && wetSlime > 0)
			{
				return !controlJump;
			}
			return false;
		}
	}

	public Vector2? MouthPosition
	{
		get
		{
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			if (mount.Active)
			{
				Mount.MountDelegatesData.OverridePositionMethod mouthPosition = mount.Delegations.MouthPosition;
				if (mouthPosition != null && mouthPosition(this, out var result))
				{
					return result;
				}
			}
			Vector2 spinningpoint = default(Vector2);
			((Vector2)(ref spinningpoint))._002Ector((float)(direction * 8), gravDir * -4f);
			return RotatedRelativePoint(MountedCenter, reverseRotation: false, addGfxOffY: false) + spinningpoint.RotatedBy(fullRotation);
		}
	}

	public Vector2? HandPosition
	{
		get
		{
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_009b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			if (mount.Active)
			{
				Mount.MountDelegatesData.OverridePositionMethod handPosition = mount.Delegations.HandPosition;
				if (handPosition != null && handPosition(this, out var result))
				{
					return result;
				}
			}
			Vector2 vector = Main.OffsetsPlayerOnhand[bodyFrame.Y / 56] * 2f;
			if (direction != 1)
			{
				vector.X = (float)bodyFrame.Width - vector.X;
			}
			if (gravDir != 1f)
			{
				vector.Y = (float)bodyFrame.Height - vector.Y;
			}
			vector -= new Vector2((float)(bodyFrame.Width - width), (float)(bodyFrame.Height - 42)) / 2f;
			Vector2 vector2 = -new Vector2(20f, 42f) / 2f + vector;
			return RotatedRelativePoint(MountedCenter + vector2);
		}
	}

	/// <summary>
	/// How many Life Crystals this player has consumed
	/// </summary>
	public int ConsumedLifeCrystals
	{
		get
		{
			return consumedLifeCrystals;
		}
		set
		{
			consumedLifeCrystals = Utils.Clamp(value, 0, 15);
		}
	}

	/// <summary>
	/// How many Life Fruit this player has consumed
	/// </summary>
	public int ConsumedLifeFruit
	{
		get
		{
			return consumedLifeFruit;
		}
		set
		{
			consumedLifeFruit = Utils.Clamp(value, 0, 20);
		}
	}

	/// <summary>
	/// How many Mana Crystals this player has consumed
	/// </summary>
	public int ConsumedManaCrystals
	{
		get
		{
			return consumedManaCrystals;
		}
		set
		{
			consumedManaCrystals = Utils.Clamp(value, 0, 9);
		}
	}

	public RefReadOnlyArray<ModPlayer> ModPlayers => modPlayers;

	RefReadOnlyArray<ModPlayer> IEntityWithInstances<ModPlayer>.Instances => modPlayers;

	public HashSet<int> NearbyModTorch { get; private set; } = new HashSet<int>();


	/// <summary>
	/// Multiplier to shot projectile velocity before throwing. Result will be capped to 16f.
	/// <br />Only applies to items counted as the <see cref="P:Terraria.ModLoader.DamageClass.Throwing" /> damage type
	/// </summary>
	public float ThrownVelocity { get; set; }

	/// <summary>
	/// If true, player has a 33% chance of not consuming the thrown item.
	/// <br />Only applies to consumable items and projectiles counted as the <see cref="P:Terraria.ModLoader.DamageClass.Throwing" /> damage type.
	/// <br />Projectiles spawned from a player who holds such item will set <see cref="F:Terraria.Projectile.noDropItem" /> to prevent duplication.
	/// <br />Stacks with <see cref="P:Terraria.Player.ThrownCost50" /> multiplicatively
	/// </summary>
	public bool ThrownCost33 { get; set; }

	/// <summary>
	/// If true, player has a 50% chance of not consuming the thrown item.
	/// <br />Only applies to consumable items counted as the <see cref="P:Terraria.ModLoader.DamageClass.Throwing" /> damage type.
	/// <br />Projectiles spawned from a player who holds such item will set <see cref="F:Terraria.Projectile.noDropItem" /> to prevent duplication.
	/// <br />Stacks with <see cref="P:Terraria.Player.ThrownCost33" /> multiplicatively
	/// </summary>
	public bool ThrownCost50 { get; set; }

	/// <summary>
	/// Returns true if either <see cref="P:Terraria.Player.ThrownCost33" /> or <see cref="P:Terraria.Player.ThrownCost50" /> are true
	/// </summary>
	public bool AnyThrownCostReduction
	{
		get
		{
			if (!ThrownCost33)
			{
				return ThrownCost50;
			}
			return true;
		}
	}

	/// <summary>
	/// Container for current SceneEffect client properties such as: Backgrounds, music, and water styling
	/// </summary>
	public SceneEffectLoader.SceneEffectInstance CurrentSceneEffect { get; set; } = new SceneEffectLoader.SceneEffectInstance();


	/// <summary>
	/// The zone property storing if the player is not in any particular biome. Updated in <see cref="M:Terraria.Player.UpdateBiomes" />
	/// Does NOT account for height. Please use ZoneForest / ZoneNormalX for height based derivatives.
	/// </summary>
	public bool ZonePurity { get; set; }

	/// <summary> Shorthand for <code>ZonePurity &amp;&amp; ZoneOverworldHeight</code></summary>
	public bool ZoneForest
	{
		get
		{
			if (ZonePurity)
			{
				return ZoneOverworldHeight;
			}
			return false;
		}
	}

	/// <summary> Shorthand for <code>ZonePurity &amp;&amp; ZoneRockLayerHeight</code></summary>
	public bool ZoneNormalCaverns
	{
		get
		{
			if (ZonePurity)
			{
				return ZoneRockLayerHeight;
			}
			return false;
		}
	}

	/// <summary> Shorthand for <code>ZonePurity &amp;&amp; ZoneDirtLayerHeight</code></summary>
	public bool ZoneNormalUnderground
	{
		get
		{
			if (ZonePurity)
			{
				return ZoneDirtLayerHeight;
			}
			return false;
		}
	}

	/// <summary> Shorthand for <code>ZonePurity &amp;&amp; ZoneSkyHeight</code></summary>
	public bool ZoneNormalSpace
	{
		get
		{
			if (ZonePurity)
			{
				return ZoneSkyHeight;
			}
			return false;
		}
	}

	/// <summary>
	/// Returns true if an item animation is currently running.
	/// </summary>
	public bool ItemAnimationActive => itemAnimation > 0;

	/// <summary>
	/// Returns true if the item animation is on or after its last frame. Meaning it could (if the player clicks etc) start again next frame. <br />
	/// Vanilla uses it to despawn spears, but it's not recommended because it will desync in multiplayer <br />
	/// (a remote player could get the packet for a new projectile just as they're finishing a swing). <br />
	/// It is recommended to use ai counters for the lifetime of animation bound projectiles instead.
	/// </summary>
	public bool ItemAnimationEndingOrEnded => itemAnimation <= 1;

	/// <summary>
	/// The number of times the item has been used/fired this animation (swing)
	/// </summary>
	public int ItemUsesThisAnimation { get; private set; }

	public Span<ExtraJumpState> ExtraJumps => extraJumps.AsSpan();

	public void RotateRelativePoint(ref float x, ref float y)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		Vector2 vector = RotatedRelativePoint(new Vector2(x, y));
		x = vector.X;
		y = vector.Y;
	}

	public Vector2 RotatedRelativePointOld(Vector2 pos, bool rotateForward = true)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		Vector2 vector = position + fullRotationOrigin;
		Matrix matrix = Matrix.CreateRotationZ(fullRotation * (float)rotateForward.ToInt());
		pos -= position + fullRotationOrigin;
		pos = Vector2.Transform(pos, matrix);
		return pos + vector;
	}

	/// <summary>
	/// Takes an input position and returns the position adjusted to the players visual rotation and offset. This accounts for the player being shifted up or down and rotated while riding a mount, sitting in a chair, and sleeping. <br />
	/// </summary>
	/// <param name="pos"></param>
	/// <param name="reverseRotation"></param>
	/// <param name="addGfxOffY"></param>
	/// <returns></returns>
	public Vector2 RotatedRelativePoint(Vector2 pos, bool reverseRotation = false, bool addGfxOffY = true)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		float num = (reverseRotation ? (0f - fullRotation) : fullRotation);
		if (sleeping.isSleeping)
		{
			num = 0f;
		}
		Vector2 vector = base.Bottom + new Vector2(0f, gfxOffY);
		int num2 = mount.PlayerOffset / 2 + 4;
		Vector2 vector2 = new Vector2(0f, (float)(-num2)) + Utils.RotatedBy(new Vector2(0f, (float)num2), num);
		if (addGfxOffY)
		{
			pos.Y += gfxOffY;
		}
		pos = vector + (pos - vector).RotatedBy(num) + vector2;
		if (sleeping.isSleeping)
		{
			sleeping.GetSleepingOffsetInfo(this, out var posOffset);
			pos += posOffset;
		}
		if (sitting.isSitting)
		{
			sitting.GetSittingOffsetInfo(this, out var posOffset2, out var seatAdjustment);
			pos += posOffset2 + new Vector2(0f, seatAdjustment);
		}
		return pos;
	}

	public bool CanDemonHeartAccessoryBeShown()
	{
		if (!IsItemSlotUnlockedAndUsable(8) && armor[8].type <= 0 && armor[18].type <= 0)
		{
			return dye[8].type > 0;
		}
		return true;
	}

	public bool CanMasterModeAccessoryBeShown()
	{
		if (!IsItemSlotUnlockedAndUsable(9) && armor[9].type <= 0 && armor[19].type <= 0)
		{
			return dye[9].type > 0;
		}
		return true;
	}

	public int GetAmountOfExtraAccessorySlotsToShow()
	{
		int num = 0;
		if (CanDemonHeartAccessoryBeShown())
		{
			num++;
		}
		if (CanMasterModeAccessoryBeShown())
		{
			num++;
		}
		return num;
	}

	public EntityShadowInfo GetAdvancedShadow(int shadowIndex)
	{
		if (shadowIndex > availableAdvancedShadowsCount)
		{
			shadowIndex = availableAdvancedShadowsCount;
		}
		int num = (_lastAddedAvancedShadow - shadowIndex).ModulusPositive(60);
		return _advancedShadows[num];
	}

	public void UpdateAdvancedShadows()
	{
		availableAdvancedShadowsCount++;
		if (availableAdvancedShadowsCount > 60)
		{
			availableAdvancedShadowsCount = 60;
		}
		if (++_lastAddedAvancedShadow >= 60)
		{
			_lastAddedAvancedShadow = 0;
		}
		_advancedShadows[_lastAddedAvancedShadow].CopyPlayer(this);
	}

	public void ResetAdvancedShadows()
	{
		availableAdvancedShadowsCount = 0;
	}

	public void SetCompositeArmFront(bool enabled, CompositeArmStretchAmount stretch, float rotation)
	{
		if (gravDir == -1f)
		{
			rotation = 0f - rotation;
		}
		compositeFrontArm = new CompositeArmData(enabled, stretch, rotation);
	}

	public void SetCompositeArmBack(bool enabled, CompositeArmStretchAmount stretch, float rotation)
	{
		if (gravDir == -1f)
		{
			rotation = 0f - rotation;
		}
		compositeBackArm = new CompositeArmData(enabled, stretch, rotation);
	}

	public void SetTalkNPC(int npcIndex, bool fromNet = false)
	{
		talkNPC = npcIndex;
		if (Main.netMode != 1 && npcIndex >= 0 && npcIndex < 200)
		{
			Main.BestiaryTracker.Chats.RegisterChatStartWith(Main.npc[npcIndex]);
		}
		if (talkNPC == -1)
		{
			currentShoppingSettings = ShoppingSettings.NotInShop;
		}
		else
		{
			currentShoppingSettings = Main.ShopHelper.GetShoppingSettings(this, Main.npc[talkNPC]);
		}
		if (currentShoppingSettings.PriceAdjustment <= 0.8199999928474426)
		{
			AchievementsHelper.HandleSpecialEvent(this, 20);
		}
	}

	public void SetItemTime(int frames)
	{
		itemTime = frames;
		itemTimeMax = frames;
	}

	public void ApplyItemTime(Item sItem, float multiplier = 1f, bool? callUseItem = null)
	{
		if (!(callUseItem ?? ItemTimeIsZero) || ItemLoader.UseItem(sItem, this) != false)
		{
			SetItemTime(CombinedHooks.TotalUseTime((float)sItem.useTime * multiplier, this, sItem));
			ItemUsesThisAnimation++;
		}
	}

	public void SetDummyItemTime(int frames)
	{
		itemAnimation = frames;
		itemTime = frames;
		itemTimeMax = frames + 1;
	}

	public void SetItemAnimation(int frames)
	{
		itemAnimation = frames;
		itemAnimationMax = frames;
	}

	public void ApplyItemAnimation(Item sItem)
	{
		if (sItem.createTile >= 0)
		{
			ApplyItemAnimation(sItem, tileSpeed);
		}
		else if (sItem.createWall >= 0)
		{
			ApplyItemAnimation(sItem, wallSpeed);
		}
		else
		{
			ApplyItemAnimation(sItem, 1f);
		}
	}

	public void ApplyItemAnimation(Item sItem, float multiplier, int? itemReuseDelay = null)
	{
		ItemLoader.UseAnimation(sItem, this);
		SetItemAnimation(CombinedHooks.TotalAnimationTime((float)sItem.useAnimation * multiplier, this, sItem));
		reuseDelay = (int)((float)(itemReuseDelay ?? sItem.reuseDelay) / CombinedHooks.TotalUseSpeedMultiplier(this, sItem));
		ItemUsesThisAnimation = 0;
	}

	public void MatchItemTimeToItemAnimation()
	{
		itemTime = itemAnimation;
	}

	public bool InOpposingTeam(Player otherPlayer)
	{
		if (hostile && otherPlayer.hostile)
		{
			if (otherPlayer.team != 0)
			{
				return otherPlayer.team != team;
			}
			return true;
		}
		return false;
	}

	public bool TeamChangeAllowed()
	{
		return true;
	}

	/// <summary>
	/// Spawns a <see cref="T:Terraria.CombatText" /> indicating the player healed <paramref name="healAmount" /> life and syncs it if <paramref name="broadcast" /> is true. <br />
	/// Note that this doesn't actually heal the player, it only spawns the floating text. The <see cref="M:Terraria.Player.Heal(System.Int32)" /> method heals the player and calls this method and is more commonly used.
	/// </summary>
	public void HealEffect(int healAmount, bool broadcast = true)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		CombatText.NewText(new Rectangle((int)position.X, (int)position.Y, width, height), CombatText.HealLife, healAmount);
		if (broadcast && Main.netMode == 1 && whoAmI == Main.myPlayer)
		{
			NetMessage.SendData(35, -1, -1, null, whoAmI, healAmount);
		}
	}

	public void ManaEffect(int manaAmount)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		CombatText.NewText(new Rectangle((int)position.X, (int)position.Y, width, height), CombatText.HealMana, manaAmount);
		if (Main.netMode == 1 && whoAmI == Main.myPlayer)
		{
			NetMessage.SendData(43, -1, -1, null, whoAmI, manaAmount);
		}
	}

	public void InterruptItemUsageIfOverTile(int tileTypeToBeOver)
	{
		Tile tile = Main.tile[tileTargetX, tileTargetY];
		if (tile != null && tile.active() && tile.type == tileTypeToBeOver)
		{
			Main.blockMouse = true;
		}
	}

	public Vector2 GetHairDrawOffset(int hairID, bool hatHair)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		Vector2 zero = Vector2.Zero;
		if (!hatHair && hairID == 163)
		{
			return new Vector2(0f, -2f) * Directions;
		}
		if (hairID == 164)
		{
			return new Vector2(-2f, 0f) * Directions;
		}
		return zero;
	}

	public Vector2 GetHelmetDrawOffset()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		Vector2 headOffset = Vector2.Zero;
		if (head == 270)
		{
			headOffset = new Vector2(-10f, 0f) * Directions;
			if (direction == -1)
			{
				headOffset.X -= 2f;
			}
		}
		else if (head == 268)
		{
			headOffset = new Vector2(0f, -6f) * Directions;
		}
		else if (head == 222)
		{
			float y = 0f;
			if (hair == 15 || hair == 76 || hair == 108)
			{
				y = 4f;
			}
			headOffset = new Vector2(0f, y) * Directions;
		}
		else if (head == 272)
		{
			if (hair == 15 || hair == 76 || hair == 108)
			{
				headOffset = new Vector2(0f, 4f) * Directions;
			}
		}
		else if (head == 275)
		{
			headOffset = new Vector2(0f, -4f) * Directions;
		}
		return GetHelmetOffsetAddonFromFaceHead(headOffset);
	}

	public Vector2 GetBeardDrawOffsetFromHelmet()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		Vector2 result = Vector2.Zero;
		switch (head)
		{
		case 165:
			((Vector2)(ref result))._002Ector((float)(8 * direction), 0f);
			break;
		case 146:
		case 150:
		case 152:
			((Vector2)(ref result))._002Ector((float)(2 * direction), 0f);
			break;
		case 148:
			((Vector2)(ref result))._002Ector((float)(2 * direction), 0f);
			break;
		}
		return result;
	}

	public Vector2 GetFaceHeadOffsetFromHelmet()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		Vector2 vector = Vector2.Zero;
		if (faceHead == 12 || faceHead == 13 || faceHead == 10 || faceHead == 11 || faceHead == 17 || faceHead == 18 || faceHead == 15 || faceHead == 16)
		{
			switch (head)
			{
			case 20:
			case 221:
				((Vector2)(ref vector))._002Ector(0f, -2f);
				break;
			case 196:
				((Vector2)(ref vector))._002Ector(2f, 0f);
				break;
			}
		}
		return vector * Directions;
	}

	public Vector2 GetHelmetOffsetAddonFromFaceHead(Vector2 headOffset)
	{
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		if (faceHead == 12 || faceHead == 13 || faceHead == 10 || faceHead == 11 || faceHead == 17 || faceHead == 18 || faceHead == 15 || faceHead == 16)
		{
			switch (head)
			{
			case 16:
			case 21:
			case 24:
			case 65:
			case 67:
			case 94:
			case 95:
			case 96:
			case 159:
			case 222:
			case 231:
			case 250:
				headOffset += new Vector2(2f, 0f) * Directions;
				break;
			case 59:
			case 64:
			case 106:
			case 138:
			case 181:
			case 220:
				headOffset += new Vector2(0f, -2f) * Directions;
				break;
			case 26:
			case 51:
			case 60:
			case 81:
				headOffset += new Vector2(2f, -2f) * Directions;
				break;
			case 97:
				headOffset += new Vector2(-2f, 0f) * Directions;
				break;
			case 117:
				headOffset += new Vector2(-4f, 0f) * Directions;
				break;
			}
		}
		return headOffset;
	}

	public Vector2 GetLegsDrawOffset()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		Vector2 result = Vector2.Zero;
		if (legs == 226)
		{
			result = new Vector2(-6f, 0f) * Directions;
		}
		return result;
	}

	public void AccumulateGolfingScore(int score)
	{
		int num = score;
		if (golferScoreAccumulated + num > 1000000000)
		{
			num = 1000000000 - golferScoreAccumulated;
		}
		golferScoreAccumulated += num;
	}

	public static byte FindClosest(Vector2 Position, int Width, int Height)
	{
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		byte result = 0;
		for (int i = 0; i < 255; i++)
		{
			if (Main.player[i].active)
			{
				result = (byte)i;
				break;
			}
		}
		float num = -1f;
		for (int j = 0; j < 255; j++)
		{
			if (Main.player[j].active && !Main.player[j].dead)
			{
				float num2 = Math.Abs(Main.player[j].position.X + (float)(Main.player[j].width / 2) - (Position.X + (float)(Width / 2))) + Math.Abs(Main.player[j].position.Y + (float)(Main.player[j].height / 2) - (Position.Y + (float)(Height / 2)));
				if (num == -1f || num2 < num)
				{
					num = num2;
					result = (byte)j;
				}
			}
		}
		return result;
	}

	public void ToggleInv()
	{
		bool grappleAndInteractAreShared = PlayerInput.GrappleAndInteractAreShared;
		if (Main.mapFullscreen)
		{
			Main.mapFullscreen = false;
			releaseInventory = false;
			SoundEngine.PlaySound(11);
			if (PlayerInput.GrappleAndInteractAreShared)
			{
				LockGamepadTileInteractions();
			}
		}
		else if (PlayerInput.InBuildingMode)
		{
			PlayerInput.ExitBuildingMode();
		}
		else if (Main.ingameOptionsWindow)
		{
			if (PlayerInput.UsingGamepadUI && UILinkPointNavigator.CurrentPage == 1002)
			{
				UILinkPointNavigator.ChangePage(1001);
			}
			else
			{
				IngameOptions.Close();
			}
		}
		else if (Main.inFancyUI)
		{
			IngameFancyUI.Close();
		}
		else if (CaptureManager.Instance.Active)
		{
			CaptureManager.Instance.Active = false;
		}
		else if (talkNPC >= 0)
		{
			SetTalkNPC(-1);
			Main.npcChatCornerItem = 0;
			Main.npcChatText = "";
			SoundEngine.PlaySound(11);
			if (PlayerInput.UsingGamepad)
			{
				Main.npcChatRelease = false;
			}
		}
		else if (sign >= 0)
		{
			sign = -1;
			Main.editSign = false;
			Main.npcChatText = "";
			SoundEngine.PlaySound(11);
		}
		else if (Main.clothesWindow)
		{
			Main.CancelClothesWindow();
		}
		else if (!Main.playerInventory)
		{
			OpenInventory();
		}
		else
		{
			Main.playerInventory = false;
			if (channel && Main.mouseItem != null && !Main.mouseItem.IsAir)
			{
				channel = false;
			}
			tileEntityAnchor.Clear();
			if (!PlayerInput.UsingGamepad)
			{
				Main.EquipPageSelected = 0;
			}
			else
			{
				PlayerInput.NavigatorUnCachePosition();
				Main.GamepadCursorAlpha = 0f;
				BlockInteractionWithProjectiles = 3;
				if (PlayerInput.GrappleAndInteractAreShared)
				{
					LockGamepadTileInteractions();
				}
			}
			SoundEngine.PlaySound(11);
			if (ItemSlot.Options.HighlightNewItems)
			{
				Item[] array = inventory;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].newAndShiny = false;
				}
			}
			if (PlayerInput.UsingGamepad)
			{
				Main.npcChatRelease = false;
				tileInteractionHappened = true;
				releaseInventory = false;
				Main.mouseRight = true;
			}
		}
		if (grappleAndInteractAreShared)
		{
			GamepadEnableGrappleCooldown();
		}
	}

	private static void OpenInventory()
	{
		Recipe.FindRecipes();
		Main.playerInventory = true;
		Main.EquipPageSelected = 0;
		SoundEngine.PlaySound(10);
	}

	public void ToggleCreativeMenu()
	{
		if (dead || difficulty != 3)
		{
			return;
		}
		bool flag = false;
		if (Main.mapFullscreen)
		{
			Main.mapFullscreen = false;
			flag = true;
		}
		if (PlayerInput.InBuildingMode)
		{
			PlayerInput.ExitBuildingMode();
		}
		if (Main.ingameOptionsWindow)
		{
			IngameOptions.Close();
		}
		if (Main.inFancyUI)
		{
			IngameFancyUI.Close();
		}
		if (CaptureManager.Instance.Active)
		{
			CaptureManager.Instance.Active = false;
		}
		if (talkNPC >= 0)
		{
			SetTalkNPC(-1);
			Main.npcChatCornerItem = 0;
			Main.npcChatText = "";
			flag = true;
			if (PlayerInput.UsingGamepad)
			{
				Main.npcChatRelease = false;
			}
		}
		if (sign >= 0)
		{
			sign = -1;
			Main.editSign = false;
			Main.npcChatText = "";
			flag = true;
		}
		else if (Main.clothesWindow)
		{
			Main.CancelClothesWindow();
		}
		if (tileEntityAnchor.InUse)
		{
			Recipe.FindRecipes();
			tileEntityAnchor.Clear();
			flag = true;
		}
		if (flag)
		{
			SoundEngine.PlaySound(11);
		}
		if (!Main.playerInventory)
		{
			OpenInventory();
		}
		Main.CreativeMenu.ToggleMenu();
	}

	public void dropItemCheck()
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_029d: Unknown result type (might be due to invalid IL or missing references)
		if (!Main.playerInventory)
		{
			noThrow = 0;
		}
		if (noThrow > 0)
		{
			noThrow--;
		}
		GetItemSettings getItemInDropItemCheck = GetItemSettings.GetItemInDropItemCheck;
		if (!Main.InGuideCraftMenu && Main.guideItem.type > 0)
		{
			Main.guideItem.position = base.Center;
			Item item = GetItem(whoAmI, Main.guideItem, getItemInDropItemCheck);
			if (item.stack > 0)
			{
				int num = Item.NewItem(new EntitySource_OverfullInventory(this), position, width, height, item, noBroadcast: false, noGrabDelay: true);
				Main.item[num].newAndShiny = false;
				if (Main.netMode == 1)
				{
					NetMessage.SendData(21, -1, -1, null, num, 1f);
				}
			}
			Main.guideItem = new Item();
		}
		if (!Main.InReforgeMenu && Main.reforgeItem.type > 0)
		{
			Main.reforgeItem.position = base.Center;
			Item item2 = GetItem(whoAmI, Main.reforgeItem, getItemInDropItemCheck);
			if (item2.stack > 0)
			{
				int num2 = Item.NewItem(new EntitySource_OverfullInventory(this), position, width, height, item2, noBroadcast: false, noGrabDelay: true);
				Main.item[num2].newAndShiny = false;
				if (Main.netMode == 1)
				{
					NetMessage.SendData(21, -1, -1, null, num2, 1f);
				}
			}
			Main.reforgeItem = new Item();
		}
		if (Main.myPlayer == whoAmI)
		{
			inventory[58] = Main.mouseItem.Clone();
		}
		bool flag = true;
		if (Main.mouseItem.type > 0 && Main.mouseItem.stack > 0)
		{
			if (!Main.gamePaused)
			{
				tileTargetX = (int)(((float)Main.mouseX + Main.screenPosition.X) / 16f);
				tileTargetY = (int)(((float)Main.mouseY + Main.screenPosition.Y) / 16f);
				if (gravDir == -1f)
				{
					tileTargetY = (int)((Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY) / 16f);
				}
			}
			if (selectedItem != 58)
			{
				oldSelectItem = selectedItem;
			}
			selectedItem = 58;
			flag = false;
		}
		if (flag && selectedItem == 58 && ItemTimeIsZero && itemAnimation == 0)
		{
			selectedItem = oldSelectItem;
		}
		if (Main.mouseItem.type > 0 && !Main.playerInventory)
		{
			Main.mouseItem.position = base.Center;
			Item item3 = GetItem(whoAmI, Main.mouseItem, getItemInDropItemCheck);
			if (item3.stack > 0)
			{
				int num3 = Item.NewItem(new EntitySource_OverfullInventory(this), (int)position.X, (int)position.Y, width, height, item3.type, item3.stack, noBroadcast: false, Main.mouseItem.prefix, noGrabDelay: true);
				Main.item[num3] = item3.Clone();
				Main.item[num3].newAndShiny = false;
				if (Main.netMode == 1)
				{
					NetMessage.SendData(21, -1, -1, null, num3, 1f);
				}
			}
			Main.mouseItem = new Item();
			inventory[58] = new Item();
			Recipe.FindRecipes();
		}
		if (((controlThrow && releaseThrow && !inventory[selectedItem].favorited && inventory[selectedItem].type > 0 && !Main.drawingPlayerChat) || (((Main.mouseRight && !mouseInterface && Main.mouseRightRelease) || !Main.playerInventory) && Main.mouseItem.type > 0 && Main.mouseItem.stack > 0)) && noThrow <= 0)
		{
			DropSelectedItem();
		}
		if (Main.gamePaused && selectedItem == 58)
		{
			selectedItem = oldSelectItem;
		}
	}

	public void DropSelectedItem()
	{
		if (Main.mouseItem != null && Main.mouseItem.type > 0 && Main.mouseItem.stack > 0)
		{
			DropSelectedItem(58, ref inventory[58]);
		}
		else
		{
			DropSelectedItem(selectedItem, ref inventory[selectedItem]);
		}
	}

	public void DropSelectedItem(int slot, ref Item theItemWeDrop)
	{
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		if (theItemWeDrop.favorited)
		{
			theItemWeDrop = GetItem(whoAmI, theItemWeDrop, GetItemSettings.GetItemInDropItemCheck);
			if (slot == 58)
			{
				Main.mouseItem = theItemWeDrop;
			}
			Recipe.FindRecipes();
			if (theItemWeDrop.type == 0)
			{
				flag = true;
			}
		}
		if (!flag)
		{
			Item item = new Item();
			if (((Main.mouseRight && !mouseInterface && Main.mouseRightRelease) || !Main.playerInventory) && Main.mouseItem.type > 0 && Main.mouseItem.stack > 0)
			{
				item = theItemWeDrop;
				theItemWeDrop = Main.mouseItem;
				delayUseItem = true;
				controlUseItem = false;
			}
			if (whoAmI == Main.myPlayer && theItemWeDrop.type == 5095)
			{
				LucyAxeMessage.Create(LucyAxeMessage.MessageSource.ThrownAway, base.Top, new Vector2((float)(direction * 7), -2f));
			}
			int num = Item.NewItem(GetItemSource_Misc(4), position, width, height, theItemWeDrop);
			theItemWeDrop.position = Main.item[num].position;
			Main.item[num] = theItemWeDrop;
			theItemWeDrop = new Item();
			if (slot == 58)
			{
				Main.mouseItem = new Item();
			}
			Item item2 = Main.item[num];
			if (Main.netMode == 0)
			{
				item2.noGrabDelay = 100;
			}
			item2.velocity.Y = -2f;
			item2.velocity.X = (float)(4 * direction) + velocity.X;
			item2.favorited = false;
			item2.newAndShiny = false;
			if (((Main.mouseRight && !mouseInterface) || !Main.playerInventory) && Main.mouseItem.type > 0)
			{
				theItemWeDrop = item;
				Main.mouseItem = new Item();
			}
			else
			{
				SetItemAnimation(10);
				JustDroppedAnItem = true;
				DropSelectedItem_InterruptActionsThatUseAnimations();
			}
			Recipe.FindRecipes();
			if (Main.netMode == 1)
			{
				NetMessage.SendData(21, -1, -1, null, num);
			}
		}
	}

	public void PlayDroppedItemAnimation(int time)
	{
		nonTorch = selectedItem;
		int num = 58;
		inventory[num].TurnToAir();
		selectedItem = num;
		JustDroppedAnItem = true;
		SetItemAnimation(time);
		SetItemTime(time);
		DropSelectedItem_InterruptActionsThatUseAnimations();
	}

	private void DropSelectedItem_InterruptActionsThatUseAnimations()
	{
		if (heldProj >= 0)
		{
			Projectile projectile = Main.projectile[heldProj];
			if (projectile.active && projectile.owner == whoAmI)
			{
				projectile.Kill();
			}
		}
		for (int i = 0; i < 1000; i++)
		{
			Projectile projectile2 = Main.projectile[i];
			if (projectile2.active && projectile2.owner == whoAmI && (projectile2.aiStyle == 61 || projectile2.aiStyle == 160))
			{
				projectile2.Kill();
			}
		}
	}

	public int FindBuffIndex(int type)
	{
		if (buffImmune[type])
		{
			return -1;
		}
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffTime[i] >= 1 && buffType[i] == type)
			{
				return i;
			}
		}
		return -1;
	}

	/// <summary>
	/// Gives the player the provided buff. This accounts for if the player is immune to the buff. This also accounts for adjusting the buff time for different game modes. If the player already has the buff, the re-apply logic will happen. Vanilla buff types are found in <see cref="T:Terraria.ID.BuffID" /> and modded buffs are typically retrieved using <see cref="M:Terraria.ModLoader.ModContent.BuffType``1" />. The quiet parameter will determine if the network sync message should happen. This should only be set to false in non-deterministic situations (such as random chance) and code that only runs locally. Other situations run on all clients so the buff should automatically be applied on all clients, keeping the player buff data in sync without burdening the network. When in doubt, consult vanilla source code examples or test your code.
	/// <br /> If applying a buff to a player other than the local player in pvp, quiet should be false and the buff must be true in <see cref="F:Terraria.Main.pvpBuff" /> to properly sync.
	/// </summary>
	/// <param name="type">The buff type</param>
	/// <param name="timeToAdd">The desired buff time in ticks. 60 ticks is 1 second</param>
	/// <param name="quiet">If true, the network sync message is skipped.</param>
	/// <param name="foodHack">unused</param>
	public void AddBuff(int type, int timeToAdd, bool quiet = true, bool foodHack = false)
	{
		if (buffImmune[type])
		{
			return;
		}
		bool flag = !quiet && Main.netMode == 1 && Main.pvpBuff[type] && Main.myPlayer != whoAmI;
		if (!flag && BuffID.Sets.IsFedState[type])
		{
			for (int i = 0; i < maxBuffs; i++)
			{
				if (BuffID.Sets.IsFedState[buffType[i]])
				{
					DelBuff(i);
				}
			}
		}
		int num = AddBuff_DetermineBuffTimeToAdd(type, timeToAdd);
		if (AddBuff_TryUpdatingExistingBuffTime(type, num))
		{
			return;
		}
		if (!quiet && Main.netMode == 1)
		{
			NetMessage.SendData(55, -1, -1, null, whoAmI, type, num);
			if (flag)
			{
				return;
			}
		}
		AddBuff_RemoveOldPetBuffsOfMatchingType(type);
		AddBuff_RemoveOldMeleeBuffsOfMatchingType(type);
		AddBuff_ActuallyTryToAddTheBuff(type, num);
	}

	private bool AddBuff_ActuallyTryToAddTheBuff(int type, int time)
	{
		int num = -1;
		while (num == -1)
		{
			int num2 = -1;
			for (int i = 0; i < maxBuffs; i++)
			{
				if (!Main.debuff[buffType[i]])
				{
					num2 = i;
					break;
				}
			}
			if (num2 == -1)
			{
				return false;
			}
			for (int j = num2; j < maxBuffs; j++)
			{
				if (buffType[j] == 0)
				{
					num = j;
					break;
				}
			}
			if (num == -1)
			{
				DelBuff(num2);
			}
		}
		buffType[num] = type;
		buffTime[num] = time;
		return true;
	}

	private void AddBuff_RemoveOldMeleeBuffsOfMatchingType(int type)
	{
		if (!Main.meleeBuff[type])
		{
			return;
		}
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffType[i] != type && Main.meleeBuff[buffType[i]])
			{
				DelBuff(i);
				i--;
			}
		}
	}

	private void AddBuff_RemoveOldPetBuffsOfMatchingType(int type)
	{
		if (Main.lightPet[type])
		{
			for (int i = 0; i < maxBuffs; i++)
			{
				if (Main.lightPet[buffType[i]])
				{
					DelBuff(i);
				}
			}
		}
		if (!Main.vanityPet[type])
		{
			return;
		}
		for (int j = 0; j < maxBuffs; j++)
		{
			if (Main.vanityPet[buffType[j]])
			{
				DelBuff(j);
			}
		}
	}

	private bool AddBuff_TryUpdatingExistingBuffTime(int type, int time)
	{
		bool result = false;
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffType[i] != type)
			{
				continue;
			}
			if (!BuffLoader.ReApply(type, this, time, i))
			{
				if (type == 94)
				{
					buffTime[i] += time;
					if (buffTime[i] > manaSickTimeMax)
					{
						buffTime[i] = manaSickTimeMax;
					}
				}
				else if (buffTime[i] < time)
				{
					buffTime[i] = time;
				}
			}
			result = true;
			break;
		}
		return result;
	}

	private int AddBuff_DetermineBuffTimeToAdd(int type, int time1)
	{
		int num = time1;
		if (Main.expertMode && whoAmI == Main.myPlayer && BuffID.Sets.LongerExpertDebuff[type])
		{
			float debuffTimeMultiplier = Main.GameModeInfo.DebuffTimeMultiplier;
			if (Main.GameModeInfo.IsJourneyMode)
			{
				if (Main.masterMode)
				{
					debuffTimeMultiplier = Main.RegisteredGameModes[2].DebuffTimeMultiplier;
				}
				else if (Main.expertMode)
				{
					debuffTimeMultiplier = Main.RegisteredGameModes[1].DebuffTimeMultiplier;
				}
			}
			num = (int)(debuffTimeMultiplier * (float)num);
		}
		return num;
	}

	/// <summary>
	/// Removes the buff at the provided index in <see cref="F:Terraria.Player.buffType" /> and <see cref="F:Terraria.Player.buffTime" /> and shuffles the remaining buff indexes down to fill the gap. Use <see cref="M:Terraria.Player.ClearBuff(System.Int32)" /> if you only know the <see cref="T:Terraria.ID.BuffID" />.
	/// </summary>
	/// <param name="b">The index in <see cref="F:Terraria.Player.buffType" /> of the buff to remove.</param>
	public void DelBuff(int b)
	{
		buffTime[b] = 0;
		buffType[b] = 0;
		int num = 0;
		for (int i = 0; i < maxBuffs - 1; i++)
		{
			if (buffTime[i] != 0 && buffType[i] != 0)
			{
				if (num < i)
				{
					buffTime[num] = buffTime[i];
					buffType[num] = buffType[i];
					buffTime[i] = 0;
					buffType[i] = 0;
				}
				num++;
			}
		}
	}

	/// <summary>
	/// Removes the provided buff type from the player and shuffles the remaining buff indexes down to fill the gap. Use <see cref="M:Terraria.Player.DelBuff(System.Int32)" /> if you only know the buff index
	/// </summary>
	/// <param name="type">The buff type</param>
	public void ClearBuff(int type)
	{
		if (type == 0)
		{
			return;
		}
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffType[i] == type)
			{
				DelBuff(i);
			}
		}
	}

	public int CountBuffs()
	{
		int num = 0;
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffType[num] > 0)
			{
				num++;
			}
		}
		return num;
	}

	public void QuickHeal()
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (cursed || CCed || dead || statLife == statLifeMax2 || potionDelay > 0)
		{
			return;
		}
		Item item = QuickHeal_GetItemToUse();
		if (item == null || !ItemCheck_CheckCanUse(item))
		{
			return;
		}
		SoundEngine.PlaySound(item.UseSound, position);
		if (item.potion)
		{
			ApplyPotionDelay(item);
		}
		ApplyLifeAndOrMana(item);
		if (item.type == 5)
		{
			TryToResetHungerToNeutral();
		}
		if (item.buffType > 0)
		{
			int num = item.buffTime;
			if (num == 0)
			{
				num = 3600;
			}
			AddBuff(item.buffType, num);
		}
		if (item.consumable && ItemLoader.ConsumeItem(item, this))
		{
			item.stack--;
		}
		if (item.stack <= 0)
		{
			item.TurnToAir();
		}
		if (Main.myPlayer == whoAmI && item.type == 126 && breath == 0)
		{
			AchievementsHelper.HandleSpecialEvent(this, 25);
		}
		Recipe.FindRecipes();
	}

	public Item QuickHeal_GetItemToUse()
	{
		int num = statLifeMax2 - statLife;
		Item result = null;
		int num2 = -statLifeMax2;
		int num3 = 58;
		if (useVoidBag())
		{
			num3 = 98;
		}
		for (int i = 0; i < num3; i++)
		{
			Item item = ((i >= 58) ? bank4.item[i - 58] : inventory[i]);
			if (item.stack <= 0 || item.type <= 0 || !item.potion || item.healLife <= 0 || !CombinedHooks.CanUseItem(this, item))
			{
				continue;
			}
			int num4 = GetHealLife(item, quickHeal: true) - num;
			if (item.type == 227 && num4 < 0)
			{
				num4 += 30;
				if (num4 > 0)
				{
					num4 = 0;
				}
			}
			if (num2 < 0)
			{
				if (num4 > num2)
				{
					result = item;
					num2 = num4;
				}
			}
			else if (num4 < num2 && num4 >= 0)
			{
				result = item;
				num2 = num4;
			}
		}
		return result;
	}

	public void QuickMana()
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (cursed || CCed || dead || statMana == statManaMax2)
		{
			return;
		}
		Item item = QuickMana_GetItemToUse();
		if (item != null && ItemCheck_CheckCanUse(item))
		{
			SoundEngine.PlaySound(item.UseSound, position);
			if (item.potion)
			{
				ApplyPotionDelay(item);
			}
			ApplyLifeAndOrMana(item);
			if (item.consumable && ItemLoader.ConsumeItem(item, this))
			{
				item.stack--;
			}
			if (item.stack <= 0)
			{
				item.TurnToAir();
			}
			Recipe.FindRecipes();
		}
	}

	public Item QuickMana_GetItemToUse()
	{
		for (int i = 0; i < 58; i++)
		{
			if (inventory[i].stack > 0 && inventory[i].type > 0 && inventory[i].healMana > 0 && (potionDelay == 0 || !inventory[i].potion))
			{
				return inventory[i];
			}
		}
		if (useVoidBag())
		{
			for (int j = 0; j < 40; j++)
			{
				if (bank4.item[j].stack > 0 && bank4.item[j].type > 0 && bank4.item[j].healMana > 0 && (potionDelay == 0 || !bank4.item[j].potion))
				{
					return bank4.item[j];
				}
			}
		}
		return null;
	}

	public void TrySwitchingLoadout(int loadoutIndex)
	{
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		bool flag = itemTime > 0 || itemAnimation > 0;
		if ((whoAmI != Main.myPlayer || (!flag && !CCed && !dead)) && loadoutIndex != CurrentLoadoutIndex && loadoutIndex >= 0 && loadoutIndex < Loadouts.Length)
		{
			Loadouts[CurrentLoadoutIndex].Swap(this);
			Loadouts[loadoutIndex].Swap(this);
			CurrentLoadoutIndex = loadoutIndex;
			if (whoAmI == Main.myPlayer)
			{
				CloneLoadouts(Main.clientPlayer);
				Main.mouseLeftRelease = false;
				ItemSlot.RecordLoadoutChange();
				SoundEngine.PlaySound(12);
				NetMessage.TrySendData(147, -1, -1, null, whoAmI, loadoutIndex);
				ParticleOrchestrator.RequestParticleSpawn(clientOnly: false, ParticleOrchestraType.LoadoutChange, new ParticleOrchestraSettings
				{
					PositionInWorld = base.Center,
					UniqueInfoPiece = loadoutIndex
				}, whoAmI);
			}
		}
	}

	public void QuickBuff()
	{
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		if (cursed || CCed || dead)
		{
			return;
		}
		SoundStyle? legacySoundStyle = null;
		if (CountBuffs() == maxBuffs)
		{
			return;
		}
		Item item = QuickBuff_PickBestFoodItem();
		if (item != null && ItemCheck_CheckCanUse(item))
		{
			legacySoundStyle = item.UseSound;
			int num = item.buffTime;
			if (num == 0)
			{
				num = 3600;
			}
			ItemLoader.UseItem(item, this);
			AddBuff(item.buffType, num);
			if (item.consumable && ItemLoader.ConsumeItem(item, this))
			{
				item.stack--;
				if (item.stack <= 0)
				{
					item.TurnToAir();
				}
			}
		}
		if (CountBuffs() != maxBuffs)
		{
			int num2 = 58;
			if (useVoidBag())
			{
				num2 = 98;
			}
			for (int i = 0; i < num2; i++)
			{
				Item item2 = ((i >= 58) ? bank4.item[i - 58] : inventory[i]);
				if (item2.stack <= 0 || item2.type <= 0 || item2.buffType <= 0 || item2.summon || !ItemCheck_CheckCanUse(item2))
				{
					continue;
				}
				int num3 = item2.buffType;
				bool flag = CombinedHooks.CanUseItem(this, item2) && QuickBuff_ShouldBotherUsingThisBuff(num3);
				if (item2.mana > 0 && flag)
				{
					if (CheckMana(item2, -1, pay: true, blockQuickMana: true))
					{
						manaRegenDelay = (int)maxRegenDelay;
					}
					else
					{
						flag = false;
					}
				}
				if (whoAmI == Main.myPlayer && item2.type == 603 && !Main.runningCollectorsEdition)
				{
					flag = false;
				}
				if (num3 == 27)
				{
					num3 = Main.rand.Next(3);
					if (num3 == 0)
					{
						num3 = 27;
					}
					if (num3 == 1)
					{
						num3 = 101;
					}
					if (num3 == 2)
					{
						num3 = 102;
					}
				}
				if (!flag)
				{
					continue;
				}
				ItemLoader.UseItem(item2, this);
				legacySoundStyle = item2.UseSound;
				int num4 = item2.buffTime;
				if (num4 == 0)
				{
					num4 = 3600;
				}
				AddBuff(num3, num4);
				if (item2.consumable && ItemLoader.ConsumeItem(item2, this))
				{
					item2.stack--;
					if (item2.stack <= 0)
					{
						item2.TurnToAir();
					}
				}
				if (CountBuffs() == maxBuffs)
				{
					break;
				}
			}
		}
		if (legacySoundStyle.HasValue)
		{
			SoundEngine.PlaySound(legacySoundStyle, position);
			Recipe.FindRecipes();
		}
	}

	private Item QuickBuff_PickBestFoodItem()
	{
		int num = 0;
		Item item = null;
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffTime[i] >= 1)
			{
				int num2 = QuickBuff_FindFoodPriority(buffType[i]);
				if (num <= num2)
				{
					num = num2 + 1;
				}
			}
		}
		for (int j = 0; j < 58; j++)
		{
			Item item2 = inventory[j];
			if (!item2.IsAir)
			{
				int num3 = QuickBuff_FindFoodPriority(item2.buffType);
				if (num3 >= num && (item == null || item.buffTime < item2.buffTime || num3 > num))
				{
					item = item2;
					num = num3;
				}
			}
		}
		if (useVoidBag())
		{
			for (int k = 0; k < 40; k++)
			{
				Item item3 = bank4.item[k];
				if (!item3.IsAir)
				{
					int num4 = QuickBuff_FindFoodPriority(item3.buffType);
					if (num4 >= num && (item == null || item.buffTime < item3.buffTime || num4 > num))
					{
						item = item3;
						num = num4;
					}
				}
			}
		}
		return item;
	}

	private int QuickBuff_FindFoodPriority(int buffType)
	{
		return buffType switch
		{
			26 => 1, 
			206 => 2, 
			207 => 3, 
			_ => 0, 
		};
	}

	private bool QuickBuff_ShouldBotherUsingThisBuff(int attemptedType)
	{
		bool result = true;
		for (int i = 0; i < maxBuffs; i++)
		{
			if (attemptedType == 27 && (buffType[i] == 27 || buffType[i] == 101 || buffType[i] == 102))
			{
				result = false;
				break;
			}
			if (BuffID.Sets.IsWellFed[attemptedType] && BuffID.Sets.IsWellFed[buffType[i]])
			{
				result = false;
				break;
			}
			if (buffType[i] == attemptedType)
			{
				result = false;
				break;
			}
			if (Main.meleeBuff[attemptedType] && Main.meleeBuff[buffType[i]])
			{
				result = false;
				break;
			}
		}
		if (Main.lightPet[attemptedType] || Main.vanityPet[attemptedType])
		{
			for (int j = 0; j < maxBuffs; j++)
			{
				if (Main.lightPet[buffType[j]] && Main.lightPet[attemptedType])
				{
					result = false;
				}
				if (Main.vanityPet[buffType[j]] && Main.vanityPet[attemptedType])
				{
					result = false;
				}
			}
		}
		return result;
	}

	public void QuickMount()
	{
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		if (mount.Active)
		{
			mount.Dismount(this);
		}
		else
		{
			if (frozen || tongued || webbed || stoned || gravDir == -1f || dead || noItems)
			{
				return;
			}
			Item item = QuickMount_GetItemToUse();
			if (item != null && item.mountType != -1 && mount.CanMount(item.mountType, this) && ItemCheck_CheckCanUse(item))
			{
				if (!QuickMinecartSnap())
				{
					mount.SetMount(item.mountType, this);
					ItemLoader.UseItem(item, this);
					if (item.UseSound.HasValue)
					{
						SoundEngine.PlaySound(item.UseSound, base.Center);
					}
				}
			}
			else
			{
				QuickMinecart();
			}
		}
	}

	public bool CanFitSpace(int heightBoost)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		int num = 42 + heightBoost;
		return Collision.IsClearSpotTest(position + new Vector2(0f, (float)(height - num)) + velocity, 16f, width, num, fallThrough: true, fall2: true);
	}

	private void QuickMinecart()
	{
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		int value5 = (int)(position.X / 16f) - tileRangeX - num + 1;
		int value2 = (int)((position.X + (float)width) / 16f) + tileRangeX + num - 1;
		int value3 = (int)(position.Y / 16f) - tileRangeY - num + 1;
		int value4 = (int)((position.Y + (float)height) / 16f) + tileRangeY + num - 2;
		int num2 = Utils.Clamp(value5, 10, Main.maxTilesX - 10);
		value2 = Utils.Clamp(value2, 10, Main.maxTilesX - 10);
		value3 = Utils.Clamp(value3, 10, Main.maxTilesY - 10);
		List<Point> list = Collision.GetTilesIn(BottomRight: new Vector2((float)(value2 + 1), (float)(Utils.Clamp(value4, 10, Main.maxTilesY - 10) + 1)) * 16f, TopLeft: new Vector2((float)num2, (float)value3) * 16f);
		if (list.Count <= 0)
		{
			return;
		}
		Point? point = null;
		_ = base.Hitbox;
		for (int i = 0; i < list.Count; i++)
		{
			Point point2 = list[i];
			Tile tileSafely = Framing.GetTileSafely(point2.X, point2.Y);
			if (tileSafely.active() && tileSafely.type == 314)
			{
				Vector2 vector = list[i].ToVector2() * 16f + new Vector2(8f);
				if (!point.HasValue || (Distance(vector) < Distance(point.Value.ToVector2() * 16f + new Vector2(8f)) && Collision.CanHitLine(base.Center, 0, 0, vector, 0, 0)))
				{
					point = list[i];
				}
			}
		}
		if (point.HasValue)
		{
			LaunchMinecartHook(point.Value.X, point.Value.Y);
		}
	}

	private bool QuickMinecartSnap()
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		bool result = false;
		List<Point> tilesIn = Collision.GetTilesIn(base.TopLeft - new Vector2(24f), base.BottomRight + new Vector2(24f));
		if (tilesIn.Count > 0)
		{
			Point? point = null;
			_ = base.Hitbox;
			for (int i = 0; i < tilesIn.Count; i++)
			{
				Point point2 = tilesIn[i];
				Tile tileSafely = Framing.GetTileSafely(point2.X, point2.Y);
				if (tileSafely.active() && tileSafely.type == 314)
				{
					Vector2 vector = tilesIn[i].ToVector2() * 16f + new Vector2(8f);
					if (!point.HasValue || (Distance(vector) < Distance(point.Value.ToVector2() * 16f + new Vector2(8f)) && Collision.CanHitLine(base.Center, 0, 0, vector, 0, 0)))
					{
						point = tilesIn[i];
					}
				}
			}
			if (point.HasValue)
			{
				LaunchMinecartHook(point.Value.X, point.Value.Y);
				result = true;
			}
		}
		return result;
	}

	public Item QuickMount_GetItemToUse()
	{
		Item item = null;
		bool equippedMountSufficient = false;
		if (item == null && miscEquips[3].mountType != -1 && !MountID.Sets.Cart[miscEquips[3].mountType])
		{
			equippedMountSufficient = true;
		}
		if (equippedMountSufficient && CombinedHooks.CanUseItem(this, miscEquips[3]))
		{
			item = miscEquips[3];
		}
		if (item == null)
		{
			for (int i = 0; i < 58; i++)
			{
				if (inventory[i].mountType != -1 && !MountID.Sets.Cart[inventory[i].mountType] && CombinedHooks.CanUseItem(this, inventory[i]))
				{
					item = inventory[i];
					break;
				}
			}
		}
		return item;
	}

	public void ClearGrapplingBlacklist()
	{
		_blackListedTileCoordsForGrappling.Clear();
	}

	public bool IsBlacklistedForGrappling(Point p)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return _blackListedTileCoordsForGrappling.Contains(p);
	}

	public void UpdateBlacklistedTilesForGrappling()
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		ClearGrapplingBlacklist();
		for (int i = 0; i < 1000; i++)
		{
			if (!Main.projectile[i].active || Main.projectile[i].owner != whoAmI || Main.projectile[i].aiStyle != 7 || Main.projectile[i].ai[0] != 2f)
			{
				continue;
			}
			Point point = Main.projectile[i].Center.ToTileCoordinates();
			for (int j = -1; j <= 1; j++)
			{
				for (int k = -1; k <= 1; k++)
				{
					if (!WorldGen.SolidTile(point.X + j, point.Y + k))
					{
						_blackListedTileCoordsForGrappling.Add(new Point(point.X + j, point.Y + k));
					}
				}
			}
		}
	}

	public void QuickGrapple()
	{
		//IL_0451: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0822: Unknown result type (might be due to invalid IL or missing references)
		//IL_0894: Unknown result type (might be due to invalid IL or missing references)
		//IL_089b: Unknown result type (might be due to invalid IL or missing references)
		if (frozen || tongued || webbed || stoned || dead)
		{
			return;
		}
		if (PlayerInput.GrappleAndInteractAreShared)
		{
			if (Main.HoveringOverAnNPC || Main.SmartInteractShowingGenuine || Main.SmartInteractShowingFake || (_quickGrappleCooldown > 0 && !Main.mapFullscreen) || (WiresUI.Settings.DrawToolModeUI && PlayerInput.UsingGamepad))
			{
				return;
			}
			bool num32 = controlUseTile;
			bool flag = releaseUseTile;
			if (!num32 && !flag)
			{
				return;
			}
			Tile tileSafely = Framing.GetTileSafely(tileTargetX, tileTargetY);
			if ((tileSafely.active() && (tileSafely.type == 4 || tileSafely.type == 33 || tileSafely.type == 372 || tileSafely.type == 174 || tileSafely.type == 646 || tileSafely.type == 49)) || (inventory[selectedItem].type == 3384 && PlayerInput.UsingGamepad))
			{
				return;
			}
		}
		if (noItems)
		{
			return;
		}
		if (mount.Active)
		{
			mount.Dismount(this);
		}
		Item item = QuickGrapple_GetItemToUse();
		if (item == null || !ItemCheck_CheckCanUse(item))
		{
			return;
		}
		bool? flag3 = ProjectileLoader.CanUseGrapple(item.shoot, this);
		if (flag3.HasValue)
		{
			if (!flag3.GetValueOrDefault())
			{
				item = null;
			}
		}
		else if (item.shoot == 73)
		{
			int num20 = 0;
			for (int i = 0; i < 1000; i++)
			{
				if (Main.projectile[i].active && Main.projectile[i].owner == Main.myPlayer && (Main.projectile[i].type == 73 || Main.projectile[i].type == 74))
				{
					num20++;
				}
			}
			if (num20 > 1)
			{
				item = null;
			}
		}
		else if (item.shoot == 165)
		{
			int num25 = 0;
			for (int j = 0; j < 1000; j++)
			{
				if (Main.projectile[j].active && Main.projectile[j].owner == Main.myPlayer && Main.projectile[j].type == 165)
				{
					num25++;
				}
			}
			if (num25 > 8)
			{
				item = null;
			}
		}
		else if (item.shoot == 372)
		{
			int num26 = 0;
			for (int k = 0; k < 1000; k++)
			{
				if (Main.projectile[k].active && Main.projectile[k].owner == Main.myPlayer && Main.projectile[k].type == 372)
				{
					num26++;
				}
			}
			if (num26 > 2)
			{
				item = null;
			}
		}
		else if (item.shoot == 652)
		{
			int num27 = 0;
			for (int l = 0; l < 1000; l++)
			{
				if (Main.projectile[l].active && Main.projectile[l].owner == Main.myPlayer && Main.projectile[l].type == 652)
				{
					num27++;
				}
			}
			if (num27 > 1)
			{
				item = null;
			}
		}
		else if (item.type == 3572)
		{
			int num28 = 0;
			bool flag2 = false;
			for (int m = 0; m < 1000; m++)
			{
				if (Main.projectile[m].active && Main.projectile[m].owner == Main.myPlayer && Main.projectile[m].type >= 646 && Main.projectile[m].type <= 649)
				{
					num28++;
					if (Main.projectile[m].ai[0] == 2f)
					{
						flag2 = true;
					}
				}
			}
			if (num28 > 4 || (!flag2 && num28 > 3))
			{
				item = null;
			}
		}
		else
		{
			for (int n = 0; n < 1000; n++)
			{
				if (Main.projectile[n].active && Main.projectile[n].owner == Main.myPlayer && Main.projectile[n].type == item.shoot && Main.projectile[n].ai[0] != 2f)
				{
					item = null;
					break;
				}
			}
		}
		if (item == null)
		{
			return;
		}
		UpdateBlacklistedTilesForGrappling();
		SoundEngine.PlaySound(item.UseSound, position);
		if (Main.netMode == 1 && whoAmI == Main.myPlayer)
		{
			NetMessage.SendData(51, -1, -1, null, whoAmI, 2f);
		}
		int num29 = item.shoot;
		float shootSpeed = item.shootSpeed;
		int damage = item.damage;
		float knockBack = item.knockBack;
		if (ProjectileID.Sets.SingleGrappleHook[num29])
		{
			grappling[0] = -1;
			grapCount = 0;
			for (int num30 = 0; num30 < 1000; num30++)
			{
				if (Main.projectile[num30].active && Main.projectile[num30].owner == whoAmI && ProjectileID.Sets.SingleGrappleHook[Main.projectile[num30].type])
				{
					Main.projectile[num30].Kill();
				}
			}
		}
		if (num29 == 256)
		{
			int num31 = 0;
			int num10 = -1;
			int num11 = 100000;
			for (int num12 = 0; num12 < 1000; num12++)
			{
				if (Main.projectile[num12].active && Main.projectile[num12].owner == whoAmI && Main.projectile[num12].type == 256)
				{
					num31++;
					if (Main.projectile[num12].timeLeft < num11)
					{
						num10 = num12;
						num11 = Main.projectile[num12].timeLeft;
					}
				}
			}
			if (num31 > 1)
			{
				Main.projectile[num10].Kill();
			}
		}
		if (num29 == 652)
		{
			int num13 = 0;
			int num14 = -1;
			int num15 = 100000;
			for (int num16 = 0; num16 < 1000; num16++)
			{
				if (Main.projectile[num16].active && Main.projectile[num16].owner == whoAmI && Main.projectile[num16].type == 652)
				{
					num13++;
					if (Main.projectile[num16].timeLeft < num15)
					{
						num14 = num16;
						num15 = Main.projectile[num16].timeLeft;
					}
				}
			}
			if (num13 > 1)
			{
				Main.projectile[num14].Kill();
			}
		}
		if (num29 == 73)
		{
			for (int num17 = 0; num17 < 1000; num17++)
			{
				if (Main.projectile[num17].active && Main.projectile[num17].owner == whoAmI && Main.projectile[num17].type == 73)
				{
					num29 = 74;
				}
			}
		}
		if (item.type == 3572)
		{
			int num18 = -1;
			int num19 = -1;
			for (int num21 = 0; num21 < 1000; num21++)
			{
				Projectile projectile = Main.projectile[num21];
				if (projectile.active && projectile.owner == whoAmI && projectile.type >= 646 && projectile.type <= 649 && (num19 == -1 || num19 < projectile.timeLeft))
				{
					num18 = projectile.type;
					num19 = projectile.timeLeft;
				}
			}
			switch (num18)
			{
			case 646:
				num29 = 647;
				break;
			case 647:
				num29 = 648;
				break;
			case 648:
				num29 = 649;
				break;
			case -1:
			case 649:
				num29 = 646;
				break;
			}
		}
		ProjectileLoader.UseGrapple(this, ref num29);
		Vector2 vector = default(Vector2);
		((Vector2)(ref vector))._002Ector(position.X + (float)width * 0.5f, position.Y + (float)height * 0.5f);
		float num22 = (float)Main.mouseX + Main.screenPosition.X - vector.X;
		float num23 = (float)Main.mouseY + Main.screenPosition.Y - vector.Y;
		if (gravDir == -1f)
		{
			num23 = Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY - vector.Y;
		}
		float num24 = (float)Math.Sqrt(num22 * num22 + num23 * num23);
		if ((float.IsNaN(num22) && float.IsNaN(num23)) || (num22 == 0f && num23 == 0f))
		{
			num22 = direction;
			num23 = 0f;
			num24 = shootSpeed;
		}
		else
		{
			num24 = shootSpeed / num24;
		}
		num22 *= num24;
		num23 *= num24;
		Projectile.NewProjectile(GetProjectileSource_Item(item), vector.X, vector.Y, num22, num23, num29, damage, knockBack, whoAmI);
	}

	public Item QuickGrapple_GetItemToUse()
	{
		Item item = null;
		if (Main.projHook[miscEquips[4].shoot])
		{
			item = miscEquips[4];
		}
		if (item == null)
		{
			for (int i = 0; i < 58; i++)
			{
				if (Main.projHook[inventory[i].shoot])
				{
					item = inventory[i];
					break;
				}
			}
		}
		return item;
	}

	public void StatusToNPC(int type, int i)
	{
		if (meleeEnchant > 0)
		{
			if (meleeEnchant == 1)
			{
				Main.npc[i].AddBuff(70, 60 * Main.rand.Next(5, 10));
			}
			if (meleeEnchant == 2)
			{
				Main.npc[i].AddBuff(39, 60 * Main.rand.Next(3, 7));
			}
			if (meleeEnchant == 3)
			{
				Main.npc[i].AddBuff(24, 60 * Main.rand.Next(3, 7));
			}
			if (meleeEnchant == 5)
			{
				Main.npc[i].AddBuff(69, 60 * Main.rand.Next(10, 20));
			}
			if (meleeEnchant == 6)
			{
				Main.npc[i].AddBuff(31, 60 * Main.rand.Next(1, 4));
			}
			if (meleeEnchant == 8)
			{
				Main.npc[i].AddBuff(20, 60 * Main.rand.Next(5, 10));
			}
			if (meleeEnchant == 4)
			{
				Main.npc[i].AddBuff(72, 120);
			}
		}
		if (frostBurn)
		{
			Main.npc[i].AddBuff(324, 60 * Main.rand.Next(5, 15));
		}
		if (magmaStone)
		{
			if (Main.rand.Next(4) == 0)
			{
				Main.npc[i].AddBuff(323, 360);
			}
			else if (Main.rand.Next(2) == 0)
			{
				Main.npc[i].AddBuff(323, 240);
			}
			else
			{
				Main.npc[i].AddBuff(323, 120);
			}
		}
		if (type == 3211)
		{
			Main.npc[i].AddBuff(69, 60 * Main.rand.Next(5, 10));
		}
		if (type == 5129)
		{
			Main.npc[i].AddBuff(120, 300);
		}
		switch (type)
		{
		case 121:
			if (Main.rand.Next(2) == 0)
			{
				Main.npc[i].AddBuff(24, 180);
			}
			break;
		case 3823:
			if (Main.rand.Next(4) == 0)
			{
				Main.npc[i].AddBuff(323, 300);
			}
			break;
		case 5382:
			if (Main.rand.Next(3) == 0)
			{
				Main.npc[i].AddBuff(323, 300);
			}
			break;
		case 122:
			if (Main.rand.Next(10) == 0)
			{
				Main.npc[i].AddBuff(24, 180);
			}
			break;
		case 190:
			if (Main.rand.Next(4) == 0)
			{
				Main.npc[i].AddBuff(20, 420);
			}
			break;
		case 217:
			if (Main.rand.Next(5) == 0)
			{
				Main.npc[i].AddBuff(24, 180);
			}
			break;
		case 1123:
			if (Main.rand.Next(10) != 0)
			{
				Main.npc[i].AddBuff(31, 120);
			}
			break;
		}
	}

	public void StatusToPlayerPvP(int type, int i)
	{
		if (meleeEnchant > 0)
		{
			if (meleeEnchant == 1)
			{
				Main.player[i].AddBuff(70, 60 * Main.rand.Next(5, 10), quiet: false);
			}
			if (meleeEnchant == 2)
			{
				Main.player[i].AddBuff(39, 60 * Main.rand.Next(3, 7), quiet: false);
			}
			if (meleeEnchant == 3)
			{
				Main.player[i].AddBuff(24, 60 * Main.rand.Next(3, 7), quiet: false);
			}
			if (meleeEnchant == 5)
			{
				Main.player[i].AddBuff(69, 60 * Main.rand.Next(10, 20), quiet: false);
			}
			if (meleeEnchant == 6)
			{
				Main.player[i].AddBuff(31, 60 * Main.rand.Next(1, 4), quiet: false);
			}
			if (meleeEnchant == 8)
			{
				Main.player[i].AddBuff(20, 60 * Main.rand.Next(5, 10), quiet: false);
			}
		}
		if (frostBurn)
		{
			Main.player[i].AddBuff(324, 60 * Main.rand.Next(1, 8), quiet: false);
		}
		if (magmaStone)
		{
			if (Main.rand.Next(7) == 0)
			{
				Main.player[i].AddBuff(323, 360, quiet: false);
			}
			else if (Main.rand.Next(3) == 0)
			{
				Main.player[i].AddBuff(323, 120, quiet: false);
			}
			else
			{
				Main.player[i].AddBuff(323, 60, quiet: false);
			}
		}
		if (type == 5129)
		{
			Main.player[i].AddBuff(120, 300, quiet: false);
		}
		switch (type)
		{
		case 121:
			if (Main.rand.Next(2) == 0)
			{
				Main.player[i].AddBuff(24, 180, quiet: false);
			}
			break;
		case 3823:
			if (Main.rand.Next(4) == 0)
			{
				Main.player[i].AddBuff(323, 300, quiet: false);
			}
			break;
		case 5382:
			if (Main.rand.Next(3) == 0)
			{
				Main.player[i].AddBuff(323, 300, quiet: false);
			}
			break;
		case 122:
			if (Main.rand.Next(10) == 0)
			{
				Main.player[i].AddBuff(24, 180, quiet: false);
			}
			break;
		case 190:
			if (Main.rand.Next(4) == 0)
			{
				Main.player[i].AddBuff(20, 420, quiet: false);
			}
			break;
		case 217:
			if (Main.rand.Next(5) == 0)
			{
				Main.player[i].AddBuff(24, 180, quiet: false);
			}
			break;
		case 1123:
			if (Main.rand.Next(9) != 0)
			{
				Main.player[i].AddBuff(31, 120, quiet: false);
			}
			break;
		}
	}

	public void Ghost()
	{
		//IL_02cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		immune = false;
		immuneAlpha = 0;
		if (Main.hasFocus && whoAmI == Main.myPlayer)
		{
			controlUp = false;
			controlLeft = false;
			controlDown = false;
			controlRight = false;
			controlJump = false;
			if (!Main.drawingPlayerChat && !Main.editSign && !Main.editChest && !Main.blockInput)
			{
				PlayerInput.Triggers.Current.CopyInto(this);
				TrySyncingInput();
				TryOpeningInGameOptionsBasedOnInput();
			}
		}
		float num = 7f;
		float num2 = 0.2f;
		if (controlUp || controlJump)
		{
			if (velocity.Y > 0f)
			{
				velocity.Y *= 0.9f;
			}
			velocity.Y -= num2;
			if (velocity.Y < 0f - num)
			{
				velocity.Y = 0f - num;
			}
		}
		else if (controlDown)
		{
			if (velocity.Y < 0f)
			{
				velocity.Y *= 0.9f;
			}
			velocity.Y += num2;
			if (velocity.Y > num)
			{
				velocity.Y = num;
			}
		}
		else if ((double)velocity.Y < -0.1 || (double)velocity.Y > 0.1)
		{
			velocity.Y *= 0.9f;
		}
		else
		{
			velocity.Y = 0f;
		}
		if (controlLeft && !controlRight)
		{
			if (velocity.X > 0f)
			{
				velocity.X *= 0.9f;
			}
			velocity.X -= num2;
			if (velocity.X < 0f - num)
			{
				velocity.X = 0f - num;
			}
		}
		else if (controlRight && !controlLeft)
		{
			if (velocity.X < 0f)
			{
				velocity.X *= 0.9f;
			}
			velocity.X += num2;
			if (velocity.X > num)
			{
				velocity.X = num;
			}
		}
		else if (velocity.X < 0f - num2 || velocity.X > num2)
		{
			velocity.X *= 0.9f;
		}
		else
		{
			velocity.X = 0f;
		}
		position += velocity;
		ghostFrameCounter++;
		if (velocity.X < 0f)
		{
			direction = -1;
		}
		else if (velocity.X > 0f)
		{
			direction = 1;
		}
		if (ghostFrameCounter >= 8)
		{
			ghostFrameCounter = 0;
			ghostFrame++;
			if (ghostFrame >= 4)
			{
				ghostFrame = 0;
			}
		}
		if (position.X < Main.leftWorld + (float)(Lighting.OffScreenTiles * 16) + 16f)
		{
			position.X = Main.leftWorld + (float)(Lighting.OffScreenTiles * 16) + 16f;
			velocity.X = 0f;
		}
		if (position.X + (float)width > Main.rightWorld - (float)(Lighting.OffScreenTiles * 16) - 32f)
		{
			position.X = Main.rightWorld - (float)(Lighting.OffScreenTiles * 16) - 32f - (float)width;
			velocity.X = 0f;
		}
		if (position.Y < Main.topWorld + (float)(Lighting.OffScreenTiles * 16) + 16f)
		{
			position.Y = Main.topWorld + (float)(Lighting.OffScreenTiles * 16) + 16f;
			if ((double)velocity.Y < -0.1)
			{
				velocity.Y = -0.1f;
			}
		}
		if (position.Y > Main.bottomWorld - (float)(Lighting.OffScreenTiles * 16) - 32f - (float)height)
		{
			position.Y = Main.bottomWorld - (float)(Lighting.OffScreenTiles * 16) - 32f - (float)height;
			velocity.Y = 0f;
		}
	}

	private void TrySyncingInput()
	{
		if (Main.netMode == 1)
		{
			bool flag = false;
			Player clientPlayer = Main.clientPlayer;
			if (controlUp != clientPlayer.controlUp)
			{
				flag = true;
			}
			if (controlDown != clientPlayer.controlDown)
			{
				flag = true;
			}
			if (controlLeft != clientPlayer.controlLeft)
			{
				flag = true;
			}
			if (controlRight != clientPlayer.controlRight)
			{
				flag = true;
			}
			if (controlJump != clientPlayer.controlJump)
			{
				flag = true;
			}
			if (controlUseItem != clientPlayer.controlUseItem)
			{
				flag = true;
			}
			if (selectedItem != clientPlayer.selectedItem)
			{
				flag = true;
			}
			if (autoReuseAllWeapons != clientPlayer.autoReuseAllWeapons)
			{
				flag = true;
			}
			if (controlDownHold != clientPlayer.controlDownHold)
			{
				flag = true;
			}
			if (isOperatingAnotherEntity != clientPlayer.isOperatingAnotherEntity)
			{
				flag = true;
			}
			if (flag)
			{
				NetMessage.SendData(13, -1, -1, null, Main.myPlayer);
			}
		}
	}

	public void OnHit(float x, float y, Entity victim)
	{
		if (Main.myPlayer == whoAmI)
		{
			OnHit_Inner(x, y, victim);
			PlayerLoader.OnHitAnything(this, x, y, victim);
		}
	}

	private void OnHit_Inner(float x, float y, Entity victim)
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0401: Unknown result type (might be due to invalid IL or missing references)
		//IL_0454: Unknown result type (might be due to invalid IL or missing references)
		//IL_0460: Unknown result type (might be due to invalid IL or missing references)
		//IL_0466: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_048b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0493: Unknown result type (might be due to invalid IL or missing references)
		//IL_0498: Unknown result type (might be due to invalid IL or missing references)
		bool flag = victim is NPC && (((NPC)victim).type == 488 || ((NPC)victim).SpawnedFromStatue);
		if (titaniumStormCooldown > 0)
		{
			flag = true;
		}
		if (victim is NPC)
		{
			Main.BigBossProgressBar.TryTracking(victim.whoAmI);
		}
		if (onHitTitaniumStorm && !flag)
		{
			titaniumStormCooldown = 10;
			AddBuff(306, 600);
			if (ownedProjectileCounts[908] < 7)
			{
				ownedProjectileCounts[908]++;
				Projectile.NewProjectile(GetProjectileSource_OnHit(victim, 4), base.Center, Vector2.Zero, 908, 50, 15f, whoAmI);
			}
		}
		if (onHitDodge && shadowDodgeTimer == 0)
		{
			AddBuff(59, 1800);
		}
		if (onHitRegen)
		{
			AddBuff(58, 300);
		}
		if (stardustMinion && victim is NPC)
		{
			for (int i = 0; i < 1000; i++)
			{
				Projectile projectile = Main.projectile[i];
				if (projectile.active && projectile.owner == whoAmI && projectile.type == 613 && !(projectile.localAI[1] > 0f) && Main.rand.Next(2) == 0)
				{
					Vector2 vector = new Vector2(x, y) - projectile.Center;
					if (((Vector2)(ref vector)).Length() > 0f)
					{
						((Vector2)(ref vector)).Normalize();
					}
					vector *= 20f;
					Projectile.NewProjectile(Entity.InheritSource(projectile), projectile.Center.X, projectile.Center.Y, vector.X, vector.Y, 614, projectile.damage / 3, 0f, projectile.owner, 0f, victim.whoAmI);
					projectile.localAI[1] = 30 + Main.rand.Next(4) * 10;
				}
			}
		}
		if (onHitPetal && petalTimer == 0)
		{
			petalTimer = 20;
			_ = position;
			_ = width / 2;
			int num20 = direction;
			float num12 = Main.screenPosition.X;
			if (num20 < 0)
			{
				num12 += (float)Main.screenWidth;
			}
			float y2 = Main.screenPosition.Y;
			y2 += (float)Main.rand.Next(Main.screenHeight);
			Vector2 vector2 = default(Vector2);
			((Vector2)(ref vector2))._002Ector(num12, y2);
			float num13 = x - vector2.X;
			float num14 = y - vector2.Y;
			num13 += (float)Main.rand.Next(-50, 51) * 0.1f;
			num14 += (float)Main.rand.Next(-50, 51) * 0.1f;
			float num15 = (float)Math.Sqrt(num13 * num13 + num14 * num14);
			num15 = 24f / num15;
			num13 *= num15;
			num14 *= num15;
			Projectile.NewProjectile(GetProjectileSource_OnHit(victim, 5), num12, y2, num13, num14, 221, 36, 0f, whoAmI);
		}
		if (!crystalLeaf || petalTimer != 0)
		{
			return;
		}
		Vector2 vector3 = default(Vector2);
		for (int j = 0; j < 1000; j++)
		{
			if (Main.projectile[j].owner != whoAmI || Main.projectile[j].type != 226)
			{
				continue;
			}
			petalTimer = 50;
			float num16 = 12f;
			((Vector2)(ref vector3))._002Ector(Main.projectile[j].position.X + (float)width * 0.5f, Main.projectile[j].position.Y + (float)height * 0.5f);
			float num17 = x - vector3.X;
			float num18 = y - vector3.Y;
			float num19 = (float)Math.Sqrt(num17 * num17 + num18 * num18);
			int num10 = 180;
			float num11 = num16 * (float)num10;
			if (!(num19 >= num11))
			{
				num19 = num16 / num19;
				num17 *= num19;
				num18 *= num19;
				Utils.ChaseResults chaseResults = Utils.GetChaseResults(Main.projectile[j].Center, num16 * (float)num10, victim.Center, victim.velocity);
				if (chaseResults.InterceptionHappens && chaseResults.InterceptionTime <= 180f)
				{
					Vector2 val = chaseResults.ChaserVelocity / (float)num10;
					num17 = val.X;
					num18 = val.Y;
				}
				Projectile.NewProjectile(GetProjectileSource_SetBonus(6), Main.projectile[j].Center.X - 4f, Main.projectile[j].Center.Y, num17, num18, 227, crystalLeafDamage, crystalLeafKB, whoAmI);
				break;
			}
		}
	}

	public void OpenPresent(int itemType)
	{
		DropFromItem(itemType);
	}

	public void OpenLegacyPresent(int itemType)
	{
		DropFromItem(itemType);
	}

	/// <summary>
	/// Spawns an item into the world at this players position. This is a simpler alternative to <see cref="M:Terraria.Item.NewItem(Terraria.DataStructures.IEntitySource,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.Int32,System.Boolean,System.Boolean)" />. This method can be called from multiplayer client code without necessitating manually syncing the item.
	/// <br /> Use <see cref="M:Terraria.Player.QuickSpawnItem(Terraria.DataStructures.IEntitySource,Terraria.Item,System.Int32)" /> if a specific instance of an Item needs to be spawned into the world to preserve modded data.
	/// </summary>
	/// <param name="source"></param>
	/// <param name="item"></param>
	/// <param name="stack"></param>
	/// <returns>The index of the item within <see cref="F:Terraria.Main.item" /></returns>
	public int QuickSpawnItem(IEntitySource source, int item, int stack = 1)
	{
		int number = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, item, stack, noBroadcast: false, -1);
		if (Main.netMode == 1)
		{
			NetMessage.SendData(21, -1, -1, null, number, 1f);
		}
		return number;
	}

	public void OpenBossBag(int type)
	{
		DropFromItem(type);
		if (!ItemID.Sets.PreHardmodeLikeBossBag[type] || Main.tenthAnniversaryWorld)
		{
			TryGettingDevArmor(GetItemSource_OpenItem(type));
		}
	}

	public void TryGettingDevArmor(IEntitySource source)
	{
		ModLoaderMod.TryGettingPatreonOrDevArmor(source, this);
		if (Main.rand.Next(Main.tenthAnniversaryWorld ? 8 : 16) == 0)
		{
			switch (Main.rand.Next(18))
			{
			case 0:
				QuickSpawnItem(source, 666);
				QuickSpawnItem(source, 667);
				QuickSpawnItem(source, 668);
				QuickSpawnItem(source, 665);
				QuickSpawnItem(source, 3287);
				break;
			case 1:
				QuickSpawnItem(source, 1554);
				QuickSpawnItem(source, 1555);
				QuickSpawnItem(source, 1556);
				QuickSpawnItem(source, 1586);
				break;
			case 2:
				QuickSpawnItem(source, 1554);
				QuickSpawnItem(source, 1587);
				QuickSpawnItem(source, 1588);
				QuickSpawnItem(source, 1586);
				break;
			case 3:
				QuickSpawnItem(source, 1557);
				QuickSpawnItem(source, 1558);
				QuickSpawnItem(source, 1559);
				QuickSpawnItem(source, 1585);
				break;
			case 4:
				QuickSpawnItem(source, 1560);
				QuickSpawnItem(source, 1561);
				QuickSpawnItem(source, 1562);
				QuickSpawnItem(source, 1584);
				break;
			case 5:
				QuickSpawnItem(source, 1563);
				QuickSpawnItem(source, 1564);
				QuickSpawnItem(source, 1565);
				QuickSpawnItem(source, 3582);
				break;
			case 6:
				QuickSpawnItem(source, 1566);
				QuickSpawnItem(source, 1567);
				QuickSpawnItem(source, 1568);
				break;
			case 7:
				QuickSpawnItem(source, 1580);
				QuickSpawnItem(source, 1581);
				QuickSpawnItem(source, 1582);
				QuickSpawnItem(source, 1583);
				break;
			case 8:
				QuickSpawnItem(source, 3226);
				QuickSpawnItem(source, 3227);
				QuickSpawnItem(source, 3228);
				QuickSpawnItem(source, 3288);
				break;
			case 9:
				QuickSpawnItem(source, 3583);
				QuickSpawnItem(source, 3581);
				QuickSpawnItem(source, 3578);
				QuickSpawnItem(source, 3579);
				QuickSpawnItem(source, 3580);
				break;
			case 10:
				QuickSpawnItem(source, 3585);
				QuickSpawnItem(source, 3586);
				QuickSpawnItem(source, 3587);
				QuickSpawnItem(source, 3588);
				QuickSpawnItem(source, 3024, 4);
				break;
			case 11:
				QuickSpawnItem(source, 3589);
				QuickSpawnItem(source, 3590);
				QuickSpawnItem(source, 3591);
				QuickSpawnItem(source, 3592);
				QuickSpawnItem(source, 3599, 4);
				break;
			case 12:
				QuickSpawnItem(source, 3368);
				QuickSpawnItem(source, 3921);
				QuickSpawnItem(source, 3922);
				QuickSpawnItem(source, 3923);
				QuickSpawnItem(source, 3924);
				break;
			case 13:
				QuickSpawnItem(source, 3925);
				QuickSpawnItem(source, 3926);
				QuickSpawnItem(source, 3927);
				QuickSpawnItem(source, 3928);
				QuickSpawnItem(source, 3929);
				break;
			case 14:
				QuickSpawnItem(source, 4732);
				QuickSpawnItem(source, 4733);
				QuickSpawnItem(source, 4734);
				QuickSpawnItem(source, 4730);
				break;
			case 15:
				QuickSpawnItem(source, 4747);
				QuickSpawnItem(source, 4748);
				QuickSpawnItem(source, 4749);
				QuickSpawnItem(source, 4746);
				break;
			case 16:
				QuickSpawnItem(source, 4751);
				QuickSpawnItem(source, 4752);
				QuickSpawnItem(source, 4753);
				QuickSpawnItem(source, 4750);
				break;
			case 17:
				QuickSpawnItem(source, 4755);
				QuickSpawnItem(source, 4756);
				QuickSpawnItem(source, 4757);
				QuickSpawnItem(source, 4754);
				break;
			}
		}
	}

	public void OpenFishingCrate(int crateItemID)
	{
		DropFromItem(crateItemID);
	}

	/// <summary>
	/// Counts the total stack of the specified item type in this players <see cref="F:Terraria.Player.inventory" />. <br />
	/// Does not check Void Bag. <br />
	/// Use <see cref="M:Terraria.Player.HasItem(System.Int32)" /> to check if the player has the item at all. <br />
	/// </summary>
	/// <param name="type">The item type to count</param>
	/// <param name="stopCountingAt">When to stop counting, useful to avoid unnecessary calculations</param>
	/// <returns>The total amount counted</returns>
	public int CountItem(int type, int stopCountingAt = 0)
	{
		int num = 0;
		for (int i = 0; i != 58; i++)
		{
			if (inventory[i].stack > 0 && inventory[i].type == type)
			{
				num += inventory[i].stack;
				if (num >= stopCountingAt)
				{
					return num;
				}
			}
		}
		return num;
	}

	/// <summary>
	/// Use to consume a single item. The item does not have to be <see cref="F:Terraria.Item.consumable" />. <br />
	/// Attempts to reduce the <see cref="F:Terraria.Item.stack" /> of the first <see cref="T:Terraria.Item" /> found in the <see cref="F:Terraria.Player.inventory" /> by 1. <br />
	/// Respects <see cref="M:Terraria.ModLoader.ItemLoader.ConsumeItem(Terraria.Item,Terraria.Player)" />, so the item won't necessarily be consumed. <br />
	/// To consume multiple of the item, first check <see cref="M:Terraria.Player.CountItem(System.Int32,System.Int32)" /> to ensure that there are enough of the item, then use a for loop to call this method many times. <br />
	/// </summary>
	/// <param name="type">The item type to consume</param>
	/// <param name="reverseOrder">If true, the search for the item will start at the end of the player inventory</param>
	/// <param name="includeVoidBag">If true, the void bag, if open, will also be considered for finding an item to consume</param>
	/// <returns>True if the item was found and attempted to be consumed</returns>
	public bool ConsumeItem(int type, bool reverseOrder = false, bool includeVoidBag = false)
	{
		int num = 0;
		int num2 = 58;
		int num3 = 1;
		if (reverseOrder)
		{
			num = 57;
			num2 = -1;
			num3 = -1;
		}
		for (int i = num; i != num2; i += num3)
		{
			if (inventory[i].stack > 0 && inventory[i].type == type)
			{
				if (ItemLoader.ConsumeItem(inventory[i], this))
				{
					inventory[i].stack--;
				}
				if (inventory[i].stack <= 0)
				{
					inventory[i].SetDefaults();
				}
				return true;
			}
		}
		if (includeVoidBag && useVoidBag())
		{
			int num4 = FindItem(type, bank4.item);
			if (num4 == -1)
			{
				return false;
			}
			Item item = bank4.item[num4];
			item.stack--;
			if (item.stack <= 0)
			{
				item.TurnToAir();
			}
			return true;
		}
		return false;
	}

	public void OpenShadowLockbox(int boxType)
	{
		DropFromItem(boxType);
	}

	public void OpenLockBox(int lockboxItemType)
	{
		DropFromItem(lockboxItemType);
	}

	public void OpenHerbBag(int bagType)
	{
		DropFromItem(bagType);
	}

	public void OpenCanofWorms(int sourceItemType)
	{
		DropFromItem(sourceItemType);
	}

	public void OpenOyster(int sourceItemType)
	{
		DropFromItem(sourceItemType);
	}

	public void OpenGoodieBag(int itemType)
	{
		DropFromItem(itemType);
	}

	public void UpdateDyes()
	{
		cShieldFallback = -1;
		cHead = (cBody = (cLegs = (cHandOn = (cHandOff = (cBack = (cFront = (cShoe = (cWaist = (cShield = (cNeck = (cFace = (cFaceHead = (cFaceFlower = (cBalloon = (cBalloon = (cWings = (cCarpet = (cFloatingTube = (cBackpack = (cTail = 0))))))))))))))))))));
		cGrapple = (cMount = (cMinecart = (cPet = (cLight = (cYorai = (cPortableStool = (cUnicornHorn = (cAngelHalo = (cBeard = (cMinion = (cLeinShampoo = (cFlameWaker = 0))))))))))));
		skinDyePacked = 0;
		cHead = dye[0].dye;
		cBody = dye[1].dye;
		cLegs = dye[2].dye;
		if (wearsRobe)
		{
			cLegs = cBody;
		}
		cPet = miscDyes[0].dye;
		cLight = miscDyes[1].dye;
		cMinecart = miscDyes[2].dye;
		cMount = miscDyes[3].dye;
		cGrapple = miscDyes[4].dye;
		for (int i = 0; i < 20; i++)
		{
			if (IsItemSlotUnlockedAndUsable(i))
			{
				int num = i % 10;
				UpdateItemDye(i < 10, hideVisibleAccessory[num], armor[i], dye[num]);
			}
			if (i == 9)
			{
				AccessorySlotLoader.ModSlotPlayer(this).UpdateDyes(socialSlots: false);
			}
			if (i == 19)
			{
				AccessorySlotLoader.ModSlotPlayer(this).UpdateDyes(socialSlots: true);
			}
		}
		PlayerLoader.UpdateDyes(this);
		cYorai = cPet;
	}

	internal void UpdateItemDye(bool isNotInVanitySlot, bool isSetToHidden, Item armorItem, Item dyeItem)
	{
		if (armorItem.IsAir)
		{
			return;
		}
		bool num = armorItem.wingSlot > 0 || armorItem.type == 934 || armorItem.type == 4341 || armorItem.type == 5126 || armorItem.type == 4563 || armorItem.type == 1987;
		bool flag = isNotInVanitySlot && isSetToHidden;
		if (armorItem.shieldSlot > 0 && armorItem.shieldSlot < ArmorIDs.Shield.Count && (cShieldFallback == -1 || !flag))
		{
			cShieldFallback = dyeItem.dye;
		}
		if (!num && flag)
		{
			return;
		}
		if (armorItem.handOnSlot > 0)
		{
			cHandOn = dyeItem.dye;
		}
		if (armorItem.handOffSlot > 0)
		{
			cHandOff = dyeItem.dye;
		}
		if (armorItem.backSlot > 0)
		{
			if (ArmorIDs.Back.Sets.DrawInBackpackLayer[armorItem.backSlot])
			{
				cBackpack = dyeItem.dye;
			}
			else if (ArmorIDs.Back.Sets.DrawInTailLayer[armorItem.backSlot])
			{
				cTail = dyeItem.dye;
			}
			else
			{
				cBack = dyeItem.dye;
			}
		}
		if (armorItem.frontSlot > 0)
		{
			cFront = dyeItem.dye;
		}
		if (armorItem.shoeSlot > 0)
		{
			if (armorItem.type == 4822 || armorItem.type == 4874)
			{
				cFlameWaker = dyeItem.dye;
			}
			else
			{
				cShoe = dyeItem.dye;
			}
		}
		if (armorItem.waistSlot > 0)
		{
			cWaist = dyeItem.dye;
		}
		if (armorItem.shieldSlot > 0)
		{
			cShield = dyeItem.dye;
		}
		if (armorItem.neckSlot > 0)
		{
			cNeck = dyeItem.dye;
		}
		if (armorItem.faceSlot > 0)
		{
			if (ArmorIDs.Face.Sets.DrawInFaceHeadLayer[armorItem.faceSlot])
			{
				cFaceHead = dyeItem.dye;
			}
			else if (ArmorIDs.Face.Sets.DrawInFaceFlowerLayer[armorItem.faceSlot])
			{
				cFaceFlower = dyeItem.dye;
			}
			else
			{
				cFace = dyeItem.dye;
			}
		}
		if (armorItem.beardSlot > 0)
		{
			cBeard = dyeItem.dye;
		}
		if (armorItem.balloonSlot > 0)
		{
			if (ArmorIDs.Balloon.Sets.DrawInFrontOfBackArmLayer[armorItem.balloonSlot])
			{
				cBalloonFront = dyeItem.dye;
			}
			else
			{
				cBalloon = dyeItem.dye;
			}
		}
		if (armorItem.wingSlot > 0)
		{
			cWings = dyeItem.dye;
		}
		if (armorItem.type == 934)
		{
			cCarpet = dyeItem.dye;
		}
		if (armorItem.type == 4404)
		{
			cFloatingTube = dyeItem.dye;
		}
		if (armorItem.type == 4341 || armorItem.type == 5126)
		{
			cPortableStool = dyeItem.dye;
		}
		if (armorItem.type == 4563)
		{
			cUnicornHorn = dyeItem.dye;
		}
		if (armorItem.type == 1987)
		{
			cAngelHalo = dyeItem.dye;
		}
		if (armorItem.type == 4762)
		{
			cMinion = dyeItem.dye;
		}
		if (armorItem.type == 3929)
		{
			cLeinShampoo = dyeItem.dye;
		}
	}

	public int ArmorSetDye()
	{
		return Main.rand.Next(3) switch
		{
			0 => cHead, 
			1 => cBody, 
			2 => cLegs, 
			_ => cBody, 
		};
	}

	public IEntitySource GetSource_Buff(int buffIndex)
	{
		return GetProjectileSource_Buff(buffIndex);
	}

	internal IEntitySource GetProjectileSource_Buff(int buffIndex)
	{
		int buffId = buffType[buffIndex];
		return new EntitySource_Buff(this, buffId, buffIndex);
	}

	internal IEntitySource GetProjectileSource_Item(Item item)
	{
		return GetSource_ItemUse(item);
	}

	internal IEntitySource GetItemSource_OpenItem(int itemType)
	{
		return GetSource_OpenItem(itemType);
	}

	internal IEntitySource GetItemSource_Death()
	{
		return GetSource_Death();
	}

	internal IEntitySource GetItemSource_Misc(int itemSourceId)
	{
		return GetSource_Misc(ItemSourceID.ToContextString(itemSourceId));
	}

	internal IEntitySource GetProjectileSource_Item_WithPotentialAmmo(Item item, int ammoItemId)
	{
		return GetSource_ItemUse_WithPotentialAmmo(item, ammoItemId);
	}

	internal IEntitySource GetProjectileSource_OnHit(Entity victim, int projectileSourceId)
	{
		return GetSource_OnHit(victim, ProjectileSourceID.ToContextString(projectileSourceId));
	}

	internal IEntitySource GetProjectileSource_OnHurt(Entity attacker, int projectileSourceId)
	{
		return GetSource_OnHurt(attacker, ProjectileSourceID.ToContextString(projectileSourceId));
	}

	internal IEntitySource GetProjectileSource_Accessory(Item item)
	{
		return GetSource_Accessory(item);
	}

	internal IEntitySource GetProjectileSource_Misc(int projectileSourceId)
	{
		return GetSource_Misc(ProjectileSourceID.ToContextString(projectileSourceId));
	}

	internal IEntitySource GetProjectileSource_TileInteraction(int tileCoordsX, int tileCoordsY)
	{
		return GetSource_TileInteraction(tileCoordsX, tileCoordsY);
	}

	internal IEntitySource GetItemSource_TileInteraction(int tileCoordsX, int tileCoordsY)
	{
		return GetSource_TileInteraction(tileCoordsX, tileCoordsY);
	}

	internal IEntitySource GetNPCSource_TileInteraction(int tileCoordsX, int tileCoordsY)
	{
		return GetSource_TileInteraction(tileCoordsX, tileCoordsY);
	}

	internal IEntitySource GetItemSource_OnHit(Entity victim, int itemSourceId)
	{
		return GetSource_OnHit(victim, ItemSourceID.ToContextString(itemSourceId));
	}

	internal IEntitySource GetProjectileSource_SetBonus(int projectileSourceId)
	{
		return GetSource_FromThis(ProjectileSourceID.ToContextString(projectileSourceId));
	}

	public void UpdateBuffs(int i)
	{
		//IL_08b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c0b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c1a: Unknown result type (might be due to invalid IL or missing references)
		//IL_096b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0972: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a32: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a39: Unknown result type (might be due to invalid IL or missing references)
		//IL_126d: Unknown result type (might be due to invalid IL or missing references)
		//IL_127f: Unknown result type (might be due to invalid IL or missing references)
		//IL_17df: Unknown result type (might be due to invalid IL or missing references)
		//IL_17e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_4454: Unknown result type (might be due to invalid IL or missing references)
		//IL_4459: Unknown result type (might be due to invalid IL or missing references)
		//IL_4447: Unknown result type (might be due to invalid IL or missing references)
		//IL_444c: Unknown result type (might be due to invalid IL or missing references)
		if (soulDrain > 0 && whoAmI == Main.myPlayer)
		{
			AddBuff(151, 2);
		}
		if (Main.dontStarveWorld)
		{
			UpdateStarvingState(withEmote: true);
		}
		for (int j = 0; j < maxBuffs; j++)
		{
			if (buffType[j] <= 0 || buffTime[j] <= 0)
			{
				continue;
			}
			if (whoAmI == Main.myPlayer && !BuffID.Sets.TimeLeftDoesNotDecrease[buffType[j]])
			{
				buffTime[j]--;
			}
			int originalIndex = j;
			if (buffType[j] == 1)
			{
				lavaImmune = true;
				fireWalk = true;
				buffImmune[24] = true;
			}
			else if (BuffID.Sets.BasicMountData[buffType[j]] != null)
			{
				BuffID.Sets.BuffMountData buffMountData = BuffID.Sets.BasicMountData[buffType[j]];
				mount.SetMount(buffMountData.mountID, this, buffMountData.faceLeft);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 158)
			{
				manaRegenDelayBonus += 0.5f;
				manaRegenBonus += 10;
			}
			else if (buffType[j] == 159)
			{
				GetArmorPenetration(DamageClass.Melee) += 12f;
			}
			else if (buffType[j] == 192)
			{
				pickSpeed -= 0.2f;
				moveSpeed += 0.2f;
			}
			else if (buffType[j] == 321)
			{
				int num = 10;
				allCrit += num;
				minionDamage += (float)num / 100f;
			}
			else if (buffType[j] == 2)
			{
				lifeRegen += 4;
			}
			else if (buffType[j] == 3)
			{
				moveSpeed += 0.25f;
			}
			else if (buffType[j] == 4)
			{
				gills = true;
			}
			else if (buffType[j] == 5)
			{
				statDefense += 8;
			}
			else if (buffType[j] == 6)
			{
				manaRegenBuff = true;
			}
			else if (buffType[j] == 7)
			{
				magicDamage += 0.2f;
			}
			else if (buffType[j] == 8)
			{
				slowFall = true;
			}
			else if (buffType[j] == 9)
			{
				findTreasure = true;
			}
			else if (buffType[j] == 343)
			{
				biomeSight = true;
			}
			else if (buffType[j] == 10)
			{
				invis = true;
			}
			else if (buffType[j] == 11)
			{
				Lighting.AddLight((int)(position.X + (float)(width / 2)) / 16, (int)(position.Y + (float)(height / 2)) / 16, 0.8f, 0.95f, 1f);
			}
			else if (buffType[j] == 12)
			{
				nightVision = true;
			}
			else if (buffType[j] == 13)
			{
				enemySpawns = true;
			}
			else if (buffType[j] == 14)
			{
				if (thorns < 1f)
				{
					thorns = 1f;
				}
			}
			else if (buffType[j] == 15)
			{
				waterWalk = true;
			}
			else if (buffType[j] == 16)
			{
				archery = true;
				arrowDamage *= 1.1f;
			}
			else if (buffType[j] == 17)
			{
				detectCreature = true;
			}
			else if (buffType[j] == 18)
			{
				gravControl = true;
			}
			else if (buffType[j] == 30)
			{
				bleed = true;
			}
			else if (buffType[j] == 31)
			{
				confused = true;
			}
			else if (buffType[j] == 32)
			{
				slow = true;
			}
			else if (buffType[j] == 35)
			{
				silence = true;
			}
			else if (buffType[j] == 160)
			{
				dazed = true;
			}
			else if (buffType[j] == 46)
			{
				chilled = true;
			}
			else if (buffType[j] == 47)
			{
				frozen = true;
			}
			else if (buffType[j] == 156)
			{
				stoned = true;
			}
			else if (buffType[j] == 69)
			{
				ichor = true;
				statDefense -= 15;
			}
			else if (buffType[j] == 36)
			{
				brokenArmor = true;
			}
			else if (buffType[j] == 48)
			{
				honey = true;
			}
			else if (buffType[j] == 59)
			{
				shadowDodge = true;
			}
			else if (buffType[j] == 93)
			{
				ammoBox = true;
			}
			else if (buffType[j] == 58)
			{
				palladiumRegen = true;
			}
			else if (buffType[j] == 306)
			{
				hasTitaniumStormBuff = true;
			}
			else if (buffType[j] == 88)
			{
				chaosState = true;
			}
			else if (buffType[j] == 215)
			{
				statDefense += 5;
			}
			else if (buffType[j] == 311)
			{
				summonerWeaponSpeedBonus += 0.35f;
			}
			else if (buffType[j] == 308)
			{
				summonerWeaponSpeedBonus += 0.25f;
			}
			else if (buffType[j] == 314)
			{
				summonerWeaponSpeedBonus += 0.12f;
			}
			else if (buffType[j] == 312)
			{
				coolWhipBuff = true;
			}
			else if (buffType[j] == 63)
			{
				moveSpeed += 1f;
			}
			else if (buffType[j] == 104)
			{
				pickSpeed -= 0.25f;
			}
			else if (buffType[j] == 105)
			{
				lifeMagnet = true;
			}
			else if (buffType[j] == 106)
			{
				calmed = true;
			}
			else if (buffType[j] == 121)
			{
				fishingSkill += 15;
			}
			else if (buffType[j] == 122)
			{
				sonarPotion = true;
			}
			else if (buffType[j] == 123)
			{
				cratePotion = true;
			}
			else if (buffType[j] == 107)
			{
				tileSpeed += 0.25f;
				wallSpeed += 0.25f;
				blockRange++;
			}
			else if (buffType[j] == 108)
			{
				kbBuff = true;
			}
			else if (buffType[j] == 109)
			{
				ignoreWater = true;
				accFlipper = true;
			}
			else if (buffType[j] == 110)
			{
				maxMinions++;
			}
			else if (buffType[j] == 150)
			{
				maxMinions++;
			}
			else if (buffType[j] == 348)
			{
				maxTurrets++;
			}
			else if (buffType[j] == 111)
			{
				dangerSense = true;
			}
			else if (buffType[j] == 112)
			{
				ammoPotion = true;
			}
			else if (buffType[j] == 113)
			{
				lifeForce = true;
				statLifeMax2 += statLifeMax / 5 / 20 * 20;
			}
			else if (buffType[j] == 114)
			{
				endurance += 0.1f;
			}
			else if (buffType[j] == 115)
			{
				allCrit += 10f;
			}
			else if (buffType[j] == 116)
			{
				inferno = true;
				Lighting.AddLight((int)(base.Center.X / 16f), (int)(base.Center.Y / 16f), 0.65f, 0.4f, 0.1f);
				int num12 = 323;
				float num20 = 200f;
				bool flag = infernoCounter % 60 == 0;
				int damage = 20;
				if (whoAmI != Main.myPlayer)
				{
					continue;
				}
				for (int k = 0; k < 200; k++)
				{
					NPC nPC = Main.npc[k];
					if (nPC.active && !nPC.friendly && nPC.damage > 0 && !nPC.dontTakeDamage && !nPC.buffImmune[num12] && CanNPCBeHitByPlayerOrPlayerProjectile(nPC) && Vector2.Distance(base.Center, nPC.Center) <= num20)
					{
						if (nPC.FindBuffIndex(num12) == -1)
						{
							nPC.AddBuff(num12, 120);
						}
						if (flag)
						{
							ApplyDamageToNPC(nPC, damage, 0f, 0);
						}
					}
				}
				if (!hostile)
				{
					continue;
				}
				for (int l = 0; l < 255; l++)
				{
					Player player = Main.player[l];
					if (player == this || !player.active || player.dead || !player.hostile || player.buffImmune[num12] || (player.team == team && player.team != 0) || !(Vector2.Distance(base.Center, player.Center) <= num20))
					{
						continue;
					}
					if (player.FindBuffIndex(num12) == -1)
					{
						player.AddBuff(num12, 120);
					}
					if (flag)
					{
						PlayerDeathReason reason = PlayerDeathReason.ByOther(16, whoAmI);
						player.Hurt(reason, damage, 0, pvp: true);
						if (Main.netMode != 0)
						{
							NetMessage.SendPlayerHurt(l, reason, damage, 0, critical: false, pvp: true, -1);
						}
					}
				}
			}
			else if (buffType[j] == 117)
			{
				allDamage += 0.1f;
			}
			else if (buffType[j] == 119)
			{
				loveStruck = true;
			}
			else if (buffType[j] == 120)
			{
				stinky = true;
			}
			else if (buffType[j] == 124)
			{
				resistCold = true;
			}
			else if (buffType[j] == 257)
			{
				if (Main.myPlayer == whoAmI)
				{
					if (buffTime[j] > 36000)
					{
						luckPotion = 3;
					}
					else if (buffTime[j] > 18000)
					{
						luckPotion = 2;
					}
					else
					{
						luckPotion = 1;
					}
				}
			}
			else if (buffType[j] == 165)
			{
				lifeRegen += 6;
				statDefense += 8;
				dryadWard = true;
				if (thorns < 1f)
				{
					thorns += 0.5f;
				}
			}
			else if (buffType[j] == 144)
			{
				electrified = true;
				Lighting.AddLight((int)base.Center.X / 16, (int)base.Center.Y / 16, 0.3f, 0.8f, 1.1f);
			}
			else if (buffType[j] == 94)
			{
				manaSick = true;
				manaSickReduction = manaSickLessDmg * ((float)buffTime[j] / (float)manaSickTime);
			}
			else if (buffType[j] >= 95 && buffType[j] <= 97)
			{
				buffTime[j] = 5;
				int num21 = (byte)(1 + buffType[j] - 95);
				if (beetleOrbs > 0 && beetleOrbs != num21)
				{
					if (beetleOrbs > num21)
					{
						DelBuff(j);
						j--;
					}
					else
					{
						for (int m = 0; m < maxBuffs; m++)
						{
							if (buffType[m] >= 95 && buffType[m] <= 95 + num21 - 1)
							{
								DelBuff(m);
								m--;
							}
						}
					}
				}
				beetleOrbs = num21;
				if (!beetleDefense)
				{
					beetleOrbs = 0;
					DelBuff(j);
					j--;
				}
				else
				{
					beetleBuff = true;
				}
			}
			else if (buffType[j] >= 170 && buffType[j] <= 172)
			{
				buffTime[j] = 5;
				int num22 = (byte)(1 + buffType[j] - 170);
				if (solarShields > 0 && solarShields != num22)
				{
					if (solarShields > num22)
					{
						DelBuff(j);
						j--;
					}
					else
					{
						for (int n = 0; n < maxBuffs; n++)
						{
							if (buffType[n] >= 170 && buffType[n] <= 170 + num22 - 1)
							{
								DelBuff(n);
								n--;
							}
						}
					}
				}
				solarShields = num22;
				if (!setSolar)
				{
					solarShields = 0;
					DelBuff(j);
					j--;
				}
			}
			else if (buffType[j] >= 98 && buffType[j] <= 100)
			{
				int num23 = (byte)(1 + buffType[j] - 98);
				if (beetleOrbs > 0 && beetleOrbs != num23)
				{
					if (beetleOrbs > num23)
					{
						DelBuff(j);
						j--;
					}
					else
					{
						for (int num24 = 0; num24 < maxBuffs; num24++)
						{
							if (buffType[num24] >= 98 && buffType[num24] <= 98 + num23 - 1)
							{
								DelBuff(num24);
								num24--;
							}
						}
					}
				}
				beetleOrbs = num23;
				meleeDamage += 0.1f * (float)beetleOrbs;
				meleeSpeed += 0.1f * (float)beetleOrbs;
				if (!beetleOffense)
				{
					beetleOrbs = 0;
					DelBuff(j);
					j--;
				}
				else
				{
					beetleBuff = true;
				}
			}
			else if (buffType[j] >= 176 && buffType[j] <= 178)
			{
				int num25 = nebulaLevelMana;
				int num26 = (byte)(1 + buffType[j] - 176);
				if (num25 > 0 && num25 != num26)
				{
					if (num25 > num26)
					{
						DelBuff(j);
						j--;
					}
					else
					{
						for (int num2 = 0; num2 < maxBuffs; num2++)
						{
							if (buffType[num2] >= 176 && buffType[num2] <= 178 + num26 - 1)
							{
								DelBuff(num2);
								num2--;
							}
						}
					}
				}
				nebulaLevelMana = num26;
				if (buffTime[j] == 2 && nebulaLevelMana > 1)
				{
					nebulaLevelMana--;
					buffType[j]--;
					buffTime[j] = 480;
				}
			}
			else if (buffType[j] >= 173 && buffType[j] <= 175)
			{
				int num3 = nebulaLevelLife;
				int num4 = (byte)(1 + buffType[j] - 173);
				if (num3 > 0 && num3 != num4)
				{
					if (num3 > num4)
					{
						DelBuff(j);
						j--;
					}
					else
					{
						for (int num5 = 0; num5 < maxBuffs; num5++)
						{
							if (buffType[num5] >= 173 && buffType[num5] <= 175 + num4 - 1)
							{
								DelBuff(num5);
								num5--;
							}
						}
					}
				}
				nebulaLevelLife = num4;
				if (buffTime[j] == 2 && nebulaLevelLife > 1)
				{
					nebulaLevelLife--;
					buffType[j]--;
					buffTime[j] = 480;
				}
				lifeRegen += 6 * nebulaLevelLife;
			}
			else if (buffType[j] >= 179 && buffType[j] <= 181)
			{
				int num6 = nebulaLevelDamage;
				int num7 = (byte)(1 + buffType[j] - 179);
				if (num6 > 0 && num6 != num7)
				{
					if (num6 > num7)
					{
						DelBuff(j);
						j--;
					}
					else
					{
						for (int num8 = 0; num8 < maxBuffs; num8++)
						{
							if (buffType[num8] >= 179 && buffType[num8] <= 181 + num7 - 1)
							{
								DelBuff(num8);
								num8--;
							}
						}
					}
				}
				nebulaLevelDamage = num7;
				if (buffTime[j] == 2 && nebulaLevelDamage > 1)
				{
					nebulaLevelDamage--;
					buffType[j]--;
					buffTime[j] = 480;
				}
				float num9 = 0.15f * (float)nebulaLevelDamage;
				allDamage += num9;
			}
			else if (buffType[j] == 62)
			{
				if ((double)statLife <= (double)statLifeMax2 * 0.5)
				{
					Lighting.AddLight((int)(base.Center.X / 16f), (int)(base.Center.Y / 16f), 0.1f, 0.2f, 0.45f);
					iceBarrier = true;
					endurance += 0.25f;
					iceBarrierFrameCounter++;
					if (iceBarrierFrameCounter > 2)
					{
						iceBarrierFrameCounter = 0;
						iceBarrierFrame++;
						if (iceBarrierFrame >= 12)
						{
							iceBarrierFrame = 0;
						}
					}
				}
				else
				{
					DelBuff(j);
					j--;
				}
			}
			else if (buffType[j] == 49)
			{
				for (int num10 = 191; num10 <= 194; num10++)
				{
					if (ownedProjectileCounts[num10] > 0)
					{
						pygmy = true;
					}
				}
				if (!pygmy)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 83)
			{
				if (ownedProjectileCounts[317] > 0)
				{
					raven = true;
				}
				if (!raven)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 64)
			{
				if (ownedProjectileCounts[266] > 0)
				{
					slime = true;
				}
				if (!slime)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 125)
			{
				if (ownedProjectileCounts[373] > 0)
				{
					hornetMinion = true;
				}
				if (!hornetMinion)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 126)
			{
				if (ownedProjectileCounts[375] > 0)
				{
					impMinion = true;
				}
				if (!impMinion)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 133)
			{
				if (ownedProjectileCounts[390] > 0 || ownedProjectileCounts[391] > 0 || ownedProjectileCounts[392] > 0)
				{
					spiderMinion = true;
				}
				if (!spiderMinion)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 134)
			{
				if (ownedProjectileCounts[387] > 0 || ownedProjectileCounts[388] > 0)
				{
					twinsMinion = true;
				}
				if (!twinsMinion)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 135)
			{
				if (ownedProjectileCounts[393] > 0 || ownedProjectileCounts[394] > 0 || ownedProjectileCounts[395] > 0)
				{
					pirateMinion = true;
				}
				if (!pirateMinion)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 214)
			{
				if (ownedProjectileCounts[758] > 0)
				{
					vampireFrog = true;
				}
				if (!vampireFrog)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 139)
			{
				if (ownedProjectileCounts[407] > 0)
				{
					sharknadoMinion = true;
				}
				if (!sharknadoMinion)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 140)
			{
				if (ownedProjectileCounts[423] > 0)
				{
					UFOMinion = true;
				}
				if (!UFOMinion)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 182)
			{
				if (ownedProjectileCounts[613] > 0)
				{
					stardustMinion = true;
				}
				if (!stardustMinion)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 213)
			{
				if (ownedProjectileCounts[755] > 0)
				{
					batsOfLight = true;
				}
				if (!batsOfLight)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 216)
			{
				bool flag12 = true;
				if (ownedProjectileCounts[759] > 0)
				{
					babyBird = true;
				}
				else if (whoAmI == Main.myPlayer)
				{
					if (numMinions < maxMinions)
					{
						int num11 = FindItem(4281);
						if (num11 != -1)
						{
							Item item = inventory[num11];
							int num13 = Projectile.NewProjectile(GetProjectileSource_Item(item), base.Top, Vector2.Zero, item.shoot, item.damage, item.knockBack, whoAmI);
							Main.projectile[num13].originalDamage = item.damage;
							babyBird = true;
						}
					}
					if (!babyBird)
					{
						DelBuff(j);
						j--;
						flag12 = false;
					}
				}
				if (flag12)
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 325)
			{
				if (ownedProjectileCounts[951] > 0)
				{
					flinxMinion = true;
				}
				if (!flinxMinion)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 335)
			{
				if (ownedProjectileCounts[970] > 0)
				{
					abigailMinion = true;
				}
				if (!abigailMinion)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
				if (whoAmI == Main.myPlayer)
				{
					UpdateAbigailStatus();
				}
			}
			else if (buffType[j] == 263)
			{
				if (ownedProjectileCounts[831] > 0)
				{
					stormTiger = true;
				}
				if (!stormTiger)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
				if (whoAmI == Main.myPlayer)
				{
					UpdateStormTigerStatus();
				}
			}
			else if (buffType[j] == 271)
			{
				if (ownedProjectileCounts[864] > 0)
				{
					smolstar = true;
				}
				if (!smolstar)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 322)
			{
				if (ownedProjectileCounts[946] > 0)
				{
					empressBlade = true;
				}
				if (!empressBlade)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 187)
			{
				if (ownedProjectileCounts[623] > 0)
				{
					stardustGuardian = true;
				}
				if (!stardustGuardian)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 188)
			{
				if (ownedProjectileCounts[625] > 0)
				{
					stardustDragon = true;
				}
				if (!stardustDragon)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 161)
			{
				if (ownedProjectileCounts[533] > 0)
				{
					DeadlySphereMinion = true;
				}
				if (!DeadlySphereMinion)
				{
					DelBuff(j);
					j--;
				}
				else
				{
					buffTime[j] = 18000;
				}
			}
			else if (buffType[j] == 90)
			{
				mount.SetMount(0, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 128)
			{
				mount.SetMount(1, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 129)
			{
				mount.SetMount(2, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 130)
			{
				mount.SetMount(3, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 131)
			{
				ignoreWater = true;
				accFlipper = true;
				mount.SetMount(4, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 132)
			{
				mount.SetMount(5, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 168)
			{
				ignoreWater = true;
				accFlipper = true;
				mount.SetMount(12, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 141)
			{
				mount.SetMount(7, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 142)
			{
				mount.SetMount(8, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 143)
			{
				mount.SetMount(9, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 162)
			{
				mount.SetMount(10, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 193)
			{
				mount.SetMount(14, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 212)
			{
				mount.SetMount(17, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 230)
			{
				mount.SetMount(23, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 265)
			{
				canFloatInWater = true;
				accFlipper = true;
				mount.SetMount(37, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 275)
			{
				mount.SetMount(40, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 276)
			{
				mount.SetMount(41, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 277)
			{
				mount.SetMount(42, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 278)
			{
				mount.SetMount(43, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 279)
			{
				ignoreWater = true;
				accFlipper = true;
				mount.SetMount(44, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 280)
			{
				mount.SetMount(45, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 281)
			{
				mount.SetMount(46, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 282)
			{
				mount.SetMount(47, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 283)
			{
				mount.SetMount(48, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 305)
			{
				ignoreWater = true;
				accFlipper = true;
				lavaImmune = true;
				mount.SetMount(49, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 318)
			{
				mount.SetMount(50, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 342)
			{
				mount.SetMount(52, this);
				buffTime[j] = 10;
			}
			else if (buffType[j] == 37)
			{
				if (Main.wofNPCIndex >= 0 && Main.npc[Main.wofNPCIndex].type == 113)
				{
					gross = true;
					buffTime[j] = 10;
				}
				else
				{
					DelBuff(j);
					j--;
				}
			}
			else if (buffType[j] == 38)
			{
				buffTime[j] = 10;
				tongued = true;
			}
			else if (buffType[j] == 146)
			{
				moveSpeed += 0.1f;
				moveSpeed *= 1.1f;
				sunflower = true;
			}
			else if (buffType[j] == 19)
			{
				buffTime[j] = 18000;
				lightOrb = true;
				bool flag23 = true;
				if (ownedProjectileCounts[18] > 0)
				{
					flag23 = false;
				}
				if (flag23 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 18, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 155)
			{
				buffTime[j] = 18000;
				crimsonHeart = true;
				bool flag27 = true;
				if (ownedProjectileCounts[500] > 0)
				{
					flag27 = false;
				}
				if (flag27 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 500, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 191)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref companionCube, 653);
			}
			else if (buffType[j] == 202)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagDD2Dragon, 701);
			}
			else if (buffType[j] == 217)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagUpbeatStar, 764);
			}
			else if (buffType[j] == 219)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagBabyShark, 774);
			}
			else if (buffType[j] == 258)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagLilHarpy, 815);
			}
			else if (buffType[j] == 259)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagFennecFox, 816);
			}
			else if (buffType[j] == 260)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagGlitteryButterfly, 817);
			}
			else if (buffType[j] == 261)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagBabyImp, 821);
			}
			else if (buffType[j] == 262)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagBabyRedPanda, 825);
			}
			else if (buffType[j] == 264)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagPlantero, 854);
			}
			else if (buffType[j] == 266)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagDynamiteKitten, 858);
			}
			else if (buffType[j] == 267)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagBabyWerewolf, 859);
			}
			else if (buffType[j] == 268)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagShadowMimic, 860);
			}
			else if (buffType[j] == 274)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagVoltBunny, 875);
			}
			else if (buffType[j] == 284)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagKingSlimePet, 881);
			}
			else if (buffType[j] == 285)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagEyeOfCthulhuPet, 882);
			}
			else if (buffType[j] == 286)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagEaterOfWorldsPet, 883);
			}
			else if (buffType[j] == 287)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagBrainOfCthulhuPet, 884);
			}
			else if (buffType[j] == 288)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagSkeletronPet, 885);
			}
			else if (buffType[j] == 289)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagQueenBeePet, 886);
			}
			else if (buffType[j] == 290)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagDestroyerPet, 887);
			}
			else if (buffType[j] == 291)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagTwinsPet, 888);
			}
			else if (buffType[j] == 292)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagSkeletronPrimePet, 889);
			}
			else if (buffType[j] == 293)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagPlanteraPet, 890);
			}
			else if (buffType[j] == 294)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagGolemPet, 891);
			}
			else if (buffType[j] == 295)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagDukeFishronPet, 892);
			}
			else if (buffType[j] == 296)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagLunaticCultistPet, 893);
			}
			else if (buffType[j] == 297)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagMoonLordPet, 894);
			}
			else if (buffType[j] == 298)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagFairyQueenPet, 895);
			}
			else if (buffType[j] == 299)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagPumpkingPet, 896);
			}
			else if (buffType[j] == 300)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagEverscreamPet, 897);
			}
			else if (buffType[j] == 301)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagIceQueenPet, 898);
			}
			else if (buffType[j] == 302)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagMartianPet, 899);
			}
			else if (buffType[j] == 303)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagDD2OgrePet, 900);
			}
			else if (buffType[j] == 304)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagDD2BetsyPet, 901);
			}
			else if (buffType[j] == 317)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagQueenSlimePet, 934);
			}
			else if (buffType[j] == 327)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagBerniePet, 956);
			}
			else if (buffType[j] == 328)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagGlommerPet, 957);
			}
			else if (buffType[j] == 329)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagDeerclopsPet, 958);
			}
			else if (buffType[j] == 330)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagPigPet, 959);
			}
			else if (buffType[j] == 331)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagChesterPet, 960);
			}
			else if (buffType[j] == 341)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagKingSlimePet, 881);
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagQueenSlimePet, 934);
			}
			else if (buffType[j] == 345)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagJunimoPet, 994);
			}
			else if (buffType[j] == 349)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagBlueChickenPet, 998);
			}
			else if (buffType[j] == 351)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagSpiffo, 1003);
			}
			else if (buffType[j] == 352)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagCaveling, 1004);
			}
			else if (buffType[j] == 354)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagDirtiestBlock, 1018);
			}
			else if (buffType[j] == 200)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagDD2Gato, 703);
			}
			else if (buffType[j] == 201)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagDD2Ghost, 702);
			}
			else if (buffType[j] == 218)
			{
				BuffHandle_SpawnPetIfNeededAndSetTime(j, ref petFlagSugarGlider, 765);
			}
			else if (buffType[j] == 190)
			{
				buffTime[j] = 18000;
				suspiciouslookingTentacle = true;
				bool flag28 = true;
				if (ownedProjectileCounts[650] > 0)
				{
					flag28 = false;
				}
				if (flag28 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 650, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 27 || buffType[j] == 101 || buffType[j] == 102)
			{
				buffTime[j] = 18000;
				bool flag29 = true;
				int num14 = 72;
				if (buffType[j] == 27)
				{
					blueFairy = true;
				}
				if (buffType[j] == 101)
				{
					num14 = 86;
					redFairy = true;
				}
				if (buffType[j] == 102)
				{
					num14 = 87;
					greenFairy = true;
				}
				if (head == 45 && body == 26 && legs == 25)
				{
					num14 = 72;
				}
				if (ownedProjectileCounts[num14] > 0)
				{
					flag29 = false;
				}
				if (flag29 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, num14, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 40)
			{
				buffTime[j] = 18000;
				bunny = true;
				bool flag30 = true;
				if (ownedProjectileCounts[111] > 0)
				{
					flag30 = false;
				}
				if (flag30 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 111, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 148)
			{
				rabid = true;
				if (Main.rand.Next(1200) == 0)
				{
					int num15 = Main.rand.Next(6);
					float num16 = (float)Main.rand.Next(60, 100) * 0.01f;
					switch (num15)
					{
					case 0:
						AddBuff(22, (int)(60f * num16 * 3f));
						break;
					case 1:
						AddBuff(23, (int)(60f * num16 * 0.75f));
						break;
					case 2:
						AddBuff(31, (int)(60f * num16 * 1.5f));
						break;
					case 3:
						AddBuff(32, (int)(60f * num16 * 3.5f));
						break;
					case 4:
						AddBuff(33, (int)(60f * num16 * 5f));
						break;
					case 5:
						AddBuff(35, (int)(60f * num16 * 1f));
						break;
					}
				}
				allDamage += 0.2f;
			}
			else if (buffType[j] == 41)
			{
				buffTime[j] = 18000;
				penguin = true;
				bool flag31 = true;
				if (ownedProjectileCounts[112] > 0)
				{
					flag31 = false;
				}
				if (flag31 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 112, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 152)
			{
				buffTime[j] = 18000;
				magicLantern = true;
				if (ownedProjectileCounts[492] == 0 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 492, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 91)
			{
				buffTime[j] = 18000;
				puppy = true;
				bool flag32 = true;
				if (ownedProjectileCounts[334] > 0)
				{
					flag32 = false;
				}
				if (flag32 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 334, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 92)
			{
				buffTime[j] = 18000;
				grinch = true;
				bool flag2 = true;
				if (ownedProjectileCounts[353] > 0)
				{
					flag2 = false;
				}
				if (flag2 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 353, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 84)
			{
				buffTime[j] = 18000;
				blackCat = true;
				bool flag3 = true;
				if (ownedProjectileCounts[319] > 0)
				{
					flag3 = false;
				}
				if (flag3 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 319, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 61)
			{
				buffTime[j] = 18000;
				dino = true;
				bool flag4 = true;
				if (ownedProjectileCounts[236] > 0)
				{
					flag4 = false;
				}
				if (flag4 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 236, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 154)
			{
				buffTime[j] = 18000;
				babyFaceMonster = true;
				bool flag5 = true;
				if (ownedProjectileCounts[499] > 0)
				{
					flag5 = false;
				}
				if (flag5 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 499, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 65)
			{
				buffTime[j] = 18000;
				eyeSpring = true;
				bool flag6 = true;
				if (ownedProjectileCounts[268] > 0)
				{
					flag6 = false;
				}
				if (flag6 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 268, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 66)
			{
				buffTime[j] = 18000;
				snowman = true;
				bool flag7 = true;
				if (ownedProjectileCounts[269] > 0)
				{
					flag7 = false;
				}
				if (flag7 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 269, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 42)
			{
				buffTime[j] = 18000;
				turtle = true;
				bool flag8 = true;
				if (ownedProjectileCounts[127] > 0)
				{
					flag8 = false;
				}
				if (flag8 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 127, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 45)
			{
				buffTime[j] = 18000;
				eater = true;
				bool flag9 = true;
				if (ownedProjectileCounts[175] > 0)
				{
					flag9 = false;
				}
				if (flag9 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 175, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 50)
			{
				buffTime[j] = 18000;
				skeletron = true;
				bool flag10 = true;
				if (ownedProjectileCounts[197] > 0)
				{
					flag10 = false;
				}
				if (flag10 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 197, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 51)
			{
				buffTime[j] = 18000;
				hornet = true;
				bool flag11 = true;
				if (ownedProjectileCounts[198] > 0)
				{
					flag11 = false;
				}
				if (flag11 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 198, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 52)
			{
				buffTime[j] = 18000;
				tiki = true;
				bool flag13 = true;
				if (ownedProjectileCounts[199] > 0)
				{
					flag13 = false;
				}
				if (flag13 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 199, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 53)
			{
				buffTime[j] = 18000;
				lizard = true;
				bool flag14 = true;
				if (ownedProjectileCounts[200] > 0)
				{
					flag14 = false;
				}
				if (flag14 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 200, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 54)
			{
				buffTime[j] = 18000;
				parrot = true;
				bool flag15 = true;
				if (ownedProjectileCounts[208] > 0)
				{
					flag15 = false;
				}
				if (flag15 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 208, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 55)
			{
				buffTime[j] = 18000;
				truffle = true;
				bool flag16 = true;
				if (ownedProjectileCounts[209] > 0)
				{
					flag16 = false;
				}
				if (flag16 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 209, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 56)
			{
				buffTime[j] = 18000;
				sapling = true;
				bool flag17 = true;
				if (ownedProjectileCounts[210] > 0)
				{
					flag17 = false;
				}
				if (flag17 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 210, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 85)
			{
				buffTime[j] = 18000;
				cSapling = true;
				bool flag18 = true;
				if (ownedProjectileCounts[324] > 0)
				{
					flag18 = false;
				}
				if (flag18 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 324, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 81)
			{
				buffTime[j] = 18000;
				spider = true;
				bool flag19 = true;
				if (ownedProjectileCounts[313] > 0)
				{
					flag19 = false;
				}
				if (flag19 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 313, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 82)
			{
				buffTime[j] = 18000;
				squashling = true;
				bool flag20 = true;
				if (ownedProjectileCounts[314] > 0)
				{
					flag20 = false;
				}
				if (flag20 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 314, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 57)
			{
				buffTime[j] = 18000;
				wisp = true;
				bool flag21 = true;
				if (ownedProjectileCounts[211] > 0)
				{
					flag21 = false;
				}
				if (flag21 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 211, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 60)
			{
				buffTime[j] = 18000;
				crystalLeaf = true;
				bool flag22 = true;
				for (int num17 = 0; num17 < 1000; num17++)
				{
					if (Main.projectile[num17].active && Main.projectile[num17].owner == whoAmI && Main.projectile[num17].type == 226)
					{
						if (!flag22)
						{
							Main.projectile[num17].Kill();
						}
						flag22 = false;
					}
				}
				if (flag22 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 226, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 127)
			{
				buffTime[j] = 18000;
				zephyrfish = true;
				bool flag24 = true;
				if (ownedProjectileCounts[380] > 0)
				{
					flag24 = false;
				}
				if (flag24 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 380, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 136)
			{
				buffTime[j] = 18000;
				miniMinotaur = true;
				bool flag25 = true;
				if (ownedProjectileCounts[398] > 0)
				{
					flag25 = false;
				}
				if (flag25 && whoAmI == Main.myPlayer)
				{
					Projectile.NewProjectile(GetProjectileSource_Buff(j), position.X + (float)(width / 2), position.Y + (float)(height / 2), 0f, 0f, 398, 0, 0f, whoAmI);
				}
			}
			else if (buffType[j] == 70)
			{
				venom = true;
			}
			else if (buffType[j] == 20)
			{
				poisoned = true;
			}
			else if (buffType[j] == 21)
			{
				potionDelay = buffTime[j];
			}
			else if (buffType[j] == 22)
			{
				blind = true;
			}
			else if (buffType[j] == 80)
			{
				blackout = true;
			}
			else if (buffType[j] == 23)
			{
				noItems = true;
				cursed = true;
			}
			else if (buffType[j] == 24)
			{
				onFire = true;
			}
			else if (buffType[j] == 103)
			{
				dripping = true;
			}
			else if (buffType[j] == 137)
			{
				drippingSlime = true;
			}
			else if (buffType[j] == 320)
			{
				drippingSparkleSlime = true;
			}
			else if (buffType[j] == 67)
			{
				burned = true;
			}
			else if (buffType[j] == 68)
			{
				suffocating = true;
			}
			else if (buffType[j] == 39)
			{
				onFire2 = true;
			}
			else if (buffType[j] == 323)
			{
				onFire3 = true;
			}
			else if (buffType[j] == 44)
			{
				onFrostBurn = true;
			}
			else if (buffType[j] == 324)
			{
				onFrostBurn2 = true;
			}
			else if (buffType[j] == 353)
			{
				shimmering = true;
				frozen = true;
				fallStart = (int)(position.Y / 16f);
				if (Main.myPlayer != whoAmI)
				{
					continue;
				}
				if (position.Y / 16f > (float)Main.UnderworldLayer)
				{
					if (Main.myPlayer == whoAmI)
					{
						DelBuff(j);
					}
					continue;
				}
				if (shimmerWet)
				{
					buffTime[j] = 60;
					continue;
				}
				bool flag26 = false;
				for (int num18 = (int)(position.X / 16f); (float)num18 <= (position.X + (float)width) / 16f; num18++)
				{
					for (int num19 = (int)(position.Y / 16f); (float)num19 <= (position.Y + (float)height) / 16f; num19++)
					{
						if (WorldGen.SolidTile3(num18, num19))
						{
							flag26 = true;
						}
					}
				}
				if (flag26)
				{
					buffTime[j] = 6;
				}
				else
				{
					DelBuff(j);
				}
			}
			else if (buffType[j] == 163)
			{
				headcovered = true;
				bleed = true;
			}
			else if (buffType[j] == 164)
			{
				vortexDebuff = true;
			}
			else if (buffType[j] == 194)
			{
				windPushed = true;
			}
			else if (buffType[j] == 195)
			{
				witheredArmor = true;
			}
			else if (buffType[j] == 205)
			{
				ballistaPanic = true;
			}
			else if (buffType[j] == 196)
			{
				witheredWeapon = true;
			}
			else if (buffType[j] == 197)
			{
				slowOgreSpit = true;
			}
			else if (buffType[j] == 198)
			{
				parryDamageBuff = true;
			}
			else if (buffType[j] == 145)
			{
				moonLeech = true;
			}
			else if (buffType[j] == 149)
			{
				webbed = true;
				if (velocity.Y != 0f)
				{
					velocity = new Vector2(0f, 1E-06f);
				}
				else
				{
					velocity = Vector2.Zero;
				}
				jumpHeight = 0;
				gravity = 0f;
				moveSpeed = 0f;
				dash = 0;
				dashType = 0;
				noKnockback = true;
				RemoveAllGrapplingHooks();
			}
			else if (buffType[j] == 43)
			{
				defendedByPaladin = true;
			}
			else if (buffType[j] == 29)
			{
				magicCrit += 2f;
				magicDamage += 0.05f;
				statManaMax2 += 20;
				manaCost -= 0.02f;
			}
			else if (buffType[j] == 28)
			{
				if (!Main.dayTime && wolfAcc && !merman)
				{
					lifeRegen++;
					wereWolf = true;
					meleeCrit += 2f;
					meleeDamage += 0.051f;
					meleeSpeed += 0.051f;
					statDefense += 3;
					moveSpeed += 0.05f;
				}
				else
				{
					DelBuff(j);
					j--;
				}
			}
			else if (buffType[j] == 33)
			{
				meleeDamage -= 0.051f;
				meleeSpeed -= 0.051f;
				statDefense -= 4;
				moveSpeed -= 0.1f;
			}
			else if (buffType[j] == 25)
			{
				tipsy = true;
				statDefense -= 4;
				meleeCrit += 2f;
				meleeDamage += 0.1f;
				meleeSpeed += 0.1f;
			}
			else if (buffType[j] == 26)
			{
				wellFed = true;
				statDefense += 2;
				allCrit += 2f;
				allDamage += 0.05f;
				meleeSpeed += 0.05f;
				minionKB += 0.5f;
				moveSpeed += 0.2f;
				pickSpeed -= 0.05f;
			}
			else if (buffType[j] == 206)
			{
				wellFed = true;
				statDefense += 3;
				allCrit += 3f;
				allDamage += 0.075f;
				meleeSpeed += 0.075f;
				minionKB += 0.75f;
				moveSpeed += 0.3f;
				pickSpeed -= 0.1f;
			}
			else if (buffType[j] == 207)
			{
				wellFed = true;
				statDefense += 4;
				allCrit += 4f;
				allDamage += 0.1f;
				meleeSpeed += 0.1f;
				minionKB += 1f;
				moveSpeed += 0.4f;
				pickSpeed -= 0.15f;
			}
			else if (buffType[j] == 333)
			{
				hungry = true;
				statDefense -= 2;
				allCrit -= 2f;
				allDamage -= 0.05f;
				meleeSpeed -= 0.05f;
				minionKB -= 0.5f;
				pickSpeed += 0.05f;
			}
			else if (buffType[j] == 334)
			{
				starving = true;
				statDefense -= 4;
				allCrit -= 4f;
				allDamage -= 0.1f;
				meleeSpeed -= 0.1f;
				minionKB -= 1f;
				pickSpeed += 0.15f;
			}
			else if (buffType[j] == 336)
			{
				heartyMeal = true;
			}
			else if (buffType[j] == 71)
			{
				meleeEnchant = 1;
			}
			else if (buffType[j] == 73)
			{
				meleeEnchant = 2;
			}
			else if (buffType[j] == 74)
			{
				meleeEnchant = 3;
			}
			else if (buffType[j] == 75)
			{
				meleeEnchant = 4;
			}
			else if (buffType[j] == 76)
			{
				meleeEnchant = 5;
			}
			else if (buffType[j] == 77)
			{
				meleeEnchant = 6;
			}
			else if (buffType[j] == 78)
			{
				meleeEnchant = 7;
			}
			else if (buffType[j] == 79)
			{
				meleeEnchant = 8;
			}
			if (j == originalIndex)
			{
				BuffLoader.Update(buffType[j], this, ref j);
			}
		}
		UpdateHungerBuffs();
		if (whoAmI == Main.myPlayer && luckPotion != oldLuckPotion)
		{
			luckNeedsSync = true;
			oldLuckPotion = luckPotion;
		}
	}

	public void TryToResetHungerToNeutral()
	{
		bool flag = false;
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffType[i] > 0 && buffTime[i] > 0 && (buffType[i] == 332 || buffType[i] == 333 || buffType[i] == 334))
			{
				buffTime[i] = 0;
				flag = true;
			}
		}
		if (flag)
		{
			UpdateHungerBuffs();
		}
	}

	public void UpdateHungerBuffs()
	{
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffType[i] <= 0 || buffTime[i] <= 0)
			{
				continue;
			}
			if (buffType[i] == 332)
			{
				if (buffTime[i] <= 2 && whoAmI == Main.myPlayer)
				{
					if (Main.remixWorld && Main.dontStarveWorld)
					{
						AddBuff(333, 28800);
					}
					else
					{
						AddBuff(333, 18000);
					}
					EmoteBubble.MakeLocalPlayerEmote(147);
				}
				if (!Main.dontStarveWorld)
				{
					buffTime[i] = 0;
				}
			}
			else if (buffType[i] == 333)
			{
				if (buffTime[i] <= 2 && whoAmI == Main.myPlayer)
				{
					if (Main.remixWorld && Main.dontStarveWorld)
					{
						AddBuff(334, 5);
					}
					else
					{
						AddBuff(334, 5);
					}
					EmoteBubble.MakeLocalPlayerEmote(148);
				}
				if (!Main.dontStarveWorld)
				{
					buffTime[i] = 0;
				}
			}
			else if (buffType[i] == 334 && !Main.dontStarveWorld)
			{
				buffTime[i] = 0;
			}
		}
	}

	public void UpdateStarvingState(bool withEmote)
	{
		if (whoAmI != Main.myPlayer)
		{
			return;
		}
		bool flag = false;
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffTime[i] > 0 && BuffID.Sets.IsFedState[buffType[i]])
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			if (Main.remixWorld && Main.dontStarveWorld)
			{
				AddBuff(332, 28800);
			}
			else
			{
				AddBuff(332, 18000);
			}
			if (withEmote)
			{
				EmoteBubble.MakeLocalPlayerEmote(146);
			}
		}
	}

	private void UpdateProjectileCaches(int i)
	{
		for (int j = 0; j < 1000; j++)
		{
			if (!Main.projectile[j].active || Main.projectile[j].owner != i)
			{
				continue;
			}
			ownedProjectileCounts[Main.projectile[j].type]++;
			switch (Main.projectile[j].type)
			{
			case 831:
			{
				int originalDamage2 = Main.projectile[j].originalDamage;
				if (highestStormTigerGemOriginalDamage < originalDamage2)
				{
					highestStormTigerGemOriginalDamage = originalDamage2;
				}
				break;
			}
			case 970:
			{
				int originalDamage = Main.projectile[j].originalDamage;
				if (highestAbigailCounterOriginalDamage < originalDamage)
				{
					highestAbigailCounterOriginalDamage = originalDamage;
				}
				break;
			}
			}
		}
	}

	private void ResetProjectileCaches()
	{
		highestStormTigerGemOriginalDamage = 0;
		highestAbigailCounterOriginalDamage = 0;
		for (int i = 0; i < ownedProjectileCounts.Length; i++)
		{
			ownedProjectileCounts[i] = 0;
		}
	}

	/// <summary>
	/// A helper method that handles code common to pet buffs. Can be used during the buff update code.<br />
	/// Sets the buff time to the value and spawns the corresponding pet projectile for the player if not yet spawned.<br />
	/// </summary>
	/// <param name="buffIndex"></param>
	/// <param name="petBool"></param>
	/// <param name="petProjID"></param>
	/// <param name="buffTimeToGive"></param>
	public void BuffHandle_SpawnPetIfNeededAndSetTime(int buffIndex, ref bool petBool, int petProjID, int buffTimeToGive = 18000)
	{
		buffTime[buffIndex] = buffTimeToGive;
		BuffHandle_SpawnPetIfNeeded(ref petBool, petProjID, buffIndex);
	}

	public void BuffHandle_SpawnPetIfNeeded(ref bool petBool, int petProjID, int buffIndex)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		petBool = true;
		bool flag = true;
		if (ownedProjectileCounts[petProjID] > 0)
		{
			flag = false;
		}
		Vector2 center = base.Center;
		if (buffType[buffIndex] == 341)
		{
			float num = 10f;
			center = ((petProjID != 934) ? (center - new Vector2(num * (float)direction, 0f)) : (center + new Vector2(num * (float)direction, 0f)));
		}
		if (flag && whoAmI == Main.myPlayer)
		{
			Projectile.NewProjectile(GetProjectileSource_Buff(buffIndex), center.X, center.Y, 0f, 0f, petProjID, 0, 0f, whoAmI);
		}
	}

	private void UpdateAbigailStatus()
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		int num = 963;
		if (ownedProjectileCounts[970] < 1)
		{
			for (int i = 0; i < 1000; i++)
			{
				Projectile projectile = Main.projectile[i];
				if (projectile.active && projectile.owner == whoAmI && projectile.type == num)
				{
					projectile.Kill();
				}
			}
		}
		else if (ownedProjectileCounts[num] < 1)
		{
			Projectile.NewProjectile(GetProjectileSource_Misc(14), base.Center, Vector2.Zero, num, 0, 0f, whoAmI);
		}
	}

	private void UpdateStormTigerStatus()
	{
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		int num = GetDesiredStormTigerMinionRank() switch
		{
			1 => 833, 
			2 => 834, 
			3 => 835, 
			_ => -1, 
		};
		bool flag = false;
		if (num == -1)
		{
			flag = true;
		}
		for (int i = 0; i < ProjectileID.Sets.StormTigerIds.Length; i++)
		{
			int num2 = ProjectileID.Sets.StormTigerIds[i];
			if (num2 != num && ownedProjectileCounts[num2] >= 1)
			{
				flag = true;
				break;
			}
		}
		if (flag)
		{
			for (int j = 0; j < 1000; j++)
			{
				Projectile projectile = Main.projectile[j];
				if (projectile.active && projectile.owner == whoAmI && projectile.type != num && ProjectileID.Sets.StormTiger[projectile.type])
				{
					projectile.Kill();
				}
			}
		}
		else if (ownedProjectileCounts[num] < 1)
		{
			int num3 = Projectile.NewProjectile(GetProjectileSource_Misc(13), base.Center, Vector2.Zero, num, 0, 0f, whoAmI, 0f, 1f);
			Main.projectile[num3].localAI[0] = 60f;
		}
	}

	private int GetDesiredStormTigerMinionRank()
	{
		int result = 0;
		int num = ownedProjectileCounts[831];
		if (num > 0)
		{
			result = 1;
		}
		if (num > 3)
		{
			result = 2;
		}
		if (num > 6)
		{
			result = 3;
		}
		return result;
	}

	public void Counterweight(Vector2 hitPos, int dmg, float kb)
	{
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		if (!yoyoGlove && counterWeight <= 0)
		{
			return;
		}
		int num = -1;
		int num2 = 0;
		int num3 = 0;
		for (int i = 0; i < 1000; i++)
		{
			if (Main.projectile[i].active && Main.projectile[i].owner == whoAmI)
			{
				if (Main.projectile[i].counterweight)
				{
					num3++;
				}
				else if (Main.projectile[i].aiStyle == 99)
				{
					num2++;
					num = i;
				}
			}
		}
		if (yoyoGlove && num2 < 2)
		{
			if (num >= 0)
			{
				Vector2 vector = hitPos - base.Center;
				((Vector2)(ref vector)).Normalize();
				vector *= 16f;
				Projectile.NewProjectile(Entity.InheritSource(Main.projectile[num]), base.Center.X, base.Center.Y, vector.X, vector.Y, Main.projectile[num].type, Main.projectile[num].damage, Main.projectile[num].knockBack, whoAmI, 1f);
			}
		}
		else if (num3 < num2)
		{
			Vector2 vector2 = hitPos - base.Center;
			((Vector2)(ref vector2)).Normalize();
			vector2 *= 16f;
			float knockBack = (kb + 6f) / 2f;
			IEntitySource spawnSource = Entity.InheritSource(Main.projectile[num]);
			if (num3 > 0)
			{
				Projectile.NewProjectile(spawnSource, base.Center.X, base.Center.Y, vector2.X, vector2.Y, counterWeight, (int)((double)dmg * 0.8), knockBack, whoAmI, 1f);
			}
			else
			{
				Projectile.NewProjectile(spawnSource, base.Center.X, base.Center.Y, vector2.X, vector2.Y, counterWeight, (int)((double)dmg * 0.8), knockBack, whoAmI);
			}
		}
	}

	public int beeType()
	{
		if (strongBees && Main.rand.Next(2) == 0)
		{
			makeStrongBee = true;
			return 566;
		}
		makeStrongBee = false;
		return 181;
	}

	public int beeDamage(int dmg)
	{
		if (makeStrongBee)
		{
			return dmg + Main.rand.Next(1, 4);
		}
		return dmg + Main.rand.Next(2);
	}

	public float beeKB(float KB)
	{
		if (makeStrongBee)
		{
			return 0.5f + KB * 1.1f;
		}
		return KB;
	}

	public void Yoraiz0rEye()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_042a: Unknown result type (might be due to invalid IL or missing references)
		//IL_042c: Unknown result type (might be due to invalid IL or missing references)
		//IL_043a: Unknown result type (might be due to invalid IL or missing references)
		//IL_043c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_037e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0397: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0408: Unknown result type (might be due to invalid IL or missing references)
		//IL_040e: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03da: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0468: Unknown result type (might be due to invalid IL or missing references)
		//IL_0481: Unknown result type (might be due to invalid IL or missing references)
		//IL_0487: Unknown result type (might be due to invalid IL or missing references)
		//IL_0495: Unknown result type (might be due to invalid IL or missing references)
		//IL_0497: Unknown result type (might be due to invalid IL or missing references)
		//IL_049f: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b6: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		num += bodyFrame.Y / 56;
		if (num >= Main.OffsetsPlayerHeadgear.Length)
		{
			num = 0;
		}
		Vector2 vector = Main.OffsetsPlayerHeadgear[num];
		vector *= Directions;
		Vector2 vector2 = new Vector2((float)(width / 2), (float)(height / 2)) + vector + (MountedCenter - base.Center);
		sitting.GetSittingOffsetInfo(this, out var posOffset, out var seatAdjustment);
		vector2 += posOffset + new Vector2(0f, seatAdjustment);
		if (face == 19)
		{
			vector2.Y -= 5f * gravDir;
		}
		if (head == 276)
		{
			vector2.X += 2.5f * (float)direction;
		}
		if (mount.Active && mount.Type == 52)
		{
			vector2.X += 14f * (float)direction;
			vector2.Y -= 2f * gravDir;
		}
		float y = -11.5f * gravDir;
		Vector2 vector3 = new Vector2((float)(3 * direction - ((direction == 1) ? 1 : 0)), y) + Vector2.UnitY * gfxOffY + vector2;
		Vector2 vector4 = new Vector2((float)(3 * shadowDirection[1] - ((direction == 1) ? 1 : 0)), y) + vector2;
		Vector2 vector5 = Vector2.Zero;
		if (mount.Active && mount.Cart)
		{
			int num2 = Math.Sign(velocity.X);
			if (num2 == 0)
			{
				num2 = direction;
			}
			vector5 = Utils.RotatedBy(new Vector2(MathHelper.Lerp(0f, -8f, fullRotation / ((float)Math.PI / 4f)), MathHelper.Lerp(0f, 2f, Math.Abs(fullRotation / ((float)Math.PI / 4f)))), fullRotation);
			if (num2 == Math.Sign(fullRotation))
			{
				vector5 *= MathHelper.Lerp(1f, 0.6f, Math.Abs(fullRotation / ((float)Math.PI / 4f)));
			}
		}
		if (fullRotation != 0f)
		{
			vector3 = vector3.RotatedBy(fullRotation, fullRotationOrigin);
			vector4 = vector4.RotatedBy(fullRotation, fullRotationOrigin);
		}
		float num3 = 0f;
		Vector2 vector6 = position + vector3 + vector5;
		Vector2 vector7 = oldPosition + vector4 + vector5;
		vector7.Y -= num3 / 2f;
		vector6.Y -= num3 / 2f;
		float num4 = 1f;
		switch (yoraiz0rEye % 10)
		{
		case 1:
			return;
		case 2:
			num4 = 0.5f;
			break;
		case 3:
			num4 = 0.625f;
			break;
		case 4:
			num4 = 0.75f;
			break;
		case 5:
			num4 = 0.875f;
			break;
		case 6:
			num4 = 1f;
			break;
		case 7:
			num4 = 1.1f;
			break;
		}
		Color newColor;
		if (yoraiz0rEye < 7)
		{
			newColor = Main.hslToRgb(Main.rgbToHsl(eyeColor).X, 1f, 0.5f);
			DelegateMethods.v3_1 = ((Color)(ref newColor)).ToVector3() * 0.5f * num4;
			if (velocity != Vector2.Zero)
			{
				Utils.PlotTileLine(base.Center, base.Center + velocity * 2f, 4f, DelegateMethods.CastLightOpen);
			}
			else
			{
				Utils.PlotTileLine(base.Left, base.Right, 4f, DelegateMethods.CastLightOpen);
			}
		}
		int num5 = (int)Vector2.Distance(vector6, vector7) / 3 + 1;
		if (Vector2.Distance(vector6, vector7) % 3f != 0f)
		{
			num5++;
		}
		for (float num6 = 1f; num6 <= (float)num5; num6 += 1f)
		{
			Dust[] dust = Main.dust;
			Vector2 center = base.Center;
			newColor = default(Color);
			Dust obj = dust[Dust.NewDust(center, 0, 0, 182, 0f, 0f, 0, newColor)];
			obj.position = Vector2.Lerp(vector7, vector6, num6 / (float)num5);
			obj.noGravity = true;
			obj.velocity = Vector2.Zero;
			obj.customData = this;
			obj.scale = num4;
			obj.shader = GameShaders.Armor.GetSecondaryShader(cYorai, this);
		}
	}

	public bool IsItemSlotUnlockedAndUsable(int slot)
	{
		switch (slot)
		{
		default:
			return true;
		case 8:
		case 18:
		{
			bool result2 = extraAccessory;
			if (!Main.expertMode && !Main.gameMenu)
			{
				result2 = false;
			}
			return result2;
		}
		case 9:
		case 19:
		{
			bool result = true;
			if (!Main.masterMode && !Main.gameMenu)
			{
				result = false;
			}
			return result;
		}
		}
	}

	public void RefreshInfoAccs()
	{
		bool flag = false;
		accWatch = 0;
		accCompass = 0;
		accDepthMeter = 0;
		accFishFinder = false;
		accWeatherRadio = false;
		accCalendar = false;
		accThirdEye = false;
		accJarOfSouls = false;
		accCritterGuide = false;
		accStopwatch = false;
		accOreFinder = false;
		accDreamCatcher = false;
		PlayerLoader.ResetInfoAccessories(this);
		for (int i = 0; i < 58; i++)
		{
			int type4 = inventory[i].type;
			RefreshInfoAccsFromItemType(inventory[i]);
			if (type4 == 4131)
			{
				flag = true;
			}
		}
		for (int j = 0; j < 10; j++)
		{
			_ = armor[j].type;
			RefreshInfoAccsFromItemType(armor[j]);
		}
		if (flag)
		{
			for (int k = 0; k < 40; k++)
			{
				int type3 = bank4.item[k].type;
				if (type3 < 0 || ItemID.Sets.WorksInVoidBag[type3])
				{
					RefreshInfoAccsFromItemType(bank4.item[k]);
				}
			}
		}
		RefreshInfoAccsFromTeamPlayers();
	}

	public void RefreshInfoAccsFromTeamPlayers()
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		if (Main.netMode != 1 || whoAmI != Main.myPlayer)
		{
			return;
		}
		for (int i = 0; i < 255; i++)
		{
			if (i == whoAmI || !Main.player[i].active || Main.player[i].dead || Main.player[i].team != team || Main.player[i].team == 0)
			{
				continue;
			}
			int num = 800;
			Vector2 val = Main.player[i].Center - base.Center;
			if (((Vector2)(ref val)).Length() < (float)num)
			{
				if (Main.player[i].accWatch > accWatch)
				{
					accWatch = Main.player[i].accWatch;
				}
				if (Main.player[i].accCompass > accCompass)
				{
					accCompass = Main.player[i].accCompass;
				}
				if (Main.player[i].accDepthMeter > accDepthMeter)
				{
					accDepthMeter = Main.player[i].accDepthMeter;
				}
				if (Main.player[i].accFishFinder)
				{
					accFishFinder = true;
				}
				if (Main.player[i].accWeatherRadio)
				{
					accWeatherRadio = true;
				}
				if (Main.player[i].accThirdEye)
				{
					accThirdEye = true;
				}
				if (Main.player[i].accJarOfSouls)
				{
					accJarOfSouls = true;
				}
				if (Main.player[i].accCalendar)
				{
					accCalendar = true;
				}
				if (Main.player[i].accStopwatch)
				{
					accStopwatch = true;
				}
				if (Main.player[i].accOreFinder)
				{
					accOreFinder = true;
				}
				if (Main.player[i].accCritterGuide)
				{
					accCritterGuide = true;
				}
				if (Main.player[i].accDreamCatcher)
				{
					accDreamCatcher = true;
				}
				if (Main.player[i].hasLuck_LuckyHorseshoe)
				{
					hasLuck_LuckyHorseshoe = true;
				}
				if (Main.player[i].hasLuck_LuckyCoin)
				{
					hasLuck_LuckyCoin = true;
				}
				PlayerLoader.RefreshInfoAccessoriesFromTeamPlayers(this, Main.player[i]);
			}
		}
	}

	public void RefreshInfoAccsFromItemType(Item item)
	{
		RefreshInfoAccsFromItemType(item.type);
		ItemLoader.UpdateInfoAccessory(item, this);
	}

	private void RefreshInfoAccsFromItemType(int accType)
	{
		if ((accType == 15 || accType == 707) && accWatch < 1)
		{
			accWatch = 1;
		}
		if ((accType == 16 || accType == 708) && accWatch < 2)
		{
			accWatch = 2;
		}
		if ((accType == 17 || accType == 709) && accWatch < 3)
		{
			accWatch = 3;
		}
		if (accType == 393)
		{
			accCompass = 1;
		}
		if (accType == 18)
		{
			accDepthMeter = 1;
		}
		if (accType == 395 || accType == 3123 || accType == 3124 || accType == 5358 || accType == 5359 || accType == 5360 || accType == 5361)
		{
			accWatch = 3;
			accDepthMeter = 1;
			accCompass = 1;
		}
		if (accType == 3120 || accType == 3036 || accType == 3123 || accType == 3124 || accType == 5358 || accType == 5359 || accType == 5360 || accType == 5361)
		{
			accFishFinder = true;
		}
		if (accType == 3037 || accType == 3036 || accType == 3123 || accType == 3124 || accType == 5358 || accType == 5359 || accType == 5360 || accType == 5361)
		{
			accWeatherRadio = true;
		}
		if (accType == 3096 || accType == 3036 || accType == 3123 || accType == 3124 || accType == 5358 || accType == 5359 || accType == 5360 || accType == 5361)
		{
			accCalendar = true;
		}
		if (accType == 3084 || accType == 3122 || accType == 3123 || accType == 3124 || accType == 5358 || accType == 5359 || accType == 5360 || accType == 5361)
		{
			accThirdEye = true;
		}
		if (accType == 3095 || accType == 3122 || accType == 3123 || accType == 3124 || accType == 5358 || accType == 5359 || accType == 5360 || accType == 5361)
		{
			accJarOfSouls = true;
		}
		if (accType == 3118 || accType == 3122 || accType == 3123 || accType == 3124 || accType == 5358 || accType == 5359 || accType == 5360 || accType == 5361)
		{
			accCritterGuide = true;
		}
		if (accType == 3099 || accType == 3121 || accType == 3123 || accType == 3124 || accType == 5358 || accType == 5359 || accType == 5360 || accType == 5361)
		{
			accStopwatch = true;
		}
		if (accType == 3102 || accType == 3121 || accType == 3123 || accType == 3124 || accType == 5358 || accType == 5359 || accType == 5360 || accType == 5361)
		{
			accOreFinder = true;
		}
		if (accType == 3119 || accType == 3121 || accType == 3123 || accType == 3124 || accType == 5358 || accType == 5359 || accType == 5360 || accType == 5361)
		{
			accDreamCatcher = true;
		}
	}

	public void RefreshMechanicalAccsFromItemType(int accType)
	{
		if (accType == 3619 || accType == 3611)
		{
			InfoAccMechShowWires = true;
		}
		if (accType == 486 || accType == 3611)
		{
			rulerLine = true;
		}
		if (accType == 2799 || accType == 3611)
		{
			rulerGrid = true;
		}
		if (accType == 2216 || accType == 3061 || accType == 5126)
		{
			autoPaint = true;
		}
		if (accType == 3624)
		{
			autoActuator = true;
		}
		if (accType == 4346)
		{
			preventAllItemPickups = true;
		}
		if (accType == 4767 || accType == 5323)
		{
			dontHurtCritters = true;
		}
		if (accType == 5309 || accType == 5323)
		{
			dontHurtNature = true;
		}
		if (accType == 5095)
		{
			hasLucyTheAxe = true;
		}
	}

	public void UpdatePermanentBoosters()
	{
		if (usedAegisFruit)
		{
			statDefense += 4;
		}
		if (usedGummyWorm)
		{
			fishingSkill += 3;
		}
		if (usedAmbrosia)
		{
			pickSpeed -= 0.05f;
			tileSpeed += 0.05f;
			wallSpeed += 0.05f;
		}
	}

	private bool UpdateEquips_CanItemGrantBenefits(int itemSlot, Item item)
	{
		switch (itemSlot)
		{
		default:
			return true;
		case 0:
			return item.headSlot > -1;
		case 1:
			return item.bodySlot > -1;
		case 2:
			return item.legSlot > -1;
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
			return item.accessory;
		}
	}

	public void UpdateEquips(int i)
	{
		if (inventory[selectedItem].type == 277 && (!mount.Active || !mount.Cart))
		{
			trident = true;
		}
		bool flag = false;
		for (int j = 0; j < 58; j++)
		{
			int type = inventory[j].type;
			ItemLoader.UpdateInventory(inventory[j], this);
			RefreshInfoAccsFromItemType(inventory[j]);
			RefreshMechanicalAccsFromItemType(type);
			if (type == 4743)
			{
				hasFootball = true;
			}
			if (type == 4131)
			{
				flag = true;
			}
		}
		if (inventory[58].type == 4743)
		{
			hasFootball = true;
		}
		for (int k = 0; k < 10; k++)
		{
			Item item = armor[k];
			if (!item.IsAir && IsItemSlotUnlockedAndUsable(k) && (!item.expertOnly || Main.expertMode) && UpdateEquips_CanItemGrantBenefits(k, item))
			{
				if (item.accessory)
				{
					GrantPrefixBenefits(item);
				}
				GrantArmorBenefits(item);
			}
		}
		if (flag)
		{
			for (int l = 0; l < 40; l++)
			{
				int type2 = bank4.item[l].type;
				if (ItemID.Sets.WorksInVoidBag[type2])
				{
					ItemLoader.UpdateInventory(bank4.item[l], this);
					RefreshInfoAccsFromItemType(bank4.item[l]);
					RefreshMechanicalAccsFromItemType(type2);
				}
			}
		}
		equippedAnyWallSpeedAcc = false;
		equippedAnyTileSpeedAcc = false;
		equippedAnyTileRangeAcc = false;
		if (whoAmI == Main.myPlayer)
		{
			Main.musicBoxNotModifiedByVolume = -1;
		}
		for (int m = 3; m < 10; m++)
		{
			if (IsItemSlotUnlockedAndUsable(m))
			{
				ApplyEquipFunctional(armor[m], hideVisibleAccessory[m]);
			}
		}
		PlayerLoader.UpdateEquips(this);
		if (kbGlove)
		{
			GetKnockback(DamageClass.Melee) *= 2f;
		}
		if (accFishingBobber)
		{
			fishingSkill += 10;
		}
		if (skyStoneEffects)
		{
			lifeRegen += 2;
			statDefense += 4;
			meleeSpeed += 0.1f;
			allDamage += 0.1f;
			allCrit += 2f;
			pickSpeed -= 0.15f;
			minionKB += 0.5f;
		}
		if (dd2Accessory)
		{
			minionDamage += 0.1f;
			maxTurrets++;
		}
		for (int num = 13; num < 20; num++)
		{
			if (IsItemSlotUnlockedAndUsable(num))
			{
				ApplyEquipVanity(num, armor[num]);
			}
		}
		if (wet && ShouldFloatInWater)
		{
			accFlipper = true;
		}
		if (whoAmI == Main.myPlayer && Main.SceneMetrics.HasClock && accWatch < 3)
		{
			accWatch++;
		}
		if (equippedAnyTileSpeedAcc && inventory[selectedItem].createTile != 4)
		{
			tileSpeed += 0.5f;
		}
		if (chiselSpeed)
		{
			pickSpeed -= 0.25f;
		}
		if (equippedAnyWallSpeedAcc)
		{
			wallSpeed += 0.5f;
		}
		if (equippedAnyTileRangeAcc && whoAmI == Main.myPlayer)
		{
			tileRangeX += 3;
			tileRangeY += 2;
		}
		if (!accThirdEye)
		{
			accThirdEyeCounter = 0;
		}
		RefreshInfoAccsFromTeamPlayers();
		if (whoAmI == Main.myPlayer && hasLuck_LuckyHorseshoe)
		{
			equipmentBasedLuckBonus += 0.05f;
		}
		if (whoAmI == Main.myPlayer && hasLuck_LuckyCoin)
		{
			equipmentBasedLuckBonus += 0.05f;
		}
		if (!accDreamCatcher && dpsStarted)
		{
			dpsStarted = false;
			dpsEnd = DateTime.Now;
		}
		if (HeldItem.type == 4760 && ownedProjectileCounts[866] < 1)
		{
			hasRaisableShield = true;
		}
		int num2 = 0;
		int num3 = 10 + num2;
		if (armor[num2].type == 5101 || armor[num3].type == 5101)
		{
			DoEyebrellaRainEffect();
			eyebrellaCloud = true;
		}
		if (lastEquipmentBasedLuckBonus != equipmentBasedLuckBonus)
		{
			lastEquipmentBasedLuckBonus = equipmentBasedLuckBonus;
			luckNeedsSync = true;
		}
	}

	public void GrantArmorBenefits(Item armorPiece)
	{
		int type = armorPiece.type;
		RefreshInfoAccsFromItemType(armorPiece);
		RefreshMechanicalAccsFromItemType(type);
		if (armorPiece.type == 3017 || armorPiece.type == 3993)
		{
			flowerBoots = true;
			if (whoAmI == Main.myPlayer)
			{
				DoBootsEffect(DoBootsEffect_PlaceFlowersOnTile);
			}
		}
		if (armorPiece.type == 5001)
		{
			moveSpeed += 0.25f;
			moonLordLegs = true;
		}
		statDefense += armorPiece.defense;
		lifeRegen += armorPiece.lifeRegen;
		if (armorPiece.shieldSlot > 0)
		{
			hasRaisableShield = true;
		}
		switch (armorPiece.type)
		{
		case 3797:
			maxTurrets++;
			manaCost -= 0.1f;
			magicDamage += 0.1f;
			break;
		case 3798:
			magicDamage += 0.1f;
			minionDamage += 0.2f;
			break;
		case 3799:
			minionDamage += 0.1f;
			magicCrit += 20f;
			moveSpeed += 0.2f;
			break;
		case 3800:
			maxTurrets++;
			lifeRegen += 4;
			break;
		case 3801:
			meleeDamage += 0.15f;
			minionDamage += 0.15f;
			break;
		case 3802:
			minionDamage += 0.15f;
			meleeCrit += 15f;
			moveSpeed += 0.15f;
			break;
		case 3806:
			maxTurrets++;
			meleeSpeed += 0.2f;
			break;
		case 3807:
			meleeDamage += 0.2f;
			minionDamage += 0.2f;
			break;
		case 3808:
			minionDamage += 0.1f;
			meleeCrit += 15f;
			moveSpeed += 0.2f;
			break;
		case 3803:
			maxTurrets++;
			rangedCrit += 10f;
			break;
		case 3804:
			rangedDamage += 0.2f;
			minionDamage += 0.2f;
			huntressAmmoCost90 = true;
			break;
		case 3805:
			minionDamage += 0.1f;
			moveSpeed += 0.2f;
			break;
		case 3871:
			maxTurrets += 2;
			meleeDamage += 0.1f;
			minionDamage += 0.1f;
			break;
		case 3872:
			minionDamage += 0.3f;
			lifeRegen += 8;
			break;
		case 3873:
			minionDamage += 0.2f;
			meleeCrit += 20f;
			moveSpeed += 0.2f;
			break;
		case 3874:
			maxTurrets += 2;
			magicDamage += 0.15f;
			minionDamage += 0.15f;
			break;
		case 3875:
			minionDamage += 0.25f;
			magicDamage += 0.1f;
			manaCost -= 0.15f;
			break;
		case 3876:
			minionDamage += 0.2f;
			magicCrit += 25f;
			moveSpeed += 0.2f;
			break;
		case 3877:
			maxTurrets += 2;
			minionDamage += 0.1f;
			rangedCrit += 10f;
			break;
		case 3878:
			minionDamage += 0.25f;
			rangedDamage += 0.25f;
			ammoCost80 = true;
			break;
		case 3879:
			minionDamage += 0.25f;
			rangedCrit += 10f;
			moveSpeed += 0.2f;
			break;
		case 3880:
			maxTurrets += 2;
			minionDamage += 0.2f;
			meleeDamage += 0.2f;
			break;
		case 3881:
			meleeSpeed += 0.2f;
			meleeCrit += 5f;
			minionDamage += 0.2f;
			break;
		case 3882:
			minionDamage += 0.2f;
			meleeCrit += 20f;
			moveSpeed += 0.3f;
			break;
		}
		if (armorPiece.type == 5100)
		{
			SpawnHallucination(armorPiece);
		}
		if (armorPiece.type == 268)
		{
			accDivingHelm = true;
		}
		if (armorPiece.type == 238)
		{
			magicDamage += 0.05f;
			if (Main.tenthAnniversaryWorld)
			{
				maxMinions++;
			}
		}
		if (armorPiece.type == 3770)
		{
			slowFall = true;
		}
		if (armorPiece.type == 4404)
		{
			canFloatInWater = true;
		}
		if (armorPiece.type == 3776)
		{
			magicDamage += 0.15f;
			minionDamage += 0.15f;
		}
		if (armorPiece.type == 3777)
		{
			statManaMax2 += 40;
			minionDamage += 0.1f;
			maxMinions++;
		}
		if (armorPiece.type == 3778)
		{
			statManaMax2 += 40;
			magicDamage += 0.1f;
			maxMinions++;
		}
		if (armorPiece.type == 3212)
		{
			armorPenetration += 5f;
		}
		if (armorPiece.type == 2277)
		{
			allDamage += 0.05f;
			allCrit += 5f;
			meleeSpeed += 0.1f;
			moveSpeed += 0.1f;
		}
		if (armorPiece.type == 2279)
		{
			magicDamage += 0.06f;
			magicCrit += 6f;
			manaCost -= 0.1f;
		}
		if (armorPiece.type == 3109 || armorPiece.type == 4008)
		{
			nightVision = true;
		}
		if (armorPiece.type == 256 || armorPiece.type == 257 || armorPiece.type == 258)
		{
			allCrit += 3f;
		}
		if (armorPiece.type == 3374)
		{
			rangedCrit += 4f;
		}
		if (armorPiece.type == 3375)
		{
			rangedDamage += 0.05f;
		}
		if (armorPiece.type == 3376)
		{
			rangedCrit += 4f;
		}
		if (armorPiece.type == 151 || armorPiece.type == 959 || armorPiece.type == 152 || armorPiece.type == 153)
		{
			rangedDamage += 0.05f;
		}
		if (armorPiece.type == 2275)
		{
			magicDamage += 0.06f;
			magicCrit += 6f;
		}
		if (armorPiece.type == 123 || armorPiece.type == 124 || armorPiece.type == 125)
		{
			magicDamage += 0.09f;
		}
		if (armorPiece.type == 228 || armorPiece.type == 960)
		{
			statManaMax2 += 40;
			magicCrit += 6f;
		}
		if (armorPiece.type == 229 || armorPiece.type == 961)
		{
			statManaMax2 += 20;
			magicDamage += 0.06f;
		}
		if (armorPiece.type == 230 || armorPiece.type == 962)
		{
			statManaMax2 += 20;
			magicCrit += 6f;
		}
		if (armorPiece.type == 100 || armorPiece.type == 101 || armorPiece.type == 102)
		{
			allCrit += 5f;
		}
		if (armorPiece.type == 956 || armorPiece.type == 957 || armorPiece.type == 958)
		{
			allCrit += 5f;
		}
		if (armorPiece.type == 792 || armorPiece.type == 793 || armorPiece.type == 794)
		{
			allDamage += 0.03f;
		}
		if (armorPiece.type == 231)
		{
			meleeCrit += 7f;
		}
		if (armorPiece.type == 232)
		{
			meleeDamage += 0.07f;
		}
		if (armorPiece.type == 233)
		{
			meleeSpeed += 0.07f;
		}
		if (armorPiece.type == 371)
		{
			magicCrit += 9f;
			magicDamage += 0.1f;
			statManaMax2 += 40;
		}
		if (armorPiece.type == 372)
		{
			moveSpeed += 0.1f;
			meleeDamage += 0.15f;
		}
		if (armorPiece.type == 373)
		{
			rangedDamage += 0.1f;
			rangedCrit += 10f;
		}
		if (armorPiece.type == 374)
		{
			allCrit += 5f;
		}
		if (armorPiece.type == 375)
		{
			allDamage += 0.03f;
			moveSpeed += 0.1f;
		}
		if (armorPiece.type == 376)
		{
			magicDamage += 0.15f;
			statManaMax2 += 60;
		}
		if (armorPiece.type == 377)
		{
			meleeCrit += 8f;
			meleeDamage += 0.1f;
		}
		if (armorPiece.type == 378)
		{
			rangedDamage += 0.12f;
			rangedCrit += 7f;
		}
		if (armorPiece.type == 379)
		{
			allDamage += 0.07f;
		}
		if (armorPiece.type == 380)
		{
			allCrit += 10f;
		}
		if (armorPiece.type >= 2367 && armorPiece.type <= 2369)
		{
			fishingSkill += 5;
		}
		if (armorPiece.type == 400)
		{
			magicDamage += 0.12f;
			magicCrit += 12f;
			statManaMax2 += 80;
		}
		if (armorPiece.type == 401)
		{
			meleeCrit += 7f;
			meleeDamage += 0.14f;
		}
		if (armorPiece.type == 402)
		{
			rangedDamage += 0.14f;
			rangedCrit += 10f;
		}
		if (armorPiece.type == 403)
		{
			allDamage += 0.08f;
		}
		if (armorPiece.type == 404)
		{
			allCrit += 7f;
			moveSpeed += 0.05f;
		}
		if (armorPiece.type == 1205)
		{
			meleeDamage += 0.12f;
			meleeSpeed += 0.12f;
		}
		if (armorPiece.type == 1206)
		{
			rangedDamage += 0.09f;
			rangedCrit += 9f;
		}
		if (armorPiece.type == 1207)
		{
			magicDamage += 0.09f;
			magicCrit += 9f;
			statManaMax2 += 60;
		}
		if (armorPiece.type == 1208)
		{
			allDamage += 0.03f;
			allCrit += 2f;
		}
		if (armorPiece.type == 1209)
		{
			allDamage += 0.02f;
			allCrit += 1f;
		}
		if (armorPiece.type == 1210)
		{
			meleeDamage += 0.11f;
			meleeSpeed += 0.11f;
			moveSpeed += 0.07f;
		}
		if (armorPiece.type == 1211)
		{
			rangedCrit += 15f;
			moveSpeed += 0.08f;
		}
		if (armorPiece.type == 1212)
		{
			magicCrit += 18f;
			statManaMax2 += 80;
		}
		if (armorPiece.type == 1213)
		{
			allCrit += 6f;
		}
		if (armorPiece.type == 1214)
		{
			moveSpeed += 0.11f;
			allDamage += 0.08f;
		}
		if (armorPiece.type == 1215)
		{
			meleeDamage += 0.09f;
			meleeCrit += 9f;
			meleeSpeed += 0.09f;
		}
		if (armorPiece.type == 1216)
		{
			rangedDamage += 0.16f;
			rangedCrit += 7f;
		}
		if (armorPiece.type == 1217)
		{
			magicDamage += 0.16f;
			magicCrit += 7f;
			statManaMax2 += 100;
		}
		if (armorPiece.type == 1218)
		{
			allDamage += 0.04f;
			allCrit += 3f;
		}
		if (armorPiece.type == 1219)
		{
			allDamage += 0.03f;
			allCrit += 3f;
			moveSpeed += 0.06f;
		}
		if (armorPiece.type == 558 || armorPiece.type == 4898)
		{
			magicDamage += 0.12f;
			magicCrit += 12f;
			statManaMax2 += 100;
		}
		if (armorPiece.type == 559 || armorPiece.type == 4896)
		{
			meleeCrit += 10f;
			meleeDamage += 0.1f;
			meleeSpeed += 0.1f;
		}
		if (armorPiece.type == 553 || armorPiece.type == 4897)
		{
			rangedDamage += 0.15f;
			rangedCrit += 8f;
		}
		if (armorPiece.type == 4873 || armorPiece.type == 4899)
		{
			minionDamage += 0.1f;
			maxMinions++;
		}
		if (armorPiece.type == 551 || armorPiece.type == 4900)
		{
			allCrit += 7f;
		}
		if (armorPiece.type == 552 || armorPiece.type == 4901)
		{
			allDamage += 0.07f;
			moveSpeed += 0.08f;
		}
		if (armorPiece.type == 4982)
		{
			allCrit += 5f;
			manaCost -= 0.1f;
		}
		if (armorPiece.type == 4983)
		{
			allDamage += 0.05f;
			huntressAmmoCost90 = true;
		}
		if (armorPiece.type == 4984)
		{
			meleeSpeed += 0.1f;
			moveSpeed += 0.2f;
		}
		if (armorPiece.type == 1001)
		{
			meleeDamage += 0.16f;
			meleeCrit += 6f;
		}
		if (armorPiece.type == 1002)
		{
			rangedDamage += 0.16f;
			chloroAmmoCost80 = true;
		}
		if (armorPiece.type == 1003)
		{
			statManaMax2 += 80;
			manaCost -= 0.17f;
			magicDamage += 0.16f;
		}
		if (armorPiece.type == 1004)
		{
			allDamage += 0.05f;
			allCrit += 7f;
		}
		if (armorPiece.type == 1005)
		{
			allCrit += 8f;
			moveSpeed += 0.05f;
		}
		if (armorPiece.type == 2189)
		{
			statManaMax2 += 60;
			manaCost -= 0.13f;
			magicDamage += 0.1f;
			magicCrit += 10f;
		}
		if (armorPiece.type == 1504)
		{
			magicDamage += 0.07f;
			magicCrit += 7f;
		}
		if (armorPiece.type == 1505)
		{
			magicDamage += 0.08f;
			moveSpeed += 0.08f;
		}
		if (armorPiece.type == 1546)
		{
			rangedCrit += 5f;
			arrowDamage *= 1.15f;
		}
		if (armorPiece.type == 1547)
		{
			rangedCrit += 5f;
			bulletDamage *= 1.15f;
		}
		if (armorPiece.type == 1548)
		{
			rangedCrit += 5f;
			specialistDamage *= 1.15f;
		}
		if (armorPiece.type == 1549)
		{
			rangedCrit += 13f;
			rangedDamage += 0.13f;
			ammoCost80 = true;
		}
		if (armorPiece.type == 1550)
		{
			rangedCrit += 7f;
			moveSpeed += 0.12f;
		}
		if (armorPiece.type == 1282)
		{
			statManaMax2 += 20;
			manaCost -= 0.05f;
		}
		if (armorPiece.type == 1283)
		{
			statManaMax2 += 40;
			manaCost -= 0.07f;
		}
		if (armorPiece.type == 1284)
		{
			statManaMax2 += 40;
			manaCost -= 0.09f;
		}
		if (armorPiece.type == 1285)
		{
			statManaMax2 += 60;
			manaCost -= 0.11f;
		}
		if (armorPiece.type == 1286 || armorPiece.type == 4256)
		{
			statManaMax2 += 60;
			manaCost -= 0.13f;
		}
		if (armorPiece.type == 1287)
		{
			statManaMax2 += 80;
			manaCost -= 0.15f;
		}
		if (armorPiece.type == 1316 || armorPiece.type == 1317 || armorPiece.type == 1318)
		{
			aggro += 250;
		}
		if (armorPiece.type == 1316)
		{
			meleeDamage += 0.06f;
		}
		if (armorPiece.type == 1317)
		{
			meleeDamage += 0.08f;
			meleeCrit += 8f;
		}
		if (armorPiece.type == 1318)
		{
			meleeCrit += 4f;
		}
		if (armorPiece.type == 2199 || armorPiece.type == 2202)
		{
			aggro += 250;
		}
		if (armorPiece.type == 2201)
		{
			aggro += 400;
		}
		if (armorPiece.type == 2199)
		{
			meleeDamage += 0.06f;
		}
		if (armorPiece.type == 2200)
		{
			meleeDamage += 0.08f;
			meleeCrit += 8f;
			meleeSpeed += 0.06f;
			moveSpeed += 0.06f;
		}
		if (armorPiece.type == 2201)
		{
			meleeDamage += 0.05f;
			meleeCrit += 5f;
		}
		if (armorPiece.type == 2202)
		{
			meleeSpeed += 0.06f;
			moveSpeed += 0.06f;
		}
		if (armorPiece.type == 684)
		{
			rangedDamage += 0.16f;
			meleeDamage += 0.16f;
		}
		if (armorPiece.type == 685)
		{
			meleeCrit += 11f;
			rangedCrit += 11f;
		}
		if (armorPiece.type == 686)
		{
			moveSpeed += 0.08f;
			meleeSpeed += 0.1f;
		}
		if (armorPiece.type == 5068)
		{
			maxMinions++;
			minionDamage += 0.05f;
		}
		if (armorPiece.type == 2361)
		{
			maxMinions++;
			minionDamage += 0.04f;
		}
		if (armorPiece.type == 2362)
		{
			maxMinions++;
			minionDamage += 0.04f;
		}
		if (armorPiece.type == 2363)
		{
			minionDamage += 0.05f;
		}
		if (armorPiece.type == 3266)
		{
			minionDamage += 0.08f;
		}
		if (armorPiece.type == 3267)
		{
			maxMinions++;
		}
		if (armorPiece.type == 3268)
		{
			minionDamage += 0.08f;
		}
		if (armorPiece.type == 410)
		{
			pickSpeed -= 0.1f;
		}
		if (armorPiece.type == 411)
		{
			pickSpeed -= 0.1f;
		}
		if (armorPiece.type >= 1158 && armorPiece.type <= 1161)
		{
			maxMinions++;
		}
		if (armorPiece.type == 1159)
		{
			whipRangeMultiplier += 0.1f;
		}
		if (armorPiece.type >= 1159 && armorPiece.type <= 1161)
		{
			minionDamage += 0.1f;
		}
		if (armorPiece.type >= 2370 && armorPiece.type <= 2371)
		{
			minionDamage += 0.05f;
			maxMinions++;
		}
		if (armorPiece.type == 2372)
		{
			minionDamage += 0.06f;
			maxMinions++;
		}
		if (armorPiece.type == 3381)
		{
			maxMinions++;
			maxTurrets++;
			minionDamage += 0.22f;
		}
		if (armorPiece.type == 3382 || armorPiece.type == 3383)
		{
			maxMinions += 2;
			whipRangeMultiplier += 0.15f;
			minionDamage += 0.22f;
		}
		if (armorPiece.type == 2763)
		{
			aggro += 300;
			meleeCrit += 26f;
			lifeRegen += 2;
		}
		if (armorPiece.type == 2764)
		{
			aggro += 300;
			meleeDamage += 0.29f;
			lifeRegen += 2;
		}
		if (armorPiece.type == 2765)
		{
			aggro += 300;
			meleeSpeed += 0.15f;
			moveSpeed += 0.15f;
			lifeRegen += 2;
		}
		if (armorPiece.type == 2757)
		{
			rangedCrit += 7f;
			rangedDamage += 0.16f;
		}
		if (armorPiece.type == 2758)
		{
			ammoCost75 = true;
			rangedCrit += 12f;
			rangedDamage += 0.12f;
		}
		if (armorPiece.type == 2759)
		{
			rangedCrit += 8f;
			rangedDamage += 0.08f;
			moveSpeed += 0.1f;
		}
		if (armorPiece.type == 2760)
		{
			statManaMax2 += 60;
			manaCost -= 0.15f;
			magicCrit += 7f;
			magicDamage += 0.07f;
		}
		if (armorPiece.type == 2761)
		{
			magicDamage += 0.09f;
			magicCrit += 9f;
		}
		if (armorPiece.type == 2762)
		{
			moveSpeed += 0.1f;
			magicDamage += 0.1f;
		}
		if (armorPiece.type == 1832)
		{
			maxMinions++;
			minionDamage += 0.11f;
		}
		if (armorPiece.type == 1833)
		{
			maxMinions += 2;
			minionDamage += 0.11f;
		}
		if (armorPiece.type == 1834)
		{
			moveSpeed += 0.2f;
			maxMinions++;
			minionDamage += 0.11f;
		}
		ItemLoader.UpdateEquip(armorPiece, this);
	}

	public void GrantPrefixBenefits(Item item)
	{
		if (item.prefix == 62)
		{
			++statDefense;
		}
		if (item.prefix == 63)
		{
			statDefense += 2;
		}
		if (item.prefix == 64)
		{
			statDefense += 3;
		}
		if (item.prefix == 65)
		{
			statDefense += 4;
		}
		if (item.prefix == 66)
		{
			statManaMax2 += 20;
		}
		if (item.prefix == 67)
		{
			allCrit += 2f;
		}
		if (item.prefix == 68)
		{
			allCrit += 4f;
		}
		if (item.prefix == 69)
		{
			allDamage += 0.01f;
		}
		if (item.prefix == 70)
		{
			allDamage += 0.02f;
		}
		if (item.prefix == 71)
		{
			allDamage += 0.03f;
		}
		if (item.prefix == 72)
		{
			allDamage += 0.04f;
		}
		if (item.prefix == 73)
		{
			moveSpeed += 0.01f;
		}
		if (item.prefix == 74)
		{
			moveSpeed += 0.02f;
		}
		if (item.prefix == 75)
		{
			moveSpeed += 0.03f;
		}
		if (item.prefix == 76)
		{
			moveSpeed += 0.04f;
		}
		if (item.prefix == 77)
		{
			meleeSpeed += 0.01f;
		}
		if (item.prefix == 78)
		{
			meleeSpeed += 0.02f;
		}
		if (item.prefix == 79)
		{
			meleeSpeed += 0.03f;
		}
		if (item.prefix == 80)
		{
			meleeSpeed += 0.04f;
		}
		PrefixLoader.ApplyAccessoryEffects(this, item);
	}

	private void SpawnHallucination(Item item)
	{
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		if (whoAmI != Main.myPlayer)
		{
			return;
		}
		insanityShadowCooldown = Utils.Clamp(insanityShadowCooldown - 1, 0, 100);
		if (insanityShadowCooldown > 0)
		{
			return;
		}
		insanityShadowCooldown = Main.rand.Next(20, 101);
		float num = 500f;
		int damage = 18;
		_hallucinationCandidates.Clear();
		for (int i = 0; i < 200; i++)
		{
			NPC nPC = Main.npc[i];
			if (nPC.CanBeChasedBy(this) && !(Distance(nPC.Center) > num) && Collision.CanHitLine(position, width, height, nPC.position, nPC.width, nPC.height))
			{
				_hallucinationCandidates.Add(nPC);
			}
		}
		if (_hallucinationCandidates.Count != 0)
		{
			Projectile.RandomizeInsanityShadowFor(Main.rand.NextFromCollection(_hallucinationCandidates), isHostile: false, out var spawnposition, out var spawnvelocity, out var ai, out var ai2);
			Projectile.NewProjectile(new EntitySource_ItemUse(this, item), spawnposition, spawnvelocity, 964, damage, 0f, whoAmI, ai, ai2);
		}
	}

	public void DoBootsEffect(Utils.TileActionAttempt theEffectMethod)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (miscCounter % 2 == 0 && velocity.Y == 0f && grappling[0] == -1 && velocity.X != 0f)
		{
			int x = (int)base.Center.X / 16;
			int y = (int)(position.Y + (float)height - 1f) / 16;
			theEffectMethod(x, y);
		}
	}

	public bool DoBootsEffect_PlaceFlamesOnTile(int X, int Y)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		Tile tile = Main.tile[X, Y + 1];
		if (tile == null || !tile.active() || tile.liquid > 0 || !WorldGen.SolidTileAllowBottomSlope(X, Y + 1))
		{
			return false;
		}
		ParticleOrchestrator.RequestParticleSpawn(clientOnly: true, ParticleOrchestraType.FlameWaders, new ParticleOrchestraSettings
		{
			PositionInWorld = new Vector2((float)(X * 16 + 8), (float)(Y * 16 + 16))
		}, whoAmI);
		return true;
	}

	public bool DoBootsEffect_PlaceFlowersOnTile(int X, int Y)
	{
		Tile tile = Main.tile[X, Y];
		if (tile == null)
		{
			return false;
		}
		if (!tile.active() && tile.liquid == 0 && Main.tile[X, Y + 1] != null && WorldGen.SolidTile(X, Y + 1))
		{
			tile.frameY = 0;
			tile.slope(0);
			tile.halfBrick(halfBrick: false);
			if (Main.tile[X, Y + 1].type == 2 || Main.tile[X, Y + 1].type == 477)
			{
				int num = Main.rand.NextFromList<int>(6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 24, 27, 30, 33, 36, 39, 42);
				switch (num)
				{
				case 21:
				case 24:
				case 27:
				case 30:
				case 33:
				case 36:
				case 39:
				case 42:
					num += Main.rand.Next(3);
					break;
				}
				tile.active(active: true);
				tile.type = 3;
				tile.frameX = (short)(num * 18);
				tile.CopyPaintAndCoating(Main.tile[X, Y + 1]);
				if (Main.netMode == 1)
				{
					NetMessage.SendTileSquare(-1, X, Y);
				}
				return true;
			}
			if (Main.tile[X, Y + 1].type == 109 || Main.tile[X, Y + 1].type == 492)
			{
				if (Main.rand.Next(2) == 0)
				{
					tile.active(active: true);
					tile.type = 110;
					tile.frameX = (short)(18 * Main.rand.Next(4, 7));
					tile.CopyPaintAndCoating(Main.tile[X, Y + 1]);
					while (tile.frameX == 90)
					{
						tile.frameX = (short)(18 * Main.rand.Next(4, 7));
					}
				}
				else
				{
					tile.active(active: true);
					tile.type = 113;
					tile.frameX = (short)(18 * Main.rand.Next(2, 8));
					tile.CopyPaintAndCoating(Main.tile[X, Y + 1]);
					while (tile.frameX == 90)
					{
						tile.frameX = (short)(18 * Main.rand.Next(2, 8));
					}
				}
				if (Main.netMode == 1)
				{
					NetMessage.SendTileSquare(-1, X, Y);
				}
				return true;
			}
			if (Main.tile[X, Y + 1].type == 60)
			{
				tile.active(active: true);
				tile.type = 74;
				tile.frameX = (short)(18 * Main.rand.Next(9, 17));
				tile.CopyPaintAndCoating(Main.tile[X, Y + 1]);
				if (Main.netMode == 1)
				{
					NetMessage.SendTileSquare(-1, X, Y);
				}
				return true;
			}
			if (Main.tile[X, Y + 1].type == 633)
			{
				tile.active(active: true);
				tile.type = 637;
				tile.frameX = (short)(18 * Main.rand.Next(6, 11));
				tile.CopyPaintAndCoating(Main.tile[X, Y + 1]);
				if (Main.netMode == 1)
				{
					NetMessage.SendTileSquare(-1, X, Y);
				}
				return true;
			}
		}
		return false;
	}

	private void ApplyEquipVanity(int itemSlot, Item currentItem)
	{
		ApplyEquipVanity(currentItem);
	}

	public void ApplyEquipVanity(Item currentItem)
	{
		int type = currentItem.type;
		if (currentItem.wingSlot > 0)
		{
			wings = currentItem.wingSlot;
		}
		if (type == 861 || type == 3110 || type == 485)
		{
			hideWolf = false;
			forceWerewolf = true;
		}
		switch (type)
		{
		case 5452:
			remoteVisionForDrone = true;
			break;
		case 3538:
			stardustMonolithShader = true;
			break;
		case 3537:
			nebulaMonolithShader = true;
			break;
		case 3536:
			vortexMonolithShader = true;
			break;
		case 3539:
			solarMonolithShader = true;
			break;
		case 4318:
			moonLordMonolithShader = true;
			break;
		case 4054:
			bloodMoonMonolithShader = true;
			break;
		case 5345:
			CanSeeInvisibleBlocks = true;
			break;
		case 5347:
			shimmerMonolithShader = true;
			break;
		}
		if (type == 5113)
		{
			dontStarveShader = !dontStarveShader;
		}
		if (((wet && !lavaWet && (!mount.Active || !mount.IsConsideredASlimeMount)) || !forceWerewolf) && (type == 861 || type == 3110 || type == 497))
		{
			hideMerman = false;
			forceMerman = true;
		}
		if ((!mount.Active || mount.Type != 47) && (type == 4822 || type == 4874))
		{
			DoBootsEffect(DoBootsEffect_PlaceFlamesOnTile);
		}
		if (Main.myPlayer == whoAmI)
		{
			ApplyMusicBox(currentItem);
		}
		UpdateBootVisualEffects(currentItem);
		UpdateFishingBobber(currentItem);
		ItemLoader.UpdateVanity(currentItem, this);
	}

	private void DoEyebrellaRainEffect()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		if (Main.netMode == 2 || Main.dedServ || Main.rand.Next(4) != 0)
		{
			return;
		}
		Vector2 vector = MountedCenter - new Vector2(0f, (float)height * 0.5f) + new Vector2((-0.5f + Main.rand.NextFloat()) * (float)(width + 18), -30f);
		int num = (int)(vector.X / 16f);
		int num2 = (int)(vector.Y / 16f);
		if (WorldGen.InWorld(num, num2))
		{
			Tile tile = Main.tile[num, num2];
			if (tile != null && !WorldGen.SolidTile3(tile) && tile.liquid <= 0)
			{
				Vector2 val = default(Vector2);
				((Vector2)(ref val))._002Ector(Main.windSpeedCurrent * 3f, 9f);
				Rain.NewRainForced(vector, val);
			}
		}
	}

	public WingStats GetWingStats(int wingID)
	{
		if (wingID <= 0 || wingID >= ArmorIDs.Wing.Sets.Stats.Length)
		{
			return default(WingStats);
		}
		return ArmorIDs.Wing.Sets.Stats[wingID];
	}

	public void ApplyEquipFunctional(Item currentItem, bool hideVisual)
	{
		//IL_04a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0503: Unknown result type (might be due to invalid IL or missing references)
		//IL_0509: Unknown result type (might be due to invalid IL or missing references)
		//IL_149e: Unknown result type (might be due to invalid IL or missing references)
		//IL_14ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_1530: Unknown result type (might be due to invalid IL or missing references)
		//IL_153f: Unknown result type (might be due to invalid IL or missing references)
		//IL_14d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_14e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_15d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_15df: Unknown result type (might be due to invalid IL or missing references)
		//IL_156a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1579: Unknown result type (might be due to invalid IL or missing references)
		//IL_160a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1619: Unknown result type (might be due to invalid IL or missing references)
		//IL_20a6: Unknown result type (might be due to invalid IL or missing references)
		int itemSlot = 0;
		bool[] hideVisibleAccessory = new bool[1] { hideVisual };
		if ((currentItem.expertOnly && !Main.expertMode) || (currentItem.masterOnly && !Main.masterMode))
		{
			return;
		}
		if (currentItem.type == 3810 || currentItem.type == 3809 || currentItem.type == 3812 || currentItem.type == 3811)
		{
			dd2Accessory = true;
		}
		if (!hideVisibleAccessory[itemSlot])
		{
			UpdateBootVisualEffects(currentItem);
			UpdateFishingBobber(currentItem);
		}
		switch (currentItem.type)
		{
		case 4056:
			chiselSpeed = true;
			break;
		case 3990:
			accRunSpeed = 6f;
			autoJump = true;
			jumpSpeedBoost += 1.6f;
			extraFall += 10;
			break;
		case 3991:
			manaFlower = true;
			manaCost -= 0.08f;
			aggro -= 400;
			break;
		case 3992:
			kbGlove = true;
			autoReuseGlove = true;
			meleeScaleGlove = true;
			meleeSpeed += 0.12f;
			aggro += 400;
			break;
		case 3993:
			accRunSpeed = 6f;
			rocketBoots = (vanityRocketBoots = 2);
			break;
		case 4055:
			accRunSpeed = 6f;
			desertBoots = true;
			break;
		case 3994:
			autoJump = true;
			jumpSpeedBoost += 1.6f;
			extraFall += 10;
			accFlipper = true;
			break;
		case 3995:
			autoJump = true;
			jumpSpeedBoost += 1.6f;
			extraFall += 10;
			accFlipper = true;
			spikedBoots += 2;
			break;
		case 3996:
			autoJump = true;
			jumpSpeedBoost += 1.6f;
			extraFall += 10;
			spikedBoots += 2;
			break;
		case 3998:
			aggro += 400;
			break;
		case 4038:
			fireWalk = true;
			break;
		case 4003:
			fireWalk = true;
			lavaRose = true;
			break;
		case 4000:
			manaFlower = true;
			manaCost -= 0.08f;
			manaMagnet = true;
			break;
		case 4001:
			manaFlower = true;
			manaCost -= 0.08f;
			starCloakItem = currentItem;
			starCloakItem_manaCloakOverrideItem = currentItem;
			break;
		case 4002:
			magicQuiver = true;
			arrowDamageAdditiveStack += 0.1f;
			hasMoltenQuiver = true;
			break;
		case 4004:
			fireWalk = true;
			lavaRose = true;
			break;
		case 3999:
			fireWalk = true;
			break;
		case 4005:
			rangedCrit += 10f;
			rangedDamage += 0.1f;
			aggro -= 400;
			break;
		case 4006:
			aggro -= 400;
			magicQuiver = true;
			arrowDamageAdditiveStack += 0.1f;
			break;
		case 4007:
			honeyCombItem = currentItem;
			armorPenetration += 5f;
			break;
		case 4341:
		case 5126:
			portableStoolInfo.SetStats(26, 26, 26);
			break;
		case 4409:
			CanSeeInvisibleBlocks = true;
			break;
		case 5010:
			treasureMagnet = true;
			break;
		case 3245:
			boneGloveItem = currentItem;
			break;
		case 5107:
			hasMagiluminescence = true;
			MountedCenter.ToTileCoordinates();
			DelegateMethods.v3_1 = new Vector3(0.9f, 0.8f, 0.5f);
			Utils.PlotTileLine(base.Center, base.Center + velocity * 6f, 20f, DelegateMethods.CastLightOpen);
			Utils.PlotTileLine(base.Left, base.Right, 20f, DelegateMethods.CastLightOpen);
			break;
		}
		if (currentItem.type == 3015)
		{
			aggro -= 400;
			allDamage += 0.05f;
			allCrit += 5f;
		}
		if (currentItem.type == 3016)
		{
			aggro += 400;
		}
		if (currentItem.type == 2373)
		{
			accFishingLine = true;
		}
		if (currentItem.type == 2374)
		{
			fishingSkill += 10;
		}
		if (currentItem.type == 5139 || currentItem.type == 5144 || currentItem.type == 5142 || currentItem.type == 5141 || currentItem.type == 5146 || currentItem.type == 5140 || currentItem.type == 5145 || currentItem.type == 5143)
		{
			accFishingBobber = true;
		}
		if (currentItem.type == 2375)
		{
			accTackleBox = true;
		}
		if (currentItem.type == 4881)
		{
			accLavaFishing = true;
		}
		if (currentItem.type == 3721)
		{
			accFishingLine = true;
			accTackleBox = true;
			fishingSkill += 10;
		}
		if (currentItem.type == 5064)
		{
			accFishingLine = true;
			accTackleBox = true;
			fishingSkill += 10;
			accLavaFishing = true;
		}
		if (currentItem.type == 3090)
		{
			npcTypeNoAggro[1] = true;
			npcTypeNoAggro[16] = true;
			npcTypeNoAggro[59] = true;
			npcTypeNoAggro[71] = true;
			npcTypeNoAggro[81] = true;
			npcTypeNoAggro[138] = true;
			npcTypeNoAggro[121] = true;
			npcTypeNoAggro[122] = true;
			npcTypeNoAggro[141] = true;
			npcTypeNoAggro[147] = true;
			npcTypeNoAggro[183] = true;
			npcTypeNoAggro[184] = true;
			npcTypeNoAggro[204] = true;
			npcTypeNoAggro[225] = true;
			npcTypeNoAggro[244] = true;
			npcTypeNoAggro[302] = true;
			npcTypeNoAggro[333] = true;
			npcTypeNoAggro[335] = true;
			npcTypeNoAggro[334] = true;
			npcTypeNoAggro[336] = true;
			npcTypeNoAggro[537] = true;
			npcTypeNoAggro[676] = true;
			npcTypeNoAggro[667] = true;
		}
		if (currentItem.stringColor > 0)
		{
			yoyoString = true;
		}
		if (currentItem.type == 3366)
		{
			counterWeight = 556 + Main.rand.Next(6);
			yoyoGlove = true;
			yoyoString = true;
		}
		if (currentItem.type >= 3309 && currentItem.type <= 3314)
		{
			counterWeight = 556 + currentItem.type - 3309;
		}
		if (currentItem.type == 3334)
		{
			yoyoGlove = true;
		}
		if (currentItem.type == 3337)
		{
			shinyStone = true;
		}
		if (currentItem.type == 4989)
		{
			empressBrooch = true;
			moveSpeed += 0.075f;
		}
		if (currentItem.type == 3336)
		{
			SporeSac(currentItem);
			sporeSac = true;
		}
		if (currentItem.type == 4987)
		{
			VolatileGelatin(currentItem);
			volatileGelatin = true;
		}
		switch (currentItem.type)
		{
		case 3538:
			stardustMonolithShader = true;
			break;
		case 3537:
			nebulaMonolithShader = true;
			break;
		case 3536:
			vortexMonolithShader = true;
			break;
		case 3539:
			solarMonolithShader = true;
			break;
		case 4318:
			moonLordMonolithShader = true;
			break;
		case 4054:
			bloodMoonMonolithShader = true;
			break;
		case 5345:
			CanSeeInvisibleBlocks = true;
			break;
		case 5347:
			shimmerMonolithShader = true;
			break;
		}
		if (currentItem.type == 5113)
		{
			dontStarveShader = !dontStarveShader;
		}
		if (currentItem.type == 2423)
		{
			autoJump = true;
			jumpSpeedBoost += 1.6f;
			extraFall += 10;
		}
		if (currentItem.type == 857)
		{
			hasJumpOption_Sandstorm = true;
		}
		if (currentItem.type == 983)
		{
			hasJumpOption_Sandstorm = true;
			jumpBoost = true;
		}
		if (currentItem.type == 987)
		{
			hasJumpOption_Blizzard = true;
		}
		if (currentItem.type == 1163)
		{
			hasJumpOption_Blizzard = true;
			jumpBoost = true;
		}
		if (currentItem.type == 1724)
		{
			hasJumpOption_Fart = true;
		}
		if (currentItem.type == 1863)
		{
			hasJumpOption_Fart = true;
			jumpBoost = true;
		}
		if (currentItem.type == 1164)
		{
			hasJumpOption_Cloud = true;
			hasJumpOption_Sandstorm = true;
			hasJumpOption_Blizzard = true;
			jumpBoost = true;
		}
		if (currentItem.type == 5331)
		{
			hasJumpOption_Cloud = true;
			hasJumpOption_Sandstorm = true;
			hasJumpOption_Blizzard = true;
			jumpBoost = true;
			noFallDmg = true;
			hasLuck_LuckyHorseshoe = true;
		}
		if (currentItem.type == 1250)
		{
			jumpBoost = true;
			hasJumpOption_Cloud = true;
			noFallDmg = true;
			hasLuck_LuckyHorseshoe = true;
		}
		if (currentItem.type == 1252)
		{
			hasJumpOption_Sandstorm = true;
			jumpBoost = true;
			noFallDmg = true;
			hasLuck_LuckyHorseshoe = true;
		}
		if (currentItem.type == 1251)
		{
			hasJumpOption_Blizzard = true;
			jumpBoost = true;
			noFallDmg = true;
			hasLuck_LuckyHorseshoe = true;
		}
		if (currentItem.type == 3250)
		{
			hasJumpOption_Fart = true;
			jumpBoost = true;
			noFallDmg = true;
			hasLuck_LuckyHorseshoe = true;
		}
		if (currentItem.type == 3252)
		{
			hasJumpOption_Sail = true;
			jumpBoost = true;
			noFallDmg = true;
			hasLuck_LuckyHorseshoe = true;
		}
		if (currentItem.type == 3251)
		{
			jumpBoost = true;
			honeyCombItem = currentItem;
			noFallDmg = true;
			hasLuck_LuckyHorseshoe = true;
		}
		if (currentItem.type == 1249)
		{
			jumpBoost = true;
			honeyCombItem = currentItem;
		}
		if (currentItem.type == 3241)
		{
			jumpBoost = true;
			hasJumpOption_Sail = true;
		}
		if ((currentItem.type == 1253 || currentItem.type == 3997) && (double)statLife <= (double)statLifeMax2 * 0.5)
		{
			AddBuff(62, 5);
		}
		if (currentItem.type == 1290)
		{
			panic = true;
		}
		if ((currentItem.type == 1300 || currentItem.type == 1858 || currentItem.type == 4005) && (inventory[selectedItem].useAmmo == AmmoID.Bullet || inventory[selectedItem].useAmmo == AmmoID.CandyCorn || inventory[selectedItem].useAmmo == AmmoID.Stake || inventory[selectedItem].useAmmo == 23 || inventory[selectedItem].useAmmo == AmmoID.Solution))
		{
			scope = true;
		}
		if (currentItem.type == 1858)
		{
			rangedCrit += 10f;
			rangedDamage += 0.1f;
		}
		if (currentItem.type == 1301)
		{
			allDamage += 0.1f;
			allCrit += 8f;
		}
		if (currentItem.type == 111)
		{
			statManaMax2 += 20;
		}
		if (currentItem.type == 982)
		{
			statManaMax2 += 20;
			manaRegenDelayBonus += 1f;
			manaRegenBonus += 25;
		}
		if (currentItem.type == 1595)
		{
			statManaMax2 += 20;
			magicCuffs = true;
		}
		if (currentItem.type == 2219)
		{
			manaMagnet = true;
		}
		if (currentItem.type == 2220)
		{
			manaMagnet = true;
			magicDamage += 0.15f;
		}
		if (currentItem.type == 2221)
		{
			manaMagnet = true;
			statManaMax2 += 20;
			magicCuffs = true;
		}
		if (whoAmI == Main.myPlayer && currentItem.type == 1923)
		{
			tileRangeX++;
			tileRangeY++;
		}
		if (currentItem.type == 1247)
		{
			starCloakItem = currentItem;
			honeyCombItem = currentItem;
			starCloakItem_beeCloakOverrideItem = currentItem;
		}
		if (currentItem.type == 1248)
		{
			allCrit += 10f;
		}
		if (currentItem.type == 854)
		{
			discountEquipped = true;
		}
		if (currentItem.type == 855)
		{
			hasLuckyCoin = true;
			hasLuck_LuckyCoin = true;
		}
		if (currentItem.type == 3033)
		{
			goldRing = true;
		}
		if (currentItem.type == 3034)
		{
			goldRing = true;
			hasLuckyCoin = true;
			hasLuck_LuckyCoin = true;
		}
		if (currentItem.type == 3035)
		{
			goldRing = true;
			hasLuckyCoin = true;
			hasLuck_LuckyCoin = true;
			discountEquipped = true;
		}
		if (currentItem.type == 53)
		{
			hasJumpOption_Cloud = true;
		}
		if (currentItem.type == 3201)
		{
			hasJumpOption_Sail = true;
		}
		if (currentItem.type == 54)
		{
			accRunSpeed = 6f;
		}
		if (currentItem.type == 3068)
		{
			cordage = true;
		}
		if (currentItem.type == 1579)
		{
			accRunSpeed = 6f;
		}
		if (currentItem.type == 3200)
		{
			accRunSpeed = 6f;
		}
		if (currentItem.type == 128)
		{
			rocketBoots = (vanityRocketBoots = 1);
		}
		if (currentItem.type == 156)
		{
			noKnockback = true;
		}
		if (currentItem.type == 158)
		{
			noFallDmg = true;
			hasLuck_LuckyHorseshoe = true;
		}
		if (currentItem.type == 934)
		{
			carpet = true;
		}
		if (currentItem.type == 953)
		{
			spikedBoots++;
		}
		if (currentItem.type == 975)
		{
			spikedBoots++;
		}
		if (currentItem.type == 976)
		{
			spikedBoots += 2;
		}
		if (currentItem.type == 977)
		{
			dashType = 1;
		}
		if (currentItem.type == 3097)
		{
			dashType = 2;
		}
		if (currentItem.type == 963)
		{
			blackBelt = true;
		}
		if (currentItem.type == 984)
		{
			blackBelt = true;
			dashType = 1;
			spikedBoots = 2;
		}
		if (currentItem.type == 1131)
		{
			gravControl2 = true;
		}
		if (currentItem.type == 1132)
		{
			honeyCombItem = currentItem;
		}
		if (currentItem.type == 1578)
		{
			honeyCombItem = currentItem;
			panic = true;
		}
		if (currentItem.type == 3224)
		{
			endurance += 0.17f;
		}
		if (currentItem.type == 3223)
		{
			brainOfConfusionItem = currentItem;
		}
		if (currentItem.type == 950)
		{
			iceSkate = true;
		}
		if (currentItem.type == 159)
		{
			jumpBoost = true;
		}
		if (currentItem.type == 3225)
		{
			jumpBoost = true;
		}
		if (currentItem.type == 187)
		{
			accFlipper = true;
		}
		if (currentItem.type == 211)
		{
			autoReuseGlove = true;
			meleeSpeed += 0.12f;
		}
		if (currentItem.type == 223)
		{
			manaCost -= 0.06f;
		}
		if (currentItem.type == 285)
		{
			moveSpeed += 0.05f;
		}
		if (currentItem.type == 212)
		{
			moveSpeed += 0.1f;
		}
		if (currentItem.type == 267)
		{
			killGuide = true;
		}
		if (currentItem.type == 1307)
		{
			killClothier = true;
		}
		if (currentItem.type == 193)
		{
			fireWalk = true;
		}
		if (currentItem.type == 861)
		{
			accMerman = true;
			wolfAcc = true;
			if (hideVisibleAccessory[itemSlot])
			{
				hideMerman = true;
				hideWolf = true;
			}
		}
		if (currentItem.type == 862)
		{
			starCloakItem = currentItem;
			longInvince = true;
			starCloakItem_starVeilOverrideItem = currentItem;
		}
		if (currentItem.type == 860)
		{
			pStone = true;
		}
		if (currentItem.type == 863)
		{
			waterWalk2 = true;
		}
		if (currentItem.type == 907)
		{
			waterWalk2 = true;
			fireWalk = true;
		}
		if (currentItem.type == 5044)
		{
			hasCreditsSceneMusicBox = true;
		}
		if (currentItem.type == 908 || currentItem.type == 5000)
		{
			waterWalk = true;
			fireWalk = true;
			lavaMax += 420;
			lavaRose = true;
		}
		if ((!mount.Active || mount.Type != 47) && !hideVisibleAccessory[itemSlot] && (currentItem.type == 4822 || currentItem.type == 4874))
		{
			DoBootsEffect(DoBootsEffect_PlaceFlamesOnTile);
		}
		if (currentItem.type == 906 || currentItem.type == 4038 || currentItem.type == 3999 || currentItem.type == 4003)
		{
			lavaMax += 420;
		}
		if (currentItem.type == 485)
		{
			wolfAcc = true;
			if (hideVisibleAccessory[itemSlot])
			{
				hideWolf = true;
			}
		}
		if (currentItem.type == 486)
		{
			rulerLine = true;
		}
		if (currentItem.type == 2799)
		{
			rulerGrid = true;
		}
		if (currentItem.type == 394)
		{
			accFlipper = true;
			accDivingHelm = true;
		}
		if (currentItem.type == 396)
		{
			noFallDmg = true;
			fireWalk = true;
			hasLuck_LuckyHorseshoe = true;
		}
		if (currentItem.type == 397)
		{
			noKnockback = true;
			fireWalk = true;
		}
		if (currentItem.type == 399)
		{
			jumpBoost = true;
			hasJumpOption_Cloud = true;
		}
		if (currentItem.type == 405)
		{
			accRunSpeed = 6f;
			rocketBoots = (vanityRocketBoots = 2);
		}
		if (currentItem.type == 1303)
		{
			if (!wet)
			{
				Lighting.AddLight((int)base.Center.X / 16, (int)base.Center.Y / 16, 0.225f, 0.05f, 0.15f);
			}
			if (wet)
			{
				Lighting.AddLight((int)base.Center.X / 16, (int)base.Center.Y / 16, 1.8f, 0.4f, 1.2f);
			}
		}
		if (currentItem.type == 1860)
		{
			accFlipper = true;
			accDivingHelm = true;
			if (!wet)
			{
				Lighting.AddLight((int)base.Center.X / 16, (int)base.Center.Y / 16, 0.225f, 0.05f, 0.15f);
			}
			if (wet)
			{
				Lighting.AddLight((int)base.Center.X / 16, (int)base.Center.Y / 16, 1.8f, 0.4f, 1.2f);
			}
		}
		if (currentItem.type == 1861)
		{
			arcticDivingGear = true;
			accFlipper = true;
			accDivingHelm = true;
			iceSkate = true;
			if (!wet)
			{
				Lighting.AddLight((int)base.Center.X / 16, (int)base.Center.Y / 16, 0.05f, 0.15f, 0.225f);
			}
			if (wet)
			{
				Lighting.AddLight((int)base.Center.X / 16, (int)base.Center.Y / 16, 0.4f, 1.2f, 1.8f);
			}
		}
		if (currentItem.type == 2214)
		{
			equippedAnyTileSpeedAcc = true;
		}
		if (currentItem.type == 2215)
		{
			equippedAnyTileRangeAcc = true;
		}
		if (currentItem.type == 2216)
		{
			autoPaint = true;
		}
		if (currentItem.type == 2217)
		{
			equippedAnyWallSpeedAcc = true;
		}
		if (currentItem.type == 3061)
		{
			equippedAnyWallSpeedAcc = true;
			equippedAnyTileSpeedAcc = true;
			autoPaint = true;
			equippedAnyTileRangeAcc = true;
		}
		if (currentItem.type == 5126)
		{
			equippedAnyWallSpeedAcc = true;
			equippedAnyTileSpeedAcc = true;
			autoPaint = true;
			equippedAnyTileRangeAcc = true;
			treasureMagnet = true;
			chiselSpeed = true;
		}
		if (currentItem.type == 3624)
		{
			autoActuator = true;
		}
		if (currentItem.type == 897)
		{
			kbGlove = true;
			autoReuseGlove = true;
			meleeScaleGlove = true;
			meleeSpeed += 0.12f;
		}
		if (currentItem.type == 1343)
		{
			kbGlove = true;
			autoReuseGlove = true;
			meleeScaleGlove = true;
			meleeSpeed += 0.12f;
			meleeDamage += 0.12f;
			magmaStone = true;
		}
		if (currentItem.type == 1167)
		{
			minionKB += 2f;
			minionDamage += 0.15f;
		}
		if (currentItem.type == 1864)
		{
			minionKB += 2f;
			minionDamage += 0.15f;
			maxMinions++;
		}
		if (currentItem.type == 1845)
		{
			minionDamage += 0.1f;
			maxMinions++;
		}
		if (currentItem.type == 1321)
		{
			magicQuiver = true;
			arrowDamageAdditiveStack += 0.1f;
		}
		if (currentItem.type == 1322)
		{
			magmaStone = true;
		}
		if (currentItem.type == 1323)
		{
			lavaRose = true;
		}
		if (currentItem.type == 3333)
		{
			strongBees = true;
		}
		if (currentItem.type == 938 || currentItem.type == 3997 || currentItem.type == 3998)
		{
			noKnockback = true;
			if ((float)statLife > (float)statLifeMax2 * 0.25f)
			{
				hasPaladinShield = true;
				if (whoAmI != Main.myPlayer && miscCounter % 10 == 0)
				{
					int myPlayer = Main.myPlayer;
					if (Main.player[myPlayer].team == team && team != 0)
					{
						float num4 = position.X - Main.player[myPlayer].position.X;
						float num2 = position.Y - Main.player[myPlayer].position.Y;
						if ((float)Math.Sqrt(num4 * num4 + num2 * num2) < 800f)
						{
							Main.player[myPlayer].AddBuff(43, 20);
						}
					}
				}
			}
		}
		if (currentItem.type == 936)
		{
			kbGlove = true;
			autoReuseGlove = true;
			meleeScaleGlove = true;
			meleeSpeed += 0.12f;
			meleeDamage += 0.12f;
		}
		if (currentItem.type == 898)
		{
			accRunSpeed = 6.75f;
			rocketBoots = (vanityRocketBoots = 2);
			moveSpeed += 0.08f;
		}
		if (currentItem.type == 1862)
		{
			accRunSpeed = 6.75f;
			rocketBoots = (vanityRocketBoots = 3);
			moveSpeed += 0.08f;
			iceSkate = true;
		}
		if (currentItem.type == 5000)
		{
			accRunSpeed = 6.75f;
			rocketBoots = (vanityRocketBoots = 4);
			moveSpeed += 0.08f;
			iceSkate = true;
		}
		if (currentItem.type == 4874)
		{
			accRunSpeed = 6f;
			rocketBoots = (vanityRocketBoots = 5);
		}
		if (currentItem.type == 3110)
		{
			accMerman = true;
			wolfAcc = true;
			if (hideVisibleAccessory[itemSlot])
			{
				hideMerman = true;
				hideWolf = true;
			}
		}
		if (currentItem.type == 1865 || currentItem.type == 3110)
		{
			skyStoneEffects = true;
		}
		if (currentItem.type == 899 && Main.dayTime)
		{
			skyStoneEffects = true;
		}
		if (currentItem.type == 900 && (!Main.dayTime || Main.eclipse))
		{
			skyStoneEffects = true;
		}
		if (currentItem.type == 407)
		{
			blockRange++;
		}
		if (currentItem.type == 489)
		{
			magicDamage += 0.15f;
		}
		if (currentItem.type == 490)
		{
			meleeDamage += 0.15f;
		}
		if (currentItem.type == 491)
		{
			rangedDamage += 0.15f;
		}
		if (currentItem.type == 2998)
		{
			minionDamage += 0.15f;
		}
		if (currentItem.type == 935)
		{
			allDamage += 0.12f;
		}
		if (currentItem.wingSlot != -1)
		{
			wingTimeMax = GetWingStats(currentItem.wingSlot).FlyTime;
		}
		if (currentItem.wingSlot == 26)
		{
			ignoreWater = true;
		}
		if (currentItem.type == 5452)
		{
			remoteVisionForDrone = true;
		}
		if (currentItem.type == 885)
		{
			buffImmune[30] = true;
		}
		if (currentItem.type == 886)
		{
			buffImmune[36] = true;
		}
		if (currentItem.type == 887)
		{
			buffImmune[20] = true;
		}
		if (currentItem.type == 888)
		{
			buffImmune[22] = true;
		}
		if (currentItem.type == 889)
		{
			buffImmune[32] = true;
		}
		if (currentItem.type == 890)
		{
			buffImmune[35] = true;
		}
		if (currentItem.type == 891)
		{
			buffImmune[23] = true;
		}
		if (currentItem.type == 892)
		{
			buffImmune[33] = true;
		}
		if (currentItem.type == 893)
		{
			buffImmune[31] = true;
		}
		if (currentItem.type == 3781)
		{
			buffImmune[156] = true;
		}
		if (currentItem.type == 901)
		{
			buffImmune[33] = true;
			buffImmune[36] = true;
		}
		if (currentItem.type == 902)
		{
			buffImmune[30] = true;
			buffImmune[20] = true;
		}
		if (currentItem.type == 903)
		{
			buffImmune[32] = true;
			buffImmune[31] = true;
		}
		if (currentItem.type == 904)
		{
			buffImmune[35] = true;
			buffImmune[23] = true;
		}
		if (currentItem.type == 5354)
		{
			buffImmune[22] = true;
			buffImmune[156] = true;
		}
		if (currentItem.type == 5355 && !controlDownHold)
		{
			shimmerImmune = true;
		}
		if (currentItem.type == 1921)
		{
			buffImmune[46] = true;
			buffImmune[47] = true;
		}
		if (currentItem.type == 1612)
		{
			buffImmune[33] = true;
			buffImmune[36] = true;
			buffImmune[30] = true;
			buffImmune[20] = true;
			buffImmune[32] = true;
			buffImmune[31] = true;
			buffImmune[35] = true;
			buffImmune[23] = true;
			buffImmune[22] = true;
			buffImmune[156] = true;
		}
		if (currentItem.type == 1613)
		{
			buffImmune[46] = true;
			noKnockback = true;
			fireWalk = true;
			buffImmune[33] = true;
			buffImmune[36] = true;
			buffImmune[30] = true;
			buffImmune[20] = true;
			buffImmune[32] = true;
			buffImmune[31] = true;
			buffImmune[35] = true;
			buffImmune[23] = true;
			buffImmune[22] = true;
			buffImmune[156] = true;
		}
		if (currentItem.type == 497)
		{
			accMerman = true;
			if (hideVisibleAccessory[itemSlot])
			{
				hideMerman = true;
			}
		}
		if (currentItem.type == 535)
		{
			pStone = true;
		}
		if (currentItem.type == 536)
		{
			kbGlove = true;
			meleeScaleGlove = true;
		}
		if (currentItem.type == 532)
		{
			starCloakItem = currentItem;
		}
		if (currentItem.type == 554)
		{
			longInvince = true;
		}
		if (currentItem.type == 555)
		{
			manaFlower = true;
			manaCost -= 0.08f;
		}
		if (currentItem.wingSlot > 0)
		{
			if (!hideVisibleAccessory[itemSlot] || (velocity.Y != 0f && !mount.Active))
			{
				wings = currentItem.wingSlot;
			}
			wingsLogic = currentItem.wingSlot;
			equippedWings = currentItem;
		}
		ItemLoader.UpdateAccessory(currentItem, this, hideVisual);
		if (Main.myPlayer != whoAmI)
		{
			return;
		}
		if (currentItem.type == 5104 || currentItem.type == 5105)
		{
			ApplyWilsonBeard(currentItem);
		}
		else if (currentItem.type == 576 && Main.rand.Next(540) == 0 && Main.curMusic > 0)
		{
			SoundEngine.PlaySound(in SoundID.Item166, base.Center);
			int num3 = -1;
			if (Main.curMusic == 1)
			{
				num3 = 0;
			}
			if (Main.curMusic == 2)
			{
				num3 = 1;
			}
			if (Main.curMusic == 3)
			{
				num3 = 2;
			}
			if (Main.curMusic == 4)
			{
				num3 = 4;
			}
			if (Main.curMusic == 5)
			{
				num3 = 5;
			}
			if (Main.curMusic == 6)
			{
				num3 = 3;
			}
			if (Main.curMusic == 7)
			{
				num3 = 6;
			}
			if (Main.curMusic == 8)
			{
				num3 = 7;
			}
			if (Main.curMusic == 9)
			{
				num3 = 9;
			}
			if (Main.curMusic == 10)
			{
				num3 = 8;
			}
			if (Main.curMusic == 11)
			{
				num3 = 11;
			}
			if (Main.curMusic == 12)
			{
				num3 = 10;
			}
			if (Main.curMusic == 13)
			{
				num3 = 12;
			}
			int modMusicBoxType;
			if (Main.curMusic == 28)
			{
				currentItem.SetDefaults(1963);
			}
			else if (Main.curMusic == 29)
			{
				currentItem.SetDefaults(1610);
			}
			else if (Main.curMusic == 30)
			{
				currentItem.SetDefaults(1963);
			}
			else if (Main.curMusic == 31)
			{
				currentItem.SetDefaults(1964);
			}
			else if (Main.curMusic == 32)
			{
				currentItem.SetDefaults(1965);
			}
			else if (Main.curMusic == 33)
			{
				currentItem.SetDefaults(2742);
			}
			else if (Main.curMusic == 34)
			{
				currentItem.SetDefaults(3370);
			}
			else if (Main.curMusic == 35)
			{
				currentItem.SetDefaults(3236);
			}
			else if (Main.curMusic == 36)
			{
				currentItem.SetDefaults(3237);
			}
			else if (Main.curMusic == 37)
			{
				currentItem.SetDefaults(3235);
			}
			else if (Main.curMusic == 38)
			{
				currentItem.SetDefaults(3044);
			}
			else if (Main.curMusic == 39)
			{
				currentItem.SetDefaults(3371);
			}
			else if (Main.curMusic == 40)
			{
				currentItem.SetDefaults(3796);
			}
			else if (Main.curMusic == 41)
			{
				currentItem.SetDefaults(3869);
			}
			else if (Main.curMusic == 42)
			{
				currentItem.SetDefaults(4079);
			}
			else if (Main.curMusic == 43)
			{
				currentItem.SetDefaults(4077);
			}
			else if (Main.curMusic == 44)
			{
				currentItem.SetDefaults(4082);
			}
			else if (Main.curMusic == 46)
			{
				currentItem.SetDefaults(4080);
			}
			else if (Main.curMusic == 47)
			{
				currentItem.SetDefaults(4081);
			}
			else if (Main.curMusic == 48)
			{
				currentItem.SetDefaults(4078);
			}
			else if (Main.curMusic == 49)
			{
				currentItem.SetDefaults(4237);
			}
			else if (Main.curMusic == 51)
			{
				currentItem.SetDefaults(4356);
			}
			else if (Main.curMusic == 52)
			{
				currentItem.SetDefaults(4357);
			}
			else if (Main.curMusic == 53)
			{
				currentItem.SetDefaults(4358);
			}
			else if (Main.curMusic == 54)
			{
				currentItem.SetDefaults(4421);
			}
			else if (Main.curMusic == 55)
			{
				currentItem.SetDefaults(4606);
			}
			else if (Main.curMusic == 56)
			{
				currentItem.SetDefaults(4979);
			}
			else if (Main.curMusic == 57)
			{
				currentItem.SetDefaults(4985);
			}
			else if (Main.curMusic == 58)
			{
				currentItem.SetDefaults(4990);
			}
			else if (Main.curMusic == 59)
			{
				currentItem.SetDefaults(4991);
			}
			else if (Main.curMusic == 60)
			{
				currentItem.SetDefaults(4992);
			}
			else if (Main.curMusic == 61)
			{
				currentItem.SetDefaults(5006);
			}
			else if (Main.curMusic == 62)
			{
				currentItem.SetDefaults(5014);
			}
			else if (Main.curMusic == 63)
			{
				currentItem.SetDefaults(5015);
			}
			else if (Main.curMusic == 64)
			{
				currentItem.SetDefaults(5016);
			}
			else if (Main.curMusic == 65)
			{
				currentItem.SetDefaults(5017);
			}
			else if (Main.curMusic == 66)
			{
				currentItem.SetDefaults(5018);
			}
			else if (Main.curMusic == 67)
			{
				currentItem.SetDefaults(5019);
			}
			else if (Main.curMusic == 68)
			{
				currentItem.SetDefaults(5020);
			}
			else if (Main.curMusic == 69)
			{
				currentItem.SetDefaults(5021);
			}
			else if (Main.curMusic == 70)
			{
				currentItem.SetDefaults(5022);
			}
			else if (Main.curMusic == 71)
			{
				currentItem.SetDefaults(5023);
			}
			else if (Main.curMusic == 72)
			{
				currentItem.SetDefaults(5024);
			}
			else if (Main.curMusic == 73)
			{
				currentItem.SetDefaults(5025);
			}
			else if (Main.curMusic == 74)
			{
				currentItem.SetDefaults(5026);
			}
			else if (Main.curMusic == 75)
			{
				currentItem.SetDefaults(5027);
			}
			else if (Main.curMusic == 76)
			{
				currentItem.SetDefaults(5028);
			}
			else if (Main.curMusic == 77)
			{
				currentItem.SetDefaults(5029);
			}
			else if (Main.curMusic == 78)
			{
				currentItem.SetDefaults(5030);
			}
			else if (Main.curMusic == 79)
			{
				currentItem.SetDefaults(5031);
			}
			else if (Main.curMusic == 80)
			{
				currentItem.SetDefaults(5032);
			}
			else if (Main.curMusic == 81)
			{
				currentItem.SetDefaults(5033);
			}
			else if (Main.curMusic == 82)
			{
				currentItem.SetDefaults(5034);
			}
			else if (Main.curMusic == 83)
			{
				currentItem.SetDefaults(5035);
			}
			else if (Main.curMusic == 84)
			{
				currentItem.SetDefaults(5036);
			}
			else if (Main.curMusic == 85)
			{
				currentItem.SetDefaults(5037);
			}
			else if (Main.curMusic == 86)
			{
				currentItem.SetDefaults(5038);
			}
			else if (Main.curMusic == 87)
			{
				currentItem.SetDefaults(5039);
			}
			else if (Main.curMusic == 88)
			{
				currentItem.SetDefaults(5040);
			}
			else if (Main.curMusic == 89)
			{
				currentItem.SetDefaults(5044);
			}
			else if (Main.curMusic == 90)
			{
				currentItem.SetDefaults(5112);
			}
			else if (Main.curMusic == 91)
			{
				currentItem.SetDefaults(5362);
			}
			else if (Main.curMusic > 13 && Main.curMusic < Main.maxMusic)
			{
				currentItem.SetDefaults(1596 + Main.curMusic - 14);
			}
			else if (num3 != -1 && Main.curMusic < Main.maxMusic)
			{
				currentItem.SetDefaults(num3 + 562);
			}
			else if (MusicLoader.musicToItem.TryGetValue(Main.curMusic, out modMusicBoxType))
			{
				currentItem.SetDefaults(modMusicBoxType);
			}
		}
		ApplyMusicBox(currentItem);
	}

	private void ApplyWilsonBeard(Item currentItem)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		beardGrowthTimer++;
		if (beardGrowthTimer >= 43200 && Main.rand.Next(540) == 0)
		{
			beardGrowthTimer = 0;
			short defaults = 5105;
			if (currentItem.type == 5105)
			{
				defaults = 5106;
			}
			SoundEngine.PlaySound(in SoundID.Item60, base.Center);
			currentItem.SetDefaults(defaults);
		}
	}

	private void ApplyMusicBox(Item currentItem)
	{
		if (currentItem.type >= 562 && currentItem.type <= 574)
		{
			Main.musicBox2 = currentItem.type - 562;
		}
		if (currentItem.type >= 1596 && currentItem.type <= 1609)
		{
			Main.musicBox2 = currentItem.type - 1596 + 13;
		}
		if (currentItem.type == 1610)
		{
			Main.musicBox2 = 27;
		}
		if (currentItem.type == 1963)
		{
			Main.musicBox2 = 28;
		}
		if (currentItem.type == 1964)
		{
			Main.musicBox2 = 29;
		}
		if (currentItem.type == 1965)
		{
			Main.musicBox2 = 30;
		}
		if (currentItem.type == 2742)
		{
			Main.musicBox2 = 31;
		}
		if (currentItem.type == 3044)
		{
			Main.musicBox2 = 32;
		}
		if (currentItem.type == 3235)
		{
			Main.musicBox2 = 33;
		}
		if (currentItem.type == 3236)
		{
			Main.musicBox2 = 34;
		}
		if (currentItem.type == 3237)
		{
			Main.musicBox2 = 35;
		}
		if (currentItem.type == 3370)
		{
			Main.musicBox2 = 36;
		}
		if (currentItem.type == 3371)
		{
			Main.musicBox2 = 37;
		}
		if (currentItem.type == 3796)
		{
			Main.musicBox2 = 38;
		}
		if (currentItem.type == 3869)
		{
			Main.musicBox2 = 39;
		}
		if (currentItem.type == 4082)
		{
			Main.musicBox2 = 40;
		}
		if (currentItem.type == 4078)
		{
			Main.musicBox2 = 41;
		}
		if (currentItem.type == 4079)
		{
			Main.musicBox2 = 42;
		}
		if (currentItem.type == 4077)
		{
			Main.musicBox2 = 43;
		}
		if (currentItem.type == 4080)
		{
			Main.musicBox2 = 44;
		}
		if (currentItem.type == 4081)
		{
			Main.musicBox2 = 45;
		}
		if (currentItem.type == 4237)
		{
			Main.musicBox2 = 46;
		}
		if (currentItem.type == 4356)
		{
			Main.musicBox2 = 47;
		}
		if (currentItem.type == 4357)
		{
			Main.musicBox2 = 48;
		}
		if (currentItem.type == 4358)
		{
			Main.musicBox2 = 49;
		}
		if (currentItem.type == 4421)
		{
			Main.musicBox2 = 50;
		}
		if (currentItem.type == 4606)
		{
			Main.musicBox2 = 51;
		}
		if (currentItem.type == 4979)
		{
			Main.musicBox2 = 52;
		}
		if (currentItem.type == 4985)
		{
			Main.musicBox2 = 53;
		}
		if (currentItem.type == 4990)
		{
			Main.musicBox2 = 54;
		}
		if (currentItem.type == 4991)
		{
			Main.musicBox2 = 55;
		}
		if (currentItem.type == 4992)
		{
			Main.musicBox2 = 56;
		}
		if (currentItem.type == 5006)
		{
			Main.musicBox2 = 57;
		}
		if (currentItem.type == 5014)
		{
			Main.musicBox2 = 58;
		}
		if (currentItem.type == 5015)
		{
			Main.musicBox2 = 59;
		}
		if (currentItem.type == 5016)
		{
			Main.musicBox2 = 60;
		}
		if (currentItem.type == 5017)
		{
			Main.musicBox2 = 61;
		}
		if (currentItem.type == 5018)
		{
			Main.musicBox2 = 62;
		}
		if (currentItem.type == 5019)
		{
			Main.musicBox2 = 63;
		}
		if (currentItem.type == 5020)
		{
			Main.musicBox2 = 64;
		}
		if (currentItem.type == 5021)
		{
			Main.musicBox2 = 65;
		}
		if (currentItem.type == 5022)
		{
			Main.musicBox2 = 66;
		}
		if (currentItem.type == 5023)
		{
			Main.musicBox2 = 67;
		}
		if (currentItem.type == 5024)
		{
			Main.musicBox2 = 68;
		}
		if (currentItem.type == 5025)
		{
			Main.musicBox2 = 69;
		}
		if (currentItem.type == 5026)
		{
			Main.musicBox2 = 70;
		}
		if (currentItem.type == 5027)
		{
			Main.musicBox2 = 71;
		}
		if (currentItem.type == 5028)
		{
			Main.musicBox2 = 72;
		}
		if (currentItem.type == 5029)
		{
			Main.musicBox2 = 73;
		}
		if (currentItem.type == 5030)
		{
			Main.musicBox2 = 74;
		}
		if (currentItem.type == 5031)
		{
			Main.musicBox2 = 75;
		}
		if (currentItem.type == 5032)
		{
			Main.musicBox2 = 76;
		}
		if (currentItem.type == 5033)
		{
			Main.musicBox2 = 77;
		}
		if (currentItem.type == 5034)
		{
			Main.musicBox2 = 78;
		}
		if (currentItem.type == 5035)
		{
			Main.musicBox2 = 79;
		}
		if (currentItem.type == 5036)
		{
			Main.musicBox2 = 80;
		}
		if (currentItem.type == 5037)
		{
			Main.musicBox2 = 81;
		}
		if (currentItem.type == 5038)
		{
			Main.musicBox2 = 82;
		}
		if (currentItem.type == 5039)
		{
			Main.musicBox2 = 83;
		}
		if (currentItem.type == 5040)
		{
			Main.musicBox2 = 84;
		}
		if (currentItem.type == 5044)
		{
			Main.musicBox2 = 85;
		}
		if (currentItem.type == 5112)
		{
			Main.musicBox2 = 86;
		}
		if (currentItem.type == 5362)
		{
			Main.musicBox2 = 87;
		}
		if (MusicLoader.itemToMusic.TryGetValue(currentItem.type, out var modMusicBox))
		{
			Main.musicBox2 = modMusicBox;
		}
		Main.musicBoxNotModifiedByVolume = Main.musicBox2;
	}

	public void UpdateArmorSets(int i)
	{
		//IL_0767: Unknown result type (might be due to invalid IL or missing references)
		//IL_0774: Unknown result type (might be due to invalid IL or missing references)
		//IL_0779: Unknown result type (might be due to invalid IL or missing references)
		//IL_077e: Unknown result type (might be due to invalid IL or missing references)
		//IL_09bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_09c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_09cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_09d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_09d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0999: Unknown result type (might be due to invalid IL or missing references)
		//IL_09a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_09a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_168d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1692: Unknown result type (might be due to invalid IL or missing references)
		//IL_16b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_16c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_16ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_16cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_16f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_1703: Unknown result type (might be due to invalid IL or missing references)
		//IL_1708: Unknown result type (might be due to invalid IL or missing references)
		//IL_15df: Unknown result type (might be due to invalid IL or missing references)
		//IL_15ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_1605: Unknown result type (might be due to invalid IL or missing references)
		//IL_1631: Unknown result type (might be due to invalid IL or missing references)
		//IL_163b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1640: Unknown result type (might be due to invalid IL or missing references)
		//IL_1750: Unknown result type (might be due to invalid IL or missing references)
		//IL_175a: Unknown result type (might be due to invalid IL or missing references)
		//IL_175f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1769: Unknown result type (might be due to invalid IL or missing references)
		//IL_176e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a01: Unknown result type (might be due to invalid IL or missing references)
		//IL_1930: Unknown result type (might be due to invalid IL or missing references)
		//IL_193b: Unknown result type (might be due to invalid IL or missing references)
		setBonus = "";
		if (body == 67 && legs == 56 && head >= 103 && head <= 105)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Shroomite");
			shroomiteStealth = true;
		}
		if ((head == 52 && body == 32 && legs == 31) || (head == 53 && body == 33 && legs == 32) || (head == 54 && body == 34 && legs == 33) || (head == 55 && body == 35 && legs == 34) || (head == 71 && body == 47 && legs == 43) || (head == 166 && body == 173 && legs == 108) || (head == 167 && body == 174 && legs == 109))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Wood");
			++statDefense;
		}
		if (head == 278 && body == 246 && legs == 234)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.AshWood");
			ashWoodBonus = true;
		}
		if ((head == 1 && body == 1 && legs == 1) || ((head == 72 || head == 2) && body == 2 && legs == 2) || (head == 47 && body == 28 && legs == 27))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.MetalTier1");
			statDefense += 2;
		}
		if ((head == 3 && body == 3 && legs == 3) || ((head == 73 || head == 4) && body == 4 && legs == 4) || (head == 48 && body == 29 && legs == 28) || (head == 49 && body == 30 && legs == 29))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.MetalTier2");
			statDefense += 3;
		}
		if (head == 50 && body == 31 && legs == 30)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Platinum");
			statDefense += 4;
		}
		if (head == 112 && body == 75 && legs == 64)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Pumpkin");
			allDamage += 0.1f;
		}
		if (head == 180 && body == 182 && legs == 122)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Gladiator");
			noKnockback = true;
		}
		if (head == 22 && body == 14 && legs == 14)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Ninja");
			moveSpeed += 0.2f;
		}
		if (head == 188 && body == 189 && legs == 129)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Fossil");
			ammoCost80 = true;
		}
		if ((head == 75 || head == 7) && body == 7 && legs == 7)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Bone");
			rangedCrit += 10f;
		}
		if (head == 157 && body == 105 && legs == 98)
		{
			int num = 0;
			setBonus = Language.GetTextValue("ArmorSetBonus.BeetleDamage");
			beetleOffense = true;
			beetleCounter -= 3f;
			beetleCounter -= beetleCountdown / 20;
			beetleCountdown++;
			if (beetleCounter < 0f)
			{
				beetleCounter = 0f;
			}
			int num10 = 400;
			int num11 = 1200;
			int num12 = 3600;
			if (beetleCounter > (float)(num10 + num11 + num12 + num11))
			{
				beetleCounter = num10 + num11 + num12 + num11;
			}
			if (beetleCounter > (float)(num10 + num11 + num12))
			{
				AddBuff(100, 5, quiet: false);
				num = 3;
			}
			else if (beetleCounter > (float)(num10 + num11))
			{
				AddBuff(99, 5, quiet: false);
				num = 2;
			}
			else if (beetleCounter > (float)num10)
			{
				AddBuff(98, 5, quiet: false);
				num = 1;
			}
			if (num < beetleOrbs)
			{
				beetleCountdown = 0;
			}
			else if (num > beetleOrbs)
			{
				beetleCounter += 200f;
			}
			if (num != beetleOrbs && beetleOrbs > 0)
			{
				for (int j = 0; j < maxBuffs; j++)
				{
					if (buffType[j] >= 98 && buffType[j] <= 100 && buffType[j] != 97 + num)
					{
						DelBuff(j);
					}
				}
			}
		}
		else if (head == 157 && body == 106 && legs == 98)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.BeetleDefense");
			beetleDefense = true;
			beetleCounter += 1f;
			int num13 = 180;
			if (beetleCounter >= (float)num13)
			{
				if (beetleOrbs > 0 && beetleOrbs < 3)
				{
					for (int k = 0; k < maxBuffs; k++)
					{
						if (buffType[k] >= 95 && buffType[k] <= 96)
						{
							DelBuff(k);
						}
					}
				}
				if (beetleOrbs < 3)
				{
					AddBuff(95 + beetleOrbs, 5, quiet: false);
					beetleCounter = 0f;
				}
				else
				{
					beetleCounter = num13;
				}
			}
		}
		if (!beetleDefense && !beetleOffense)
		{
			beetleCounter = 0f;
		}
		else
		{
			beetleFrameCounter++;
			if (beetleFrameCounter >= 1)
			{
				beetleFrameCounter = 0;
				beetleFrame++;
				if (beetleFrame > 2)
				{
					beetleFrame = 0;
				}
			}
			for (int l = beetleOrbs; l < 3; l++)
			{
				beetlePos[l].X = 0f;
				beetlePos[l].Y = 0f;
			}
			for (int m = 0; m < beetleOrbs; m++)
			{
				ref Vector2 reference = ref beetlePos[m];
				reference += beetleVel[m];
				beetleVel[m].X += (float)Main.rand.Next(-100, 101) * 0.005f;
				beetleVel[m].Y += (float)Main.rand.Next(-100, 101) * 0.005f;
				float x = beetlePos[m].X;
				float y = beetlePos[m].Y;
				float num14 = (float)Math.Sqrt(x * x + y * y);
				if (num14 > 100f)
				{
					num14 = 20f / num14;
					x *= 0f - num14;
					y *= 0f - num14;
					int num15 = 10;
					beetleVel[m].X = (beetleVel[m].X * (float)(num15 - 1) + x) / (float)num15;
					beetleVel[m].Y = (beetleVel[m].Y * (float)(num15 - 1) + y) / (float)num15;
				}
				else if (num14 > 30f)
				{
					num14 = 10f / num14;
					x *= 0f - num14;
					y *= 0f - num14;
					int num16 = 20;
					beetleVel[m].X = (beetleVel[m].X * (float)(num16 - 1) + x) / (float)num16;
					beetleVel[m].Y = (beetleVel[m].Y * (float)(num16 - 1) + y) / (float)num16;
				}
				x = beetleVel[m].X;
				y = beetleVel[m].Y;
				num14 = (float)Math.Sqrt(x * x + y * y);
				if (num14 > 2f)
				{
					ref Vector2 reference2 = ref beetleVel[m];
					reference2 *= 0.9f;
				}
				ref Vector2 reference3 = ref beetlePos[m];
				reference3 -= velocity * 0.25f;
			}
		}
		if (head == 14 && ((body >= 58 && body <= 63) || body == 167 || body == 213))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Wizard");
			magicCrit += 10f;
		}
		if (head == 159 && ((body >= 58 && body <= 63) || body == 167 || body == 213))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.MagicHat");
			statManaMax2 += 60;
		}
		if ((head == 5 || head == 74) && (body == 5 || body == 48) && (legs == 5 || legs == 44))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.ShadowScale");
			shadowArmor = true;
		}
		if (head == 57 && body == 37 && legs == 35)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Crimson");
			crimsonRegen = true;
		}
		if (head == 101 && body == 66 && legs == 55)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.SpectreHealing");
			ghostHeal = true;
			magicDamage -= 0.4f;
		}
		if (head == 156 && body == 66 && legs == 55)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.SpectreDamage");
			ghostHurt = true;
		}
		if (head == 6 && body == 6 && legs == 6)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Meteor");
			spaceGun = true;
		}
		if (head == 46 && body == 27 && legs == 26)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Frost");
			frostBurn = true;
			meleeDamage += 0.1f;
			rangedDamage += 0.1f;
		}
		if ((head == 76 || head == 8) && (body == 49 || body == 8) && (legs == 45 || legs == 8))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Jungle");
			manaCost -= 0.16f;
		}
		if (head == 9 && body == 9 && legs == 9)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Molten");
			meleeDamage += 0.1f;
			buffImmune[24] = true;
		}
		if ((head == 58 || head == 77) && (body == 38 || body == 50) && (legs == 36 || legs == 46))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Snow");
			buffImmune[46] = true;
			buffImmune[47] = true;
		}
		if (head == 11 && body == 20 && legs == 19)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Mining");
			pickSpeed -= 0.1f;
		}
		if (head == 216 && body == 20 && legs == 19)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Mining");
			pickSpeed -= 0.1f;
		}
		if (head == 78 && body == 51 && legs == 47)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.ChlorophyteMelee");
			AddBuff(60, 18000);
			endurance += 0.05f;
		}
		else if ((head == 80 || head == 79) && body == 51 && legs == 47)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Chlorophyte");
			AddBuff(60, 18000);
		}
		else if (crystalLeaf)
		{
			for (int n = 0; n < maxBuffs; n++)
			{
				if (buffType[n] == 60)
				{
					DelBuff(n);
				}
			}
		}
		if (head == 161 && body == 169 && legs == 104)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Angler");
			anglerSetSpawnReduction = true;
		}
		if (head == 70 && body == 46 && legs == 42)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Cactus");
			cactusThorns = true;
		}
		if (head == 99 && body == 65 && legs == 54)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Turtle");
			endurance += 0.15f;
			thorns = 1f;
			turtleThorns = true;
		}
		if (body == 17 && legs == 16)
		{
			if (head == 29)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.CobaltCaster");
				manaCost -= 0.14f;
			}
			else if (head == 30)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.CobaltMelee");
				meleeSpeed += 0.15f;
			}
			else if (head == 31)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.CobaltRanged");
				ammoCost80 = true;
			}
		}
		if (body == 18 && legs == 17)
		{
			if (head == 32)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.MythrilCaster");
				manaCost -= 0.17f;
			}
			else if (head == 33)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.MythrilMelee");
				meleeCrit += 10f;
			}
			else if (head == 34)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.MythrilRanged");
				ammoCost80 = true;
			}
		}
		if (body == 19 && legs == 18)
		{
			if (head == 35)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.AdamantiteCaster");
				manaCost -= 0.19f;
			}
			else if (head == 36)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.AdamantiteMelee");
				meleeSpeed += 0.2f;
				moveSpeed += 0.2f;
			}
			else if (head == 37)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.AdamantiteRanged");
				ammoCost75 = true;
			}
		}
		if (body == 54 && legs == 49 && (head == 83 || head == 84 || head == 85))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Palladium");
			onHitRegen = true;
		}
		if (body == 55 && legs == 50 && (head == 86 || head == 87 || head == 88))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Orichalcum");
			onHitPetal = true;
		}
		if (body == 56 && legs == 51)
		{
			bool flag = false;
			if (head == 91)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.Titanium");
				flag = true;
			}
			else if (head == 89)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.Titanium");
				flag = true;
			}
			else if (head == 90)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.Titanium");
				flag = true;
			}
			if (flag)
			{
				onHitTitaniumStorm = true;
			}
		}
		if ((body == 24 || body == 229) && (legs == 23 || legs == 212) && (head == 42 || head == 41 || head == 43 || head == 254 || head == 257 || head == 256 || head == 255 || head == 258))
		{
			if (head == 254 || head == 258)
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.HallowedSummoner");
				maxMinions += 2;
			}
			else
			{
				setBonus = Language.GetTextValue("ArmorSetBonus.Hallowed");
			}
			onHitDodge = true;
		}
		if (head == 261 && body == 230 && legs == 213)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.CrystalNinja");
			allDamage += 0.1f;
			allCrit += 10f;
			dashType = 5;
		}
		if (head == 82 && body == 53 && legs == 48)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Tiki");
			maxMinions++;
			whipRangeMultiplier += 0.2f;
		}
		if (head == 134 && body == 95 && legs == 79)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Spooky");
			minionDamage += 0.25f;
		}
		if (head == 160 && body == 168 && legs == 103)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Bee");
			minionDamage += 0.1f;
			if (itemAnimation > 0 && inventory[selectedItem].type == 1121)
			{
				AchievementsHelper.HandleSpecialEvent(this, 3);
			}
		}
		if (head == 162 && body == 170 && legs == 105)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Spider");
			minionDamage += 0.12f;
		}
		if (head == 171 && body == 177 && legs == 112)
		{
			endurance += 0.12f;
			setSolar = true;
			setBonus = Language.GetTextValue("ArmorSetBonus.Solar");
			solarCounter++;
			int num17 = 180;
			if (solarCounter >= num17)
			{
				if (solarShields > 0 && solarShields < 3)
				{
					for (int num2 = 0; num2 < maxBuffs; num2++)
					{
						if (buffType[num2] >= 170 && buffType[num2] <= 171)
						{
							DelBuff(num2);
						}
					}
				}
				if (solarShields < 3)
				{
					AddBuff(170 + solarShields, 5, quiet: false);
					for (int num3 = 0; num3 < 16; num3++)
					{
						Dust obj = Main.dust[Dust.NewDust(position, width, height, 6, 0f, 0f, 100)];
						obj.noGravity = true;
						obj.scale = 1.7f;
						obj.fadeIn = 0.5f;
						obj.velocity *= 5f;
						obj.shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
					}
					solarCounter = 0;
				}
				else
				{
					solarCounter = num17;
				}
			}
			for (int num4 = solarShields; num4 < 3; num4++)
			{
				solarShieldPos[num4] = Vector2.Zero;
			}
			for (int num5 = 0; num5 < solarShields; num5++)
			{
				ref Vector2 reference4 = ref solarShieldPos[num5];
				reference4 += solarShieldVel[num5];
				Vector2 vector = ((float)miscCounter / 100f * ((float)Math.PI * 2f) + (float)num5 * ((float)Math.PI * 2f / (float)solarShields)).ToRotationVector2() * 6f;
				vector.X = direction * 20;
				if (mount.Active && mount.Type == 52)
				{
					vector.X = direction * 50;
				}
				solarShieldVel[num5] = (vector - solarShieldPos[num5]) * 0.2f;
			}
			if (dashDelay >= 0)
			{
				solarDashing = false;
				solarDashConsumedFlare = false;
			}
			bool flag2 = solarDashing && dashDelay < 0;
			if (solarShields > 0 || flag2)
			{
				dashType = 3;
			}
		}
		else
		{
			solarCounter = 0;
		}
		if (head == 169 && body == 175 && legs == 110)
		{
			setVortex = true;
			setBonus = Language.GetTextValue("ArmorSetBonus.Vortex", Language.GetTextValue(Main.ReversedUpDownArmorSetBonuses ? "Key.UP" : "Key.DOWN"));
		}
		else
		{
			vortexStealthActive = false;
		}
		if (head == 170 && body == 176 && legs == 111)
		{
			if (nebulaCD > 0)
			{
				nebulaCD--;
			}
			setNebula = true;
			setBonus = Language.GetTextValue("ArmorSetBonus.Nebula");
		}
		if (head == 189 && body == 190 && legs == 130)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Stardust", Language.GetTextValue(Main.ReversedUpDownArmorSetBonuses ? "Key.UP" : "Key.DOWN"));
			setStardust = true;
			if (whoAmI == Main.myPlayer)
			{
				if (FindBuffIndex(187) == -1)
				{
					AddBuff(187, 3600);
				}
				if (ownedProjectileCounts[623] < 1)
				{
					int num6 = 10;
					int num7 = 30;
					int num8 = Projectile.NewProjectile(GetProjectileSource_SetBonus(7), base.Center.X, base.Center.Y, 0f, -1f, 623, num7, num6, Main.myPlayer);
					Main.projectile[num8].originalDamage = num7;
				}
			}
		}
		else if (FindBuffIndex(187) != -1)
		{
			DelBuff(FindBuffIndex(187));
		}
		if (head == 200 && body == 198 && legs == 142)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.Forbidden", Language.GetTextValue(Main.ReversedUpDownArmorSetBonuses ? "Key.UP" : "Key.DOWN"));
			setForbidden = true;
			UpdateForbiddenSetLock();
			Lighting.AddLight(base.Center, 0.8f, 0.7f, 0.2f);
		}
		if (head == 204 && body == 201 && legs == 145)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.SquireTier2");
			setSquireT2 = true;
			maxTurrets++;
		}
		if (head == 203 && body == 200 && legs == 144)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.ApprenticeTier2");
			setApprenticeT2 = true;
			maxTurrets++;
		}
		if (head == 205 && body == 202 && (legs == 147 || legs == 146))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.HuntressTier2");
			setHuntressT2 = true;
			maxTurrets++;
		}
		if (head == 206 && body == 203 && legs == 148)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.MonkTier2");
			setMonkT2 = true;
			maxTurrets++;
		}
		if (head == 210 && body == 204 && legs == 152)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.SquireTier3");
			setSquireT3 = true;
			setSquireT2 = true;
			maxTurrets++;
		}
		if (head == 211 && body == 205 && legs == 153)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.ApprenticeTier3");
			setApprenticeT3 = true;
			setApprenticeT2 = true;
			maxTurrets++;
		}
		if (head == 212 && body == 206 && (legs == 154 || legs == 155))
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.HuntressTier3");
			setHuntressT3 = true;
			setHuntressT2 = true;
			maxTurrets++;
		}
		if (head == 213 && body == 207 && legs == 156)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.MonkTier3");
			setMonkT3 = true;
			setMonkT2 = true;
			maxTurrets++;
		}
		if (head == 185 && body == 187 && legs == 127)
		{
			setBonus = Language.GetTextValue("ArmorSetBonus.ObsidianOutlaw");
			minionDamage += 0.15f;
			whipRangeMultiplier += 0.3f;
			float num9 = 1.15f;
			summonerWeaponSpeedBonus += num9 - 1f;
		}
		ApplyArmorSoundAndDustChanges();
		ItemLoader.UpdateArmorSet(this, armor[0], armor[1], armor[2]);
	}

	public void UpdateSocialShadow()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		for (int num = 2; num > 0; num--)
		{
			shadowDirection[num] = shadowDirection[num - 1];
		}
		shadowDirection[0] = direction;
		shadowCount++;
		if (shadowCount == 1)
		{
			shadowPos[2] = shadowPos[1];
			shadowRotation[2] = shadowRotation[1];
			shadowOrigin[2] = shadowOrigin[1];
		}
		else if (shadowCount == 2)
		{
			shadowPos[1] = shadowPos[0];
			shadowRotation[1] = shadowRotation[0];
			shadowOrigin[1] = shadowOrigin[0];
		}
		else if (shadowCount >= 3)
		{
			shadowCount = 0;
			shadowPos[0] = position;
			shadowPos[0].Y += gfxOffY;
			shadowRotation[0] = fullRotation;
			shadowOrigin[0] = fullRotationOrigin;
		}
	}

	public void UpdateTeleportVisuals()
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		if (!(teleportTime > 0f))
		{
			return;
		}
		if (teleportStyle == 0)
		{
			if ((float)Main.rand.Next(100) <= 100f * teleportTime * 2f)
			{
				int num = Dust.NewDust(new Vector2((float)getRect().X, (float)getRect().Y), getRect().Width, getRect().Height, 159);
				Main.dust[num].scale = teleportTime * 1.5f;
				Main.dust[num].noGravity = true;
				Dust obj = Main.dust[num];
				obj.velocity *= 1.1f;
			}
		}
		else if (teleportStyle == 1)
		{
			if ((float)Main.rand.Next(100) <= 100f * teleportTime)
			{
				int num2 = Dust.NewDust(new Vector2((float)getRect().X, (float)getRect().Y), getRect().Width, getRect().Height, 164);
				Main.dust[num2].scale = teleportTime * 1.5f;
				Main.dust[num2].noGravity = true;
				Dust obj2 = Main.dust[num2];
				obj2.velocity *= 1.1f;
			}
		}
		else if (teleportStyle == 2)
		{
			teleportTime = 0.005f;
		}
		else if (teleportStyle == 3)
		{
			teleportTime = 0.005f;
		}
		else if (teleportStyle == 4)
		{
			teleportTime -= 0.02f;
			if ((float)Main.rand.Next(100) <= 100f * teleportTime)
			{
				Dust obj3 = Main.dust[Dust.NewDust(position, width, height, 263)];
				obj3.color = PortalHelper.GetPortalColor(lastPortalColorIndex);
				obj3.noLight = true;
				obj3.noGravity = true;
				obj3.scale = 1.2f;
				obj3.fadeIn = 0.4f;
			}
		}
		else if (teleportStyle == 9)
		{
			Rectangle hitbox = base.Hitbox;
			((Rectangle)(ref hitbox)).Inflate(5, 5);
			if ((float)Main.rand.Next(100) <= 100f * teleportTime)
			{
				TeleportPylonsSystem.SpawnInWorldDust(lastTeleportPylonStyleUsed, hitbox);
			}
		}
		teleportTime -= 0.005f;
	}

	private void UpdateGraveyard(bool now = false)
	{
		float lerpValue = Utils.GetLerpValue(SceneMetrics.GraveyardTileMin, SceneMetrics.GraveyardTileMax, Main.SceneMetrics.GraveyardTileCount, clamped: true);
		if (now)
		{
			graveImmediateTime = 30;
		}
		if (graveImmediateTime > 0)
		{
			graveImmediateTime--;
			Main.GraveyardVisualIntensity = lerpValue;
		}
		else if (Main.GraveyardVisualIntensity < lerpValue)
		{
			Main.GraveyardVisualIntensity += 0.02f;
			if (Main.GraveyardVisualIntensity > lerpValue)
			{
				Main.GraveyardVisualIntensity = lerpValue;
			}
		}
		else if (Main.GraveyardVisualIntensity > lerpValue)
		{
			Main.GraveyardVisualIntensity -= 0.01f;
			if (Main.GraveyardVisualIntensity < lerpValue)
			{
				Main.GraveyardVisualIntensity = lerpValue;
			}
		}
	}

	public void ForceUpdateBiomes()
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if (whoAmI == Main.myPlayer)
		{
			Main.GetAreaToLight(out var firstTileX, out var lastTileX, out var firstTileY, out var lastTileY);
			Rectangle value = default(Rectangle);
			((Rectangle)(ref value))._002Ector(firstTileX, firstTileY, lastTileX - firstTileX, lastTileY - firstTileY);
			int num = 28;
			((Rectangle)(ref value)).Inflate(num, num);
			Main.SceneMetrics.ScanAndExportToMain(new SceneMetricsScanSettings
			{
				VisualScanArea = value,
				BiomeScanCenterPositionInWorld = base.Center,
				ScanOreFinderData = accOreFinder
			});
			UpdateBiomes();
		}
	}

	public bool CanSeeShimmerEffects()
	{
		if (Main.SceneMetrics.ShimmerMonolithState == 2)
		{
			return false;
		}
		if (ZoneShimmer)
		{
			return true;
		}
		if (shimmerMonolithShader || Main.SceneMetrics.ShimmerMonolithState == 1)
		{
			return true;
		}
		if (!((double)(Main.screenPosition.Y / 16f) > Main.worldSurface + 50.0) || !(Main.screenPosition.Y / 16f < (float)(Main.maxTilesY - 330 - 100)))
		{
			return false;
		}
		return shimmering;
	}

	public void UpdateBiomes()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_13ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_13b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_13b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_13b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_13bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_13d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_13dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_13f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_13fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0410: Unknown result type (might be due to invalid IL or missing references)
		//IL_041e: Unknown result type (might be due to invalid IL or missing references)
		//IL_043f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0460: Unknown result type (might be due to invalid IL or missing references)
		//IL_0466: Unknown result type (might be due to invalid IL or missing references)
		//IL_047e: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_049f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0533: Unknown result type (might be due to invalid IL or missing references)
		//IL_0538: Unknown result type (might be due to invalid IL or missing references)
		//IL_053a: Unknown result type (might be due to invalid IL or missing references)
		//IL_053f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0541: Unknown result type (might be due to invalid IL or missing references)
		//IL_0546: Unknown result type (might be due to invalid IL or missing references)
		//IL_0548: Unknown result type (might be due to invalid IL or missing references)
		//IL_054d: Unknown result type (might be due to invalid IL or missing references)
		//IL_054f: Unknown result type (might be due to invalid IL or missing references)
		//IL_058c: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_05af: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0624: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0600: Unknown result type (might be due to invalid IL or missing references)
		//IL_0816: Unknown result type (might be due to invalid IL or missing references)
		//IL_0823: Unknown result type (might be due to invalid IL or missing references)
		//IL_0670: Unknown result type (might be due to invalid IL or missing references)
		//IL_0647: Unknown result type (might be due to invalid IL or missing references)
		//IL_064c: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0690: Unknown result type (might be due to invalid IL or missing references)
		//IL_0695: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_06db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0978: Unknown result type (might be due to invalid IL or missing references)
		//IL_0995: Unknown result type (might be due to invalid IL or missing references)
		//IL_09d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_09e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_09e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_09fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a07: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a0c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a22: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a2e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a33: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a49: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a55: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a5a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a76: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a7c: Unknown result type (might be due to invalid IL or missing references)
		//IL_09a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0aa7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0aad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ac4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0aca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b25: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b2b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ae2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b90: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b63: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b69: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c42: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c48: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cb3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cb9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d1e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0dbf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0dfe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e77: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ffe: Unknown result type (might be due to invalid IL or missing references)
		//IL_1003: Unknown result type (might be due to invalid IL or missing references)
		//IL_1005: Unknown result type (might be due to invalid IL or missing references)
		//IL_100c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1014: Unknown result type (might be due to invalid IL or missing references)
		Point point = base.Center.ToTileCoordinates();
		ZoneDungeon = false;
		if (Main.SceneMetrics.DungeonTileCount >= 250 && (double)base.Center.Y > Main.worldSurface * 16.0)
		{
			int num = (int)base.Center.X / 16;
			int num12 = (int)base.Center.Y / 16;
			if (Main.tile[num, num12] != null && Main.wallDungeon[Main.tile[num, num12].wall])
			{
				ZoneDungeon = true;
			}
		}
		ZoneLihzhardTemple = false;
		int num15 = (int)base.Center.X / 16;
		int num16 = (int)base.Center.Y / 16;
		if (Main.tile[num15, num16] != null && Main.tile[num15, num16].wall == 87)
		{
			ZoneLihzhardTemple = true;
		}
		Tile tileSafely = Framing.GetTileSafely(base.Center);
		if (tileSafely != null)
		{
			behindBackWall = tileSafely.wall > 0;
		}
		if (behindBackWall && ZoneDesert && (double)base.Center.Y > Main.worldSurface)
		{
			if (WallID.Sets.Conversion.Sandstone[tileSafely.wall] || WallID.Sets.Conversion.HardenedSand[tileSafely.wall])
			{
				ZoneUndergroundDesert = true;
			}
		}
		else
		{
			ZoneUndergroundDesert = false;
		}
		if (behindBackWall && (tileSafely.wall == 184 || tileSafely.wall == 180))
		{
			ZoneGranite = true;
		}
		else
		{
			ZoneGranite = false;
		}
		if (behindBackWall && (tileSafely.wall == 183 || tileSafely.wall == 178))
		{
			ZoneMarble = true;
		}
		else
		{
			ZoneMarble = false;
		}
		if (behindBackWall && (tileSafely.wall == 108 || tileSafely.wall == 86))
		{
			ZoneHive = true;
		}
		else
		{
			ZoneHive = false;
		}
		if (behindBackWall && tileSafely.wall >= 48 && tileSafely.wall <= 53)
		{
			ZoneGemCave = true;
		}
		else
		{
			ZoneGemCave = false;
		}
		bool flag = (double)(Main.screenPosition.Y / 16f) > Main.worldSurface + 50.0 && Main.screenPosition.Y / 16f < (float)(Main.maxTilesY - 330 - 100);
		ZoneShimmer = Main.SceneMetrics.EnoughTilesForShimmer && flag;
		ZoneCorrupt = Main.SceneMetrics.EnoughTilesForCorruption;
		ZoneCrimson = Main.SceneMetrics.EnoughTilesForCrimson;
		ZoneHallow = Main.SceneMetrics.EnoughTilesForHallow;
		ZoneJungle = Main.SceneMetrics.EnoughTilesForJungle && position.Y / 16f < (float)Main.UnderworldLayer;
		ZoneSnow = Main.SceneMetrics.EnoughTilesForSnow;
		ZoneDesert = Main.SceneMetrics.EnoughTilesForDesert;
		ZoneGlowshroom = Main.SceneMetrics.EnoughTilesForGlowingMushroom;
		ZoneMeteor = Main.SceneMetrics.EnoughTilesForMeteor;
		ZoneWaterCandle = Main.SceneMetrics.WaterCandleCount > 0;
		ZonePeaceCandle = Main.SceneMetrics.PeaceCandleCount > 0;
		ZoneShadowCandle = Main.SceneMetrics.ShadowCandleCount > 0;
		ZoneGraveyard = Main.SceneMetrics.EnoughTilesForGraveyard;
		UpdateGraveyard();
		if (HasGardenGnomeNearby != Main.SceneMetrics.HasGardenGnome)
		{
			luckNeedsSync = true;
			HasGardenGnomeNearby = Main.SceneMetrics.HasGardenGnome;
		}
		ZoneUnderworldHeight = point.Y > Main.UnderworldLayer;
		ZoneRockLayerHeight = point.Y <= Main.UnderworldLayer && (double)point.Y > Main.rockLayer;
		ZoneDirtLayerHeight = (double)point.Y <= Main.rockLayer && (double)point.Y > Main.worldSurface;
		ZoneOverworldHeight = (double)point.Y <= Main.worldSurface && (double)point.Y > Main.worldSurface * 0.3499999940395355;
		ZoneSkyHeight = (double)point.Y <= Main.worldSurface * 0.3499999940395355;
		ZoneBeach = WorldGen.oceanDepths(point.X, point.Y);
		ZoneRain = Main.raining && (double)point.Y <= Main.worldSurface;
		if (Main.remixWorld)
		{
			ZoneSandstorm = (double)point.Y >= Main.rockLayer && ZoneDesert && !ZoneBeach && Sandstorm.Happening;
		}
		else
		{
			ZoneSandstorm = (double)point.Y <= Main.worldSurface && ZoneDesert && !ZoneBeach && Sandstorm.Happening;
		}
		bool flag9 = (ZoneTowerStardust = false);
		bool flag3 = flag9;
		flag9 = (ZoneTowerNebula = flag3);
		bool flag4 = flag9;
		flag9 = (ZoneTowerVortex = flag4);
		bool zoneTowerSolar = flag9;
		ZoneTowerSolar = zoneTowerSolar;
		ZoneOldOneArmy = false;
		Vector2 vector = Vector2.Zero;
		Vector2 vector2 = Vector2.Zero;
		Vector2 vector3 = Vector2.Zero;
		Vector2 vector4 = Vector2.Zero;
		_ = Vector2.Zero;
		for (int i = 0; i < 200; i++)
		{
			if (!Main.npc[i].active)
			{
				continue;
			}
			if (Main.npc[i].type == 493)
			{
				if (Distance(Main.npc[i].Center) <= 4000f)
				{
					ZoneTowerStardust = true;
					vector4 = Main.npc[i].Center;
				}
			}
			else if (Main.npc[i].type == 507)
			{
				if (Distance(Main.npc[i].Center) <= 4000f)
				{
					ZoneTowerNebula = true;
					vector3 = Main.npc[i].Center;
				}
			}
			else if (Main.npc[i].type == 422)
			{
				if (Distance(Main.npc[i].Center) <= 4000f)
				{
					ZoneTowerVortex = true;
					vector2 = Main.npc[i].Center;
				}
			}
			else if (Main.npc[i].type == 517)
			{
				if (Distance(Main.npc[i].Center) <= 4000f)
				{
					ZoneTowerSolar = true;
					vector = Main.npc[i].Center;
				}
			}
			else if (Main.npc[i].type == 549 && Distance(Main.npc[i].Center) <= 4000f)
			{
				ZoneOldOneArmy = true;
				vector = Main.npc[i].Center;
			}
		}
		float num17 = 1f;
		float num18 = 1f;
		float num19 = Main.shimmerAlpha;
		if (CanSeeShimmerEffects())
		{
			num17 *= 1f;
			num18 *= 0.7f;
			if (num19 < 1f)
			{
				num19 += 0.025f;
				if (num19 > 1f)
				{
					num19 = 1f;
				}
			}
			if (num19 >= 0.5f)
			{
				Main.shimmerDarken = MathHelper.Clamp(Main.shimmerDarken + 0.025f, 0f, 1f);
				Main.shimmerBrightenDelay = 4f;
			}
		}
		else if (num19 > 0f)
		{
			Main.shimmerDarken = MathHelper.Clamp(Main.shimmerDarken - 0.05f, 0f, 1f);
			if (Main.shimmerDarken == 0f && Main.shimmerBrightenDelay > 0f)
			{
				Main.shimmerBrightenDelay -= 1f;
			}
			if (Main.shimmerBrightenDelay == 0f)
			{
				num19 -= 0.05f;
			}
			if (num19 < 0f)
			{
				num19 = 0f;
			}
		}
		Main.shimmerAlpha = num19;
		if (Main.getGoodWorld)
		{
			bool flag5 = false;
			int num20 = NPC.FindFirstNPC(245);
			if (num20 >= 0 && Vector2.Distance(base.Center, Main.npc[num20].Center) < 2000f)
			{
				flag5 = true;
			}
			if (flag5)
			{
				num17 *= 0.6f;
				num18 *= 0.6f;
			}
			else if (ZoneLihzhardTemple)
			{
				num17 *= 0.88f;
				num18 *= 0.88f;
			}
			else if (ZoneDungeon)
			{
				num17 *= 0.94f;
				num18 *= 0.94f;
			}
		}
		if (num17 != airLightDecay)
		{
			if (airLightDecay >= num17)
			{
				airLightDecay -= 0.005f;
				if (airLightDecay < num17)
				{
					airLightDecay = num17;
				}
			}
			else
			{
				airLightDecay += 0.005f;
				if (airLightDecay > num17)
				{
					airLightDecay = num17;
				}
			}
		}
		if (num18 != solidLightDecay)
		{
			if (solidLightDecay >= num18)
			{
				solidLightDecay -= 0.005f;
				if (solidLightDecay < num18)
				{
					solidLightDecay = num18;
				}
			}
			else
			{
				solidLightDecay += 0.005f;
				if (solidLightDecay > num18)
				{
					solidLightDecay = num18;
				}
			}
		}
		bool flag6 = ZoneRain && ZoneSnow;
		if (Main.remixWorld)
		{
			flag6 = (double)(position.Y / 16f) > Main.worldSurface && Main.raining && ZoneSnow;
		}
		bool flag7 = point.Y > Main.maxTilesY - 320;
		bool flag2 = ZoneOverworldHeight && (point.X < 380 || point.X > Main.maxTilesX - 380);
		LoaderManager.Get<BiomeLoader>().UpdateBiomes(this);
		ManageSpecialBiomeVisuals("Stardust", ZoneTowerStardust, vector4 - new Vector2(0f, 10f));
		ManageSpecialBiomeVisuals("Nebula", ZoneTowerNebula, vector3 - new Vector2(0f, 10f));
		ManageSpecialBiomeVisuals("Vortex", ZoneTowerVortex, vector2 - new Vector2(0f, 10f));
		ManageSpecialBiomeVisuals("Solar", ZoneTowerSolar, vector - new Vector2(0f, 10f));
		ManageSpecialBiomeVisuals("MoonLord", NPC.AnyNPCs(398));
		ManageSpecialBiomeVisuals("BloodMoon", Main.bloodMoon || Main.SceneMetrics.BloodMoonMonolith || bloodMoonMonolithShader);
		ManageSpecialBiomeVisuals("Blizzard", Main.UseStormEffects && flag6);
		ManageSpecialBiomeVisuals("HeatDistortion", Main.UseHeatDistortion && (flag7 || ((double)point.Y < Main.worldSurface && ZoneDesert && !flag2 && !Main.raining && !Filters.Scene["Sandstorm"].IsActive())));
		if (Main.GraveyardVisualIntensity > 0f)
		{
			if (!Filters.Scene["Graveyard"].IsActive())
			{
				Filters.Scene.Activate("Graveyard", default(Vector2));
			}
			else
			{
				Filters.Scene["Graveyard"].GetShader().UseTargetPosition(base.Center);
				float progress = MathHelper.Lerp(0f, 0.75f, Main.GraveyardVisualIntensity);
				Filters.Scene["Graveyard"].GetShader().UseProgress(progress);
				Filters.Scene["Graveyard"].GetShader().UseIntensity(1.2f);
			}
		}
		else if (Filters.Scene["Graveyard"].IsActive())
		{
			Filters.Scene.Deactivate("Graveyard");
		}
		if (!Filters.Scene["Sepia"].IsActive() && dontStarveShader)
		{
			Filters.Scene.Activate("Sepia", default(Vector2));
		}
		else if (Filters.Scene["Sepia"].IsActive() && !dontStarveShader)
		{
			Filters.Scene.Deactivate("Sepia");
		}
		if (!Filters.Scene["WaterDistortion"].IsActive() && Main.WaveQuality > 0)
		{
			Filters.Scene.Activate("WaterDistortion", default(Vector2));
		}
		else if (Filters.Scene["WaterDistortion"].IsActive() && Main.WaveQuality == 0)
		{
			Filters.Scene.Deactivate("WaterDistortion");
		}
		if (Filters.Scene["WaterDistortion"].IsActive())
		{
			float num21 = (float)Main.maxTilesX * 0.5f - Math.Abs((float)point.X - (float)Main.maxTilesX * 0.5f);
			float num2 = 1f;
			float num3 = Math.Abs(Main.windSpeedCurrent);
			num2 += num3 * 1.25f;
			float num4 = MathHelper.Clamp(Main.maxRaining, 0f, 1f);
			num2 += num4 * 1.25f;
			float num5 = 0f - (MathHelper.Clamp((num21 - 380f) / 100f, 0f, 1f) * 0.5f - 0.25f);
			num2 += num5;
			float num6 = 1f - MathHelper.Clamp(3f * ((float)((double)point.Y - Main.worldSurface) / (float)(Main.rockLayer - Main.worldSurface)), 0f, 1f);
			num2 *= num6;
			float num7 = 0.9f - MathHelper.Clamp((float)(Main.maxTilesY - point.Y - 200) / 300f, 0f, 1f) * 0.9f;
			num2 += num7;
			num2 += (1f - num6) * 0.75f;
			num2 = MathHelper.Clamp(num2, 0f, 2.5f);
			Filters.Scene["WaterDistortion"].GetShader().UseIntensity(num2);
		}
		if (flag7)
		{
			float val = (float)(point.Y - (Main.maxTilesY - 320)) / 120f;
			val = Math.Min(1f, val) * 2f;
			Filters.Scene["HeatDistortion"].GetShader().UseIntensity(val);
		}
		_shaderObstructionInternalValue = Utils.Clamp(_shaderObstructionInternalValue + (float)behindBackWall.ToDirectionInt() * -0.005f, -0.1f, 1.1f);
		_stormShaderObstruction = Utils.Clamp(_shaderObstructionInternalValue, 0f, 1f);
		if (Filters.Scene["Sandstorm"].IsActive())
		{
			Filters.Scene["Sandstorm"].GetShader().UseIntensity(_stormShaderObstruction * 0.4f * Math.Min(1f, Sandstorm.Severity));
			Filters.Scene["Sandstorm"].GetShader().UseOpacity(Math.Min(1f, Sandstorm.Severity * 1.5f) * _stormShaderObstruction);
			((SimpleOverlay)Overlays.Scene["Sandstorm"]).GetShader().UseOpacity(Math.Min(1f, Sandstorm.Severity * 1.5f) * (1f - _stormShaderObstruction));
		}
		else if (ZoneDesert && !flag2 && !Main.raining && !flag7)
		{
			Vector3 vector5 = ((Color)(ref Main.tileColor)).ToVector3();
			float num8 = (vector5.X + vector5.Y + vector5.Z) / 3f;
			float num9 = _stormShaderObstruction * 4f * Math.Max(0f, 0.5f - Main.cloudAlpha) * num8;
			Filters.Scene["HeatDistortion"].GetShader().UseIntensity(num9);
			if (num9 <= 0f)
			{
				Filters.Scene["HeatDistortion"].IsHidden = true;
			}
			else
			{
				Filters.Scene["HeatDistortion"].IsHidden = false;
			}
		}
		if (!disabledBlizzardGraphic)
		{
			try
			{
				if (flag6)
				{
					float cloudAlpha = Main.cloudAlpha;
					if (Main.remixWorld)
					{
						Main.cloudAlpha = 0.4f;
					}
					bool value = NPC.IsADeerclopsNearScreen();
					_deerclopsBlizzardSmoothedEffect = MathHelper.Clamp(_deerclopsBlizzardSmoothedEffect + (float)value.ToDirectionInt() * 0.0033333334f, 0f, 1f);
					float num10 = Math.Min(1f, Main.cloudAlpha * 2f) * _stormShaderObstruction;
					float num11 = _stormShaderObstruction * 0.4f * Math.Min(1f, Main.cloudAlpha * 2f) * 0.9f + 0.1f;
					num11 = MathHelper.Lerp(num11, num11 * 0.5f, _deerclopsBlizzardSmoothedEffect);
					num10 = MathHelper.Lerp(num10, num10 * 0.5f, _deerclopsBlizzardSmoothedEffect);
					Filters.Scene["Blizzard"].GetShader().UseIntensity(num11);
					Filters.Scene["Blizzard"].GetShader().UseOpacity(num10);
					((SimpleOverlay)Overlays.Scene["Blizzard"]).GetShader().UseOpacity(1f - num10);
					if (Main.remixWorld)
					{
						Main.cloudAlpha = cloudAlpha;
					}
				}
			}
			catch
			{
				disabledBlizzardGraphic = true;
			}
		}
		if (!disabledBlizzardSound)
		{
			try
			{
				if (flag6)
				{
					ActiveSound? activeSound5 = SoundEngine.GetActiveSound(_strongBlizzardSound);
					ActiveSound activeSound2 = SoundEngine.GetActiveSound(_insideBlizzardSound);
					if (activeSound5 == null)
					{
						_strongBlizzardSound = SoundEngine.PlayTrackedSound(in SoundID.BlizzardStrongLoop);
					}
					if (activeSound2 == null)
					{
						_insideBlizzardSound = SoundEngine.PlayTrackedSound(in SoundID.BlizzardInsideBuildingLoop);
					}
					SoundEngine.GetActiveSound(_strongBlizzardSound);
					activeSound2 = SoundEngine.GetActiveSound(_insideBlizzardSound);
				}
				if (flag6)
				{
					_blizzardSoundVolume = Math.Min(_blizzardSoundVolume + 0.01f, 1f);
				}
				else
				{
					_blizzardSoundVolume = Math.Max(_blizzardSoundVolume - 0.01f, 0f);
				}
				float num13 = Math.Min(1f, Main.cloudAlpha * 2f) * _stormShaderObstruction;
				ActiveSound activeSound3 = SoundEngine.GetActiveSound(_strongBlizzardSound);
				ActiveSound activeSound4 = SoundEngine.GetActiveSound(_insideBlizzardSound);
				if (_blizzardSoundVolume > 0f)
				{
					if (activeSound3 == null)
					{
						_strongBlizzardSound = SoundEngine.PlayTrackedSound(in SoundID.BlizzardStrongLoop);
						activeSound3 = SoundEngine.GetActiveSound(_strongBlizzardSound);
					}
					activeSound3.Volume = num13 * _blizzardSoundVolume;
					if (activeSound4 == null)
					{
						_insideBlizzardSound = SoundEngine.PlayTrackedSound(in SoundID.BlizzardInsideBuildingLoop);
						activeSound4 = SoundEngine.GetActiveSound(_insideBlizzardSound);
					}
					activeSound4.Volume = (1f - num13) * _blizzardSoundVolume;
				}
				else
				{
					if (activeSound3 != null)
					{
						activeSound3.Volume = 0f;
					}
					else
					{
						_strongBlizzardSound = SlotId.Invalid;
					}
					if (activeSound4 != null)
					{
						activeSound4.Volume = 0f;
					}
					else
					{
						_insideBlizzardSound = SlotId.Invalid;
					}
				}
			}
			catch
			{
				disabledBlizzardSound = true;
			}
		}
		ZonePurity = InZonePurity();
		if (!dead)
		{
			Point point2 = base.Center.ToTileCoordinates();
			if (WorldGen.InWorld(point2.X, point2.Y, 1))
			{
				int num14 = 0;
				if (Main.tile[point2.X, point2.Y] != null)
				{
					num14 = Main.tile[point2.X, point2.Y].wall;
				}
				switch (num14)
				{
				case 86:
					AchievementsHelper.HandleSpecialEvent(this, 12);
					break;
				case 62:
					AchievementsHelper.HandleSpecialEvent(this, 13);
					break;
				}
			}
			if (_funkytownAchievementCheckCooldown > 0)
			{
				_funkytownAchievementCheckCooldown--;
			}
			if (Main.specialSeedWorld)
			{
				AchievementsHelper.HandleSpecialEvent(this, 26);
			}
			if (position.Y / 16f > (float)Main.UnderworldLayer)
			{
				AchievementsHelper.HandleSpecialEvent(this, 14);
			}
			else if (_funkytownAchievementCheckCooldown == 0 && (double)(position.Y / 16f) < Main.worldSurface && ZoneGlowshroom)
			{
				AchievementsHelper.HandleSpecialEvent(this, 15);
			}
			else if (_funkytownAchievementCheckCooldown == 0 && ZoneGraveyard)
			{
				AchievementsHelper.HandleSpecialEvent(this, 18);
			}
		}
		else
		{
			_funkytownAchievementCheckCooldown = 100;
		}
		LoaderManager.Get<SceneEffectLoader>().UpdateSceneEffect(this);
	}

	private void TrySpawningFaelings()
	{
		if (!_wasInShimmerZone && ZoneShimmer && Main.netMode != 1)
		{
			NPC.SpawnFaelings(whoAmI);
		}
		_wasInShimmerZone = ZoneShimmer;
	}

	public void ManageSpecialBiomeVisuals(string biomeName, bool inZone, Vector2 activationSource = default(Vector2))
	{
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		if (SkyManager.Instance[biomeName] != null && inZone != SkyManager.Instance[biomeName].IsActive())
		{
			if (inZone)
			{
				SkyManager.Instance.Activate(biomeName, activationSource);
			}
			else
			{
				SkyManager.Instance.Deactivate(biomeName);
			}
		}
		if (inZone != Filters.Scene[biomeName].IsActive())
		{
			if (inZone)
			{
				Filters.Scene.Activate(biomeName, activationSource);
			}
			else
			{
				Filters.Scene[biomeName].Deactivate();
			}
		}
		else if (inZone)
		{
			Filters.Scene[biomeName].GetShader().UseTargetPosition(activationSource);
		}
		if (Overlays.Scene[biomeName] != null && inZone != (Overlays.Scene[biomeName].Mode != OverlayMode.Inactive))
		{
			if (inZone)
			{
				Overlays.Scene.Activate(biomeName, activationSource);
			}
			else
			{
				Overlays.Scene[biomeName].Deactivate();
			}
		}
	}

	public void GetHairSettings(out bool fullHair, out bool hatHair, out bool hideHair, out bool backHairDraw, out bool drawsBackHairWithoutHeadgear)
	{
		fullHair = head >= 0 && ArmorIDs.Head.Sets.DrawFullHair[head];
		hatHair = head >= 0 && ArmorIDs.Head.Sets.DrawHatHair[head];
		hideHair = (face >= 0 && ArmorIDs.Face.Sets.PreventHairDraw[face]) || (faceHead >= 0 && head != 0);
		backHairDraw = hair >= 0 && HairID.Sets.DrawBackHair[hair];
		drawsBackHairWithoutHeadgear = head >= 0 && ArmorIDs.Head.Sets.DrawsBackHairWithoutHeadgear[head];
	}

	public void UpdateDead()
	{
		//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0301: Unknown result type (might be due to invalid IL or missing references)
		//IL_0306: Unknown result type (might be due to invalid IL or missing references)
		//IL_030b: Unknown result type (might be due to invalid IL or missing references)
		shimmerUnstuckHelper.Clear();
		timeShimmering = 0;
		forcedGravity = 0;
		_portalPhysicsTime = 0;
		MountFishronSpecialCounter = 0f;
		gem = -1;
		ownedLargeGems = (byte)0;
		brainOfConfusionDodgeAnimationCounter = 0;
		ResetFloorFlags();
		wings = 0;
		wingsLogic = 0;
		equippedWings = null;
		selectItemOnNextUse = false;
		ResetVisibleAccessories();
		poisoned = false;
		venom = false;
		onFire = false;
		dripping = false;
		drippingSlime = false;
		drippingSparkleSlime = false;
		hungry = false;
		heartyMeal = false;
		starving = false;
		burned = false;
		suffocating = false;
		onFire2 = false;
		onFire3 = false;
		onFrostBurn = false;
		onFrostBurn2 = false;
		shimmering = false;
		blind = false;
		blackout = false;
		loveStruck = false;
		dryadWard = false;
		stinky = false;
		resistCold = false;
		electrified = false;
		moonLeech = false;
		headcovered = false;
		vortexDebuff = false;
		windPushed = false;
		setForbidden = false;
		setMonkT3 = false;
		setHuntressT3 = false;
		setApprenticeT3 = false;
		setSquireT3 = false;
		setForbiddenCooldownLocked = false;
		setSolar = (setVortex = (setNebula = (setStardust = false)));
		nebulaLevelDamage = (nebulaLevelLife = (nebulaLevelMana = 0));
		trapDebuffSource = false;
		yoraiz0rEye = 0;
		yoraiz0rDarkness = false;
		hasFloatingTube = false;
		hasUnicornHorn = false;
		hasAngelHalo = false;
		hasRainbowCursor = false;
		leinforsHair = false;
		overrideFishingBobber = -1;
		gravDir = 1f;
		PlayerLoader.UpdateDead(this);
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffType[i] <= 0 || !Main.persistentBuff[buffType[i]])
			{
				buffTime[i] = 0;
				buffType[i] = 0;
			}
		}
		if (whoAmI == Main.myPlayer)
		{
			Main.npcChatText = "";
			Main.editSign = false;
			Main.npcChatCornerItem = 0;
		}
		numMinions = 0;
		grappling[0] = -1;
		grappling[1] = -1;
		grappling[2] = -1;
		sign = -1;
		SetTalkNPC(-1);
		statLife = 0;
		channel = false;
		potionDelay = 0;
		chest = -1;
		tileEntityAnchor.Clear();
		changeItem = -1;
		itemAnimation = 0;
		immuneAlpha += 2;
		if (immuneAlpha > 255)
		{
			immuneAlpha = 255;
		}
		headPosition += headVelocity;
		bodyPosition += bodyVelocity;
		legPosition += legVelocity;
		headRotation += headVelocity.X * 0.1f;
		bodyRotation += bodyVelocity.X * 0.1f;
		legRotation += legVelocity.X * 0.1f;
		headVelocity.Y += 0.1f;
		bodyVelocity.Y += 0.1f;
		legVelocity.Y += 0.1f;
		headVelocity.X *= 0.99f;
		bodyVelocity.X *= 0.99f;
		legVelocity.X *= 0.99f;
		for (int j = 0; j < npcTypeNoAggro.Length; j++)
		{
			npcTypeNoAggro[j] = false;
		}
		if (difficulty == 2)
		{
			if (respawnTimer > 0)
			{
				respawnTimer = Utils.Clamp(respawnTimer - 1, 0, 3600);
			}
			else if (whoAmI == Main.myPlayer || Main.netMode == 2)
			{
				ghost = true;
			}
		}
		else
		{
			respawnTimer = Utils.Clamp(respawnTimer - 1, 0, 3600);
			if (respawnTimer <= 0 && Main.myPlayer == whoAmI)
			{
				if (Main.mouseItem.type > 0)
				{
					Main.playerInventory = true;
				}
				Spawn(PlayerSpawnContext.ReviveFromDeath);
			}
		}
		if (whoAmI == Main.myPlayer && !Main.drawingPlayerChat && !Main.editSign && !Main.editChest && !Main.blockInput)
		{
			PlayerInput.Triggers.Current.CopyInto(this);
			TryOpeningInGameOptionsBasedOnInput();
		}
	}

	private void TryOpeningInGameOptionsBasedOnInput()
	{
		if (controlInv)
		{
			if (releaseInventory)
			{
				releaseInventory = false;
				if (Main.ingameOptionsWindow)
				{
					IngameOptions.Close();
				}
				else
				{
					IngameOptions.Open();
				}
			}
		}
		else
		{
			releaseInventory = true;
		}
	}

	public void UpdatePet(int i)
	{
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		if (i == Main.myPlayer && miscEquips[0].buffType >= 1 && miscEquips[0].stack >= 1)
		{
			int num = miscEquips[0].buffType;
			if ((Main.vanityPet[num] || Main.lightPet[num]) && !hideMisc[0] && (miscEquips[0].type != 603 || Main.runningCollectorsEdition) && FindBuffIndex(num) == -1)
			{
				AddBuff(num, 3600);
				SoundEngine.PlaySound(miscEquips[0].UseSound, position);
			}
		}
	}

	public void UpdatePetLight(int i)
	{
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		if (i != Main.myPlayer || miscEquips[1].buffType < 1 || miscEquips[1].stack < 1)
		{
			return;
		}
		int num = miscEquips[1].buffType;
		if ((!Main.vanityPet[num] && !Main.lightPet[num]) || hideMisc[1] || (miscEquips[1].type == 603 && !Main.runningCollectorsEdition))
		{
			return;
		}
		int num2 = FindBuffIndex(num);
		if (num == 27 && num2 == -1)
		{
			num2 = FindBuffIndex(102);
		}
		if (num == 27 && num2 == -1)
		{
			num2 = FindBuffIndex(101);
		}
		if (num2 == -1)
		{
			if (num == 27)
			{
				num = Utils.SelectRandom<int>(Main.rand, 27, 102, 101);
			}
			AddBuff(num, 3600);
			SoundEngine.PlaySound(miscEquips[1].UseSound, position);
		}
	}

	public void TogglePet()
	{
		hideMisc[0] = !hideMisc[0];
		if (hideMisc[0])
		{
			ClearBuff(miscEquips[0].buffType);
		}
	}

	public void ToggleLight()
	{
		hideMisc[1] = !hideMisc[1];
		if (hideMisc[1])
		{
			ClearBuff(miscEquips[1].buffType);
			if (miscEquips[1].buffType == 27)
			{
				ClearBuff(102);
				ClearBuff(101);
			}
		}
	}

	public bool IsWithinSnappngRangeToTile(int x, int y, int distanceInPixels)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = new Vector2((float)(x * 16 + 8), (float)(y * 16 + 8)) - new Vector2(base.Center.X, base.Bottom.Y - 16f);
		if (((Vector2)(ref val)).Length() <= (float)distanceInPixels)
		{
			return true;
		}
		return false;
	}

	public void SmartInteractLookup()
	{
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		Main.ClearSmartInteract();
		if (UILinkPointNavigator.InUse || (PlayerInput.UsingGamepad && Main.HoveringOverAnNPC))
		{
			Main.SmartInteractTileCoordsSelected.Clear();
		}
		bool showGamepadHints = PlayerInput.SettingsForUI.ShowGamepadHints;
		bool flag = showGamepadHints || Main.SmartCursorIsUsed;
		if (!flag && !showGamepadHints)
		{
			_smartInteractSys.Clear();
			return;
		}
		SmartInteractLookup_PrepareCommonlyUsedInfo(out var mousevec, out var LX, out var HX, out var LY, out var HY);
		_smartInteractSys.RunQuery(new SmartInteractScanSettings
		{
			DemandOnlyZeroDistanceTargets = (PlayerInput.SettingsForUI.ShowGamepadHints && !Main.SmartCursorIsUsed),
			FullInteraction = flag,
			HX = HX,
			HY = HY,
			LX = LX,
			LY = LY,
			mousevec = mousevec,
			player = this
		});
	}

	private void SmartInteractLookup_PrepareCommonlyUsedInfo(out Vector2 mousevec, out int LX, out int HX, out int LY, out int HY)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		mousevec = Main.ReverseGravitySupport(Main.MouseScreen) + Main.screenPosition;
		int num = 0;
		LX = (int)(position.X / 16f) - tileRangeX - num + 1;
		HX = (int)((position.X + (float)width) / 16f) + tileRangeX + num - 1;
		LY = (int)(position.Y / 16f) - tileRangeY - num + 1;
		HY = (int)((position.Y + (float)height) / 16f) + tileRangeY + num - 2;
		LX = Utils.Clamp(LX, 10, Main.maxTilesX - 10);
		HX = Utils.Clamp(HX, 10, Main.maxTilesX - 10);
		LY = Utils.Clamp(LY, 10, Main.maxTilesY - 10);
		HY = Utils.Clamp(HY, 10, Main.maxTilesY - 10);
	}

	public void SmartSelectLookup()
	{
		if (selectedItem == 58)
		{
			return;
		}
		if (mouseInterface)
		{
			controlTorch = false;
		}
		if (controlTorch && itemAnimation == 0)
		{
			PlayerInput.smartSelectPointer.SmartSelectLookup_GetTargetTile(this, out var tX, out var tY);
			SmartSelect_GetToolStrategy(tX, tY, out var toolStrategy, out var wetTile);
			if (PlayerInput.UsingGamepad && _lastSmartCursorToolStrategy != -1)
			{
				toolStrategy = _lastSmartCursorToolStrategy;
			}
			if (toolStrategy == 0 || toolStrategy == 4)
			{
				float num3 = Math.Abs((float)Main.mouseX + Main.screenPosition.X - (position.X + (float)(width / 2)));
				float num2 = Math.Abs((float)Main.mouseY + Main.screenPosition.Y - (position.Y + (float)(height / 2))) * 1.3f;
				if ((float)Math.Sqrt(num3 * num3 + num2 * num2) > 200f)
				{
					toolStrategy = 5;
				}
			}
			int modSelect = TileLoader.AutoSelect(tX, tY, this);
			if (modSelect >= 0)
			{
				SmartSelect_SelectItem(modSelect);
				return;
			}
			SmartSelect_PickToolForStrategy(tX, tY, toolStrategy, wetTile);
			_lastSmartCursorToolStrategy = toolStrategy;
		}
		else if (itemAnimation == 0 && DpadRadial.SelectedItem != -1 && inventory[DpadRadial.SelectedItem].stack > 0)
		{
			if (nonTorch == -1)
			{
				nonTorch = selectedItem;
			}
			selectedItem = DpadRadial.SelectedItem;
			_lastSmartCursorToolStrategy = -1;
		}
		else if (itemAnimation == 0 && CircularRadial.SelectedItem != -1 && inventory[CircularRadial.SelectedItem].stack > 0)
		{
			if (nonTorch == -1)
			{
				nonTorch = selectedItem;
			}
			selectedItem = CircularRadial.SelectedItem;
			_lastSmartCursorToolStrategy = -1;
		}
		else if (nonTorch > -1 && itemAnimation == 0)
		{
			selectedItem = nonTorch;
			nonTorch = -1;
			_lastSmartCursorToolStrategy = -1;
		}
	}

	private void SmartSelectLookup_GetTargetTile(out int tX, out int tY)
	{
		tX = (int)(((float)Main.mouseX + Main.screenPosition.X) / 16f);
		tY = (int)(((float)Main.mouseY + Main.screenPosition.Y) / 16f);
		if (gravDir == -1f)
		{
			tY = (int)((Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY) / 16f);
		}
	}

	private void SmartSelect_PickToolForStrategy(int tX, int tY, int toolStrategy, bool wetTile)
	{
		for (int i = 0; i < 50; i++)
		{
			int type = inventory[i].type;
			switch (toolStrategy)
			{
			case 0:
				if (ItemID.Sets.Torches[type])
				{
					SmartSelect_SelectItem(i);
					return;
				}
				if (ItemID.Sets.Glowsticks[type])
				{
					SmartSelect_SelectItem(i);
				}
				break;
			case 1:
				if (inventory[i].hammer > 0)
				{
					SmartSelect_SelectItem(i);
					return;
				}
				break;
			case 2:
				if (inventory[i].axe > 0)
				{
					SmartSelect_SelectItem(i);
					return;
				}
				break;
			case 3:
				if (inventory[i].pick > 0)
				{
					SmartSelect_SelectItem(i);
					return;
				}
				break;
			case 4:
				if (inventory[i].type != 930 && ItemID.Sets.Torches[type] && !ItemID.Sets.WaterTorches[type] && !ItemID.Sets.Glowsticks[type])
				{
					if (nonTorch == -1)
					{
						nonTorch = selectedItem;
					}
					if (inventory[selectedItem].createTile < 0 || !TileID.Sets.Torch[inventory[selectedItem].createTile])
					{
						selectedItem = i;
					}
					break;
				}
				if (ItemID.Sets.Glowsticks[type] && wetTile)
				{
					SmartSelect_SelectItem(i);
					return;
				}
				if (type == 930 && wetTile)
				{
					bool flag = false;
					for (int num = 57; num >= 0; num--)
					{
						if (inventory[num].ammo == inventory[i].useAmmo && inventory[num].stack > 0)
						{
							flag = true;
							break;
						}
					}
					if (!flag && !ItemLoader.NeedsAmmo(inventory[i], this))
					{
						flag = true;
					}
					if (flag)
					{
						SmartSelect_SelectItem(i);
						return;
					}
				}
				else if (ItemID.Sets.WaterTorches[type])
				{
					SmartSelect_SelectItem(i);
					return;
				}
				break;
			case 5:
			{
				if (ItemID.Sets.Torches[type])
				{
					if (nonTorch == -1)
					{
						nonTorch = selectedItem;
					}
					if (inventory[selectedItem].createTile < 0 || !TileID.Sets.Torch[inventory[selectedItem].createTile])
					{
						selectedItem = i;
					}
					break;
				}
				int thisType = type;
				switch (thisType)
				{
				case 930:
				{
					bool flag2 = false;
					for (int num2 = 57; num2 >= 0; num2--)
					{
						if (inventory[num2].ammo == inventory[i].useAmmo && inventory[num2].stack > 0)
						{
							flag2 = true;
							break;
						}
					}
					if (flag2)
					{
						SmartSelect_SelectItem(i);
						return;
					}
					goto end_IL_0016;
				}
				default:
					if (!ItemID.Sets.Glowsticks[thisType])
					{
						goto end_IL_0016;
					}
					break;
				case 282:
				case 286:
				case 3002:
				case 3112:
				case 4776:
					break;
				}
				SmartSelect_SelectItem(i);
				return;
			}
			case 6:
			{
				int num3 = Main.tile[tX, tY].frameX / 72;
				int num4 = -1;
				switch (num3)
				{
				case 0:
					num4 = 929;
					break;
				case 1:
					num4 = 1338;
					break;
				case 2:
					num4 = 1345;
					break;
				}
				if (type == num4)
				{
					SmartSelect_SelectItem(i);
					return;
				}
				break;
			}
			case 7:
			{
				ItemTrader itemTrader = TryGettingItemTraderFromBlock(Main.tile[tX, tY]);
				if (itemTrader != null && itemTrader.TryGetTradeOption(inventory[i], out var _))
				{
					SmartSelect_SelectItem(i);
					return;
				}
				if (ItemID.Sets.ExtractinatorMode[type] >= 0)
				{
					SmartSelect_SelectItem(i);
					return;
				}
				break;
			}
			case 8:
				{
					if (ItemID.Sets.IsPaintScraper[type])
					{
						SmartSelect_SelectItem(i);
						return;
					}
					break;
				}
				end_IL_0016:
				break;
			}
		}
	}

	private void SmartSelect_SelectItem(int t)
	{
		if (nonTorch == -1)
		{
			nonTorch = selectedItem;
		}
		selectedItem = t;
	}

	private void SmartSelect_GetToolStrategy(int tX, int tY, out int toolStrategy, out bool wetTile)
	{
		toolStrategy = 0;
		bool flag = false;
		wetTile = false;
		try
		{
			int num = 0;
			int num2 = 0;
			if (position.X / 16f >= (float)tX)
			{
				num = (int)(position.X / 16f) - tX;
			}
			if ((position.X + (float)width) / 16f <= (float)tX)
			{
				num = tX - (int)((position.X + (float)width) / 16f);
			}
			if (position.Y / 16f >= (float)tY)
			{
				num2 = (int)(position.Y / 16f) - tY;
			}
			if ((position.Y + (float)height) / 16f <= (float)tY)
			{
				num2 = tY - (int)((position.Y + (float)height) / 16f);
			}
			SmartSelect_GetAvailableToolRanges(out var pickRange, out var axeRange, out var hammerRange, out var cannonRange, out var extractItemRange, out var paintScraperRange);
			wetTile = Main.tile[tX, tY].liquid > 0;
			if (Main.tile[tX, tY].active())
			{
				int type = Main.tile[tX, tY].type;
				if ((type == 219 || type == 642) && num <= extractItemRange + tileRangeX && num2 <= extractItemRange + tileRangeY)
				{
					toolStrategy = 7;
					flag = true;
				}
				else if (type == 209 && num <= cannonRange + tileRangeX && num2 <= cannonRange + tileRangeY)
				{
					toolStrategy = 6;
					flag = true;
				}
				else if (Main.tileHammer[type] && num <= hammerRange + tileRangeX && num2 <= hammerRange + tileRangeY)
				{
					toolStrategy = 1;
					flag = true;
				}
				else if (Main.tileAxe[type] && num <= axeRange + tileRangeX && num2 <= axeRange + tileRangeY)
				{
					toolStrategy = 2;
					flag = true;
				}
				else if (type == 184 && num <= paintScraperRange + tileRangeX && num2 <= paintScraperRange + tileRangeY)
				{
					toolStrategy = 8;
					flag = true;
				}
				else if (num <= pickRange + tileRangeX && num2 <= pickRange + tileRangeY)
				{
					toolStrategy = 3;
					flag = true;
				}
			}
			else if (wetTile && wet)
			{
				toolStrategy = 4;
				flag = true;
			}
		}
		catch
		{
		}
		if (!flag && wet)
		{
			toolStrategy = 4;
		}
	}

	private void SmartSelect_GetAvailableToolRanges(out int pickRange, out int axeRange, out int hammerRange, out int cannonRange, out int extractItemRange, out int paintScraperRange)
	{
		pickRange = -10;
		axeRange = -10;
		hammerRange = -10;
		cannonRange = -10;
		extractItemRange = -10;
		paintScraperRange = -10;
		for (int i = 0; i < 50; i++)
		{
			if (inventory[i].pick > 0 && pickRange == -10)
			{
				pickRange = inventory[i].tileBoost;
			}
			if (inventory[i].axe > 0 && axeRange == -10)
			{
				axeRange = inventory[i].tileBoost;
			}
			if (inventory[i].hammer > 0 && hammerRange == -10)
			{
				hammerRange = inventory[i].tileBoost;
			}
			if ((inventory[i].type == 929 || inventory[i].type == 1338 || inventory[i].type == 1345) && cannonRange == -10)
			{
				cannonRange = inventory[i].tileBoost;
			}
			if (ItemID.Sets.IsPaintScraper[inventory[i].type] && paintScraperRange == -10)
			{
				paintScraperRange = inventory[i].tileBoost;
			}
			if (ItemID.Sets.ExtractinatorMode[inventory[i].type] != -1 && extractItemRange == -10)
			{
				extractItemRange = inventory[i].tileBoost;
			}
		}
	}

	private void EndOngoingTorchGodEvent()
	{
		if (happyFunTorchTime)
		{
			RelightTorches();
			happyFunTorchTime = false;
			if (Main.netMode == 1)
			{
				NetMessage.SendData(4, -1, -1, null, whoAmI);
			}
		}
	}

	private void TryRecalculatingTorchLuck()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		if (happyFunTorchTime)
		{
			luckyTorchCounter = 0;
			TorchAttack();
			return;
		}
		if (torchGodCooldown > 0)
		{
			torchGodCooldown--;
		}
		Vector2 nextTorchLuckCheckCenter = _nextTorchLuckCheckCenter;
		if (((double)nextTorchLuckCheckCenter.Y < Main.worldSurface * 16.0) | dead)
		{
			UpdateTorchLuck_ConsumeCountersAndCalculate();
			return;
		}
		int num = 1;
		int num2 = 40;
		int num3 = (int)nextTorchLuckCheckCenter.Y / 16 - num2;
		int value = (int)nextTorchLuckCheckCenter.X / 16 - num2;
		int value2 = (int)nextTorchLuckCheckCenter.X / 16 + num2;
		value = Utils.Clamp(value, 10, Main.maxTilesX - 10);
		value2 = Utils.Clamp(value2, 10, Main.maxTilesX - 10);
		for (int i = 0; i < num; i++)
		{
			int num4 = num3 + i + luckyTorchCounter * num;
			if (num4 < 10 || num4 > Main.maxTilesY - 10)
			{
				continue;
			}
			for (int j = value; j <= value2; j++)
			{
				Tile tile = Main.tile[j, num4];
				if (tile == null)
				{
					return;
				}
				if (tile.type >= TileID.Count)
				{
					if (tile.active() && TileID.Sets.Torch[tile.type])
					{
						NearbyModTorch.Add(tile.type);
					}
				}
				else
				{
					if (!tile.active() || tile.type != 4 || tile.frameX < 0 || tile.frameY < 0)
					{
						continue;
					}
					if (tile.frameX < 66)
					{
						nearbyTorches++;
					}
					int num5 = tile.frameY / 22;
					if (num5 < TorchID.Count)
					{
						nearbyTorch[num5] = true;
						if (num5 == 17 && (tile.liquid == 0 || tile.liquidType() != 0))
						{
							dryCoralTorch = true;
						}
					}
				}
			}
			if (num4 >= (int)nextTorchLuckCheckCenter.Y / 16 + num2)
			{
				UpdateTorchLuck_ConsumeCountersAndCalculate();
				return;
			}
		}
		luckyTorchCounter++;
	}

	private void RelightTorches()
	{
		torchGodCooldown = 3600;
		for (int i = 0; i < numberOfTorchAttacksMade; i++)
		{
			int num = unlitTorchX[i];
			int num2 = unlitTorchY[i];
			Tile tile = Main.tile[num, num2];
			if (tile.type == 4)
			{
				tile = Main.tile[num, num2];
				if (tile.frameX >= 66)
				{
					tile = Main.tile[num, num2];
					tile.frameX -= 66;
					NetMessage.SendTileSquare(-1, num, num2);
				}
			}
		}
	}

	private void TorchAttack()
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0350: Unknown result type (might be due to invalid IL or missing references)
		//IL_0355: Unknown result type (might be due to invalid IL or missing references)
		//IL_0357: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_036e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0372: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_0383: Unknown result type (might be due to invalid IL or missing references)
		if (whoAmI != Main.myPlayer)
		{
			return;
		}
		if ((double)position.Y < Main.worldSurface * 16.0)
		{
			EndOngoingTorchGodEvent();
			return;
		}
		AddBuff(80, 2);
		torchFunTimer++;
		if (torchFunTimer <= 20)
		{
			return;
		}
		torchFunTimer = 0;
		int num = 0;
		int num4 = 100;
		int value5 = (int)base.Center.X / 16 - num4;
		int value2 = (int)base.Center.X / 16 + num4;
		int value3 = (int)base.Center.Y / 16 - num4;
		int value4 = (int)base.Center.Y / 16 + num4;
		int num11 = Utils.Clamp(value5, 10, Main.maxTilesX - 10);
		value2 = Utils.Clamp(value2, 10, Main.maxTilesX - 10);
		value3 = Utils.Clamp(value3, 10, Main.maxTilesY - 10);
		value4 = Utils.Clamp(value4, 10, Main.maxTilesY - 10);
		for (int i = num11; i <= value2; i++)
		{
			for (int j = value3; j <= value4; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile != null && (tile.active() & (tile.type == 4)) && tile.frameX < 66)
				{
					_torchAttackPosX[num] = i;
					_torchAttackPosY[num] = j;
					num++;
					if (num >= _torchAttackPosX.Length)
					{
						break;
					}
				}
			}
			if (num >= _torchAttackPosX.Length)
			{
				break;
			}
		}
		if (num == 0 || numberOfTorchAttacksMade >= maxTorchAttacks)
		{
			RelightTorches();
			happyFunTorchTime = false;
			if (Main.netMode == 1)
			{
				NetMessage.SendData(4, -1, -1, null, whoAmI);
			}
			if (numberOfTorchAttacksMade >= 95)
			{
				int number = Item.NewItem(GetItemSource_Misc(6), (int)position.X, (int)position.Y, width, height, 5043);
				if (Main.netMode == 1)
				{
					NetMessage.SendData(21, -1, -1, null, number, 1f);
				}
			}
		}
		else
		{
			if (num <= 0)
			{
				return;
			}
			int num5 = Main.rand.Next(num);
			int num6 = _torchAttackPosX[num5];
			int num7 = _torchAttackPosY[num5];
			Tile tile2 = Main.tile[num6, num7];
			if (tile2.type != 4)
			{
				return;
			}
			tile2 = Main.tile[num6, num7];
			if (tile2.frameX < 66)
			{
				float num8 = 8f;
				int num9 = 20;
				if (num9 < 10)
				{
					num9 = 10;
				}
				tile2 = Main.tile[num6, num7];
				int num10 = (int)MathHelper.Clamp((float)(tile2.frameY / 22), 0f, (float)(TorchID.Count - 1));
				num10 = TorchID.Dust[num10];
				tile2 = Main.tile[num6, num7];
				tile2.frameX += 66;
				unlitTorchX[numberOfTorchAttacksMade] = num6;
				unlitTorchY[numberOfTorchAttacksMade] = num7;
				numberOfTorchAttacksMade++;
				NetMessage.SendTileSquare(-1, num6, num7);
				Vector2 vector = default(Vector2);
				((Vector2)(ref vector))._002Ector((float)(num6 * 16 + 8), (float)(num7 * 16));
				Vector2 vector2 = base.Center - vector;
				float num2 = ((Vector2)(ref vector2)).Length();
				((Vector2)(ref vector2)).Normalize();
				vector2 *= num8;
				int num3 = Projectile.NewProjectile(GetProjectileSource_Misc(10), vector, vector2, 949, num9, 1f, whoAmI, num10, num2);
				Main.projectile[num3].ai[0] = num10;
				Main.projectile[num3].ai[1] = num2;
				Main.projectile[num3].netUpdate = true;
				if ((num == 1 && numberOfTorchAttacksMade >= 95) || numberOfTorchAttacksMade >= maxTorchAttacks)
				{
					torchFunTimer = -180;
				}
			}
		}
	}

	private void UpdateTorchLuck_ConsumeCountersAndCalculate()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		luckyTorchCounter = 0;
		torchLuck = 0f;
		_nextTorchLuckCheckCenter = base.Center;
		if (inventory[selectedItem].createTile == 4 && inventory[selectedItem].placeStyle < TorchID.Count)
		{
			nearbyTorch[inventory[selectedItem].placeStyle] = true;
		}
		ModTile modTile = TileLoader.GetTile(inventory[selectedItem].createTile);
		if (modTile != null && TileID.Sets.Torch[modTile.Type])
		{
			NearbyModTorch.Add(modTile.Type);
		}
		float num = 0f;
		float num2 = 0f;
		if (!ZoneDungeon && !ZoneLihzhardTemple)
		{
			if (nearbyTorch[9])
			{
				if (ZoneSnow)
				{
					num2 += 1f;
				}
				else
				{
					num += 1f;
				}
			}
			if (nearbyTorch[16])
			{
				if (ZoneDesert)
				{
					num2 += 1f;
				}
				else
				{
					num += 1f;
				}
			}
			if (nearbyTorch[17])
			{
				if (WorldGen.oceanDepths((int)base.Center.X / 16, (int)base.Center.Y / 16))
				{
					num2 += 1f;
				}
				else if (dryCoralTorch)
				{
					num += 1f;
				}
			}
			if (nearbyTorch[21])
			{
				if (ZoneJungle)
				{
					num2 += 1f;
				}
				else
				{
					num += 1f;
				}
			}
			if (nearbyTorch[22])
			{
				if (ZoneGlowshroom)
				{
					num2 += 1f;
				}
				else
				{
					num += 1f;
				}
			}
			if (nearbyTorch[18])
			{
				if (ZoneCorrupt)
				{
					num2 += 1f;
				}
				else
				{
					num += 1f;
				}
			}
			if (nearbyTorch[8] && ZoneCorrupt)
			{
				num2 += 1f;
			}
			if (nearbyTorch[19])
			{
				if (ZoneCrimson)
				{
					num2 += 1f;
				}
				else
				{
					num += 1f;
				}
			}
			if (nearbyTorch[11] && ZoneCrimson)
			{
				num2 += 1f;
			}
			if (nearbyTorch[20])
			{
				if (ZoneHallow)
				{
					num2 += 1f;
				}
				else
				{
					num += 1f;
				}
			}
			if (nearbyTorch[13] && !ZoneSnow && !ZoneDesert && !ZoneCorrupt && !ZoneCrimson && !ZoneHallow && !ZoneJungle)
			{
				num2 += 0.5f;
			}
			if (nearbyTorch[0])
			{
				if (ZoneSnow)
				{
					num += 2f;
				}
				else if (ZoneDesert || ZoneCorrupt || ZoneCrimson || ZoneHallow)
				{
					num += 0.5f;
				}
			}
		}
		TileLoader.ModifyTorchLuck(this, ref num2, ref num);
		if (num2 >= 1f)
		{
			torchLuck += 1f;
		}
		else if (num2 > 0f)
		{
			torchLuck += 0.5f;
		}
		if (num >= 2f)
		{
			torchLuck += -1.5f;
		}
		else if (num >= 1f)
		{
			torchLuck += -1f;
		}
		else if (num > 0f)
		{
			torchLuck += -0.5f;
		}
		dryCoralTorch = false;
		for (int i = 0; i < TorchID.Count; i++)
		{
			nearbyTorch[i] = false;
		}
		NearbyModTorch.Clear();
		if (torchLuck < 0f)
		{
			torchLuck = 0f;
		}
		if (torchGodCooldown <= 0 && !unlockedBiomeTorches && nearbyTorches > 100 && !happyFunTorchTime && (double)position.Y > Main.worldSurface * 16.0)
		{
			bool flag = false;
			for (int j = 0; j < inventory.Length; j++)
			{
				if (inventory[j].type == 5043)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				happyFunTorchTime = true;
				numberOfTorchAttacksMade = 0;
			}
		}
		nearbyTorches = 0;
	}

	public void AddCoinLuck(Vector2 coinPosition, int coinAmount)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		if (!dead && Vector2.Distance(coinPosition, base.Center) < 1000f)
		{
			coinLuck += coinAmount;
			if (coinLuck > 1000000f)
			{
				coinLuck = 1000000f;
			}
			luckNeedsSync = true;
		}
	}

	private void UpdateCoinLuck()
	{
		if (!(coinLuck <= 0f))
		{
			coinLuck *= 0.9999f;
			if ((double)coinLuck < 0.25)
			{
				coinLuck = 0f;
			}
		}
	}

	private float CalculateCoinLuck()
	{
		if (coinLuck == 0f)
		{
			return 0f;
		}
		if (coinLuck > 249000f)
		{
			return 0.2f;
		}
		if (coinLuck > 24900f)
		{
			return 0.175f;
		}
		if (coinLuck > 24900f)
		{
			return 0.175f;
		}
		if (coinLuck > 2490f)
		{
			return 0.15f;
		}
		if (coinLuck > 249f)
		{
			return 0.125f;
		}
		if ((double)coinLuck > 24.9)
		{
			return 0.1f;
		}
		if ((double)coinLuck > 2.49)
		{
			return 0.075f;
		}
		if ((double)coinLuck > 0.249)
		{
			return 0.05f;
		}
		return 0.025f;
	}

	private float GetLadyBugLuck()
	{
		if (ladyBugLuckTimeLeft > 0.0)
		{
			return (float)ladyBugLuckTimeLeft / (float)NPC.ladyBugGoodLuckTime;
		}
		if (ladyBugLuckTimeLeft < 0.0)
		{
			return (0f - (float)ladyBugLuckTimeLeft) / (float)NPC.ladyBugBadLuckTime;
		}
		return 0f;
	}

	public static float GetClosestPlayersLuck(Point Position)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		return Main.player[FindClosest(new Vector2((float)(Position.X * 16), (float)(Position.Y * 16)), 1, 1)].luck;
	}

	public static float GetClosestPlayersLuck(Vector2 Position)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		return Main.player[FindClosest(Position, 1, 1)].luck;
	}

	public int RollLuck(int range)
	{
		if (luck > 0f && Main.rand.NextFloat() < luck)
		{
			return Main.rand.Next(Main.rand.Next(range / 2, range));
		}
		if (luck < 0f && Main.rand.NextFloat() < 0f - luck)
		{
			return Main.rand.Next(Main.rand.Next(range, range * 2));
		}
		return Main.rand.Next(range);
	}

	public static float GetClosestRollLuck(Vector2 position, int range)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		return Main.player[FindClosest(position, 1, 1)].RollLuck(range);
	}

	public static float GetClosestRollLuck(int x, int y, int range)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		return Main.player[FindClosest(new Vector2((float)(x * 16), (float)(y * 16)), 1, 1)].RollLuck(range);
	}

	public void ResetEffects()
	{
		if (extraAccessory && (Main.expertMode || Main.gameMenu))
		{
			extraAccessorySlots = 1;
		}
		else
		{
			extraAccessorySlots = 0;
		}
		if (shimmering)
		{
			shimmerTransparency += 0.015f;
			if (shimmerTransparency > 0.8f)
			{
				shimmerTransparency = 0.8f;
			}
		}
		else if (shimmerTransparency > 0f)
		{
			if (shimmerTransparency == 0.8f)
			{
				SoundEngine.PlaySound(19, (int)position.X, (int)position.Y, 3);
			}
			shimmerTransparency -= 0.015f;
			if (shimmerTransparency < 0f)
			{
				shimmerTransparency = 0f;
			}
		}
		shimmering = false;
		fairyBoots = false;
		hellfireTreads = false;
		moonLordLegs = false;
		flowerBoots = false;
		arcticDivingGear = false;
		noBuilding = false;
		strongBees = false;
		ashWoodBonus = false;
		shroomiteStealth = false;
		statDefense = DefenseStat.Default;
		DefenseEffectiveness = MultipliableFloat.One * VanillaBaseDefenseEffectiveness();
		accWatch = 0;
		accCompass = 0;
		accDepthMeter = 0;
		accDivingHelm = false;
		canFloatInWater = false;
		lifeRegen = 0;
		manaCost = 1f;
		hasFootball = false;
		drawingFootball = false;
		minionKB = 0f;
		moveSpeed = 1f;
		boneArmor = false;
		honey = false;
		frostArmor = false;
		rocketBoots = 0;
		vanityRocketBoots = 0;
		fireWalk = false;
		noKnockback = false;
		jumpBoost = false;
		frogLegJumpBoost = false;
		skyStoneEffects = false;
		noFallDmg = false;
		spawnMax = false;
		spaceGun = false;
		killGuide = false;
		killClothier = false;
		lavaImmune = false;
		gills = false;
		slowFall = false;
		findTreasure = false;
		biomeSight = false;
		invis = false;
		nightVision = false;
		enemySpawns = false;
		hasTitaniumStormBuff = false;
		thorns = 0f;
		aggro = 0;
		waterWalk = false;
		waterWalk2 = false;
		detectCreature = false;
		gravControl = false;
		if (forcedGravity > 0)
		{
			forcedGravity--;
		}
		honeyCombItem = null;
		gravControl2 = false;
		PlayerLoader.ModifyMaxStats(this);
		statLifeMax2 = statLifeMax;
		statManaMax2 = statManaMax;
		chloroAmmoCost80 = false;
		huntressAmmoCost90 = false;
		ammoCost80 = false;
		ammoCost75 = false;
		ThrownCost50 = false;
		ThrownCost33 = false;
		ThrownVelocity = 1f;
		manaRegenBuff = false;
		hasCreditsSceneMusicBox = false;
		arrowDamage = StatModifier.Default;
		bulletDamage = StatModifier.Default;
		specialistDamage = StatModifier.Default;
		coolWhipBuff = false;
		yoraiz0rEye = 0;
		yoraiz0rDarkness = false;
		hasFloatingTube = false;
		hasUnicornHorn = false;
		hasAngelHalo = false;
		hasRainbowCursor = false;
		leinforsHair = false;
		overrideFishingBobber = -1;
		suspiciouslookingTentacle = false;
		crimsonHeart = false;
		lightOrb = false;
		blueFairy = false;
		redFairy = false;
		greenFairy = false;
		wisp = false;
		bunny = false;
		turtle = false;
		eater = false;
		trident = false;
		skeletron = false;
		hornet = false;
		zephyrfish = false;
		tiki = false;
		lizard = false;
		parrot = false;
		sapling = false;
		cSapling = false;
		truffle = false;
		yoyoGlove = false;
		counterWeight = 0;
		stringColor = 0;
		yoyoString = false;
		shadowDodge = false;
		palladiumRegen = false;
		chaosState = false;
		onHitDodge = false;
		onHitRegen = false;
		onHitPetal = false;
		iceBarrier = false;
		onHitTitaniumStorm = false;
		maxMinions = 1;
		maxTurrets = 1;
		ammoBox = false;
		ammoPotion = false;
		penguin = false;
		sporeSac = false;
		shinyStone = false;
		empressBrooch = false;
		volatileGelatin = false;
		hasMagiluminescence = false;
		shadowArmor = false;
		if (Main.dontStarveWorld && Main.remixWorld)
		{
			dontStarveShader = false;
		}
		else
		{
			dontStarveShader = Main.dontStarveWorld;
		}
		eyebrellaCloud = false;
		stardustMonolithShader = false;
		nebulaMonolithShader = false;
		vortexMonolithShader = false;
		solarMonolithShader = false;
		moonLordMonolithShader = false;
		bloodMoonMonolithShader = false;
		shimmerMonolithShader = false;
		dd2Accessory = false;
		magicLantern = false;
		rabid = false;
		sunflower = false;
		wellFed = false;
		inferno = false;
		manaMagnet = false;
		lifeMagnet = false;
		treasureMagnet = false;
		chiselSpeed = false;
		lifeForce = false;
		dangerSense = false;
		endurance = 0f;
		whipRangeMultiplier = 1f;
		calmed = false;
		beetleOrbs = 0;
		beetleBuff = false;
		miniMinotaur = false;
		goldRing = false;
		solarShields = 0;
		GoingDownWithGrapple = false;
		fishingSkill = 0;
		cratePotion = false;
		sonarPotion = false;
		accTackleBox = false;
		accFishingBobber = false;
		accFishingLine = false;
		accLavaFishing = false;
		accFishFinder = false;
		accWeatherRadio = false;
		accThirdEye = false;
		InfoAccMechShowWires = false;
		accJarOfSouls = false;
		accCalendar = false;
		accStopwatch = false;
		accOreFinder = false;
		accCritterGuide = false;
		accDreamCatcher = false;
		wallSpeed = 1f;
		tileSpeed = 1f;
		autoPaint = false;
		autoActuator = false;
		petFlagKingSlimePet = false;
		petFlagEyeOfCthulhuPet = false;
		petFlagEaterOfWorldsPet = false;
		petFlagBrainOfCthulhuPet = false;
		petFlagSkeletronPet = false;
		petFlagQueenBeePet = false;
		petFlagDestroyerPet = false;
		petFlagTwinsPet = false;
		petFlagSkeletronPrimePet = false;
		petFlagPlanteraPet = false;
		petFlagGolemPet = false;
		petFlagDukeFishronPet = false;
		petFlagLunaticCultistPet = false;
		petFlagMoonLordPet = false;
		petFlagFairyQueenPet = false;
		petFlagPumpkingPet = false;
		petFlagEverscreamPet = false;
		petFlagIceQueenPet = false;
		petFlagMartianPet = false;
		petFlagDD2OgrePet = false;
		petFlagDD2BetsyPet = false;
		petFlagQueenSlimePet = false;
		petFlagVoltBunny = false;
		petFlagShadowMimic = false;
		petFlagBabyWerewolf = false;
		petFlagDynamiteKitten = false;
		petFlagPlantero = false;
		petFlagBabyRedPanda = false;
		petFlagLilHarpy = false;
		petFlagFennecFox = false;
		petFlagGlitteryButterfly = false;
		petFlagBabyImp = false;
		petFlagBabyShark = false;
		petFlagUpbeatStar = false;
		petFlagDD2Gato = false;
		petFlagDD2Dragon = false;
		petFlagDD2Ghost = false;
		petFlagBerniePet = false;
		petFlagGlommerPet = false;
		petFlagDeerclopsPet = false;
		petFlagPigPet = false;
		petFlagChesterPet = false;
		petFlagJunimoPet = false;
		petFlagBlueChickenPet = false;
		petFlagSpiffo = false;
		petFlagCaveling = false;
		petFlagDirtiestBlock = false;
		companionCube = false;
		petFlagSugarGlider = false;
		babyFaceMonster = false;
		manaSick = false;
		puppy = false;
		grinch = false;
		blackCat = false;
		spider = false;
		squashling = false;
		magicCuffs = false;
		coldDash = false;
		desertDash = false;
		desertBoots = false;
		sailDash = false;
		cordage = false;
		magicQuiver = false;
		shimmerImmune = false;
		hasMoltenQuiver = false;
		magmaStone = false;
		hasRaisableShield = false;
		lavaRose = false;
		eyeSpring = false;
		snowman = false;
		scope = false;
		panic = false;
		brainOfConfusionItem = null;
		dino = false;
		crystalLeaf = false;
		pygmy = false;
		raven = false;
		slime = false;
		hornetMinion = false;
		impMinion = false;
		twinsMinion = false;
		spiderMinion = false;
		pirateMinion = false;
		sharknadoMinion = false;
		stardustMinion = false;
		batsOfLight = false;
		babyBird = false;
		stormTiger = false;
		flinxMinion = false;
		abigailMinion = false;
		smolstar = false;
		empressBlade = false;
		stardustGuardian = false;
		stardustDragon = false;
		UFOMinion = false;
		DeadlySphereMinion = false;
		chilled = false;
		tipsy = false;
		dazed = false;
		frozen = false;
		stoned = false;
		webbed = false;
		ichor = false;
		manaRegenBonus = 0;
		manaRegenDelayBonus = 0f;
		carpet = false;
		iceSkate = false;
		dashType = 0;
		spikedBoots = 0;
		blackBelt = false;
		lavaMax = 0;
		archery = false;
		poisoned = false;
		venom = false;
		blind = false;
		blackout = false;
		onFire = false;
		dripping = false;
		hungry = false;
		heartyMeal = false;
		starving = false;
		drippingSlime = false;
		drippingSparkleSlime = false;
		burned = false;
		suffocating = false;
		onFire2 = false;
		onFire3 = false;
		onFrostBurn = false;
		onFrostBurn2 = false;
		frostBurn = false;
		noItems = false;
		cursed = false;
		blockRange = 0;
		pickSpeed = 1f;
		wereWolf = false;
		rulerGrid = false;
		rulerLine = true;
		bleed = false;
		confused = false;
		witheredArmor = false;
		witheredWeapon = false;
		parryDamageBuff = false;
		slowOgreSpit = false;
		wings = 0;
		wingsLogic = 0;
		equippedWings = null;
		wingTimeMax = 0;
		brokenArmor = false;
		silence = false;
		slow = false;
		gross = false;
		tongued = false;
		kbGlove = false;
		autoReuseGlove = false;
		meleeScaleGlove = false;
		remoteVisionForDrone = false;
		kbBuff = false;
		starCloakItem = null;
		starCloakItem_manaCloakOverrideItem = null;
		starCloakItem_starVeilOverrideItem = null;
		starCloakItem_beeCloakOverrideItem = null;
		longInvince = false;
		pStone = false;
		manaFlower = false;
		crimsonRegen = false;
		ghostHeal = false;
		ghostHurt = false;
		turtleArmor = false;
		turtleThorns = false;
		cactusThorns = false;
		spiderArmor = false;
		anglerSetSpawnReduction = false;
		loveStruck = false;
		stinky = false;
		dryadWard = false;
		resistCold = false;
		electrified = false;
		moonLeech = false;
		headcovered = false;
		vortexDebuff = false;
		windPushed = false;
		ballistaPanic = false;
		vampireFrog = false;
		CanSeeInvisibleBlocks = false;
		setVortex = (setNebula = (setStardust = false));
		setForbidden = false;
		setHuntressT3 = false;
		setSquireT3 = false;
		setMonkT3 = false;
		setApprenticeT3 = false;
		setHuntressT2 = false;
		setSquireT2 = false;
		setMonkT2 = false;
		setApprenticeT2 = false;
		setForbiddenCooldownLocked = false;
		nebulaLevelDamage = (nebulaLevelLife = (nebulaLevelMana = 0));
		ignoreWater = false;
		meleeEnchant = 0;
		discountEquipped = false;
		hasLuckyCoin = false;
		boneGloveItem = null;
		hasLuck_LuckyCoin = false;
		hasLuck_LuckyHorseshoe = false;
		blockExtraJumps = false;
		ExtraJumpLoader.ResetEnableFlags(this);
		defendedByPaladin = false;
		hasPaladinShield = false;
		hasLucyTheAxe = false;
		preventAllItemPickups = false;
		dontHurtCritters = false;
		dontHurtNature = false;
		portableStoolInfo.Reset();
		ResizeHitbox();
		autoJump = false;
		justJumped = false;
		jumpSpeedBoost = 0f;
		extraFall = 0;
		creativeGodMode = false;
		if (phantasmTime > 0)
		{
			phantasmTime--;
		}
		if (brainOfConfusionDodgeAnimationCounter > 0)
		{
			brainOfConfusionDodgeAnimationCounter--;
		}
		if (wireOperationsCooldown > 0)
		{
			wireOperationsCooldown--;
		}
		if (releaseUseItem)
		{
			ActuationRodLock = false;
		}
		for (int i = 0; i < npcTypeNoAggro.Length; i++)
		{
			npcTypeNoAggro[i] = false;
		}
		ResetProjectileCaches();
		if (whoAmI == Main.myPlayer && !isDisplayDollOrInanimate)
		{
			equipmentBasedLuckBonus = 0f;
			luckPotion = 0;
			tileRangeX = 5;
			tileRangeY = 4;
			if (Main.GameModeInfo.IsJourneyMode)
			{
				CreativePowers.FarPlacementRangePower power = CreativePowerManager.Instance.GetPower<CreativePowers.FarPlacementRangePower>();
				if (power.GetIsUnlocked() && power.IsEnabledForPlayer(whoAmI))
				{
					tileRangeX *= 2;
					tileRangeY *= 2;
					tileRangeX += 8;
					tileRangeY += 8;
				}
			}
		}
		ResetDamageClassData();
		mount.CheckMountBuff(this);
		PlayerLoader.ResetEffects(this);
		PlayerLoader.ResetInfoAccessories(this);
	}

	private void UpdateLadyBugLuckTime()
	{
		if (ladyBugLuckTimeLeft > 0.0)
		{
			ladyBugLuckTimeLeft -= Main.desiredWorldEventsUpdateRate;
			if (ladyBugLuckTimeLeft < 0.0)
			{
				ladyBugLuckTimeLeft = 0.0;
			}
		}
		else if (ladyBugLuckTimeLeft < 0.0)
		{
			ladyBugLuckTimeLeft += Main.desiredWorldEventsUpdateRate;
			if (ladyBugLuckTimeLeft > 0.0)
			{
				ladyBugLuckTimeLeft = 0.0;
			}
		}
	}

	public void UpdateImmunity()
	{
		if (immune)
		{
			immuneTime--;
			if (immuneTime <= 0)
			{
				immune = false;
				immuneNoBlink = false;
			}
			if (immuneNoBlink)
			{
				immuneAlpha = 0;
			}
			else
			{
				immuneAlpha += immuneAlphaDirection * 50;
				if (immuneAlpha <= 50)
				{
					immuneAlphaDirection = 1;
				}
				else if (immuneAlpha >= 205)
				{
					immuneAlphaDirection = -1;
				}
			}
		}
		else
		{
			immuneAlpha = 0;
		}
		for (int i = 0; i < hurtCooldowns.Length; i++)
		{
			if (hurtCooldowns[i] > 0)
			{
				hurtCooldowns[i]--;
			}
		}
	}

	private void TryToPoop()
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		if (whoAmI != Main.myPlayer || !wellFed)
		{
			return;
		}
		int maxValue = 600;
		if (Main.rand.Next(maxValue) != 0)
		{
			return;
		}
		int num = 3;
		int num2 = FindBuffIndex(207);
		if (num2 == -1)
		{
			num = 2;
			num2 = FindBuffIndex(206);
		}
		if (num2 == -1)
		{
			num = 1;
			num2 = FindBuffIndex(26);
		}
		if (num2 != -1)
		{
			int num4 = buffTime[num2];
			DelBuff(num2);
			int stack = Utils.Clamp(num4 / 3600 * num, num, 999);
			Vector2 mountedCenter = MountedCenter;
			ParticleOrchestrator.RequestParticleSpawn(clientOnly: false, ParticleOrchestraType.Digestion, new ParticleOrchestraSettings
			{
				PositionInWorld = mountedCenter,
				MovementVector = new Vector2((float)(-direction), 0f)
			}, whoAmI);
			int num3 = Item.NewItem(GetItemSource_Misc(9), mountedCenter, Vector2.Zero, 5395, stack, noBroadcast: false, 0, noGrabDelay: true);
			if (Main.netMode == 0)
			{
				Main.item[num3].noGrabDelay = 100;
			}
			if (Main.netMode == 1)
			{
				NetMessage.SendData(21, -1, -1, null, num3);
			}
		}
	}

	public void UpdateLifeRegen()
	{
		//IL_0a81: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a86: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0800: Unknown result type (might be due to invalid IL or missing references)
		//IL_0805: Unknown result type (might be due to invalid IL or missing references)
		//IL_0848: Unknown result type (might be due to invalid IL or missing references)
		//IL_085f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0864: Unknown result type (might be due to invalid IL or missing references)
		//IL_086e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0870: Unknown result type (might be due to invalid IL or missing references)
		//IL_087c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0883: Unknown result type (might be due to invalid IL or missing references)
		//IL_0888: Unknown result type (might be due to invalid IL or missing references)
		//IL_0893: Unknown result type (might be due to invalid IL or missing references)
		//IL_0898: Unknown result type (might be due to invalid IL or missing references)
		//IL_089a: Unknown result type (might be due to invalid IL or missing references)
		//IL_089f: Unknown result type (might be due to invalid IL or missing references)
		//IL_08eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_090e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0914: Unknown result type (might be due to invalid IL or missing references)
		//IL_0939: Unknown result type (might be due to invalid IL or missing references)
		//IL_0943: Unknown result type (might be due to invalid IL or missing references)
		//IL_0948: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c41: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c46: Unknown result type (might be due to invalid IL or missing references)
		//IL_0caa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0caf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d69: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d6e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d13: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d18: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b9e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ba3: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		if (shinyStone && IsStandingStillForSpecialEffects && itemAnimation == 0)
		{
			flag = true;
		}
		if (poisoned)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			lifeRegenTime = 0f;
			lifeRegen -= 4;
		}
		if (venom)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			lifeRegenTime = 0f;
			lifeRegen -= 30;
		}
		if (onFire)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			lifeRegenTime = 0f;
			lifeRegen -= 8;
		}
		if (onFire3)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			lifeRegenTime = 0f;
			lifeRegen -= 8;
		}
		if (onFrostBurn)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			lifeRegenTime = 0f;
			lifeRegen -= 16;
		}
		if (onFrostBurn2)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			lifeRegenTime = 0f;
			lifeRegen -= 16;
		}
		if (onFire2)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			lifeRegenTime = 0f;
			lifeRegen -= 24;
		}
		if (burned)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			lifeRegenTime = 0f;
			lifeRegen -= 60;
			moveSpeed *= 0.5f;
		}
		if (suffocating)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			lifeRegenTime = 0f;
			lifeRegen -= 40;
		}
		if (electrified)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			lifeRegenTime = 0f;
			lifeRegen -= 8;
			if (controlLeft || controlRight)
			{
				lifeRegen -= 32;
			}
		}
		if (tongued && Main.expertMode)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			lifeRegenTime = 0f;
			lifeRegen -= 100;
		}
		PlayerLoader.UpdateBadLifeRegen(this);
		if (honey && lifeRegen < 0)
		{
			lifeRegen += 4;
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
		}
		if (lifeRegen < 0 && nebulaLevelLife > 0)
		{
			lifeRegen = 0;
		}
		if (flag && lifeRegen < 0)
		{
			lifeRegen /= 2;
		}
		lifeRegenTime += 1f;
		if (usedAegisCrystal)
		{
			lifeRegenTime += 0.2f;
		}
		if (crimsonRegen)
		{
			lifeRegenTime += 1f;
		}
		if (soulDrain > 0)
		{
			lifeRegenTime += 2f;
		}
		if (flag)
		{
			if (lifeRegenTime > 90f && lifeRegenTime < 1800f)
			{
				lifeRegenTime = 1800f;
			}
			lifeRegenTime += 4f;
			lifeRegen += 4;
		}
		if (honey)
		{
			lifeRegenTime += 2f;
			lifeRegen += 2;
		}
		if (starving)
		{
			if (lifeRegen > 0)
			{
				lifeRegen = 0;
			}
			if (lifeRegenCount > 0)
			{
				lifeRegenCount = 0;
			}
			if (lifeRegenTime > 0f)
			{
				lifeRegenTime = 0f;
			}
			int num = 3000;
			int num7 = 120 * statLifeMax2 / num;
			if (num7 < 4)
			{
				num7 = 4;
			}
			lifeRegen = -num7;
		}
		if (soulDrain > 0)
		{
			int num8 = (5 + soulDrain) / 2;
			lifeRegenTime += num8;
			lifeRegen += num8;
		}
		if (heartyMeal)
		{
			int num9 = 6;
			lifeRegen += num9;
		}
		if (whoAmI == Main.myPlayer && Main.SceneMetrics.HasCampfire)
		{
			lifeRegen++;
		}
		if (whoAmI == Main.myPlayer && Main.SceneMetrics.HasHeartLantern)
		{
			lifeRegen += 2;
		}
		PlayerLoader.UpdateLifeRegen(this);
		if (bleed)
		{
			lifeRegenTime = 0f;
		}
		float num10 = 0f;
		if (lifeRegenTime >= 300f)
		{
			num10 += 1f;
		}
		if (lifeRegenTime >= 600f)
		{
			num10 += 1f;
		}
		if (lifeRegenTime >= 900f)
		{
			num10 += 1f;
		}
		if (lifeRegenTime >= 1200f)
		{
			num10 += 1f;
		}
		if (lifeRegenTime >= 1500f)
		{
			num10 += 1f;
		}
		if (lifeRegenTime >= 1800f)
		{
			num10 += 1f;
		}
		if (lifeRegenTime >= 2400f)
		{
			num10 += 1f;
		}
		if (lifeRegenTime >= 3000f)
		{
			num10 += 1f;
		}
		if (flag)
		{
			float num11 = lifeRegenTime - 3000f;
			num11 /= 300f;
			if (num11 > 0f)
			{
				if (num11 > 30f)
				{
					num11 = 30f;
				}
				num10 += num11;
			}
		}
		else if (lifeRegenTime >= 3600f)
		{
			num10 += 1f;
			lifeRegenTime = 3600f;
		}
		if (sitting.isSitting || sleeping.isSleeping)
		{
			lifeRegenTime += 3f;
			num10 *= 1.3f;
		}
		if (sitting.isSitting && sitting.details.IsAToilet)
		{
			TryToPoop();
		}
		num10 = ((velocity.X != 0f && grappling[0] <= 0) ? (num10 * 0.5f) : (num10 * 1.25f));
		if (crimsonRegen)
		{
			num10 *= 1.5f;
		}
		if (shinyStone)
		{
			num10 *= 1.1f;
		}
		if (whoAmI == Main.myPlayer && Main.SceneMetrics.HasCampfire)
		{
			num10 *= 1.1f;
		}
		if (Main.expertMode && !wellFed)
		{
			num10 = ((!shinyStone) ? (num10 / 2f) : (num10 * 0.75f));
		}
		if (rabid)
		{
			num10 = ((!shinyStone) ? (num10 / 2f) : (num10 * 0.75f));
		}
		PlayerLoader.NaturalLifeRegen(this, ref num10);
		float num12 = (float)statLifeMax2 / 400f * 0.85f + 0.15f;
		num10 *= num12;
		lifeRegen += (int)Math.Round(num10);
		lifeRegenCount += lifeRegen;
		if (palladiumRegen)
		{
			lifeRegenCount += 4;
		}
		if (flag && lifeRegen > 0 && statLife < statLifeMax2)
		{
			lifeRegenCount++;
			if (flag && ((float)Main.rand.Next(30000) < lifeRegenTime || Main.rand.Next(30) == 0))
			{
				int num13 = Dust.NewDust(position, width, height, 55, 0f, 0f, 200, default(Color), 0.5f);
				Main.dust[num13].noGravity = true;
				Dust obj = Main.dust[num13];
				obj.velocity *= 0.75f;
				Main.dust[num13].fadeIn = 1.3f;
				Vector2 vector = default(Vector2);
				((Vector2)(ref vector))._002Ector((float)Main.rand.Next(-100, 101), (float)Main.rand.Next(-100, 101));
				((Vector2)(ref vector)).Normalize();
				vector *= (float)Main.rand.Next(50, 100) * 0.04f;
				Main.dust[num13].velocity = vector;
				((Vector2)(ref vector)).Normalize();
				vector *= 34f;
				Main.dust[num13].position = base.Center - vector;
			}
		}
		while (lifeRegenCount >= 120)
		{
			lifeRegenCount -= 120;
			if (statLife < statLifeMax2)
			{
				statLife++;
				if (crimsonRegen)
				{
					for (int i = 0; i < 10; i++)
					{
						int num14 = Dust.NewDust(position, width, height, 5, 0f, 0f, 175, default(Color), 1.75f);
						Main.dust[num14].noGravity = true;
						Dust obj2 = Main.dust[num14];
						obj2.velocity *= 0.75f;
						int num2 = Main.rand.Next(-40, 41);
						int num3 = Main.rand.Next(-40, 41);
						Main.dust[num14].position.X += num2;
						Main.dust[num14].position.Y += num3;
						Main.dust[num14].velocity.X = (float)(-num2) * 0.075f;
						Main.dust[num14].velocity.Y = (float)(-num3) * 0.075f;
					}
				}
			}
			if (statLife > statLifeMax2)
			{
				statLife = statLifeMax2;
			}
		}
		if (burned || suffocating || (tongued && Main.expertMode))
		{
			while (lifeRegenCount <= -600)
			{
				lifeRegenCount += 600;
				statLife -= 5;
				CombatText.NewText(new Rectangle((int)position.X, (int)position.Y, width, height), CombatText.LifeRegen, 5, dramatic: false, dot: true);
				if (statLife <= 0 && whoAmI == Main.myPlayer)
				{
					if (suffocating)
					{
						KillMe(PlayerDeathReason.ByOther(7), 10.0, 0);
					}
					else if (tongued)
					{
						KillMe(PlayerDeathReason.ByOther(12), 10.0, 0);
					}
					else
					{
						KillMe(PlayerDeathReason.ByOther(8), 10.0, 0);
					}
				}
			}
			return;
		}
		if (starving)
		{
			int num4 = statLifeMax2 / 50;
			if (num4 < 2)
			{
				num4 = 2;
			}
			int num5 = ((ZoneDesert || ZoneSnow) ? (num4 * 2) : num4);
			int num6 = 120 * num4;
			while (lifeRegenCount <= -num6)
			{
				lifeRegenCount += num6;
				statLife -= num5;
				CombatText.NewText(new Rectangle((int)position.X, (int)position.Y, width, height), CombatText.LifeRegen, num5, dramatic: false, dot: true);
				if (statLife <= 0 && whoAmI == Main.myPlayer)
				{
					KillMe(PlayerDeathReason.ByOther(18), 10.0, 0);
				}
			}
			return;
		}
		while (lifeRegenCount <= -120)
		{
			if (lifeRegenCount <= -480)
			{
				lifeRegenCount += 480;
				statLife -= 4;
				CombatText.NewText(new Rectangle((int)position.X, (int)position.Y, width, height), CombatText.LifeRegen, 4, dramatic: false, dot: true);
			}
			else if (lifeRegenCount <= -360)
			{
				lifeRegenCount += 360;
				statLife -= 3;
				CombatText.NewText(new Rectangle((int)position.X, (int)position.Y, width, height), CombatText.LifeRegen, 3, dramatic: false, dot: true);
			}
			else if (lifeRegenCount <= -240)
			{
				lifeRegenCount += 240;
				statLife -= 2;
				CombatText.NewText(new Rectangle((int)position.X, (int)position.Y, width, height), CombatText.LifeRegen, 2, dramatic: false, dot: true);
			}
			else
			{
				lifeRegenCount += 120;
				statLife--;
				CombatText.NewText(new Rectangle((int)position.X, (int)position.Y, width, height), CombatText.LifeRegen, 1, dramatic: false, dot: true);
			}
			if (statLife <= 0 && whoAmI == Main.myPlayer)
			{
				if (poisoned || venom)
				{
					KillMe(PlayerDeathReason.ByOther(9), 10.0, 0);
				}
				else if (electrified)
				{
					KillMe(PlayerDeathReason.ByOther(10), 10.0, 0);
				}
				else
				{
					KillMe(PlayerDeathReason.ByOther(8), 10.0, 0);
				}
			}
		}
	}

	public void UpdateManaRegen()
	{
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d2: Unknown result type (might be due to invalid IL or missing references)
		if (nebulaLevelMana > 0)
		{
			int num = 6;
			nebulaManaCounter += nebulaLevelMana;
			if (nebulaManaCounter >= num)
			{
				nebulaManaCounter -= num;
				statMana++;
				if (statMana >= statManaMax2)
				{
					statMana = statManaMax2;
				}
			}
		}
		else
		{
			nebulaManaCounter = 0;
		}
		if (manaRegenDelay > 0f)
		{
			manaRegenDelay -= 1f;
			manaRegenDelay -= manaRegenDelayBonus;
			if (IsStandingStillForSpecialEffects || grappling[0] >= 0 || manaRegenBuff)
			{
				manaRegenDelay -= 1f;
			}
			if (usedArcaneCrystal)
			{
				manaRegenDelay -= 0.05f;
			}
		}
		if (manaRegenBuff && manaRegenDelay > 20f)
		{
			manaRegenDelay = 20f;
		}
		if (manaRegenDelay <= 0f)
		{
			manaRegenDelay = 0f;
			manaRegen = statManaMax2 / 3 + 1 + manaRegenBonus;
			if (IsStandingStillForSpecialEffects || grappling[0] >= 0 || manaRegenBuff)
			{
				manaRegen += statManaMax2 / 3;
			}
			if (usedArcaneCrystal)
			{
				manaRegen += statManaMax2 / 50;
			}
			float num2 = (float)statMana / (float)statManaMax2 * 0.8f + 0.2f;
			if (manaRegenBuff)
			{
				num2 = 1f;
			}
			manaRegen = (int)((double)((float)manaRegen * num2) * 1.15);
		}
		else
		{
			manaRegen = 0;
		}
		manaRegenCount += manaRegen;
		while (manaRegenCount >= 120)
		{
			bool flag = false;
			manaRegenCount -= 120;
			if (statMana < statManaMax2)
			{
				statMana++;
				flag = true;
			}
			if (statMana < statManaMax2)
			{
				continue;
			}
			if (whoAmI == Main.myPlayer && flag)
			{
				SoundEngine.PlaySound(25);
				for (int i = 0; i < 5; i++)
				{
					int num3 = Dust.NewDust(position, width, height, 45, 0f, 0f, 255, default(Color), (float)Main.rand.Next(20, 26) * 0.1f);
					Main.dust[num3].noLight = true;
					Main.dust[num3].noGravity = true;
					Dust obj = Main.dust[num3];
					obj.velocity *= 0.5f;
				}
			}
			statMana = statManaMax2;
		}
	}

	public void UpdateJumpHeight()
	{
		if (mount.Active)
		{
			jumpHeight = mount.JumpHeight(this, velocity.X);
			jumpSpeed = mount.JumpSpeed(this, velocity.X);
		}
		else
		{
			if (jumpBoost)
			{
				jumpHeight = 20;
				jumpSpeed = 6.51f;
			}
			if (empressBrooch)
			{
				jumpSpeedBoost += 1.8f;
			}
			if (frogLegJumpBoost)
			{
				jumpSpeedBoost += 2.4f;
				extraFall += 15;
			}
			if (moonLordLegs)
			{
				jumpSpeedBoost += 1.8f;
				extraFall += 10;
				jumpHeight++;
			}
			if (wereWolf)
			{
				jumpHeight += 2;
				jumpSpeed += 0.2f;
			}
			if (portableStoolInfo.IsInUse)
			{
				jumpHeight += 5;
			}
			jumpSpeed += jumpSpeedBoost;
		}
		if (sticky)
		{
			jumpHeight /= 10;
			jumpSpeed /= 5f;
		}
		if (dazed)
		{
			jumpHeight /= 5;
			jumpSpeed /= 2f;
		}
	}

	public void FindPulley()
	{
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a4: Unknown result type (might be due to invalid IL or missing references)
		if (portableStoolInfo.IsInUse || (!controlUp && !controlDown))
		{
			return;
		}
		int num = (int)(position.X + (float)(width / 2)) / 16;
		int num2 = (int)(position.Y - 8f) / 16;
		if (!WorldGen.IsRope(num, num2))
		{
			return;
		}
		float num3 = position.Y;
		if (Main.tile[num, num2 - 1] == null)
		{
			Main.tile[num, num2 - 1] = default(Tile);
		}
		if (Main.tile[num, num2 + 1] == null)
		{
			Main.tile[num, num2 + 1] = default(Tile);
		}
		if ((!Main.tile[num, num2 - 1].active() || !Main.tileRope[Main.tile[num, num2 - 1].type]) && (!Main.tile[num, num2 + 1].active() || !Main.tileRope[Main.tile[num, num2 + 1].type]))
		{
			num3 = num2 * 16 + 22;
		}
		float num4 = num * 16 + 8 - width / 2 + 6 * direction;
		int num5 = num * 16 + 8 - width / 2 + 6;
		int num6 = num * 16 + 8 - width / 2;
		int num7 = num * 16 + 8 - width / 2 + -6;
		int num8 = 1;
		float num9 = Math.Abs(position.X - (float)num5);
		if (Math.Abs(position.X - (float)num6) < num9)
		{
			num8 = 2;
			num9 = Math.Abs(position.X - (float)num6);
		}
		if (Math.Abs(position.X - (float)num7) < num9)
		{
			num8 = 3;
			num9 = Math.Abs(position.X - (float)num7);
		}
		if (num8 == 1)
		{
			num4 = num5;
			pulleyDir = 2;
			direction = 1;
		}
		if (num8 == 2)
		{
			num4 = num6;
			pulleyDir = 1;
		}
		if (num8 == 3)
		{
			num4 = num7;
			pulleyDir = 2;
			direction = -1;
		}
		if (!Collision.SolidCollision(new Vector2(num4, position.Y), width, height))
		{
			if (whoAmI == Main.myPlayer)
			{
				Main.cameraX = Main.cameraX + position.X - num4;
			}
			pulley = true;
			position.X = num4;
			gfxOffY = position.Y - num3;
			stepSpeed = 2.5f;
			position.Y = num3;
			velocity.X = 0f;
			return;
		}
		num4 = num5;
		pulleyDir = 2;
		direction = 1;
		if (!Collision.SolidCollision(new Vector2(num4, position.Y), width, height))
		{
			if (whoAmI == Main.myPlayer)
			{
				Main.cameraX = Main.cameraX + position.X - num4;
			}
			pulley = true;
			position.X = num4;
			gfxOffY = position.Y - num3;
			stepSpeed = 2.5f;
			position.Y = num3;
			velocity.X = 0f;
			return;
		}
		num4 = num7;
		pulleyDir = 2;
		direction = -1;
		if (!Collision.SolidCollision(new Vector2(num4, position.Y), width, height))
		{
			if (whoAmI == Main.myPlayer)
			{
				Main.cameraX = Main.cameraX + position.X - num4;
			}
			pulley = true;
			position.X = num4;
			gfxOffY = position.Y - num3;
			stepSpeed = 2.5f;
			position.Y = num3;
			velocity.X = 0f;
		}
	}

	public void HorizontalMovement()
	{
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_040f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0414: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_07bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_1193: Unknown result type (might be due to invalid IL or missing references)
		//IL_1198: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_045e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0464: Unknown result type (might be due to invalid IL or missing references)
		//IL_046e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0473: Unknown result type (might be due to invalid IL or missing references)
		//IL_124a: Unknown result type (might be due to invalid IL or missing references)
		//IL_124f: Unknown result type (might be due to invalid IL or missing references)
		//IL_11ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_10bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_10c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0979: Unknown result type (might be due to invalid IL or missing references)
		//IL_0807: Unknown result type (might be due to invalid IL or missing references)
		//IL_080d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0817: Unknown result type (might be due to invalid IL or missing references)
		//IL_081c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0556: Unknown result type (might be due to invalid IL or missing references)
		//IL_055c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0566: Unknown result type (might be due to invalid IL or missing references)
		//IL_056b: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_1301: Unknown result type (might be due to invalid IL or missing references)
		//IL_1306: Unknown result type (might be due to invalid IL or missing references)
		//IL_12a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0905: Unknown result type (might be due to invalid IL or missing references)
		//IL_090f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0914: Unknown result type (might be due to invalid IL or missing references)
		//IL_0851: Unknown result type (might be due to invalid IL or missing references)
		//IL_0857: Unknown result type (might be due to invalid IL or missing references)
		//IL_0861: Unknown result type (might be due to invalid IL or missing references)
		//IL_0866: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_13b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_13bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_135d: Unknown result type (might be due to invalid IL or missing references)
		//IL_094c: Unknown result type (might be due to invalid IL or missing references)
		//IL_089e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1415: Unknown result type (might be due to invalid IL or missing references)
		//IL_112c: Unknown result type (might be due to invalid IL or missing references)
		if (chilled)
		{
			accRunSpeed = maxRunSpeed;
		}
		bool flag = (itemAnimation == 0 || inventory[selectedItem].useTurn) && mount.AllowDirectionChange;
		bool flag2 = controlLeft || controlRight;
		float num = (accRunSpeed + maxRunSpeed) / 2f;
		float num2 = 0f;
		bool flag3 = false;
		if (flag2 && mount.Active && mount.Type == 43 && velocity.Y == 0f && !controlJump)
		{
			SoundEngine.PlaySound(in SoundID.Item168, base.Center);
			float num3 = jumpSpeed * gravDir * 0.5f;
			if (num3 < 2f)
			{
				num3 = 2f;
			}
			num3 += 0.01f;
			velocity.Y = 0f - num3;
			jump = jumpHeight;
			fullRotation = 0f;
			return;
		}
		if (windPushed && !isLockedToATile && !(mount.Active && velocity.Y == 0f && flag2))
		{
			num2 = (float)Math.Sign(Main.windSpeedCurrent) * 0.06f;
			if (Math.Abs(Main.windSpeedCurrent) > 0.5f)
			{
				num2 *= 1.37f;
			}
			if (velocity.Y != 0f)
			{
				num2 *= 1.5f;
			}
			if (flag2)
			{
				num2 *= 0.8f;
				float num4 = 0.072f;
				num2 = MathHelper.Clamp(num2, 0f - num4, num4);
			}
			flag3 = true;
			if (Math.Sign(direction) != Math.Sign(num2))
			{
				num -= Math.Abs(num2) * 40f;
			}
		}
		if (trackBoost != 0f)
		{
			velocity.X += trackBoost;
			trackBoost = 0f;
			if (velocity.X < 0f)
			{
				if (velocity.X < 0f - maxRunSpeed)
				{
					velocity.X = 0f - maxRunSpeed;
				}
			}
			else if (velocity.X > maxRunSpeed)
			{
				velocity.X = maxRunSpeed;
			}
		}
		if (controlLeft && velocity.X > 0f - maxRunSpeed)
		{
			if (!mount.Active || !mount.Cart || velocity.Y == 0f)
			{
				if (velocity.X > runSlowdown)
				{
					velocity.X -= runSlowdown;
				}
				velocity.X -= runAcceleration;
			}
			if (onWrongGround)
			{
				if (velocity.X < 0f - runSlowdown)
				{
					velocity.X += runSlowdown;
				}
				else
				{
					velocity.X = 0f;
				}
			}
			if (mount.Active && mount.Cart && !onWrongGround)
			{
				if (velocity.X < 0f && flag)
				{
					direction = -1;
				}
				else if (itemAnimation <= 0 && velocity.Y == 0f)
				{
					SoundEngine.PlaySound(SoundID.Item55, (int)position.X + width / 2, (int)position.Y + height / 2);
					DelegateMethods.Minecart.rotation = fullRotation;
					DelegateMethods.Minecart.rotationOrigin = fullRotationOrigin;
					if ((double)Math.Abs(velocity.X) > (double)maxRunSpeed * 0.66)
					{
						if (Main.rand.Next(2) == 0)
						{
							Minecart.WheelSparks(mount.Delegations.MinecartDust, position + velocity * 0.66f, width, height, 1);
						}
						if (Main.rand.Next(2) == 0)
						{
							Minecart.WheelSparks(mount.Delegations.MinecartDust, position + velocity * 0.33f, width, height, 1);
						}
						if (Main.rand.Next(2) == 0)
						{
							Minecart.WheelSparks(mount.Delegations.MinecartDust, position, width, height, 1);
						}
					}
					else if ((double)Math.Abs(velocity.X) > (double)maxRunSpeed * 0.33)
					{
						if (Main.rand.Next(3) != 0)
						{
							Minecart.WheelSparks(mount.Delegations.MinecartDust, position + velocity * 0.5f, width, height, 1);
						}
						if (Main.rand.Next(3) != 0)
						{
							Minecart.WheelSparks(mount.Delegations.MinecartDust, position, width, height, 1);
						}
					}
					else
					{
						Minecart.WheelSparks(mount.Delegations.MinecartDust, position, width, height, 1);
					}
				}
			}
			else if (!sandStorm && (itemAnimation == 0 || inventory[selectedItem].useTurn) && mount.AllowDirectionChange)
			{
				direction = -1;
			}
		}
		else if (controlRight && velocity.X < maxRunSpeed)
		{
			if (!mount.Active || !mount.Cart || velocity.Y == 0f)
			{
				if (velocity.X < 0f - runSlowdown)
				{
					velocity.X += runSlowdown;
				}
				velocity.X += runAcceleration;
			}
			if (onWrongGround)
			{
				if (velocity.X > runSlowdown)
				{
					velocity.X -= runSlowdown;
				}
				else
				{
					velocity.X = 0f;
				}
			}
			if (mount.Active && mount.Cart && !onWrongGround)
			{
				if (velocity.X > 0f && flag)
				{
					direction = 1;
				}
				else if (itemAnimation <= 0 && velocity.Y == 0f)
				{
					SoundEngine.PlaySound(SoundID.Item55, (int)position.X + width / 2, (int)position.Y + height / 2);
					DelegateMethods.Minecart.rotation = fullRotation;
					DelegateMethods.Minecart.rotationOrigin = fullRotationOrigin;
					if ((double)Math.Abs(velocity.X) > (double)maxRunSpeed * 0.66)
					{
						if (Main.rand.Next(2) == 0)
						{
							Minecart.WheelSparks(mount.Delegations.MinecartDust, position + velocity * 0.66f, width, height, 1);
						}
						if (Main.rand.Next(2) == 0)
						{
							Minecart.WheelSparks(mount.Delegations.MinecartDust, position + velocity * 0.33f, width, height, 1);
						}
						if (Main.rand.Next(2) == 0)
						{
							Minecart.WheelSparks(mount.Delegations.MinecartDust, position, width, height, 1);
						}
					}
					else if ((double)Math.Abs(velocity.X) > (double)maxRunSpeed * 0.33)
					{
						if (Main.rand.Next(3) != 0)
						{
							Minecart.WheelSparks(mount.Delegations.MinecartDust, position + velocity * 0.5f, width, height, 1);
						}
						if (Main.rand.Next(3) != 0)
						{
							Minecart.WheelSparks(mount.Delegations.MinecartDust, position, width, height, 1);
						}
					}
					else
					{
						Minecart.WheelSparks(mount.Delegations.MinecartDust, position, width, height, 1);
					}
				}
			}
			else if (!sandStorm && (itemAnimation == 0 || inventory[selectedItem].useTurn) && mount.AllowDirectionChange)
			{
				direction = 1;
			}
		}
		else if (controlLeft && velocity.X > 0f - accRunSpeed && dashDelay >= 0)
		{
			if (mount.Active && mount.Cart)
			{
				if (velocity.X < 0f)
				{
					direction = -1;
				}
			}
			else if ((itemAnimation == 0 || inventory[selectedItem].useTurn) && mount.AllowDirectionChange)
			{
				direction = -1;
			}
			if (velocity.Y == 0f || wingsLogic > 0 || mount.CanFly())
			{
				if (velocity.X > runSlowdown)
				{
					velocity.X -= runSlowdown;
				}
				velocity.X -= runAcceleration * 0.2f;
				if (wingsLogic > 0)
				{
					velocity.X -= runAcceleration * 0.2f;
				}
			}
			if (onWrongGround)
			{
				if (velocity.X < runSlowdown)
				{
					velocity.X += runSlowdown;
				}
				else
				{
					velocity.X = 0f;
				}
			}
			if (velocity.X < 0f - num && velocity.Y == 0f && !mount.Active)
			{
				SpawnFastRunParticles();
			}
		}
		else if (controlRight && velocity.X < accRunSpeed && dashDelay >= 0)
		{
			if (mount.Active && mount.Cart)
			{
				if (velocity.X > 0f)
				{
					direction = -1;
				}
			}
			else if ((itemAnimation == 0 || inventory[selectedItem].useTurn) && mount.AllowDirectionChange)
			{
				direction = 1;
			}
			if (velocity.Y == 0f || wingsLogic > 0 || mount.CanFly())
			{
				if (velocity.X < 0f - runSlowdown)
				{
					velocity.X += runSlowdown;
				}
				velocity.X += runAcceleration * 0.2f;
				if (wingsLogic > 0)
				{
					velocity.X += runAcceleration * 0.2f;
				}
			}
			if (onWrongGround)
			{
				if (velocity.X > runSlowdown)
				{
					velocity.X -= runSlowdown;
				}
				else
				{
					velocity.X = 0f;
				}
			}
			if (velocity.X > num && velocity.Y == 0f && !mount.Active)
			{
				SpawnFastRunParticles();
			}
		}
		else if (mount.Active && mount.Cart && Math.Abs(velocity.X) >= 1f)
		{
			if (onWrongGround)
			{
				if (velocity.X > 0f)
				{
					if (velocity.X > runSlowdown)
					{
						velocity.X -= runSlowdown;
					}
					else
					{
						velocity.X = 0f;
					}
				}
				else if (velocity.X < 0f)
				{
					if (velocity.X < 0f - runSlowdown)
					{
						velocity.X += runSlowdown;
					}
					else
					{
						velocity.X = 0f;
					}
				}
			}
			if (velocity.X > maxRunSpeed)
			{
				velocity.X = maxRunSpeed;
			}
			if (velocity.X < 0f - maxRunSpeed)
			{
				velocity.X = 0f - maxRunSpeed;
			}
		}
		else if (velocity.Y == 0f)
		{
			if (velocity.X > runSlowdown)
			{
				velocity.X -= runSlowdown;
			}
			else if (velocity.X < 0f - runSlowdown)
			{
				velocity.X += runSlowdown;
			}
			else
			{
				velocity.X = 0f;
			}
		}
		else if (!PortalPhysicsEnabled)
		{
			if ((double)velocity.X > (double)runSlowdown * 0.5)
			{
				velocity.X -= runSlowdown * 0.5f;
			}
			else if ((double)velocity.X < (double)(0f - runSlowdown) * 0.5)
			{
				velocity.X += runSlowdown * 0.5f;
			}
			else
			{
				velocity.X = 0f;
			}
		}
		if (flag3)
		{
			if (num2 < 0f && velocity.X > num2)
			{
				velocity.X += num2;
				if (velocity.X < num2)
				{
					velocity.X = num2;
				}
			}
			if (num2 > 0f && velocity.X < num2)
			{
				velocity.X += num2;
				if (velocity.X > num2)
				{
					velocity.X = num2;
				}
			}
		}
		bool flag4 = mount.Type == 40 || mount.Type == 41 || mount.Type == 42;
		if (mount.Active && (mount.Type == 10 || mount.Type == 47 || flag4) && Math.Abs(velocity.X) > mount.DashSpeed - mount.RunSpeed / 2f)
		{
			Rectangle rect = getRect();
			if (direction == 1)
			{
				((Rectangle)(ref rect)).Offset(width - 1, 0);
			}
			rect.Width = 2;
			((Rectangle)(ref rect)).Inflate(6, 12);
			int num5 = 60;
			if (flag4)
			{
				num5 = 30;
			}
			float damage = GetTotalDamage(DamageClass.Summon).ApplyTo(num5);
			float knockback = 10f;
			if (flag4)
			{
				knockback = 7f;
			}
			int nPCImmuneTime = 30;
			int playerImmuneTime = 6;
			CollideWithNPCs(rect, damage, knockback, nPCImmuneTime, playerImmuneTime, DamageClass.Summon);
		}
		if (mount.Active && mount.Type == 44 && Math.Abs(velocity.X) > mount.DashSpeed - mount.RunSpeed / 4f)
		{
			Rectangle rect2 = getRect();
			if (direction == 1)
			{
				((Rectangle)(ref rect2)).Offset(width - 1, 0);
			}
			rect2.Width = 2;
			((Rectangle)(ref rect2)).Inflate(6, 12);
			float damage2 = GetTotalDamage(DamageClass.Summon).ApplyTo(100f);
			float knockback2 = 12f;
			int nPCImmuneTime2 = 30;
			int playerImmuneTime2 = 6;
			CollideWithNPCs(rect2, damage2, knockback2, nPCImmuneTime2, playerImmuneTime2, DamageClass.Summon);
		}
		if (mount.Active && mount.Type == 45 && Math.Abs(velocity.X) > mount.DashSpeed * 0.9f)
		{
			Rectangle rect3 = getRect();
			if (direction == 1)
			{
				((Rectangle)(ref rect3)).Offset(width - 1, 0);
			}
			rect3.Width = 2;
			((Rectangle)(ref rect3)).Inflate(6, 12);
			float damage3 = GetTotalDamage(DamageClass.Summon).ApplyTo(120f);
			float knockback3 = 12f;
			int nPCImmuneTime3 = 30;
			int playerImmuneTime3 = 6;
			CollideWithNPCs(rect3, damage3, knockback3, nPCImmuneTime3, playerImmuneTime3, DamageClass.Summon);
		}
		if (mount.Active && mount.Type == 14 && Math.Abs(velocity.X) > mount.RunSpeed / 2f)
		{
			Rectangle rect4 = getRect();
			if (direction == 1)
			{
				((Rectangle)(ref rect4)).Offset(width - 1, 0);
			}
			rect4.Width = 2;
			((Rectangle)(ref rect4)).Inflate(6, 12);
			float damage4 = GetTotalDamage(DamageClass.Summon).ApplyTo(90f);
			float knockback4 = 10f;
			int nPCImmuneTime4 = 30;
			int playerImmuneTime4 = 6;
			CollideWithNPCs(rect4, damage4, knockback4, nPCImmuneTime4, playerImmuneTime4, DamageClass.Summon);
		}
		if (mount.Active && mount.Type == 17 && Math.Abs(velocity.X) > mount.RunSpeed / 2f)
		{
			Rectangle rect5 = getRect();
			if (direction == 1)
			{
				((Rectangle)(ref rect5)).Offset(width - 1, 0);
			}
			rect5.Width = 2;
			((Rectangle)(ref rect5)).Inflate(6, 12);
			float damage5 = GetTotalDamage(DamageClass.Summon).ApplyTo(40f);
			float knockback5 = 10f;
			int nPCImmuneTime5 = 30;
			int playerImmuneTime5 = 12;
			CollideWithNPCs(rect5, damage5, knockback5, nPCImmuneTime5, playerImmuneTime5, DamageClass.Summon);
		}
		TryUsingDiggerCart();
		if (HeldItem.type == 4049 && whoAmI == Main.myPlayer)
		{
			MowTheLawn();
		}
	}

	private void TryUsingDiggerCart()
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		if (whoAmI == Main.myPlayer && mount.Active && mount.Type == 39 && velocity.Y == 0f)
		{
			int num = 12;
			int num2 = 20;
			Vector2 vector = default(Vector2);
			((Vector2)(ref vector))._002Ector(0f, gravDir * 10f);
			Vector2 trackWorldPosition = RotatedRelativePoint(base.Center + new Vector2((float)(num * direction), gravDir * (float)num2));
			trackWorldPosition += vector;
			Tile tileSafely = Framing.GetTileSafely(trackWorldPosition);
			if (!tileSafely.active() || tileSafely.type != 314)
			{
				trackWorldPosition = RotatedRelativePoint(base.Center + new Vector2((float)(num * direction) * 0.5f, gravDir * (float)num2));
				trackWorldPosition += vector;
			}
			int digDirectionY = controlDown.ToInt() - controlUp.ToInt();
			if (controlUp.ToInt() + controlDown.ToInt() + controlLeft.ToInt() + controlRight.ToInt() > 0)
			{
				MinecartDiggerHelper.Instance.TryDigging(this, trackWorldPosition, direction, digDirectionY);
			}
		}
	}

	private void SpawnFastRunParticles()
	{
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0811: Unknown result type (might be due to invalid IL or missing references)
		//IL_084d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0853: Unknown result type (might be due to invalid IL or missing references)
		//IL_070b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0746: Unknown result type (might be due to invalid IL or missing references)
		//IL_074c: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0451: Unknown result type (might be due to invalid IL or missing references)
		//IL_046e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0474: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0639: Unknown result type (might be due to invalid IL or missing references)
		//IL_063f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0652: Unknown result type (might be due to invalid IL or missing references)
		//IL_065c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0661: Unknown result type (might be due to invalid IL or missing references)
		//IL_0534: Unknown result type (might be due to invalid IL or missing references)
		//IL_053e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0543: Unknown result type (might be due to invalid IL or missing references)
		//IL_0674: Unknown result type (might be due to invalid IL or missing references)
		//IL_0681: Unknown result type (might be due to invalid IL or missing references)
		//IL_0686: Unknown result type (might be due to invalid IL or missing references)
		//IL_068b: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		if (gravDir == -1f)
		{
			num -= height;
		}
		if (runSoundDelay == 0 && velocity.Y == 0f)
		{
			SoundEngine.PlaySound(hermesStepSound.Style, position);
			runSoundDelay = hermesStepSound.IntendedCooldown;
		}
		if (wings == 3)
		{
			int num2 = Dust.NewDust(new Vector2(position.X - 4f, position.Y + (float)height + (float)num), width + 8, 4, 186, (0f - velocity.X) * 0.5f, velocity.Y * 0.5f, 50, default(Color), 1.5f);
			Dust obj = Main.dust[num2];
			obj.velocity *= 0.025f;
			Main.dust[num2].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
			num2 = Dust.NewDust(new Vector2(position.X - 4f, position.Y + (float)height + (float)num), width + 8, 4, 186, (0f - velocity.X) * 0.5f, velocity.Y * 0.5f, 50, default(Color), 1.5f);
			Dust obj2 = Main.dust[num2];
			obj2.velocity *= 0.2f;
			Main.dust[num2].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
		}
		else if (sailDash)
		{
			Vector2 vector = default(Vector2);
			for (int i = 0; i < 4; i++)
			{
				int num3 = Dust.NewDust(new Vector2(position.X - 4f, position.Y), width + 8, height, 253, (0f - velocity.X) * 0.5f, velocity.Y * 0.5f, 100, default(Color), 1.5f);
				Main.dust[num3].noGravity = true;
				Main.dust[num3].velocity.X = Main.dust[num3].velocity.X * 0.2f;
				Main.dust[num3].velocity.Y = Main.dust[num3].velocity.Y * 0.2f;
				Main.dust[num3].shader = GameShaders.Armor.GetSecondaryShader(cShoe, this);
				Main.dust[num3].scale += (float)Main.rand.Next(-5, 3) * 0.1f;
				((Vector2)(ref vector))._002Ector((float)Main.rand.Next(-100, 101), (float)Main.rand.Next(-100, 101));
				((Vector2)(ref vector)).Normalize();
				vector *= (float)Main.rand.Next(81) * 0.1f;
			}
		}
		else if (desertDash)
		{
			Dust dust = Dust.NewDustDirect(new Vector2(position.X - 4f, position.Y + (float)height + (float)num), width + 8, 4, 32, (0f - velocity.X) * 0.5f, velocity.Y * 0.5f);
			dust.velocity *= 0.2f;
			dust.velocity.Y -= gravDir * 2f;
			dust.shader = GameShaders.Armor.GetSecondaryShader(cShoe, this);
		}
		else if (coldDash)
		{
			for (int j = 0; j < 2; j++)
			{
				int num4 = ((j != 0) ? Dust.NewDust(new Vector2(position.X + (float)(width / 2), position.Y + (float)height + gfxOffY), width / 2, 6, 76, 0f, 0f, 0, default(Color), 1.35f) : Dust.NewDust(new Vector2(position.X, position.Y + (float)height + gfxOffY), width / 2, 6, 76, 0f, 0f, 0, default(Color), 1.35f));
				Main.dust[num4].scale *= 1f + (float)Main.rand.Next(20, 40) * 0.01f;
				Main.dust[num4].noGravity = true;
				Main.dust[num4].noLight = true;
				Dust obj3 = Main.dust[num4];
				obj3.velocity *= 0.001f;
				Main.dust[num4].velocity.Y -= 0.003f;
				Main.dust[num4].shader = GameShaders.Armor.GetSecondaryShader(cShoe, this);
			}
		}
		else if (fairyBoots)
		{
			int type = Main.rand.NextFromList(new short[6] { 61, 61, 61, 242, 64, 63 });
			int alpha = 0;
			for (int k = 1; k < 3; k++)
			{
				float scale = 1.5f;
				if (k == 2)
				{
					scale = 1f;
				}
				int num5 = Dust.NewDust(new Vector2(position.X - 4f, position.Y + (float)height + (float)num), width + 8, 4, type, (0f - velocity.X) * 0.5f, velocity.Y * 0.5f, alpha, default(Color), scale);
				Dust obj4 = Main.dust[num5];
				obj4.velocity *= 1.5f;
				if (k == 2)
				{
					Dust obj5 = Main.dust[num5];
					obj5.position += Main.dust[num5].velocity;
				}
				Main.dust[num5].noGravity = true;
				Main.dust[num5].noLightEmittence = true;
				Main.dust[num5].shader = GameShaders.Armor.GetSecondaryShader(cShoe, this);
			}
		}
		else if (hellfireTreads)
		{
			int num6 = Dust.NewDust(new Vector2(position.X - 4f, position.Y + (float)height + (float)num), width + 8, 4, 6, (0f - velocity.X) * 0.5f, velocity.Y * 0.5f, 50, default(Color), 2f);
			Main.dust[num6].velocity.X = Main.dust[num6].velocity.X * 0.2f;
			Main.dust[num6].velocity.Y = -1.5f - Main.rand.NextFloat() * 0.5f;
			Main.dust[num6].fadeIn = 0.5f;
			Main.dust[num6].noGravity = true;
			Main.dust[num6].shader = GameShaders.Armor.GetSecondaryShader(cShoe, this);
		}
		else
		{
			int num7 = Dust.NewDust(new Vector2(position.X - 4f, position.Y + (float)height + (float)num), width + 8, 4, 16, (0f - velocity.X) * 0.5f, velocity.Y * 0.5f, 50, default(Color), 1.5f);
			Main.dust[num7].velocity.X = Main.dust[num7].velocity.X * 0.2f;
			Main.dust[num7].velocity.Y = Main.dust[num7].velocity.Y * 0.2f;
			Main.dust[num7].shader = GameShaders.Armor.GetSecondaryShader(cShoe, this);
		}
	}

	private void MowTheLawn()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		if (miscCounter % 2 != 0 || velocity.Y != 0f || grappling[0] != -1 || itemAnimation < 1)
		{
			return;
		}
		Vector2 vector = base.Center + new Vector2((float)(direction * 38), (float)(height / 2 + 4) * gravDir);
		float num = 1f - (float)itemAnimation / (float)itemAnimationMax;
		num *= 2f;
		num = ((!(num < 1f)) ? (num - 1f) : (1f - num));
		Vector2 val = vector + new Vector2((float)(direction * -16), gravDir * -4f);
		Vector2 value2 = vector + new Vector2((float)(direction * -6), gravDir * -4f);
		Dust dust = Dust.NewDustDirect(Vector2.Lerp(val, value2, num), 0, 0, 31, 0f, (0f - gravDir) * 0.25f, 127);
		dust.scale = 0.9f;
		dust.position -= new Vector2(4f);
		if (dust.velocity.Y > 0f)
		{
			dust.velocity.Y *= -1f;
		}
		dust.velocity *= 0.25f;
		Rectangle rectangle = Utils.CenteredRectangle(vector, new Vector2(8f, 20f));
		if (velocity.X * (float)direction > 0f || velocity.Y * gravDir > 0f)
		{
			Rectangle myRect = rectangle;
			myRect.Height -= 4;
			myRect.Y += 2;
			float damage = 8f;
			float knockback = 2f;
			int nPCImmuneTime = 12;
			int playerImmuneTime = 6;
			CollideWithNPCs(myRect, damage, knockback, nPCImmuneTime, playerImmuneTime);
		}
		rectangle.X -= direction * 10;
		if (whoAmI == Main.myPlayer)
		{
			bool[] shouldIgnore = ItemCheck_GetTileCutIgnoreList(HeldItem);
			ItemCheck_CutTiles(HeldItem, rectangle, shouldIgnore);
			MowGrassTile(vector);
			if (!WorldGen.SolidTile(Framing.GetTileSafely(vector.ToTileCoordinates())))
			{
				MowGrassTile(vector + new Vector2(0f, 16f * gravDir));
			}
		}
	}

	private void MowGrassTile(Vector2 thePos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		Point point = thePos.ToTileCoordinates();
		Tile tile = Main.tile[point.X, point.Y];
		if (tile == null || !WorldGen.CanKillTile(point.X, point.Y, WorldGen.SpecialKillTileContext.MowingTheGrass))
		{
			return;
		}
		ushort num = 0;
		switch (tile.type)
		{
		case 2:
			num = 477;
			break;
		case 109:
			num = 492;
			break;
		}
		if (num != 0)
		{
			int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile, point.X, point.Y);
			for (int i = 0; i < num2; i++)
			{
				WorldGen.KillTile_MakeTileDust(point.X, point.Y, tile);
			}
			tile.type = num;
			if (Main.netMode == 1)
			{
				NetMessage.SendTileSquare(-1, point.X, point.Y);
			}
		}
	}

	public int CollideWithNPCs(Rectangle myRect, float Damage, float Knockback, int NPCImmuneTime, int PlayerImmuneTime, DamageClass? damageType = null)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		for (int i = 0; i < 200; i++)
		{
			NPC nPC = Main.npc[i];
			if (!nPC.active || nPC.dontTakeDamage || nPC.friendly || nPC.immune[whoAmI] != 0 || !CanNPCBeHitByPlayerOrPlayerProjectile(nPC))
			{
				continue;
			}
			Rectangle rect = nPC.getRect();
			if (((Rectangle)(ref myRect)).Intersects(rect) && (nPC.noTileCollide || Collision.CanHit(position, width, height, nPC.position, nPC.width, nPC.height)))
			{
				int num2 = direction;
				if (velocity.X < 0f)
				{
					num2 = -1;
				}
				if (velocity.X > 0f)
				{
					num2 = 1;
				}
				if (whoAmI == Main.myPlayer)
				{
					ApplyDamageToNPC(nPC, (int)Damage, Knockback, num2, crit: false, damageType);
				}
				nPC.immune[whoAmI] = NPCImmuneTime;
				GiveImmuneTimeForCollisionAttack(PlayerImmuneTime);
				num++;
				break;
			}
		}
		return num;
	}

	public void ApplyBannerOffenseBuff(NPC npc, ref NPC.HitModifiers modifiers)
	{
		ApplyBannerOffenseBuff(Item.NPCtoBanner(npc.BannerID()), ref modifiers);
	}

	public void ApplyBannerOffenseBuff(int bannerId, ref NPC.HitModifiers modifiers)
	{
		if (HasNPCBannerBuff(bannerId))
		{
			ItemID.BannerEffect effect = ItemID.Sets.BannerStrength[Item.BannerToItem(bannerId)];
			modifiers.TargetDamageMultiplier *= (Main.expertMode ? effect.ExpertDamageDealt : effect.NormalDamageDealt);
		}
	}

	public void ApplyBannerDefenseBuff(NPC npc, ref HurtModifiers modifiers)
	{
		ApplyBannerDefenseBuff(Item.NPCtoBanner(npc.BannerID()), ref modifiers);
	}

	public void ApplyBannerDefenseBuff(int bannerId, ref HurtModifiers modifiers)
	{
		if (HasNPCBannerBuff(bannerId))
		{
			ItemID.BannerEffect effect = ItemID.Sets.BannerStrength[Item.BannerToItem(bannerId)];
			modifiers.IncomingDamageMultiplier *= (Main.expertMode ? effect.ExpertDamageReceived : effect.NormalDamageReceived);
		}
	}

	/// <summary>
	/// Deals damage to an NPC (and syncs the hit in multiplayer). <br />
	/// The damage will be affected by modifiers, armor pen, enemy resistances etc. <br />
	/// Will not apply damage class modifiers/knockback. Use <see cref="M:Terraria.Player.GetTotalDamage``1" /> to adjust the damage before calling if necessary. <br />
	/// Will apply damage class based armor penetration. <br />
	/// Will exit early with no effect if <see cref="M:Terraria.ModLoader.PlayerLoader.CanHitNPC(Terraria.Player,Terraria.NPC)" /> returns false.
	/// </summary>
	/// <param name="npc">The NPC to strike</param>
	/// <param name="damage">The damage to deal to the NPC, before modifications, defense, resistances etc</param>
	/// <param name="knockback">The amount of knockback to apply</param>
	/// <param name="direction">The hit direction of the resulting strike (1 or -1)</param>
	/// <param name="crit">Whether or not the strike is a crit</param>
	/// <param name="damageType">Defaults to <see cref="P:Terraria.ModLoader.DamageClass.Default" /></param>
	/// <param name="damageVariation">Whether to apply damage variation. Defaults to false.</param>
	public void ApplyDamageToNPC(NPC npc, int damage, float knockback, int direction, bool crit = false, DamageClass? damageType = null, bool damageVariation = false)
	{
		if (PlayerLoader.CanHitNPC(this, npc))
		{
			NPC.HitModifiers modifiers = npc.GetIncomingStrikeModifiers(damageType ?? DamageClass.Default, direction);
			PlayerLoader.ModifyHitNPC(this, npc, ref modifiers);
			ApplyBannerOffenseBuff(npc, ref modifiers);
			modifiers.ArmorPenetration += GetTotalArmorPenetration(damageType ?? DamageClass.Generic);
			StrikeNPCDirect(npc, modifiers.ToHitInfo(damage, crit, knockback, damageVariation, luck));
		}
	}

	/// <summary>
	/// Applies a hit to an NPC via <see cref="M:Terraria.NPC.StrikeNPC(Terraria.NPC.HitInfo,System.Boolean,System.Boolean)" />. <br />
	/// Also calls player based OnHit and OnKill hooks, tracks dps and net syncs the strike
	/// </summary>
	/// <param name="npc">The NPC to strike</param>
	/// <param name="hit">The hit to apply</param>
	public void StrikeNPCDirect(NPC npc, NPC.HitInfo hit)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		OnHit(npc.Center.X, npc.Center.Y, npc);
		NPCKillAttempt attempt = new NPCKillAttempt(npc);
		int dmg = npc.StrikeNPC(hit);
		PlayerLoader.OnHitNPC(this, npc, in hit, dmg);
		if (accDreamCatcher && !npc.HideStrikeDamage)
		{
			addDPS(dmg);
		}
		if (Main.netMode != 0)
		{
			NetMessage.SendStrikeNPC(npc, in hit);
		}
		int num2 = Item.NPCtoBanner(npc.BannerID());
		if (num2 >= 0)
		{
			lastCreatureHit = num2;
		}
		if (attempt.DidNPCDie())
		{
			OnKillNPC(ref attempt, null);
		}
	}

	public void OnKillNPC(ref NPCKillAttempt attempt, object externalKillingBlowSource)
	{
		if (Main.myPlayer == whoAmI && externalKillingBlowSource is Item { type: 5096 })
		{
			AddBuff(336, 420, quiet: false);
		}
	}

	public void GiveImmuneTimeForCollisionAttack(int time)
	{
		if (_timeSinceLastImmuneGet <= 20)
		{
			_immuneStrikes++;
		}
		else
		{
			_immuneStrikes = 1;
		}
		_timeSinceLastImmuneGet = 0;
		if (_immuneStrikes < 3 && (!immune || immuneTime <= time))
		{
			immune = true;
			immuneNoBlink = true;
			immuneTime = time;
		}
	}

	public bool CanNPCBeHitByPlayerOrPlayerProjectile(NPC npc, Projectile projectile = null)
	{
		bool flag = dontHurtCritters || (projectile != null && (projectile.minion || ProjectileID.Sets.MinionShot[projectile.type] || projectile.sentry || ProjectileID.Sets.SentryShot[projectile.type]));
		if (NPCID.Sets.CountsAsCritter[npc.type] && flag)
		{
			return false;
		}
		return true;
	}

	public void JumpMovement()
	{
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a1: Unknown result type (might be due to invalid IL or missing references)
		if (mount.Active && mount.IsConsideredASlimeMount && wetSlime == 0 && velocity.Y > 0f)
		{
			Rectangle rect = getRect();
			((Rectangle)(ref rect)).Offset(0, height - 1);
			rect.Height = 2;
			((Rectangle)(ref rect)).Inflate(12, 6);
			for (int i = 0; i < 200; i++)
			{
				NPC nPC = Main.npc[i];
				if (!nPC.active || nPC.dontTakeDamage || nPC.friendly || nPC.immune[whoAmI] != 0 || !CanNPCBeHitByPlayerOrPlayerProjectile(nPC))
				{
					continue;
				}
				Rectangle rect2 = nPC.getRect();
				if (((Rectangle)(ref rect)).Intersects(rect2) && (nPC.noTileCollide || Collision.CanHit(position, width, height, nPC.position, nPC.width, nPC.height)))
				{
					float num = GetTotalDamage(DamageClass.Summon).ApplyTo(40f);
					float knockback = 5f;
					int num2 = direction;
					if (velocity.X < 0f)
					{
						num2 = -1;
					}
					if (velocity.X > 0f)
					{
						num2 = 1;
					}
					if (whoAmI == Main.myPlayer)
					{
						ApplyDamageToNPC(nPC, (int)num, knockback, num2, crit: false, DamageClass.Summon);
					}
					nPC.immune[whoAmI] = 10;
					velocity.Y = -10f;
					GiveImmuneTimeForCollisionAttack(6);
					break;
				}
			}
		}
		if (mount.Active && mount.Type == 17 && velocity.Y > 0f)
		{
			Rectangle rect3 = getRect();
			((Rectangle)(ref rect3)).Offset(0, height - 1);
			rect3.Height = 2;
			((Rectangle)(ref rect3)).Inflate(12, 6);
			for (int j = 0; j < 200; j++)
			{
				NPC nPC2 = Main.npc[j];
				if (!nPC2.active || nPC2.dontTakeDamage || nPC2.friendly || nPC2.immune[whoAmI] != 0 || !CanNPCBeHitByPlayerOrPlayerProjectile(nPC2))
				{
					continue;
				}
				Rectangle rect4 = nPC2.getRect();
				if (((Rectangle)(ref rect3)).Intersects(rect4) && (nPC2.noTileCollide || Collision.CanHit(position, width, height, nPC2.position, nPC2.width, nPC2.height)))
				{
					float num3 = 40f;
					float knockback2 = 5f;
					int num4 = direction;
					if (velocity.X < 0f)
					{
						num4 = -1;
					}
					if (velocity.X > 0f)
					{
						num4 = 1;
					}
					if (whoAmI == Main.myPlayer)
					{
						ApplyDamageToNPC(nPC2, (int)num3, knockback2, num4);
					}
					nPC2.immune[whoAmI] = 12;
					GiveImmuneTimeForCollisionAttack(12);
					break;
				}
			}
		}
		if (controlJump)
		{
			if (sliding)
			{
				autoJump = false;
			}
			bool flag = false;
			if (mount.Active && mount.IsConsideredASlimeMount && wetSlime > 0)
			{
				wetSlime = 0;
				flag = true;
			}
			if (mount.Active && mount.Type == 43 && releaseJump && velocity.Y != 0f)
			{
				isPerformingPogostickTricks = true;
			}
			if (jump > 0)
			{
				if (velocity.Y == 0f)
				{
					jump = 0;
				}
				else
				{
					velocity.Y = (0f - jumpSpeed) * gravDir;
					if (merman && (!mount.Active || !mount.Cart))
					{
						if (swimTime <= 10)
						{
							swimTime = 30;
						}
					}
					else
					{
						jump--;
					}
				}
			}
			else if ((sliding || velocity.Y == 0f || flag || AnyExtraJumpUsable()) && (releaseJump || (autoJump && (velocity.Y == 0f || sliding))))
			{
				if (mount.Active && MountID.Sets.Cart[mount.Type])
				{
					position.Y -= 0.001f;
				}
				if (sliding || velocity.Y == 0f)
				{
					justJumped = true;
				}
				bool flag2 = false;
				bool attemptDoubleJumps = !flag;
				canRocket = false;
				rocketRelease = false;
				if (velocity.Y == 0f || sliding || (autoJump && justJumped))
				{
					RefreshDoubleJumps();
				}
				if (velocity.Y == 0f || flag2 || sliding || flag)
				{
					if (mount.Active && mount.Type == 43)
					{
						SoundEngine.PlaySound(in SoundID.Item168, base.Center);
					}
					velocity.Y = (0f - jumpSpeed) * gravDir;
					jump = jumpHeight;
					if (portableStoolInfo.IsInUse)
					{
						position.Y -= portableStoolInfo.HeightBoost;
						gfxOffY += portableStoolInfo.HeightBoost;
					}
					if (sliding)
					{
						velocity.X = 3 * -slideDir;
					}
				}
				else if (attemptDoubleJumps && !blockExtraJumps)
				{
					ExtraJumpLoader.ProcessJumps(this);
				}
			}
			releaseJump = false;
		}
		else
		{
			jump = 0;
			releaseJump = true;
			rocketRelease = true;
		}
	}

	public void DashMovement()
	{
		//IL_0cde: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d13: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d18: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d1d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d22: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d25: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d3d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d42: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d47: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d4c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d4e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d55: Unknown result type (might be due to invalid IL or missing references)
		//IL_0629: Unknown result type (might be due to invalid IL or missing references)
		//IL_0646: Unknown result type (might be due to invalid IL or missing references)
		//IL_064c: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_1053: Unknown result type (might be due to invalid IL or missing references)
		//IL_1088: Unknown result type (might be due to invalid IL or missing references)
		//IL_108d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1092: Unknown result type (might be due to invalid IL or missing references)
		//IL_1097: Unknown result type (might be due to invalid IL or missing references)
		//IL_109a: Unknown result type (might be due to invalid IL or missing references)
		//IL_10b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_10b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_10bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_10c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_10c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_10ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d63: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d6a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0827: Unknown result type (might be due to invalid IL or missing references)
		//IL_0849: Unknown result type (might be due to invalid IL or missing references)
		//IL_084f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0866: Unknown result type (might be due to invalid IL or missing references)
		//IL_0870: Unknown result type (might be due to invalid IL or missing references)
		//IL_0875: Unknown result type (might be due to invalid IL or missing references)
		//IL_0757: Unknown result type (might be due to invalid IL or missing references)
		//IL_0774: Unknown result type (might be due to invalid IL or missing references)
		//IL_077a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0701: Unknown result type (might be due to invalid IL or missing references)
		//IL_071d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0723: Unknown result type (might be due to invalid IL or missing references)
		//IL_0663: Unknown result type (might be due to invalid IL or missing references)
		//IL_066d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0672: Unknown result type (might be due to invalid IL or missing references)
		//IL_1246: Unknown result type (might be due to invalid IL or missing references)
		//IL_127b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1280: Unknown result type (might be due to invalid IL or missing references)
		//IL_1285: Unknown result type (might be due to invalid IL or missing references)
		//IL_128a: Unknown result type (might be due to invalid IL or missing references)
		//IL_128d: Unknown result type (might be due to invalid IL or missing references)
		//IL_12a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_12aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_12af: Unknown result type (might be due to invalid IL or missing references)
		//IL_12b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_12b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_12bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_10d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_10df: Unknown result type (might be due to invalid IL or missing references)
		//IL_145d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1492: Unknown result type (might be due to invalid IL or missing references)
		//IL_1497: Unknown result type (might be due to invalid IL or missing references)
		//IL_149c: Unknown result type (might be due to invalid IL or missing references)
		//IL_14a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_14a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_14bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_14c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_14c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_14cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_14cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_14d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_094e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0974: Unknown result type (might be due to invalid IL or missing references)
		//IL_097a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0991: Unknown result type (might be due to invalid IL or missing references)
		//IL_099b: Unknown result type (might be due to invalid IL or missing references)
		//IL_09a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0791: Unknown result type (might be due to invalid IL or missing references)
		//IL_079b: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_12cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_12d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_14e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_14e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0db1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0dd2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0dd8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e37: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e41: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e46: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ebd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ec4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0eca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f3d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f47: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f4c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f87: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f8e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f94: Unknown result type (might be due to invalid IL or missing references)
		//IL_1007: Unknown result type (might be due to invalid IL or missing references)
		//IL_1011: Unknown result type (might be due to invalid IL or missing references)
		//IL_1016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0adc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0af9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0aff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a86: Unknown result type (might be due to invalid IL or missing references)
		//IL_0aa2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0aa8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0399: Unknown result type (might be due to invalid IL or missing references)
		//IL_039e: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_112e: Unknown result type (might be due to invalid IL or missing references)
		//IL_114f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1155: Unknown result type (might be due to invalid IL or missing references)
		//IL_11b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_11be: Unknown result type (might be due to invalid IL or missing references)
		//IL_11c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b16: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b20: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b25: Unknown result type (might be due to invalid IL or missing references)
		//IL_1319: Unknown result type (might be due to invalid IL or missing references)
		//IL_1339: Unknown result type (might be due to invalid IL or missing references)
		//IL_133f: Unknown result type (might be due to invalid IL or missing references)
		//IL_139e: Unknown result type (might be due to invalid IL or missing references)
		//IL_13a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_13ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_154d: Unknown result type (might be due to invalid IL or missing references)
		//IL_156e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1574: Unknown result type (might be due to invalid IL or missing references)
		//IL_15db: Unknown result type (might be due to invalid IL or missing references)
		//IL_15e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_15ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_15ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0490: Unknown result type (might be due to invalid IL or missing references)
		//IL_049b: Unknown result type (might be due to invalid IL or missing references)
		if (dashDelay == 0)
		{
			dash = dashType;
		}
		if (dash == 0)
		{
			dashTime = 0;
			dashDelay = 0;
		}
		if (dash == 2 && eocDash > 0)
		{
			if (eocHit < 0)
			{
				Rectangle rectangle = default(Rectangle);
				((Rectangle)(ref rectangle))._002Ector((int)((double)position.X + (double)velocity.X * 0.5 - 4.0), (int)((double)position.Y + (double)velocity.Y * 0.5 - 4.0), width + 8, height + 8);
				for (int i = 0; i < 200; i++)
				{
					NPC nPC = Main.npc[i];
					if (!nPC.active || nPC.dontTakeDamage || nPC.friendly || (nPC.aiStyle == 112 && !(nPC.ai[2] <= 1f)) || !CanNPCBeHitByPlayerOrPlayerProjectile(nPC))
					{
						continue;
					}
					Rectangle rect = nPC.getRect();
					if (((Rectangle)(ref rectangle)).Intersects(rect) && (nPC.noTileCollide || CanHit(nPC)))
					{
						float num = GetTotalDamage(DamageClass.Melee).ApplyTo(30f);
						float num12 = GetTotalKnockback(DamageClass.Melee).ApplyTo(9f);
						bool crit = false;
						if ((float)Main.rand.Next(100) < GetTotalCritChance(DamageClass.Melee))
						{
							crit = true;
						}
						int num21 = direction;
						if (velocity.X < 0f)
						{
							num21 = -1;
						}
						if (velocity.X > 0f)
						{
							num21 = 1;
						}
						if (whoAmI == Main.myPlayer)
						{
							ApplyDamageToNPC(nPC, (int)num, num12, num21, crit, DamageClass.Melee);
						}
						eocDash = 10;
						dashDelay = 30;
						velocity.X = -num21 * 9;
						velocity.Y = -4f;
						GiveImmuneTimeForCollisionAttack(4);
						eocHit = i;
					}
				}
			}
			else if ((!controlLeft || !(velocity.X < 0f)) && (!controlRight || !(velocity.X > 0f)))
			{
				velocity.X *= 0.95f;
			}
		}
		if (dash == 3 && dashDelay < 0 && whoAmI == Main.myPlayer)
		{
			Rectangle rectangle2 = default(Rectangle);
			((Rectangle)(ref rectangle2))._002Ector((int)((double)position.X + (double)velocity.X * 0.5 - 4.0), (int)((double)position.Y + (double)velocity.Y * 0.5 - 4.0), width + 8, height + 8);
			for (int j = 0; j < 200; j++)
			{
				NPC nPC2 = Main.npc[j];
				if (!nPC2.active || nPC2.dontTakeDamage || nPC2.friendly || nPC2.immune[whoAmI] > 0 || (nPC2.aiStyle == 112 && !(nPC2.ai[2] <= 1f)) || !CanNPCBeHitByPlayerOrPlayerProjectile(nPC2))
				{
					continue;
				}
				Rectangle rect2 = nPC2.getRect();
				if (((Rectangle)(ref rectangle2)).Intersects(rect2) && (nPC2.noTileCollide || CanHit(nPC2)))
				{
					if (!solarDashConsumedFlare)
					{
						solarDashConsumedFlare = true;
						ConsumeSolarFlare();
					}
					float num22 = GetTotalDamage(DamageClass.Melee).ApplyTo(150f);
					float num23 = GetTotalKnockback(DamageClass.Melee).ApplyTo(9f);
					bool crit2 = false;
					if ((float)Main.rand.Next(100) < GetTotalCritChance(DamageClass.Melee))
					{
						crit2 = true;
					}
					int num24 = direction;
					if (velocity.X < 0f)
					{
						num24 = -1;
					}
					if (velocity.X > 0f)
					{
						num24 = 1;
					}
					if (whoAmI == Main.myPlayer)
					{
						ApplyDamageToNPC(nPC2, (int)num22, num23, num24, crit2, DamageClass.Melee);
						int num25 = Projectile.NewProjectile(GetProjectileSource_OnHit(nPC2, 2), base.Center.X, base.Center.Y, 0f, 0f, 608, (int)num22, 15f, Main.myPlayer);
						Main.projectile[num25].Kill();
					}
					nPC2.immune[whoAmI] = 6;
					GiveImmuneTimeForCollisionAttack(4);
				}
			}
		}
		if (dashDelay > 0)
		{
			if (eocDash > 0)
			{
				eocDash--;
			}
			if (eocDash == 0)
			{
				eocHit = -1;
			}
			dashDelay--;
		}
		else if (dashDelay < 0)
		{
			StopVanityActions();
			float num26 = 12f;
			float num27 = 0.992f;
			float num2 = Math.Max(accRunSpeed, maxRunSpeed);
			float num3 = 0.96f;
			int num4 = 20;
			if (dash == 1)
			{
				for (int k = 0; k < 2; k++)
				{
					int num5 = ((velocity.Y != 0f) ? Dust.NewDust(new Vector2(position.X, position.Y + (float)(height / 2) - 8f), width, 16, 31, 0f, 0f, 100, default(Color), 1.4f) : Dust.NewDust(new Vector2(position.X, position.Y + (float)height - 4f), width, 8, 31, 0f, 0f, 100, default(Color), 1.4f));
					Dust obj = Main.dust[num5];
					obj.velocity *= 0.1f;
					Main.dust[num5].scale *= 1f + (float)Main.rand.Next(20) * 0.01f;
				}
			}
			else if (dash == 2)
			{
				for (int l = 0; l < 0; l++)
				{
					int num6 = ((velocity.Y != 0f) ? Dust.NewDust(new Vector2(position.X, position.Y + (float)(height / 2) - 8f), width, 16, 31, 0f, 0f, 100, default(Color), 1.4f) : Dust.NewDust(new Vector2(position.X, position.Y + (float)height - 4f), width, 8, 31, 0f, 0f, 100, default(Color), 1.4f));
					Dust obj2 = Main.dust[num6];
					obj2.velocity *= 0.1f;
					Main.dust[num6].scale *= 1f + (float)Main.rand.Next(20) * 0.01f;
				}
				num27 = 0.985f;
				num3 = 0.94f;
				num4 = 30;
			}
			else if (dash == 3)
			{
				for (int m = 0; m < 4; m++)
				{
					int num7 = Dust.NewDust(new Vector2(position.X, position.Y + 4f), width, height - 8, 6, 0f, 0f, 100, default(Color), 1.7f);
					Dust obj3 = Main.dust[num7];
					obj3.velocity *= 0.1f;
					Main.dust[num7].scale *= 1f + (float)Main.rand.Next(20) * 0.01f;
					Main.dust[num7].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
					Main.dust[num7].noGravity = true;
					if (Main.rand.Next(2) == 0)
					{
						Main.dust[num7].fadeIn = 0.5f;
					}
				}
				num26 = 14f;
				num27 = 0.985f;
				num3 = 0.94f;
				num4 = 20;
			}
			else if (dash == 4)
			{
				for (int n = 0; n < 2; n++)
				{
					int num8 = Dust.NewDust(new Vector2(position.X, position.Y + 4f), width, height - 8, 229, 0f, 0f, 100, default(Color), 1.2f);
					Dust obj4 = Main.dust[num8];
					obj4.velocity *= 0.1f;
					Main.dust[num8].scale *= 1f + (float)Main.rand.Next(20) * 0.01f;
					Main.dust[num8].noGravity = true;
					if (Main.rand.Next(2) == 0)
					{
						Main.dust[num8].fadeIn = 0.3f;
					}
				}
				num27 = 0.985f;
				num3 = 0.94f;
				num4 = 20;
			}
			if (dash == 5)
			{
				for (int num9 = 0; num9 < 2; num9++)
				{
					int type = Main.rand.NextFromList(new short[3] { 68, 69, 70 });
					int num10 = ((velocity.Y != 0f) ? Dust.NewDust(new Vector2(position.X, position.Y + (float)(height / 2) - 8f), width, 16, type, 0f, 0f, 100) : Dust.NewDust(new Vector2(position.X, position.Y + (float)height - 4f), width, 8, type, 0f, 0f, 100));
					Dust obj5 = Main.dust[num10];
					obj5.velocity *= 0.2f;
					Main.dust[num10].scale *= 1f + (float)Main.rand.Next(20) * 0.01f;
					Main.dust[num10].fadeIn = 0.5f + (float)Main.rand.Next(20) * 0.01f;
					Main.dust[num10].noGravity = true;
					Main.dust[num10].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
				}
			}
			if (dash <= 0)
			{
				return;
			}
			doorHelper.AllowOpeningDoorsByVelocityAloneForATime(num4 * 3);
			vortexStealthActive = false;
			if (velocity.X > num26 || velocity.X < 0f - num26)
			{
				velocity.X *= num27;
				return;
			}
			if (velocity.X > num2 || velocity.X < 0f - num2)
			{
				velocity.X *= num3;
				return;
			}
			dashDelay = num4;
			if (velocity.X < 0f)
			{
				velocity.X = 0f - num2;
			}
			else if (velocity.X > 0f)
			{
				velocity.X = num2;
			}
		}
		else
		{
			if (dash <= 0 || mount.Active)
			{
				return;
			}
			if (dash == 1)
			{
				DoCommonDashHandle(out var dir, out var dashing);
				if (dashing)
				{
					velocity.X = 16.9f * (float)dir;
					Point point = (base.Center + new Vector2((float)(dir * width / 2 + 2), gravDir * (float)(-height) / 2f + gravDir * 2f)).ToTileCoordinates();
					Point point2 = (base.Center + new Vector2((float)(dir * width / 2 + 2), 0f)).ToTileCoordinates();
					if (WorldGen.SolidOrSlopedTile(point.X, point.Y) || WorldGen.SolidOrSlopedTile(point2.X, point2.Y))
					{
						velocity.X /= 2f;
					}
					dashDelay = -1;
					for (int num11 = 0; num11 < 20; num11++)
					{
						int num13 = Dust.NewDust(new Vector2(position.X, position.Y), width, height, 31, 0f, 0f, 100, default(Color), 2f);
						Main.dust[num13].position.X += Main.rand.Next(-5, 6);
						Main.dust[num13].position.Y += Main.rand.Next(-5, 6);
						Dust obj6 = Main.dust[num13];
						obj6.velocity *= 0.2f;
						Main.dust[num13].scale *= 1f + (float)Main.rand.Next(20) * 0.01f;
					}
					int num14 = Gore.NewGore(new Vector2(position.X + (float)(width / 2) - 24f, position.Y + (float)(height / 2) - 34f), default(Vector2), Main.rand.Next(61, 64));
					Main.gore[num14].velocity.X = (float)Main.rand.Next(-50, 51) * 0.01f;
					Main.gore[num14].velocity.Y = (float)Main.rand.Next(-50, 51) * 0.01f;
					Gore obj7 = Main.gore[num14];
					obj7.velocity *= 0.4f;
					num14 = Gore.NewGore(new Vector2(position.X + (float)(width / 2) - 24f, position.Y + (float)(height / 2) - 14f), default(Vector2), Main.rand.Next(61, 64));
					Main.gore[num14].velocity.X = (float)Main.rand.Next(-50, 51) * 0.01f;
					Main.gore[num14].velocity.Y = (float)Main.rand.Next(-50, 51) * 0.01f;
					Gore obj8 = Main.gore[num14];
					obj8.velocity *= 0.4f;
				}
			}
			else if (dash == 2)
			{
				DoCommonDashHandle(out var dir2, out var dashing2);
				if (dashing2)
				{
					velocity.X = 14.5f * (float)dir2;
					Point point3 = (base.Center + new Vector2((float)(dir2 * width / 2 + 2), gravDir * (float)(-height) / 2f + gravDir * 2f)).ToTileCoordinates();
					Point point4 = (base.Center + new Vector2((float)(dir2 * width / 2 + 2), 0f)).ToTileCoordinates();
					if (WorldGen.SolidOrSlopedTile(point3.X, point3.Y) || WorldGen.SolidOrSlopedTile(point4.X, point4.Y))
					{
						velocity.X /= 2f;
					}
					dashDelay = -1;
					eocDash = 15;
					for (int num15 = 0; num15 < 0; num15++)
					{
						int num16 = Dust.NewDust(new Vector2(position.X, position.Y), width, height, 31, 0f, 0f, 100, default(Color), 2f);
						Main.dust[num16].position.X += Main.rand.Next(-5, 6);
						Main.dust[num16].position.Y += Main.rand.Next(-5, 6);
						Dust obj9 = Main.dust[num16];
						obj9.velocity *= 0.2f;
						Main.dust[num16].scale *= 1f + (float)Main.rand.Next(20) * 0.01f;
					}
				}
			}
			else if (dash == 3)
			{
				DoCommonDashHandle(out var dir3, out var dashing3, SolarDashStart);
				if (dashing3)
				{
					velocity.X = 21.9f * (float)dir3;
					Point point5 = (base.Center + new Vector2((float)(dir3 * width / 2 + 2), gravDir * (float)(-height) / 2f + gravDir * 2f)).ToTileCoordinates();
					Point point6 = (base.Center + new Vector2((float)(dir3 * width / 2 + 2), 0f)).ToTileCoordinates();
					if (WorldGen.SolidOrSlopedTile(point5.X, point5.Y) || WorldGen.SolidOrSlopedTile(point6.X, point6.Y))
					{
						velocity.X /= 2f;
					}
					dashDelay = -1;
					for (int num17 = 0; num17 < 20; num17++)
					{
						int num18 = Dust.NewDust(new Vector2(position.X, position.Y), width, height, 6, 0f, 0f, 100, default(Color), 2f);
						Main.dust[num18].position.X += Main.rand.Next(-5, 6);
						Main.dust[num18].position.Y += Main.rand.Next(-5, 6);
						Dust obj10 = Main.dust[num18];
						obj10.velocity *= 0.2f;
						Main.dust[num18].scale *= 1f + (float)Main.rand.Next(20) * 0.01f;
						Main.dust[num18].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
						Main.dust[num18].noGravity = true;
						Main.dust[num18].fadeIn = 0.5f;
					}
				}
			}
			if (dash != 5)
			{
				return;
			}
			DoCommonDashHandle(out var dir4, out var dashing4);
			if (dashing4)
			{
				velocity.X = 16.9f * (float)dir4;
				Point point7 = (base.Center + new Vector2((float)(dir4 * width / 2 + 2), gravDir * (float)(-height) / 2f + gravDir * 2f)).ToTileCoordinates();
				Point point8 = (base.Center + new Vector2((float)(dir4 * width / 2 + 2), 0f)).ToTileCoordinates();
				if (WorldGen.SolidOrSlopedTile(point7.X, point7.Y) || WorldGen.SolidOrSlopedTile(point8.X, point8.Y))
				{
					velocity.X /= 2f;
				}
				dashDelay = -1;
				for (int num19 = 0; num19 < 20; num19++)
				{
					int type2 = Main.rand.NextFromList(new short[3] { 68, 69, 70 });
					int num20 = Dust.NewDust(new Vector2(position.X, position.Y), width, height, type2, 0f, 0f, 100, default(Color), 1.5f);
					Main.dust[num20].position.X += Main.rand.Next(-5, 6);
					Main.dust[num20].position.Y += Main.rand.Next(-5, 6);
					Main.dust[num20].velocity = DirectionTo(Main.dust[num20].position) * 2f;
					Main.dust[num20].scale *= 1f + (float)Main.rand.Next(20) * 0.01f;
					Main.dust[num20].fadeIn = 0.5f + (float)Main.rand.Next(20) * 0.01f;
					Main.dust[num20].noGravity = true;
					Main.dust[num20].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
				}
			}
		}
	}

	private void SolarDashStart(int dashDirection)
	{
		solarDashing = true;
		solarDashConsumedFlare = false;
	}

	private void DoCommonDashHandle(out int dir, out bool dashing, DashStartAction dashStartAction = null)
	{
		dir = 0;
		dashing = false;
		if (dashTime > 0)
		{
			dashTime--;
		}
		if (dashTime < 0)
		{
			dashTime++;
		}
		if (controlRight && releaseRight)
		{
			if (dashTime > 0)
			{
				dir = 1;
				dashing = true;
				dashTime = 0;
				timeSinceLastDashStarted = 0;
				dashStartAction?.Invoke(dir);
			}
			else
			{
				dashTime = 15;
			}
		}
		else if (controlLeft && releaseLeft)
		{
			if (dashTime < 0)
			{
				dir = -1;
				dashing = true;
				dashTime = 0;
				timeSinceLastDashStarted = 0;
				dashStartAction?.Invoke(dir);
			}
			else
			{
				dashTime = -15;
			}
		}
	}

	public void WallslideMovement()
	{
		//IL_043d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0453: Unknown result type (might be due to invalid IL or missing references)
		//IL_0459: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		sliding = false;
		if (slideDir == 0 || spikedBoots <= 0 || mount.Active || ((!controlLeft || slideDir != -1) && (!controlRight || slideDir != 1)))
		{
			return;
		}
		bool flag = false;
		float num = position.X;
		if (slideDir == 1)
		{
			num += (float)width;
		}
		num += (float)slideDir;
		float num2 = position.Y + (float)height + 1f;
		if (gravDir < 0f)
		{
			num2 = position.Y - 1f;
		}
		num /= 16f;
		num2 /= 16f;
		if (WorldGen.SolidTile((int)num, (int)num2) && WorldGen.SolidTile((int)num, (int)num2 - 1))
		{
			flag = true;
		}
		if (spikedBoots >= 2)
		{
			if (!flag || ((!(velocity.Y > 0f) || gravDir != 1f) && (!(velocity.Y < gravity) || gravDir != -1f)))
			{
				return;
			}
			float num3 = gravity;
			if (slowFall)
			{
				num3 = ((!TryingToHoverUp) ? (gravity / 3f * gravDir) : (gravity / 10f * gravDir));
			}
			fallStart = (int)(position.Y / 16f);
			if ((controlDown && gravDir == 1f) || (controlUp && gravDir == -1f))
			{
				velocity.Y = 4f * gravDir;
				int num4 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)((width / 2 - 4) * slideDir), position.Y + (float)(height / 2) + (float)(height / 2 - 4) * gravDir), 8, 8, 31);
				if (slideDir < 0)
				{
					Main.dust[num4].position.X -= 10f;
				}
				if (gravDir < 0f)
				{
					Main.dust[num4].position.Y -= 12f;
				}
				Dust obj = Main.dust[num4];
				obj.velocity *= 0.1f;
				Main.dust[num4].scale *= 1.2f;
				Main.dust[num4].noGravity = true;
				Main.dust[num4].shader = GameShaders.Armor.GetSecondaryShader(cShoe, this);
			}
			else if (gravDir == -1f)
			{
				velocity.Y = (0f - num3 + 1E-05f) * gravDir;
			}
			else
			{
				velocity.Y = (0f - num3 + 1E-05f) * gravDir;
			}
			sliding = true;
		}
		else if ((flag && (double)velocity.Y > 0.5 && gravDir == 1f) || ((double)velocity.Y < -0.5 && gravDir == -1f))
		{
			fallStart = (int)(position.Y / 16f);
			if (controlDown)
			{
				velocity.Y = 4f * gravDir;
			}
			else
			{
				velocity.Y = 0.5f * gravDir;
			}
			sliding = true;
			int num5 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)((width / 2 - 4) * slideDir), position.Y + (float)(height / 2) + (float)(height / 2 - 4) * gravDir), 8, 8, 31);
			if (slideDir < 0)
			{
				Main.dust[num5].position.X -= 10f;
			}
			if (gravDir < 0f)
			{
				Main.dust[num5].position.Y -= 12f;
			}
			Dust obj2 = Main.dust[num5];
			obj2.velocity *= 0.1f;
			Main.dust[num5].scale *= 1.2f;
			Main.dust[num5].noGravity = true;
			Main.dust[num5].shader = GameShaders.Armor.GetSecondaryShader(cShoe, this);
		}
	}

	public void CarpetMovement()
	{
		bool flag = false;
		if (grappling[0] == -1 && carpet && !AnyExtraJumpUsable() && jump == 0 && velocity.Y != 0f && rocketTime == 0 && wingTime == 0f && !mount.Active)
		{
			if (controlJump && canCarpet)
			{
				canCarpet = false;
				carpetTime = 300;
			}
			if (carpetTime > 0 && controlJump)
			{
				fallStart = (int)(position.Y / 16f);
				flag = true;
				carpetTime--;
				float num = gravity;
				if (gravDir == 1f && velocity.Y > 0f - num)
				{
					velocity.Y = 0f - (num + 1E-06f);
				}
				else if (gravDir == -1f && velocity.Y < num)
				{
					velocity.Y = num + 1E-06f;
				}
				carpetFrameCounter += 1f + Math.Abs(velocity.X * 0.5f);
				if (carpetFrameCounter > 8f)
				{
					carpetFrameCounter = 0f;
					carpetFrame++;
				}
				if (carpetFrame < 0)
				{
					carpetFrame = 0;
				}
				if (carpetFrame > 5)
				{
					carpetFrame = 0;
				}
			}
		}
		if (!flag)
		{
			carpetFrame = -1;
		}
		else
		{
			slowFall = false;
		}
	}

	public void DoubleJumpVisuals()
	{
		ExtraJumpLoader.JumpVisuals(this);
	}

	public void WingMovement()
	{
		if (wingsLogic == 4 && TryingToHoverUp)
		{
			velocity.Y -= 0.2f * gravDir;
			if (gravDir == 1f)
			{
				if (velocity.Y > 0f)
				{
					velocity.Y -= 1f;
				}
				else if (velocity.Y > 0f - jumpSpeed)
				{
					velocity.Y -= 0.2f;
				}
				if (velocity.Y < (0f - jumpSpeed) * 3f)
				{
					velocity.Y = (0f - jumpSpeed) * 3f;
				}
			}
			else
			{
				if (velocity.Y < 0f)
				{
					velocity.Y += 1f;
				}
				else if (velocity.Y < jumpSpeed)
				{
					velocity.Y += 0.2f;
				}
				if (velocity.Y > jumpSpeed * 3f)
				{
					velocity.Y = jumpSpeed * 3f;
				}
			}
			wingTime -= 2f;
		}
		else
		{
			float num = 0.1f;
			float num2 = 0.5f;
			float num3 = 1.5f;
			float num4 = 0.5f;
			float num5 = 0.1f;
			if (wingsLogic == 26)
			{
				num2 = 0.75f;
				num5 = 0.15f;
				num4 = 1f;
				num3 = 2.5f;
				num = 0.125f;
			}
			if (wingsLogic == 8 || wingsLogic == 11 || wingsLogic == 24 || wingsLogic == 27 || wingsLogic == 22)
			{
				num3 = 1.66f;
			}
			if (wingsLogic == 21 || wingsLogic == 12 || wingsLogic == 20 || wingsLogic == 23)
			{
				num3 = 1.805f;
			}
			if (wingsLogic == 37)
			{
				num2 = 0.75f;
				num5 = 0.15f;
				num4 = 1f;
				num3 = 2.5f;
				num = 0.125f;
			}
			if (wingsLogic == 44)
			{
				num2 = 0.85f;
				num5 = 0.15f;
				num4 = 1f;
				num3 = 2.75f;
				num = 0.125f;
				if (TryingToHoverUp)
				{
					velocity.Y -= 0.4f * gravDir;
					if (gravDir == 1f)
					{
						if (velocity.Y > 0f)
						{
							velocity.Y -= 1f;
						}
						else if (velocity.Y > 0f - jumpSpeed)
						{
							velocity.Y -= 0.2f;
						}
						if (velocity.Y < (0f - jumpSpeed) * 3f)
						{
							velocity.Y = (0f - jumpSpeed) * 3f;
						}
					}
					else
					{
						if (velocity.Y < 0f)
						{
							velocity.Y += 1f;
						}
						else if (velocity.Y < jumpSpeed)
						{
							velocity.Y += 0.2f;
						}
						if (velocity.Y > jumpSpeed * 3f)
						{
							velocity.Y = jumpSpeed * 3f;
						}
					}
				}
				if (TryingToHoverDown && !controlJump && velocity.Y != 0f)
				{
					velocity.Y += 0.4f;
				}
			}
			if (wingsLogic == 45)
			{
				num2 = 0.95f;
				num5 = 0.15f;
				num4 = 1f;
				num3 = 4.5f;
				if (TryingToHoverUp)
				{
					velocity.Y -= 0.4f * gravDir;
					if (gravDir == 1f)
					{
						if (velocity.Y > 0f)
						{
							velocity.Y -= 1f;
						}
						else if (velocity.Y > 0f - jumpSpeed)
						{
							velocity.Y -= 0.2f;
						}
						if (velocity.Y < (0f - jumpSpeed) * 3f)
						{
							velocity.Y = (0f - jumpSpeed) * 3f;
						}
					}
					else
					{
						if (velocity.Y < 0f)
						{
							velocity.Y += 1f;
						}
						else if (velocity.Y < jumpSpeed)
						{
							velocity.Y += 0.2f;
						}
						if (velocity.Y > jumpSpeed * 3f)
						{
							velocity.Y = jumpSpeed * 3f;
						}
					}
				}
				if (TryingToHoverDown && !controlJump && velocity.Y != 0f)
				{
					velocity.Y += 0.4f;
				}
			}
			if (wingsLogic == 29 || wingsLogic == 32)
			{
				num2 = 0.85f;
				num5 = 0.15f;
				num4 = 1f;
				num3 = 3f;
				num = 0.135f;
			}
			if (wingsLogic == 30 || wingsLogic == 31)
			{
				num4 = 1f;
				num3 = 2.45f;
				if (!TryingToHoverDown)
				{
					num = 0.15f;
				}
			}
			ItemLoader.VerticalWingSpeeds(this, ref num2, ref num5, ref num4, ref num3, ref num);
			velocity.Y -= num * gravDir;
			if (gravDir == 1f)
			{
				if (velocity.Y > 0f)
				{
					velocity.Y -= num2;
				}
				else if (velocity.Y > (0f - jumpSpeed) * num4)
				{
					velocity.Y -= num5;
				}
				if (velocity.Y < (0f - jumpSpeed) * num3)
				{
					velocity.Y = (0f - jumpSpeed) * num3;
				}
			}
			else
			{
				if (velocity.Y < 0f)
				{
					velocity.Y += num2;
				}
				else if (velocity.Y < jumpSpeed * num4)
				{
					velocity.Y += num5;
				}
				if (velocity.Y > jumpSpeed * num3)
				{
					velocity.Y = jumpSpeed * num3;
				}
			}
			if ((wingsLogic == 22 || wingsLogic == 28 || wingsLogic == 30 || wingsLogic == 31 || wingsLogic == 37 || wingsLogic == 45) && TryingToHoverDown && !controlLeft && !controlRight)
			{
				wingTime -= 0.5f;
			}
			else
			{
				wingTime -= 1f;
			}
		}
		if (empressBrooch && wingTime != 0f)
		{
			wingTime = wingTimeMax;
		}
	}

	public void MoonLeechRope()
	{
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		int num = -1;
		for (int i = 0; i < 1000; i++)
		{
			if (Main.projectile[i].active && Main.projectile[i].type == 456 && Main.projectile[i].ai[1] == (float)whoAmI)
			{
				num = i;
				break;
			}
		}
		if (num != -1 && !(Main.projectile[num].ai[0] < 0f))
		{
			Projectile projectile = Main.projectile[num];
			Vector2 vector = default(Vector2);
			((Vector2)(ref vector))._002Ector(0f, 216f);
			Vector2 value = Main.npc[(int)Math.Abs(projectile.ai[0]) - 1].Center - base.Center + vector;
			if (((Vector2)(ref value)).Length() > 200f)
			{
				Vector2 vector2 = Vector2.Normalize(value);
				position += vector2 * (((Vector2)(ref value)).Length() - 200f);
			}
		}
	}

	public void WOFTongue()
	{
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		if (Main.wofNPCIndex < 0 || !Main.npc[Main.wofNPCIndex].active)
		{
			return;
		}
		float num = Main.npc[Main.wofNPCIndex].position.X + 40f;
		if (Main.npc[Main.wofNPCIndex].direction > 0)
		{
			num -= 96f;
		}
		if (position.X + (float)width > num && position.X < num + 140f && gross)
		{
			noKnockback = false;
			int attackDamage_ScaledByStrength = Main.npc[Main.wofNPCIndex].GetAttackDamage_ScaledByStrength(50f);
			Hurt(PlayerDeathReason.LegacyDefault(), attackDamage_ScaledByStrength, Main.npc[Main.wofNPCIndex].direction);
		}
		if (!gross && position.Y > (float)((Main.maxTilesY - 250) * 16) && position.X > num - 1920f && position.X < num + 1920f)
		{
			AddBuff(37, 10);
			SoundEngine.PlaySound(4, (int)Main.npc[Main.wofNPCIndex].position.X, (int)Main.npc[Main.wofNPCIndex].position.Y, 10);
		}
		if (gross)
		{
			if (position.Y < (float)(Main.UnderworldLayer * 16))
			{
				AddBuff(38, 10);
			}
			if (Main.npc[Main.wofNPCIndex].direction < 0)
			{
				if (position.X + (float)(width / 2) > Main.npc[Main.wofNPCIndex].position.X + (float)(Main.npc[Main.wofNPCIndex].width / 2) + 40f)
				{
					AddBuff(38, 10);
				}
			}
			else if (position.X + (float)(width / 2) < Main.npc[Main.wofNPCIndex].position.X + (float)(Main.npc[Main.wofNPCIndex].width / 2) - 40f)
			{
				AddBuff(38, 10);
			}
		}
		if (!tongued)
		{
			return;
		}
		controlHook = false;
		controlUseItem = false;
		for (int i = 0; i < 1000; i++)
		{
			if (Main.projectile[i].active && Main.projectile[i].owner == Main.myPlayer && Main.projectile[i].aiStyle == 7)
			{
				Main.projectile[i].Kill();
			}
		}
		Vector2 center = base.Center;
		float num3 = Main.npc[Main.wofNPCIndex].position.X + (float)(Main.npc[Main.wofNPCIndex].width / 2) - center.X;
		float num2 = Main.npc[Main.wofNPCIndex].position.Y + (float)(Main.npc[Main.wofNPCIndex].height / 2) - center.Y;
		if ((float)Math.Sqrt(num3 * num3 + num2 * num2) > 3000f)
		{
			KillMe(PlayerDeathReason.ByOther(11), 1000.0, 0);
		}
		else if (Main.npc[Main.wofNPCIndex].position.X < 608f || Main.npc[Main.wofNPCIndex].position.X > (float)((Main.maxTilesX - 38) * 16))
		{
			KillMe(PlayerDeathReason.ByOther(12), 1000.0, 0);
		}
	}

	public void StatusFromNPC(NPC npc)
	{
		if (Main.expertMode && ((npc.type == 266 && Main.rand.Next(3) == 0) || npc.type == 267))
		{
			int num = Main.rand.Next(9);
			if (num == 2 || num == 4)
			{
				num = Main.rand.Next(9);
			}
			float num2 = (float)Main.rand.Next(75, 150) * 0.01f;
			switch (num)
			{
			case 0:
				AddBuff(20, (int)(60f * num2 * 3.5f));
				break;
			case 1:
				AddBuff(22, (int)(60f * num2 * 2f));
				break;
			case 2:
				AddBuff(23, (int)(60f * num2 * 0.5f));
				break;
			case 3:
				AddBuff(30, (int)(60f * num2 * 5f));
				break;
			case 4:
				AddBuff(31, (int)(60f * num2 * 1f));
				break;
			case 5:
				AddBuff(32, (int)(60f * num2 * 3.5f));
				break;
			case 6:
				AddBuff(33, (int)(60f * num2 * 7.5f));
				break;
			case 7:
				AddBuff(35, (int)(60f * num2 * 1f));
				break;
			case 8:
				AddBuff(36, (int)((double)(60f * num2) * 6.5));
				break;
			}
		}
		if (npc.type == 530 || npc.type == 531)
		{
			AddBuff(70, Main.rand.Next(240, 241));
		}
		if (npc.type == 159 || npc.type == 158)
		{
			AddBuff(30, Main.rand.Next(300, 600));
		}
		if (npc.type == 525)
		{
			AddBuff(39, 240);
		}
		if (npc.type == 526)
		{
			AddBuff(69, 420);
		}
		if (npc.type == 527)
		{
			AddBuff(31, 840);
		}
		if (Main.expertMode && (npc.type == 49 || npc.type == 93 || npc.type == 51 || npc.type == 152 || npc.type == 634) && Main.rand.Next(10) == 0)
		{
			AddBuff(148, Main.rand.Next(1800, 5400));
		}
		if (Main.expertMode && npc.type == 222)
		{
			AddBuff(20, Main.rand.Next(60, 240));
		}
		if (Main.expertMode && (npc.type == 210 || npc.type == 211))
		{
			AddBuff(20, Main.rand.Next(60, 180));
		}
		if (Main.expertMode && npc.type == 35)
		{
			AddBuff(30, Main.rand.Next(180, 300));
		}
		if (Main.expertMode && npc.type == 36 && Main.rand.Next(2) == 0)
		{
			AddBuff(32, Main.rand.Next(30, 60));
		}
		if (npc.type >= 269 && npc.type <= 272)
		{
			if (Main.rand.Next(3) == 0)
			{
				AddBuff(30, 600);
			}
			else if (Main.rand.Next(3) == 0)
			{
				AddBuff(32, 300);
			}
		}
		if (npc.type >= 273 && npc.type <= 276 && Main.rand.Next(2) == 0)
		{
			AddBuff(36, 600);
		}
		if (npc.type >= 277 && npc.type <= 280)
		{
			AddBuff(24, 600);
		}
		if (npc.type == 371)
		{
			AddBuff(103, 60 * Main.rand.Next(3, 8));
		}
		if (npc.type == 370 && Main.expertMode)
		{
			int num3 = Utils.SelectRandom<int>(Main.rand, 0, 148, 30);
			if (num3 != 0)
			{
				AddBuff(num3, 60 * Main.rand.Next(3, 11));
			}
		}
		if (((npc.type == 1 && npc.netID == -6) || npc.type == 81 || npc.type == 79 || npc.type == 183 || npc.type == 630) && Main.rand.Next(4) == 0)
		{
			AddBuff(22, 900);
		}
		if ((npc.type == 23 || npc.type == 25) && Main.rand.Next(3) == 0)
		{
			AddBuff(24, 420);
		}
		if ((npc.type == 34 || npc.type == 83 || npc.type == 84 || npc.type == 179 || npc.type == 289) && Main.rand.Next(3) == 0)
		{
			AddBuff(23, 240);
		}
		if ((npc.type == 104 || npc.type == 102) && Main.rand.Next(8) == 0)
		{
			AddBuff(30, 2700);
		}
		if (npc.type == 75 && Main.rand.Next(10) == 0)
		{
			AddBuff(35, 420);
		}
		if ((npc.type == 163 || npc.type == 238 || npc.type == 236 || npc.type == 237) && Main.rand.Next(10) == 0)
		{
			AddBuff(70, 240);
		}
		if ((npc.type == 79 || npc.type == 103 || npc.type == 630) && Main.rand.Next(5) == 0)
		{
			AddBuff(35, 420);
		}
		if ((npc.type == 75 || npc.type == 78 || npc.type == 82) && Main.rand.Next(8) == 0)
		{
			AddBuff(32, 900);
		}
		if ((npc.type == 93 || npc.type == 109 || npc.type == 80) && Main.rand.Next(14) == 0)
		{
			AddBuff(31, 300);
		}
		if (npc.type >= 305 && npc.type <= 314 && Main.rand.Next(10) == 0)
		{
			AddBuff(33, 3600);
		}
		if (npc.type == 77 && Main.rand.Next(6) == 0)
		{
			AddBuff(36, 7200);
		}
		if (npc.type == 112 && Main.rand.Next(20) == 0)
		{
			AddBuff(33, 18000);
		}
		if (npc.type == 182 && Main.rand.Next(25) == 0)
		{
			AddBuff(33, 7200);
		}
		if (npc.type == 141 && Main.rand.Next(2) == 0)
		{
			AddBuff(20, 600);
		}
		if (npc.type == 147 && !frozen && Main.rand.Next(12) == 0)
		{
			AddBuff(46, 600);
		}
		if (npc.type == 150)
		{
			if (Main.rand.Next(2) == 0)
			{
				AddBuff(46, 900);
			}
			if (!frozen && Main.rand.Next(35) == 0)
			{
				AddBuff(47, 60);
			}
			else if (!frozen && Main.expertMode && Main.rand.Next(35) == 0)
			{
				AddBuff(47, 60);
			}
		}
		if (npc.type == 184)
		{
			AddBuff(46, 1200);
			if (!frozen && Main.rand.Next(15) == 0)
			{
				AddBuff(47, 60);
			}
			else if (!frozen && Main.expertMode && Main.rand.Next(25) == 0)
			{
				AddBuff(47, 60);
			}
		}
	}

	public void GrappleMovement()
	{
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0367: Unknown result type (might be due to invalid IL or missing references)
		//IL_037c: Unknown result type (might be due to invalid IL or missing references)
		//IL_037e: Unknown result type (might be due to invalid IL or missing references)
		//IL_038f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_03be: Unknown result type (might be due to invalid IL or missing references)
		if (grappling[0] < 0)
		{
			return;
		}
		StopVanityActions();
		if (Main.myPlayer == whoAmI && mount.Active)
		{
			mount.Dismount(this);
		}
		canCarpet = true;
		carpetFrame = -1;
		wingFrame = 1;
		if (velocity.Y == 0f || (wet && (double)velocity.Y > -0.02 && (double)velocity.Y < 0.02))
		{
			wingFrame = 0;
		}
		if (wings == 4)
		{
			wingFrame = 3;
		}
		if (wings == 30)
		{
			wingFrame = 0;
		}
		RefreshMovementAbilities();
		rocketFrame = false;
		canRocket = false;
		rocketRelease = false;
		fallStart = (int)(position.Y / 16f);
		int num = -1;
		for (int i = 0; i < grapCount; i++)
		{
			if (Main.projectile[grappling[i]].type == 403)
			{
				num = i;
			}
		}
		GetGrapplingForces(base.Center, out var preferredPlayerDirectionToSet, out var preferedPlayerVelocityX, out var preferedPlayerVelocityY);
		if (preferedPlayerVelocityY > 0f)
		{
			GoingDownWithGrapple = true;
		}
		velocity.X = preferedPlayerVelocityX;
		velocity.Y = preferedPlayerVelocityY;
		if (num != -1)
		{
			Projectile projectile = Main.projectile[grappling[num]];
			if (projectile.position.X < position.X + (float)width && projectile.position.X + (float)projectile.width >= position.X && projectile.position.Y < position.Y + (float)height && projectile.position.Y + (float)projectile.height >= position.Y)
			{
				int num2 = (int)(projectile.position.X + (float)(projectile.width / 2)) / 16;
				int num3 = (int)(projectile.position.Y + (float)(projectile.height / 2)) / 16;
				velocity = Vector2.Zero;
				if (Main.tile[num2, num3].type == 314)
				{
					Vector2 Position = default(Vector2);
					Position.X = projectile.position.X + (float)(projectile.width / 2) - (float)(width / 2);
					Position.Y = projectile.position.Y + (float)(projectile.height / 2) - (float)(height / 2);
					RemoveAllGrapplingHooks();
					int num4 = 13;
					if (miscEquips[2].stack > 0 && miscEquips[2].mountType >= 0 && MountID.Sets.Cart[miscEquips[2].mountType] && (!miscEquips[2].expertOnly || Main.expertMode) && (!miscEquips[2].masterOnly || Main.masterMode))
					{
						num4 = miscEquips[2].mountType;
					}
					int num5 = height + Mount.GetHeightBoost(num4);
					if (Minecart.GetOnTrack(num2, num3, ref Position, width, num5) && !Collision.SolidCollision(Position, width, num5 - 20))
					{
						position = Position;
						DelegateMethods.Minecart.rotation = fullRotation;
						DelegateMethods.Minecart.rotationOrigin = fullRotationOrigin;
						mount.SetMount(num4, this, minecartLeft);
						Minecart.WheelSparks(mount.Delegations.MinecartDust, position, width, height, 25);
					}
				}
			}
		}
		if (itemAnimation == 0)
		{
			if (velocity.X == 0f && preferredPlayerDirectionToSet.HasValue)
			{
				ChangeDir(preferredPlayerDirectionToSet.Value);
			}
			if (velocity.X > 0f)
			{
				ChangeDir(1);
			}
			if (velocity.X < 0f)
			{
				ChangeDir(-1);
			}
		}
		if (controlJump)
		{
			if (releaseJump)
			{
				if ((velocity.Y == 0f || (wet && (double)velocity.Y > -0.02 && (double)velocity.Y < 0.02)) && !controlDown)
				{
					velocity.Y = 0f - jumpSpeed;
					jump = jumpHeight / 2;
					releaseJump = false;
				}
				else
				{
					velocity.Y += 0.01f;
					releaseJump = false;
				}
				RefreshDoubleJumps();
				RemoveAllGrapplingHooks();
			}
		}
		else
		{
			releaseJump = true;
		}
	}

	public void DoQueenSlimeHookTeleport(Vector2 targetPosition)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		int num = 150;
		Vector2 vector = position;
		Vector2 vector2 = velocity;
		for (int i = 0; i < num; i++)
		{
			vector2 = (vector + base.Size / 2f).DirectionTo(targetPosition).SafeNormalize(Vector2.Zero) * 12f;
			Vector2 vector3 = Collision.TileCollision(vector, vector2, width, height, fallThrough: true, fall2: true, (int)gravDir);
			vector += vector3;
		}
		int num2 = 10;
		_ = vector - position;
		Teleport(vector, num2);
		NetMessage.SendData(65, -1, -1, null, 0, whoAmI, vector.X, vector.Y, num2);
	}

	private void GetGrapplingForces(Vector2 fromPosition, out int? preferredPlayerDirectionToSet, out float preferedPlayerVelocityX, out float preferedPlayerVelocityY)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0363: Unknown result type (might be due to invalid IL or missing references)
		//IL_0364: Unknown result type (might be due to invalid IL or missing references)
		//IL_0368: Unknown result type (might be due to invalid IL or missing references)
		//IL_0375: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		float num3 = 0f;
		preferredPlayerDirectionToSet = null;
		int num4 = 0;
		Vector2 vector = default(Vector2);
		for (int i = 0; i < grapCount; i++)
		{
			Projectile projectile = Main.projectile[grappling[i]];
			if (projectile.ai[0] != 2f || projectile.position.HasNaNs())
			{
				continue;
			}
			int type = projectile.type;
			int num11;
			if (projectile.ModProjectile != null)
			{
				num11 = ((projectile.ModProjectile.AIType > 0) ? 1 : 0);
				if (num11 != 0)
				{
					projectile.type = projectile.ModProjectile.AIType;
				}
			}
			else
			{
				num11 = 0;
			}
			num += projectile.position.X + (float)(projectile.width / 2);
			num3 += projectile.position.Y + (float)(projectile.height / 2);
			num4++;
			if (projectile.type == 446)
			{
				((Vector2)(ref vector))._002Ector((float)(controlRight.ToInt() - controlLeft.ToInt()), (float)(controlDown.ToInt() - controlUp.ToInt()) * gravDir);
				if (vector != Vector2.Zero)
				{
					((Vector2)(ref vector)).Normalize();
				}
				vector *= 100f;
				Vector2 vec = Vector2.Normalize(base.Center - projectile.Center + vector);
				if (vec.HasNaNs())
				{
					vec = -Vector2.UnitY;
				}
				float num5 = 200f;
				num += vec.X * num5;
				num3 += vec.Y * num5;
			}
			else if (projectile.type == 652)
			{
				Vector2 vector2 = Utils.SafeNormalize(new Vector2((float)(controlRight.ToInt() - controlLeft.ToInt()), (float)(controlDown.ToInt() - controlUp.ToInt()) * gravDir), Vector2.Zero);
				Vector2 vector3 = projectile.Center - base.Center;
				Vector2 vector4 = vector3.SafeNormalize(Vector2.Zero);
				Vector2 value = Vector2.Zero;
				if (vector2 != Vector2.Zero)
				{
					value = vector4 * Vector2.Dot(vector4, vector2);
				}
				float num6 = 6f;
				if (Vector2.Dot(value, vector3) < 0f && ((Vector2)(ref vector3)).Length() >= 600f)
				{
					num6 = 0f;
				}
				num += 0f - vector3.X + value.X * num6;
				num3 += 0f - vector3.Y + value.Y * num6;
			}
			else if (projectile.type == 865)
			{
				Vector2 vector5 = (projectile.rotation - (float)Math.PI / 2f).ToRotationVector2().SafeNormalize(Vector2.UnitY);
				Vector2 vector6 = -vector5 * 28f;
				num += vector6.X;
				num3 += vector6.Y;
				if (vector5.X != 0f)
				{
					preferredPlayerDirectionToSet = Math.Sign(vector5.X);
				}
			}
			if (num11 != 0)
			{
				projectile.type = type;
			}
			ProjectileLoader.GrappleTargetPoint(projectile, this, ref num, ref num3);
		}
		if (num4 == 0)
		{
			preferedPlayerVelocityX = velocity.X;
			preferedPlayerVelocityY = velocity.Y;
			return;
		}
		float num7 = num / (float)num4;
		float num8 = num3 / (float)num4;
		preferedPlayerVelocityX = num7 - fromPosition.X;
		preferedPlayerVelocityY = num8 - fromPosition.Y;
		float num9 = (float)Math.Sqrt(preferedPlayerVelocityX * preferedPlayerVelocityX + preferedPlayerVelocityY * preferedPlayerVelocityY);
		float num10 = 11f;
		if (Main.projectile[grappling[0]].type == 315)
		{
			num10 = 14f;
		}
		if (Main.projectile[grappling[0]].type == 487)
		{
			num10 = 12f;
		}
		if (Main.projectile[grappling[0]].type >= 646 && Main.projectile[grappling[0]].type <= 649)
		{
			num10 = 16f;
		}
		ProjectileLoader.GrapplePullSpeed(Main.projectile[grappling[0]], this, ref num10);
		float num2 = num9;
		num2 = ((!(num9 > num10)) ? 1f : (num10 / num9));
		preferedPlayerVelocityX *= num2;
		preferedPlayerVelocityY *= num2;
	}

	public void RefreshMovementAbilities(bool doubleJumps = true)
	{
		wingTime = wingTimeMax;
		rocketTime = rocketTimeMax;
		rocketDelay = 0;
		if (doubleJumps)
		{
			RefreshDoubleJumps();
		}
	}

	private void RefreshDoubleJumps()
	{
		RefreshExtraJumps();
	}

	/// <summary>
	/// For each extra jump that is <see cref="P:Terraria.DataStructures.ExtraJumpState.Enabled" />, its <see cref="P:Terraria.DataStructures.ExtraJumpState.Available" /> property set to <see langword="true" />, allowing the extra jump to be used again.<br />
	/// Vanilla calls this method when the player is grounded and when jumping off of a grappling hook.
	/// </summary>
	public void RefreshExtraJumps()
	{
		ExtraJumpLoader.RefreshJumps(this);
	}

	/// <summary>
	/// Sets the <see cref="P:Terraria.DataStructures.ExtraJumpState.Available" /> flag for all extra jumps to <see langword="false" />.<br />
	/// If you want to disable an extra jump, use <see cref="M:Terraria.DataStructures.ExtraJumpState.Disable" /> instead.<br />
	/// If you want to disable <b>all</b> extra jumps, but not prevent them once the disabling factor is removed, use <see cref="F:Terraria.Player.blockExtraJumps" /> instead.
	/// </summary>
	public void ConsumeAllExtraJumps()
	{
		ExtraJumpLoader.ConsumeAllJumps(this);
	}

	public void StickyMovement()
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0510: Unknown result type (might be due to invalid IL or missing references)
		//IL_051a: Unknown result type (might be due to invalid IL or missing references)
		//IL_051f: Unknown result type (might be due to invalid IL or missing references)
		//IL_040c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0427: Unknown result type (might be due to invalid IL or missing references)
		//IL_042d: Unknown result type (might be due to invalid IL or missing references)
		//IL_046b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0475: Unknown result type (might be due to invalid IL or missing references)
		//IL_047a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0673: Unknown result type (might be due to invalid IL or missing references)
		//IL_068e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0694: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_062a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0634: Unknown result type (might be due to invalid IL or missing references)
		//IL_0639: Unknown result type (might be due to invalid IL or missing references)
		//IL_0831: Unknown result type (might be due to invalid IL or missing references)
		//IL_084c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0852: Unknown result type (might be due to invalid IL or missing references)
		//IL_0890: Unknown result type (might be due to invalid IL or missing references)
		//IL_089a: Unknown result type (might be due to invalid IL or missing references)
		//IL_089f: Unknown result type (might be due to invalid IL or missing references)
		//IL_078d: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_07fb: Unknown result type (might be due to invalid IL or missing references)
		if (shimmering)
		{
			return;
		}
		bool flag = false;
		if (mount.Type > 0 && MountID.Sets.Cart[mount.Type] && Math.Abs(velocity.X) > 5f)
		{
			flag = true;
		}
		int num = width / 2;
		int num3 = height / 2;
		new Vector2(position.X + (float)(width / 2) - (float)(num / 2), position.Y + (float)(height / 2) - (float)(num3 / 2));
		Vector2 vector = Collision.StickyTiles(position, velocity, width, height);
		if (vector.Y != -1f && vector.X != -1f)
		{
			int num4 = (int)vector.X;
			int num5 = (int)vector.Y;
			int type = Main.tile[num4, num5].type;
			if (whoAmI == Main.myPlayer && type == 51 && (velocity.X != 0f || velocity.Y != 0f))
			{
				stickyBreak++;
				if (stickyBreak > Main.rand.Next(20, 100) || flag)
				{
					stickyBreak = 0;
					WorldGen.KillTile(num4, num5);
					if (Main.netMode == 1 && !Main.tile[num4, num5].active() && Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 0, num4, num5);
					}
				}
			}
			if (flag)
			{
				return;
			}
			fallStart = (int)(position.Y / 16f);
			if (type != 229)
			{
				jump = 0;
			}
			if (velocity.X > 1f)
			{
				velocity.X = 1f;
			}
			if (velocity.X < -1f)
			{
				velocity.X = -1f;
			}
			if ((double)velocity.X > 0.75 || (double)velocity.X < -0.75)
			{
				velocity.X *= 0.85f;
			}
			else
			{
				velocity.X *= 0.6f;
			}
			if (gravDir == -1f)
			{
				if (velocity.Y < -1f)
				{
					velocity.Y = -1f;
				}
				if (velocity.Y > 5f)
				{
					velocity.Y = 5f;
				}
				if (velocity.Y > 0f)
				{
					velocity.Y *= 0.96f;
				}
				else
				{
					velocity.Y *= 0.3f;
				}
			}
			else
			{
				if (velocity.Y > 1f)
				{
					velocity.Y = 1f;
				}
				if (velocity.Y < -5f)
				{
					velocity.Y = -5f;
				}
				if (velocity.Y < 0f)
				{
					velocity.Y *= 0.96f;
				}
				else
				{
					velocity.Y *= 0.3f;
				}
			}
			if (type != 229 || Main.rand.Next(5) != 0 || (!((double)velocity.Y > 0.15) && !(velocity.Y < 0f)))
			{
				return;
			}
			if ((float)(num4 * 16) < position.X + (float)(width / 2))
			{
				int num6 = Dust.NewDust(new Vector2(position.X - 4f, (float)(num5 * 16)), 4, 16, 153, 0f, 0f, 50);
				Main.dust[num6].scale += (float)Main.rand.Next(0, 6) * 0.1f;
				Dust obj = Main.dust[num6];
				obj.velocity *= 0.1f;
				Main.dust[num6].noGravity = true;
			}
			else
			{
				int num7 = Dust.NewDust(new Vector2(position.X + (float)width - 2f, (float)(num5 * 16)), 4, 16, 153, 0f, 0f, 50);
				Main.dust[num7].scale += (float)Main.rand.Next(0, 6) * 0.1f;
				Dust obj2 = Main.dust[num7];
				obj2.velocity *= 0.1f;
				Main.dust[num7].noGravity = true;
			}
			if (Main.tile[num4, num5 + 1] != null && Main.tile[num4, num5 + 1].type == 229 && position.Y + (float)height > (float)((num5 + 1) * 16))
			{
				if ((float)(num4 * 16) < position.X + (float)(width / 2))
				{
					int num8 = Dust.NewDust(new Vector2(position.X - 4f, (float)(num5 * 16 + 16)), 4, 16, 153, 0f, 0f, 50);
					Main.dust[num8].scale += (float)Main.rand.Next(0, 6) * 0.1f;
					Dust obj3 = Main.dust[num8];
					obj3.velocity *= 0.1f;
					Main.dust[num8].noGravity = true;
				}
				else
				{
					int num9 = Dust.NewDust(new Vector2(position.X + (float)width - 2f, (float)(num5 * 16 + 16)), 4, 16, 153, 0f, 0f, 50);
					Main.dust[num9].scale += (float)Main.rand.Next(0, 6) * 0.1f;
					Dust obj4 = Main.dust[num9];
					obj4.velocity *= 0.1f;
					Main.dust[num9].noGravity = true;
				}
			}
			if (Main.tile[num4, num5 + 2] != null && Main.tile[num4, num5 + 2].type == 229 && position.Y + (float)height > (float)((num5 + 2) * 16))
			{
				if ((float)(num4 * 16) < position.X + (float)(width / 2))
				{
					int num10 = Dust.NewDust(new Vector2(position.X - 4f, (float)(num5 * 16 + 32)), 4, 16, 153, 0f, 0f, 50);
					Main.dust[num10].scale += (float)Main.rand.Next(0, 6) * 0.1f;
					Dust obj5 = Main.dust[num10];
					obj5.velocity *= 0.1f;
					Main.dust[num10].noGravity = true;
				}
				else
				{
					int num2 = Dust.NewDust(new Vector2(position.X + (float)width - 2f, (float)(num5 * 16 + 32)), 4, 16, 153, 0f, 0f, 50);
					Main.dust[num2].scale += (float)Main.rand.Next(0, 6) * 0.1f;
					Dust obj6 = Main.dust[num2];
					obj6.velocity *= 0.1f;
					Main.dust[num2].noGravity = true;
				}
			}
		}
		else
		{
			stickyBreak = 0;
		}
	}

	public bool HasLockedInventory()
	{
		return IsStackingItems();
	}

	public bool IsStackingItems()
	{
		for (int i = 0; i < inventoryChestStack.Length; i++)
		{
			if (inventoryChestStack[i])
			{
				if (inventory[i].type != 0 && inventory[i].stack != 0)
				{
					return true;
				}
				inventoryChestStack[i] = false;
			}
		}
		if (disableVoidBag >= 0)
		{
			return true;
		}
		return false;
	}

	public List<int> GetNearbyContainerProjectilesList()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		List<int> list = new List<int>();
		Vector2 center = base.Center;
		for (int i = 0; i < 1000; i++)
		{
			Projectile projectile = Main.projectile[i];
			if (!projectile.active)
			{
				continue;
			}
			int containerIndex = -1;
			if (projectile.TryGetContainerIndex(out containerIndex))
			{
				Point point = projectile.Hitbox.ClosestPointInRect(center).ToTileCoordinates();
				if (IsInTileInteractionRange(point.X, point.Y, TileReachCheckSettings.QuickStackToNearbyChests))
				{
					list.Add(i);
				}
			}
		}
		return list;
	}

	public void UpdateNearbyInteractibleProjectilesList()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		List<int> projectilesToInteractWith = _projectilesToInteractWith;
		projectilesToInteractWith.Clear();
		if (!Main.CurrentFrameFlags.HadAnActiveInteractibleProjectile)
		{
			return;
		}
		Vector2 compareSpot = base.Center;
		for (int i = 0; i < 1000; i++)
		{
			Projectile proj = Main.projectile[i];
			if (IsProjectileInteractibleAndInInteractionRange(proj, ref compareSpot))
			{
				projectilesToInteractWith.Add(i);
			}
		}
	}

	public bool IsProjectileInteractibleAndInInteractionRange(Projectile proj, ref Vector2 compareSpot)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (!proj.active)
		{
			return false;
		}
		if (!proj.IsInteractible())
		{
			return false;
		}
		Point point = proj.Hitbox.ClosestPointInRect(compareSpot).ToTileCoordinates();
		if (!IsInTileInteractionRange(point.X, point.Y, TileReachCheckSettings.Simple))
		{
			return false;
		}
		return true;
	}

	public bool useVoidBag()
	{
		for (int i = 0; i < 58; i++)
		{
			if (inventory[i].stack > 0 && inventory[i].type == 4131)
			{
				return true;
			}
		}
		return false;
	}

	public void QuickStackAllChests()
	{
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_041e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_050e: Unknown result type (might be due to invalid IL or missing references)
		if (HasLockedInventory())
		{
			return;
		}
		List<int> nearbyContainerProjectilesList = GetNearbyContainerProjectilesList();
		for (int i = 0; i < nearbyContainerProjectilesList.Count; i++)
		{
			Projectile projectile = Main.projectile[nearbyContainerProjectilesList[i]];
			if (projectile.TryGetContainerIndex(out var containerIndex))
			{
				ContainerTransferContext context = ContainerTransferContext.FromProjectile(projectile);
				int num = chest;
				chest = containerIndex;
				ChestUI.QuickStack(context);
				if (useVoidBag())
				{
					ChestUI.QuickStack(context, voidStack: true);
				}
				chest = num;
			}
		}
		int num2 = 39;
		int num3 = (int)(base.Center.X / 16f);
		int num4 = (int)(base.Center.Y / 16f);
		for (int j = num3 - num2; j <= num3 + num2; j++)
		{
			if (j < 0 || j >= Main.maxTilesX)
			{
				continue;
			}
			for (int k = num4 - num2; k <= num4 + num2; k++)
			{
				if (k < 0 || k >= Main.maxTilesY)
				{
					continue;
				}
				int num5 = 0;
				if (Main.tile[j, k].type == 29)
				{
					num5 = -2;
				}
				else if (Main.tile[j, k].type == 97)
				{
					num5 = -3;
				}
				else if (Main.tile[j, k].type == 463)
				{
					num5 = -4;
				}
				else if (Main.tile[j, k].type == 491)
				{
					num5 = -5;
				}
				if (num5 >= 0)
				{
					continue;
				}
				Vector2 val = new Vector2((float)(j * 16 + 8), (float)(k * 16 + 8)) - base.Center;
				if (((Vector2)(ref val)).Length() < 600f)
				{
					ContainerTransferContext context2 = ContainerTransferContext.FromBlockPosition(j, k);
					int num6 = chest;
					chest = num5;
					ChestUI.QuickStack(context2);
					if (useVoidBag())
					{
						ChestUI.QuickStack(context2, voidStack: true);
					}
					chest = num6;
				}
			}
		}
		if (Main.netMode == 1)
		{
			for (int l = 10; l < 50; l++)
			{
				if (inventory[l].type > 0 && inventory[l].stack > 0 && !inventory[l].favorited && !inventory[l].IsACoin)
				{
					NetMessage.SendData(5, -1, -1, null, whoAmI, PlayerItemSlotID.Inventory0 + l, inventory[l].prefix);
					NetMessage.SendData(85, -1, -1, null, PlayerItemSlotID.Inventory0 + l);
					inventoryChestStack[l] = true;
				}
			}
			if (!useVoidBag())
			{
				return;
			}
			for (int m = 0; m < 40; m++)
			{
				if (bank4.item[m].type > 0 && bank4.item[m].stack > 0 && !bank4.item[m].favorited && !bank4.item[m].IsACoin)
				{
					NetMessage.SendData(5, -1, -1, null, whoAmI, PlayerItemSlotID.Bank4_0 + m, bank4.item[m].prefix);
					NetMessage.SendData(85, -1, -1, null, PlayerItemSlotID.Bank4_0 + m);
					disableVoidBag = m;
				}
			}
			return;
		}
		for (int n = 10; n < 50; n++)
		{
			if (inventory[n].type > 0 && inventory[n].stack > 0 && !inventory[n].favorited && !inventory[n].IsACoin)
			{
				int type = inventory[n].type;
				_ = inventory[n].stack;
				inventory[n] = Chest.PutItemInNearbyChest(inventory[n], base.Center);
				if (inventory[n].type == type)
				{
					_ = inventory[n].stack;
				}
			}
		}
		if (!useVoidBag())
		{
			return;
		}
		for (int num7 = 0; num7 < 40; num7++)
		{
			if (bank4.item[num7].type > 0 && bank4.item[num7].stack > 0 && !bank4.item[num7].favorited && !bank4.item[num7].IsACoin)
			{
				int type2 = bank4.item[num7].type;
				_ = bank4.item[num7].stack;
				bank4.item[num7] = Chest.PutItemInNearbyChest(bank4.item[num7], base.Center);
				if (bank4.item[num7].type == type2)
				{
					_ = bank4.item[num7].stack;
				}
			}
		}
	}

	public void CheckDrowning()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_035f: Unknown result type (might be due to invalid IL or missing references)
		//IL_037c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0382: Unknown result type (might be due to invalid IL or missing references)
		bool flag = Collision.DrownCollision(position, width, height, gravDir);
		if (armor[0].type == 250 || armor[0].type == 4275)
		{
			flag = true;
		}
		if (inventory[selectedItem].type == 186 && itemAnimation == 0)
		{
			try
			{
				int num = (int)((position.X + (float)(width / 2) + (float)(6 * direction)) / 16f);
				int num2 = 0;
				if (gravDir == -1f)
				{
					num2 = height;
				}
				int num3 = (int)((position.Y + (float)num2 - 44f * gravDir) / 16f);
				if (Main.tile[num, num3] != null && Main.tile[num, num3].liquid < 128)
				{
					if (Main.tile[num, num3] == null)
					{
						Main.tile[num, num3] = default(Tile);
					}
					if (!Main.tile[num, num3].active() || !Main.tileSolid[Main.tile[num, num3].type] || Main.tileSolidTop[Main.tile[num, num3].type])
					{
						flag = false;
					}
				}
			}
			catch
			{
			}
		}
		if (gills)
		{
			flag = Main.getGoodWorld && !flag;
		}
		if (shimmering)
		{
			flag = false;
		}
		if (mount.Active && mount.Type == 4)
		{
			flag = false;
		}
		if (Main.myPlayer == whoAmI)
		{
			if (accMerman)
			{
				if (flag)
				{
					merman = true;
				}
				flag = false;
			}
			if (flag)
			{
				breathCD++;
				if (breathCD >= breathCDMax)
				{
					breathCD = 0;
					breath--;
					if (breath == 0)
					{
						SoundEngine.PlaySound(23);
					}
					if (breath <= 0)
					{
						lifeRegenTime = 0f;
						breath = 0;
						statLife -= 2;
						if (statLife <= 0)
						{
							statLife = 0;
							KillMe(PlayerDeathReason.ByOther(1), 10.0, 0);
						}
					}
				}
			}
			else
			{
				breath += 3;
				if (breath > breathMax)
				{
					breath = breathMax;
				}
				breathCD = 0;
			}
		}
		if (flag && Main.rand.Next(20) == 0 && !lavaWet && !honeyWet)
		{
			int num4 = 0;
			if (gravDir == -1f)
			{
				num4 += height - 12;
			}
			if (inventory[selectedItem].type == 186)
			{
				Dust.NewDust(new Vector2(position.X + (float)(10 * direction) + 4f, position.Y + (float)num4 - 54f * gravDir), width - 8, 8, 34, 0f, 0f, 0, default(Color), 1.2f);
			}
			else
			{
				Dust.NewDust(new Vector2(position.X + (float)(12 * direction), position.Y + (float)num4 + 4f * gravDir), width - 8, 8, 34, 0f, 0f, 0, default(Color), 1.2f);
			}
		}
	}

	public void CheckCrackedBrickBreak()
	{
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		if (shimmering)
		{
			return;
		}
		bool flag = false;
		if ((float)Main.rand.Next(2, 12) < Math.Abs(velocity.X))
		{
			flag = true;
		}
		if ((float)Main.rand.Next(2, 12) < velocity.Y)
		{
			flag = true;
		}
		if (flag && velocity.Y < 1f)
		{
			Point point = (base.Bottom + Vector2.UnitY).ToTileCoordinates();
			Point point2 = (base.BottomLeft + Vector2.UnitY).ToTileCoordinates();
			Point point3 = (base.BottomRight + Vector2.UnitY).ToTileCoordinates();
			if ((WorldGen.SolidTileAllowBottomSlope(point.X, point.Y) && !TileID.Sets.CrackedBricks[Main.tile[point.X, point.Y].type]) || (WorldGen.SolidTileAllowBottomSlope(point2.X, point2.Y) && !TileID.Sets.CrackedBricks[Main.tile[point2.X, point2.Y].type]) || (WorldGen.SolidTileAllowBottomSlope(point3.X, point3.Y) && !TileID.Sets.CrackedBricks[Main.tile[point3.X, point3.Y].type]))
			{
				flag = false;
			}
		}
		if (!flag)
		{
			return;
		}
		Vector2 vector = position + velocity;
		flag = false;
		int num = (int)(vector.X / 16f);
		int num2 = (int)((vector.X + (float)width) / 16f);
		int num3 = (int)((position.Y + (float)height + 1f) / 16f);
		Rectangle rect = getRect();
		((Rectangle)(ref rect)).Inflate(1, 1);
		for (int i = num; i <= num2; i++)
		{
			for (int j = num3; j <= num3 + 1 && Main.tile[i, j] != null; j++)
			{
				if (!Main.tile[i, j].nactive() || WorldGen.SolidTile(i, j - 1) || !TileID.Sets.CrackedBricks[Main.tile[i, j].type])
				{
					continue;
				}
				Rectangle val = new Rectangle(i * 16, j * 16, 16, 16);
				if (((Rectangle)(ref val)).Intersects(rect))
				{
					flag = true;
					if (velocity.Y > 1f)
					{
						velocity.Y = 1f;
					}
					NetMessage.SendData(13, -1, -1, null, whoAmI);
				}
			}
		}
		if (!flag)
		{
			return;
		}
		num = (int)((vector.X - 16f - 8f) / 16f);
		num2 = (int)((vector.X + (float)width + 16f + 8f) / 16f);
		for (int k = num; k <= num2; k++)
		{
			for (int l = num3; l <= num3 + 2; l++)
			{
				if (Main.tile[k, l].nactive() && !WorldGen.SolidTile(k, l - 1) && TileID.Sets.CrackedBricks[Main.tile[k, l].type])
				{
					WorldGen.KillTile(k, l);
					if (Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 20, k, l);
					}
				}
			}
		}
	}

	public void CheckIceBreak()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (!(velocity.Y > 7f))
		{
			return;
		}
		Vector2 val = position + velocity;
		int num = (int)(val.X / 16f);
		int num2 = (int)((val.X + (float)width) / 16f);
		int num3 = (int)((position.Y + (float)height + 1f) / 16f);
		for (int i = num; i <= num2; i++)
		{
			for (int j = num3; j <= num3 + 1 && Main.tile[i, j] != null; j++)
			{
				if (Main.tile[i, j].nactive() && Main.tile[i, j].type == 162 && !WorldGen.SolidTile(i, j - 1))
				{
					WorldGen.KillTile(i, j);
					if (Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 0, i, j);
					}
				}
			}
		}
	}

	public void SlopeDownMovement()
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		sloping = false;
		if (!mount.Active || mount.Type != 48)
		{
			float y = velocity.Y;
			Vector4 vector = Collision.WalkDownSlope(position, velocity, width, height, gravity * gravDir);
			position.X = vector.X;
			position.Y = vector.Y;
			velocity.X = vector.Z;
			velocity.Y = vector.W;
			if (velocity.Y != y)
			{
				sloping = true;
			}
		}
	}

	public void ShimmerCollision(bool fallThrough, bool ignorePlats, bool noCollision)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		int num = ((!onTrack) ? height : (height - 20));
		Vector2 vector = velocity;
		if (!noCollision)
		{
			velocity = Collision.TileCollision(position, velocity, width, num, fallThrough, ignorePlats, (int)gravDir);
		}
		Vector2 vector2 = velocity * 0.375f;
		if (velocity.X != vector.X)
		{
			vector2.X = velocity.X;
		}
		if (velocity.Y != vector.Y)
		{
			vector2.Y = velocity.Y;
		}
		position += vector2;
		if (shimmerImmune && !noCollision)
		{
			TryFloatingInFluid();
		}
	}

	public void HoneyCollision(bool fallThrough, bool ignorePlats)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		int num = ((!onTrack) ? height : (height - 20));
		Vector2 vector = velocity;
		velocity = Collision.TileCollision(position, velocity, width, num, fallThrough, ignorePlats, (int)gravDir);
		Vector2 vector2 = velocity * 0.25f;
		if (velocity.X != vector.X)
		{
			vector2.X = velocity.X;
		}
		if (velocity.Y != vector.Y)
		{
			vector2.Y = velocity.Y;
		}
		position += vector2;
		TryFloatingInFluid();
	}

	public void WaterCollision(bool fallThrough, bool ignorePlats)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		int num = ((!onTrack) ? height : (height - 20));
		Vector2 vector = velocity;
		velocity = Collision.TileCollision(position, velocity, width, num, fallThrough, ignorePlats, (int)gravDir);
		Vector2 vector2 = velocity * 0.5f;
		if (velocity.X != vector.X)
		{
			vector2.X = velocity.X;
		}
		if (velocity.Y != vector.Y)
		{
			vector2.Y = velocity.Y;
		}
		position += vector2;
		TryFloatingInFluid();
	}

	private void TryFloatingInFluid()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if (!ShouldFloatInWater)
		{
			return;
		}
		if (whoAmI == Main.myPlayer && sitting.isSitting)
		{
			sitting.SitUp(this);
		}
		if (Collision.GetWaterLine(base.Center.ToTileCoordinates(), out var waterLineHeight))
		{
			float num = base.Center.Y;
			if (mount.Active && mount.Type == 37)
			{
				num -= 6f;
			}
			float num2 = num + 8f;
			if (num2 + velocity.Y < waterLineHeight)
			{
				return;
			}
			if (num > waterLineHeight)
			{
				velocity.Y -= 0.4f;
				if (velocity.Y < -6f)
				{
					velocity.Y = -6f;
				}
				return;
			}
			velocity.Y = waterLineHeight - num2;
			if (velocity.Y < -3f)
			{
				velocity.Y = -3f;
			}
			if (velocity.Y == 0f)
			{
				velocity.Y = float.Epsilon;
			}
		}
		else
		{
			velocity.Y -= 0.4f;
		}
	}

	public void DryCollision(bool fallThrough, bool ignorePlats)
	{
		//IL_0396: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_040d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0412: Unknown result type (might be due to invalid IL or missing references)
		//IL_0418: Unknown result type (might be due to invalid IL or missing references)
		//IL_043e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0444: Unknown result type (might be due to invalid IL or missing references)
		//IL_0449: Unknown result type (might be due to invalid IL or missing references)
		//IL_044e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_038d: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_0307: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0316: Unknown result type (might be due to invalid IL or missing references)
		//IL_0328: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0343: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_0378: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0380: Unknown result type (might be due to invalid IL or missing references)
		int num = ((!onTrack) ? height : (height - 10));
		if (((Vector2)(ref velocity)).Length() > 16f)
		{
			Vector2 val = Collision.TileCollision(position, velocity, width, num, fallThrough, ignorePlats, (int)gravDir);
			float num2 = ((Vector2)(ref velocity)).Length();
			Vector2 vector2 = Vector2.Normalize(velocity);
			if (val.Y == 0f)
			{
				vector2.Y = 0f;
			}
			Vector2 zero = Vector2.Zero;
			bool flag = mount.Type == 7 || mount.Type == 8 || mount.Type == 12 || mount.Type == 44 || mount.Type == 49;
			_ = Vector2.Zero;
			while (num2 > 0f)
			{
				float num3 = num2;
				if (num3 > 16f)
				{
					num3 = 16f;
				}
				num2 -= num3;
				Vector2 vector3 = vector2 * num3;
				velocity = vector3;
				SlopeDownMovement();
				vector3 = velocity;
				if (velocity.Y == gravity && (!mount.Active || (!mount.Cart && mount.Type != 48 && !flag)))
				{
					Collision.StepDown(ref position, ref vector3, width, height, ref stepSpeed, ref gfxOffY, (int)gravDir, waterWalk || waterWalk2);
				}
				if (gravDir == -1f)
				{
					if ((carpetFrame != -1 || velocity.Y <= gravity) && !controlUp)
					{
						Collision.StepUp(ref position, ref vector3, width, height, ref stepSpeed, ref gfxOffY, (int)gravDir, controlUp);
					}
				}
				else if (flag || ((carpetFrame != -1 || velocity.Y >= gravity) && !controlDown && !mount.Cart))
				{
					Collision.StepUp(ref position, ref vector3, width, height, ref stepSpeed, ref gfxOffY, (int)gravDir, controlUp);
				}
				Vector2 vector4 = Collision.TileCollision(position, vector3, width, num, fallThrough, ignorePlats, (int)gravDir);
				if (Collision.up && gravDir == 1f)
				{
					jump = 0;
				}
				if (waterWalk || waterWalk2)
				{
					Vector2 val2 = velocity;
					vector4 = Collision.WaterCollision(position, vector4, width, height, fallThrough, fall2: false, waterWalk);
					if (val2 != velocity)
					{
						fallStart = (int)(position.Y / 16f);
					}
				}
				position += vector4;
				bool falling = false;
				if (vector4.Y > gravity)
				{
					falling = true;
				}
				if (vector4.Y < 0f - gravity)
				{
					falling = true;
				}
				velocity = vector4;
				UpdateTouchingTiles();
				TryBouncingBlocks(falling);
				TryLandingOnDetonator();
				SlopingCollision(fallThrough, ignorePlats);
				Collision.StepConveyorBelt(this, gravDir);
				vector4 = velocity;
				zero += vector4;
			}
			velocity = zero;
			return;
		}
		velocity = Collision.TileCollision(position, velocity, width, num, fallThrough, ignorePlats, (int)gravDir);
		if (Collision.up && gravDir == 1f)
		{
			jump = 0;
		}
		if (waterWalk || waterWalk2)
		{
			Vector2 val3 = velocity;
			velocity = Collision.WaterCollision(position, velocity, width, height, fallThrough, fall2: false, waterWalk);
			if (val3 != velocity)
			{
				fallStart = (int)(position.Y / 16f);
			}
		}
		position += velocity;
	}

	private bool TouchBlockSurfaceCenter(int x, int y, Tile tile, out int exitNormalX, out int exitNormalY, out Vector2 surfaceCenter)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		exitNormalX = (exitNormalY = 0);
		Vector2 vector = default(Vector2);
		((Vector2)(ref vector))._002Ector((float)(x * 16), (float)(y * 16));
		Vector2 vector2 = default(Vector2);
		((Vector2)(ref vector2))._002Ector(vector.X + 16f, vector.Y);
		Vector2 vector3 = default(Vector2);
		((Vector2)(ref vector3))._002Ector(vector.X, vector.Y + 16f);
		Vector2 vector4 = default(Vector2);
		((Vector2)(ref vector4))._002Ector(vector.X + 16f, vector.Y + 16f);
		int num = 0;
		int num2 = 0;
		switch (tile.blockType())
		{
		case 1:
			vector.Y += 8f;
			vector2.Y += 8f;
			break;
		case 3:
			vector.Y += 16f;
			num = -1;
			break;
		case 2:
			vector2.Y += 16f;
			num = 1;
			break;
		case 5:
			vector3.Y -= 16f;
			num2 = -1;
			break;
		case 4:
			vector4.Y -= 16f;
			num2 = 1;
			break;
		}
		Vector2 vector5 = default(Vector2);
		((Vector2)(ref vector5))._002Ector(0.0001f);
		_ = position - vector5;
		_ = base.Size + vector5 * 2f;
		Rectangle hitbox = base.Hitbox;
		surfaceCenter = Vector2.Lerp(vector, vector2, 0.5f);
		float num3 = 4f;
		if (hitbox.Distance(surfaceCenter) <= num3)
		{
			exitNormalX = num;
			exitNormalY = -1;
			return true;
		}
		surfaceCenter = Vector2.Lerp(vector3, vector4, 0.5f);
		if (hitbox.Distance(surfaceCenter) <= num3)
		{
			exitNormalX = num2;
			exitNormalY = 1;
			return true;
		}
		if (vector != vector3)
		{
			surfaceCenter = Vector2.Lerp(vector, vector3, 0.5f);
			if (hitbox.Distance(surfaceCenter) <= num3)
			{
				exitNormalX = -1;
				exitNormalY = 0;
				return true;
			}
		}
		if (vector2 != vector4)
		{
			surfaceCenter = Vector2.Lerp(vector2, vector4, 0.5f);
			if (hitbox.Distance(surfaceCenter) <= num3)
			{
				exitNormalX = 1;
				exitNormalY = 0;
				return true;
			}
		}
		return false;
	}

	public void SlopingCollision(bool fallThrough, bool ignorePlats)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		if (ignorePlats || controlDown || grappling[0] >= 0 || gravDir == -1f)
		{
			stairFall = true;
		}
		Vector4 vector = Collision.SlopeCollision(position, velocity, width, height, gravity, stairFall);
		if (Collision.stairFall)
		{
			stairFall = true;
		}
		else if (!fallThrough)
		{
			stairFall = false;
		}
		if (Collision.stair && Math.Abs(vector.Y - position.Y) > 8f + Math.Abs(velocity.X))
		{
			gfxOffY -= vector.Y - position.Y;
			stepSpeed = 4f;
		}
		_ = velocity;
		position.X = vector.X;
		position.Y = vector.Y;
		velocity.X = vector.Z;
		velocity.Y = vector.W;
		if (gravDir == -1f && velocity.Y == 0.0101f)
		{
			velocity.Y = 0f;
		}
	}

	public void FloorVisuals(bool Falling)
	{
		int num = (int)((position.X + (float)(width / 2)) / 16f);
		int num2 = (int)((position.Y + (float)height) / 16f);
		if (gravDir == -1f)
		{
			num2 = (int)(position.Y - 0.1f) / 16;
		}
		Tile? floorTile = GetFloorTile(num, num2);
		int num3 = -1;
		if (floorTile.HasValue)
		{
			num3 = floorTile.Value.type;
		}
		if (num3 <= -1)
		{
			ResetFloorFlags();
			return;
		}
		sticky = num3 == 229;
		slippy = TileID.Sets.IceSkateSlippery[num3];
		slippy2 = num3 == 197;
		powerrun = num3 == 198;
		runningOnSand = TileID.Sets.Conversion.Sand[num3] || TileID.Sets.Conversion.Sandstone[num3] || TileID.Sets.Conversion.HardenedSand[num3];
		if (num3 == 666 && whoAmI == Main.myPlayer)
		{
			AddBuff(120, 180);
		}
		TileLoader.FloorVisuals(num3, this);
		if (Main.tile[num - 1, num2].slope() != 0 || Main.tile[num, num2].slope() != 0 || Main.tile[num + 1, num2].slope() != 0)
		{
			num3 = -1;
		}
		if (!wet && !mount.Cart)
		{
			MakeFloorDust(Falling, num3, floorTile.Value.color());
		}
	}

	public void ResetFloorFlags()
	{
		slippy = false;
		slippy2 = false;
		sticky = false;
		powerrun = false;
		runningOnSand = false;
	}

	public static Tile? GetFloorTile(int x, int y)
	{
		Tile? result = null;
		if (Main.tile[x - 1, y] == null)
		{
			Main.tile[x - 1, y] = default(Tile);
		}
		if (Main.tile[x + 1, y] == null)
		{
			Main.tile[x + 1, y] = default(Tile);
		}
		if (Main.tile[x, y] == null)
		{
			Main.tile[x, y] = default(Tile);
		}
		if (Main.tile[x, y].nactive() && Main.tileSolid[Main.tile[x, y].type])
		{
			result = Main.tile[x, y];
		}
		else if (Main.tile[x - 1, y].nactive() && Main.tileSolid[Main.tile[x - 1, y].type])
		{
			result = Main.tile[x - 1, y];
		}
		else if (Main.tile[x + 1, y].nactive() && Main.tileSolid[Main.tile[x + 1, y].type])
		{
			result = Main.tile[x + 1, y];
		}
		return result;
	}

	public static int GetFloorTileType(int x, int y)
	{
		Tile? floorTile = GetFloorTile(x, y);
		return ((int?)(floorTile.HasValue ? new ushort?(floorTile.GetValueOrDefault().type) : null)) ?? (-1);
	}

	private void MakeFloorDust(bool Falling, int type, int paintColor)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0431: Unknown result type (might be due to invalid IL or missing references)
		//IL_044b: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0701: Unknown result type (might be due to invalid IL or missing references)
		//IL_061b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0625: Unknown result type (might be due to invalid IL or missing references)
		//IL_062a: Unknown result type (might be due to invalid IL or missing references)
		if (type == 659 || type == 667)
		{
			bool flag = true;
			if (!Falling)
			{
				float num = Math.Abs(velocity.X) / 3f;
				if ((float)Main.rand.Next(100) > num * 50f)
				{
					flag = false;
				}
			}
			if (!flag)
			{
				return;
			}
			Vector2 positionInWorld = new Vector2(position.X, position.Y + (float)height - 2f) + new Vector2((float)width * Main.rand.NextFloat(), 6f * Main.rand.NextFloat());
			Vector2 movementVector = Main.rand.NextVector2Circular(0.8f, 0.8f);
			if (movementVector.Y > 0f)
			{
				movementVector.Y *= -1f;
			}
			ParticleOrchestrator.RequestParticleSpawn(clientOnly: true, ParticleOrchestraType.ShimmerBlock, new ParticleOrchestraSettings
			{
				PositionInWorld = positionInWorld,
				MovementVector = movementVector
			}, whoAmI);
		}
		if (!TileLoader.HasWalkDust(type) && type != 147 && type != 25 && type != 53 && type != 189 && type != 0 && type != 123 && type != 57 && type != 112 && type != 116 && type != 196 && type != 193 && type != 195 && type != 197 && type != 199 && type != 229 && type != 234 && type != 371 && type != 460 && type != 666)
		{
			return;
		}
		int num2 = 1;
		if (Falling)
		{
			num2 = 20;
			if (type == 666)
			{
				SoundEngine.PlaySound(SoundID.Item177, (int)base.Center.X, (int)base.Bottom.Y);
			}
		}
		for (int i = 0; i < num2; i++)
		{
			bool flag2 = true;
			int num3 = 76;
			if (type == 666)
			{
				if (paintColor != 0)
				{
					break;
				}
				num3 = 322;
			}
			if (type == 53)
			{
				num3 = 32;
			}
			if (type == 189)
			{
				num3 = 16;
			}
			if (type == 0)
			{
				num3 = 0;
			}
			if (type == 123)
			{
				num3 = 53;
			}
			if (type == 57)
			{
				num3 = 36;
			}
			if (type == 112)
			{
				num3 = 14;
			}
			if (type == 234)
			{
				num3 = 122;
			}
			if (type == 116)
			{
				num3 = 51;
			}
			if (type == 196)
			{
				num3 = 108;
			}
			if (type == 193)
			{
				num3 = 4;
			}
			if (type == 195 || type == 199)
			{
				num3 = 5;
			}
			if (type == 197)
			{
				num3 = 4;
			}
			if (type == 229)
			{
				num3 = 153;
			}
			if (type == 371)
			{
				num3 = 243;
			}
			if (type == 460)
			{
				num3 = 108;
			}
			if (type == 25)
			{
				num3 = 37;
			}
			if (num3 == 32 && Main.rand.Next(2) == 0)
			{
				flag2 = false;
			}
			if (num3 == 14 && Main.rand.Next(2) == 0)
			{
				flag2 = false;
			}
			if (num3 == 51 && Main.rand.Next(2) == 0)
			{
				flag2 = false;
			}
			if (num3 == 36 && Main.rand.Next(2) == 0)
			{
				flag2 = false;
			}
			if (num3 == 0 && Main.rand.Next(3) != 0)
			{
				flag2 = false;
			}
			if (num3 == 53 && Main.rand.Next(3) != 0)
			{
				flag2 = false;
			}
			Color newColor = default(Color);
			if (type == 193)
			{
				((Color)(ref newColor))._002Ector(30, 100, 255, 100);
			}
			if (type == 197)
			{
				((Color)(ref newColor))._002Ector(97, 200, 255, 100);
			}
			if (type == 460)
			{
				((Color)(ref newColor))._002Ector(100, 150, 130, 100);
			}
			TileLoader.WalkDust(type, ref num3, ref flag2, ref newColor);
			if (!Falling)
			{
				float num4 = Math.Abs(velocity.X) / 3f;
				if ((float)Main.rand.Next(100) > num4 * 100f)
				{
					flag2 = false;
				}
			}
			if (!flag2)
			{
				continue;
			}
			float num5 = velocity.X;
			if (num5 > 6f)
			{
				num5 = 6f;
			}
			if (num5 < -6f)
			{
				num5 = -6f;
			}
			if (!(velocity.X != 0f || Falling))
			{
				continue;
			}
			int num6 = Dust.NewDust(new Vector2(position.X, position.Y + (float)height - 2f), width, 6, num3, 0f, 0f, 50, newColor);
			if (gravDir == -1f)
			{
				Main.dust[num6].position.Y -= height + 4;
			}
			if (num3 == 76)
			{
				Main.dust[num6].scale += (float)Main.rand.Next(3) * 0.1f;
				Main.dust[num6].noLight = true;
			}
			if (num3 == 16 || num3 == 108 || num3 == 153)
			{
				Main.dust[num6].scale += (float)Main.rand.Next(6) * 0.1f;
			}
			if (num3 == 37)
			{
				Main.dust[num6].scale += 0.25f;
				Main.dust[num6].alpha = 50;
			}
			if (num3 == 5)
			{
				Main.dust[num6].scale += (float)Main.rand.Next(2, 8) * 0.1f;
			}
			Main.dust[num6].noGravity = true;
			if (num3 == 322)
			{
				if (Main.rand.Next(4) == 0)
				{
					Main.dust[num6].noGravity = false;
					Main.dust[num6].scale *= 1.1f;
				}
				else
				{
					Main.dust[num6].scale *= 1.2f;
				}
			}
			if (num2 > 1)
			{
				Main.dust[num6].velocity.X *= 1.2f;
				Main.dust[num6].velocity.Y *= 0.8f;
				Main.dust[num6].velocity.Y -= 1f;
				Dust obj = Main.dust[num6];
				obj.velocity *= 0.8f;
				Main.dust[num6].scale += (float)Main.rand.Next(3) * 0.1f;
				Main.dust[num6].velocity.X = (Main.dust[num6].position.X - (position.X + (float)(width / 2))) * 0.2f;
				if (Main.dust[num6].velocity.Y > 0f)
				{
					Main.dust[num6].velocity.Y *= -1f;
				}
				Main.dust[num6].velocity.X += num5 * 0.3f;
			}
			else
			{
				Dust obj2 = Main.dust[num6];
				obj2.velocity *= 0.2f;
			}
			Main.dust[num6].position.X -= num5 * 1f;
			if (gravDir == -1f)
			{
				Main.dust[num6].velocity.Y *= -1f;
			}
		}
	}

	public void BordersMovement()
	{
		if (position.X < Main.leftWorld + 640f + 16f)
		{
			Main.cameraX = 0f;
			position.X = Main.leftWorld + 640f + 16f;
			velocity.X = 0f;
		}
		if (position.X + (float)width > Main.rightWorld - 640f - 32f)
		{
			Main.cameraX = 0f;
			position.X = Main.rightWorld - 640f - 32f - (float)width;
			velocity.X = 0f;
		}
		if (position.Y < Main.topWorld + 640f + 16f)
		{
			if (Main.remixWorld || forcedGravity > 0)
			{
				if (position.Y < Main.topWorld + 640f + 16f - (float)height && !dead)
				{
					KillMe(PlayerDeathReason.ByOther(19), 10.0, 0);
				}
				if (position.Y < Main.topWorld + 320f + 16f)
				{
					position.Y = Main.topWorld + 320f + 16f;
					if (velocity.Y < 0f)
					{
						velocity.Y = 0f;
					}
					gravDir = 1f;
				}
			}
			else
			{
				position.Y = Main.topWorld + 640f + 16f;
				if ((double)velocity.Y < 0.11)
				{
					velocity.Y = 0.11f;
				}
				gravDir = 1f;
			}
			AchievementsHelper.HandleSpecialEvent(this, 11);
		}
		if (position.Y > Main.bottomWorld - 640f - 32f - (float)height)
		{
			position.Y = Main.bottomWorld - 640f - 32f - (float)height;
			velocity.Y = 0f;
		}
		if (position.Y > Main.bottomWorld - 640f - 150f - (float)height)
		{
			AchievementsHelper.HandleSpecialEvent(this, 10);
		}
	}

	public void CollectTaxes()
	{
		int num = Item.buyPrice(0, 0, 0, 50);
		int num2 = Item.buyPrice(0, 25);
		if (Main.tenthAnniversaryWorld)
		{
			num2 *= 2;
			num *= 2;
		}
		if (!NPC.taxCollector || taxMoney >= num2)
		{
			return;
		}
		int num3 = 0;
		for (int i = 0; i < 200; i++)
		{
			if (Main.npc[i].active && !Main.npc[i].homeless && !NPCID.Sets.IsTownPet[Main.npc[i].type] && NPC.TypeToDefaultHeadIndex(Main.npc[i].type) > 0)
			{
				num3++;
			}
		}
		taxMoney += num * num3;
		if (taxMoney > num2)
		{
			taxMoney = num2;
		}
	}

	public void GamepadEnableGrappleCooldown()
	{
		_quickGrappleCooldown = 3;
	}

	public void TryInterruptingItemUsage()
	{
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		if (heldProj > -1 && Main.projectile[heldProj].IsInterruptible(this))
		{
			flag = true;
		}
		if (!flag)
		{
			return;
		}
		bool flag2 = false;
		if (PlayerInput.Triggers.Current.Hotbar1)
		{
			flag2 = true;
		}
		if (PlayerInput.Triggers.Current.Hotbar2)
		{
			flag2 = true;
		}
		if (PlayerInput.Triggers.Current.Hotbar3)
		{
			flag2 = true;
		}
		if (PlayerInput.Triggers.Current.Hotbar4)
		{
			flag2 = true;
		}
		if (PlayerInput.Triggers.Current.Hotbar5)
		{
			flag2 = true;
		}
		if (PlayerInput.Triggers.Current.Hotbar6)
		{
			flag2 = true;
		}
		if (PlayerInput.Triggers.Current.Hotbar7)
		{
			flag2 = true;
		}
		if (PlayerInput.Triggers.Current.Hotbar8)
		{
			flag2 = true;
		}
		if (PlayerInput.Triggers.Current.Hotbar9)
		{
			flag2 = true;
		}
		if (PlayerInput.Triggers.Current.Hotbar10)
		{
			flag2 = true;
		}
		bool flag3 = Main.hairWindow;
		if (flag3)
		{
			int y = Main.screenHeight / 2 + 60;
			Rectangle val = new Rectangle(Main.screenWidth / 2 - TextureAssets.HairStyleBack.Width() / 2, y, TextureAssets.HairStyleBack.Width(), TextureAssets.HairStyleBack.Height());
			flag3 = ((Rectangle)(ref val)).Contains(Main.MouseScreen.ToPoint());
		}
		if (!Main.mapFullscreen && !CaptureManager.Instance.Active && !flag3 && !Main.playerInventory)
		{
			int num = PlayerInput.Triggers.Current.HotbarPlus.ToInt() - PlayerInput.Triggers.Current.HotbarMinus.ToInt();
			if (PlayerInput.CurrentProfile.HotbarRadialHoldTimeRequired != -1)
			{
				num = PlayerInput.Triggers.JustReleased.HotbarPlus.ToInt() - PlayerInput.Triggers.JustReleased.HotbarMinus.ToInt();
			}
			if (PlayerInput.Triggers.Current.HotbarScrollCD != 0)
			{
				num = 0;
			}
			if (!Main.inFancyUI && !Main.ingameOptionsWindow)
			{
				num += PlayerInput.ScrollWheelDelta / -120;
			}
			if (num != 0)
			{
				num = ClampHotbarOffset(num);
				_ = selectedItem;
				flag2 = true;
			}
		}
		if (flag2 && heldProj > -1)
		{
			Main.projectile[heldProj].Interrupt(this);
		}
	}

	private bool CanMoveForwardOnRope(int dir, int x, int y)
	{
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		int num = x + dir;
		if (Main.tile[num, y] != null && Main.tile[num, y].active() && Main.tileRope[Main.tile[num, y].type])
		{
			int num2 = num * 16 + 8 - width / 2;
			float y2 = position.Y;
			y2 = y * 16 + 22;
			if ((!Main.tile[num, y - 1].active() || !Main.tileRope[Main.tile[num, y - 1].type]) && (!Main.tile[num, y + 1].active() || !Main.tileRope[Main.tile[num, y + 1].type]))
			{
				y2 = y * 16 + 22;
			}
			if (Collision.SolidCollision(new Vector2((float)num2, y2), width, height))
			{
				return false;
			}
			return true;
		}
		return false;
	}

	public void UpdateHairDyeDust()
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0348: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0358: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0362: Unknown result type (might be due to invalid IL or missing references)
		if (Main.netMode != 2 && !Main.gamePaused && !dead && !ghost && !stoned && !frozen && hairDye == ContentSamples.CommonlyUsedContentSamples.TeamDyeShaderIndex)
		{
			if (Main.rand.Next(45) == 0)
			{
				int type = Main.rand.Next(139, 143);
				int num = Dust.NewDust(position, width, 8, type, 0f, 0f, 0, default(Color), 1.2f);
				Main.dust[num].velocity.X *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.dust[num].velocity.Y *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.dust[num].velocity.X += (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.dust[num].velocity.Y += (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.dust[num].velocity.Y -= 1f;
				Main.dust[num].scale *= 0.7f + (float)Main.rand.Next(-30, 31) * 0.01f;
				Dust obj = Main.dust[num];
				obj.velocity += velocity * 0.2f;
			}
			if (Main.rand.Next(225) == 0)
			{
				int type2 = Main.rand.Next(276, 283);
				int num2 = Gore.NewGore(new Vector2(position.X + (float)Main.rand.Next(width), position.Y + (float)Main.rand.Next(8)), velocity, type2);
				Main.gore[num2].velocity.X *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.gore[num2].velocity.Y *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.gore[num2].scale *= 1f + (float)Main.rand.Next(-20, 21) * 0.01f;
				Main.gore[num2].velocity.X += (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.gore[num2].velocity.Y += (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.gore[num2].velocity.Y -= 1f;
				Gore obj2 = Main.gore[num2];
				obj2.velocity += velocity * 0.2f;
			}
		}
	}

	public void Update(int i)
	{
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_6c9c: Unknown result type (might be due to invalid IL or missing references)
		//IL_6a5a: Unknown result type (might be due to invalid IL or missing references)
		//IL_6df4: Unknown result type (might be due to invalid IL or missing references)
		//IL_6e52: Unknown result type (might be due to invalid IL or missing references)
		//IL_7927: Unknown result type (might be due to invalid IL or missing references)
		//IL_7946: Unknown result type (might be due to invalid IL or missing references)
		//IL_794c: Unknown result type (might be due to invalid IL or missing references)
		//IL_755b: Unknown result type (might be due to invalid IL or missing references)
		//IL_757d: Unknown result type (might be due to invalid IL or missing references)
		//IL_7583: Unknown result type (might be due to invalid IL or missing references)
		//IL_73a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_73c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_73c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0657: Unknown result type (might be due to invalid IL or missing references)
		//IL_067b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0681: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_06bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_7819: Unknown result type (might be due to invalid IL or missing references)
		//IL_783b: Unknown result type (might be due to invalid IL or missing references)
		//IL_7841: Unknown result type (might be due to invalid IL or missing references)
		//IL_7711: Unknown result type (might be due to invalid IL or missing references)
		//IL_7733: Unknown result type (might be due to invalid IL or missing references)
		//IL_7739: Unknown result type (might be due to invalid IL or missing references)
		//IL_7620: Unknown result type (might be due to invalid IL or missing references)
		//IL_7625: Unknown result type (might be due to invalid IL or missing references)
		//IL_7643: Unknown result type (might be due to invalid IL or missing references)
		//IL_7648: Unknown result type (might be due to invalid IL or missing references)
		//IL_7666: Unknown result type (might be due to invalid IL or missing references)
		//IL_766b: Unknown result type (might be due to invalid IL or missing references)
		//IL_6fcf: Unknown result type (might be due to invalid IL or missing references)
		//IL_6ff1: Unknown result type (might be due to invalid IL or missing references)
		//IL_6ff7: Unknown result type (might be due to invalid IL or missing references)
		//IL_7689: Unknown result type (might be due to invalid IL or missing references)
		//IL_768e: Unknown result type (might be due to invalid IL or missing references)
		//IL_7293: Unknown result type (might be due to invalid IL or missing references)
		//IL_72b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_72bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_7185: Unknown result type (might be due to invalid IL or missing references)
		//IL_71a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_71ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_7094: Unknown result type (might be due to invalid IL or missing references)
		//IL_7099: Unknown result type (might be due to invalid IL or missing references)
		//IL_70b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_70bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_70da: Unknown result type (might be due to invalid IL or missing references)
		//IL_70df: Unknown result type (might be due to invalid IL or missing references)
		//IL_70fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_7102: Unknown result type (might be due to invalid IL or missing references)
		//IL_7e19: Unknown result type (might be due to invalid IL or missing references)
		//IL_7e1e: Unknown result type (might be due to invalid IL or missing references)
		//IL_7e65: Unknown result type (might be due to invalid IL or missing references)
		//IL_7e6a: Unknown result type (might be due to invalid IL or missing references)
		//IL_8208: Unknown result type (might be due to invalid IL or missing references)
		//IL_820d: Unknown result type (might be due to invalid IL or missing references)
		//IL_822f: Unknown result type (might be due to invalid IL or missing references)
		//IL_7fad: Unknown result type (might be due to invalid IL or missing references)
		//IL_7fb4: Unknown result type (might be due to invalid IL or missing references)
		//IL_7fb9: Unknown result type (might be due to invalid IL or missing references)
		//IL_7fca: Unknown result type (might be due to invalid IL or missing references)
		//IL_7fcf: Unknown result type (might be due to invalid IL or missing references)
		//IL_8274: Unknown result type (might be due to invalid IL or missing references)
		//IL_827a: Unknown result type (might be due to invalid IL or missing references)
		//IL_827f: Unknown result type (might be due to invalid IL or missing references)
		//IL_8284: Unknown result type (might be due to invalid IL or missing references)
		//IL_8032: Unknown result type (might be due to invalid IL or missing references)
		//IL_8038: Unknown result type (might be due to invalid IL or missing references)
		//IL_803d: Unknown result type (might be due to invalid IL or missing references)
		//IL_8080: Unknown result type (might be due to invalid IL or missing references)
		//IL_8085: Unknown result type (might be due to invalid IL or missing references)
		//IL_8151: Unknown result type (might be due to invalid IL or missing references)
		//IL_8158: Unknown result type (might be due to invalid IL or missing references)
		//IL_815d: Unknown result type (might be due to invalid IL or missing references)
		//IL_80a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1987: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e1a: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e28: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e2d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e35: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e3a: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e41: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e46: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e5f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e65: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e7b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e80: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e90: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e95: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e9a: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ea0: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ead: Unknown result type (might be due to invalid IL or missing references)
		//IL_2eb3: Unknown result type (might be due to invalid IL or missing references)
		//IL_2eb5: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ebf: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ec4: Unknown result type (might be due to invalid IL or missing references)
		//IL_1767: Unknown result type (might be due to invalid IL or missing references)
		//IL_1786: Unknown result type (might be due to invalid IL or missing references)
		//IL_178c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ef9: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f07: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f0c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f14: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f19: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f20: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f25: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f3e: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f44: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f5a: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f5f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f66: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f6b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f70: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f76: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f83: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f89: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f8b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f95: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f9a: Unknown result type (might be due to invalid IL or missing references)
		//IL_849f: Unknown result type (might be due to invalid IL or missing references)
		//IL_8489: Unknown result type (might be due to invalid IL or missing references)
		//IL_843b: Unknown result type (might be due to invalid IL or missing references)
		//IL_3159: Unknown result type (might be due to invalid IL or missing references)
		//IL_84b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_84ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_8139: Unknown result type (might be due to invalid IL or missing references)
		//IL_83a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_83aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_83cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_8343: Unknown result type (might be due to invalid IL or missing references)
		//IL_8348: Unknown result type (might be due to invalid IL or missing references)
		//IL_836a: Unknown result type (might be due to invalid IL or missing references)
		//IL_8582: Unknown result type (might be due to invalid IL or missing references)
		//IL_8594: Unknown result type (might be due to invalid IL or missing references)
		//IL_1377: Unknown result type (might be due to invalid IL or missing references)
		//IL_137c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1380: Unknown result type (might be due to invalid IL or missing references)
		//IL_1385: Unknown result type (might be due to invalid IL or missing references)
		//IL_14d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_14dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_14e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_14e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_39ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_39fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_359b: Unknown result type (might be due to invalid IL or missing references)
		//IL_35f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_3b74: Unknown result type (might be due to invalid IL or missing references)
		//IL_64b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_64cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_64da: Unknown result type (might be due to invalid IL or missing references)
		//IL_64df: Unknown result type (might be due to invalid IL or missing references)
		//IL_64e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_64ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_3d76: Unknown result type (might be due to invalid IL or missing references)
		//IL_3ba8: Unknown result type (might be due to invalid IL or missing references)
		//IL_3dc3: Unknown result type (might be due to invalid IL or missing references)
		//IL_3c44: Unknown result type (might be due to invalid IL or missing references)
		//IL_3e5f: Unknown result type (might be due to invalid IL or missing references)
		//IL_66cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_67de: Unknown result type (might be due to invalid IL or missing references)
		//IL_67e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_67e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_37af: Unknown result type (might be due to invalid IL or missing references)
		//IL_460a: Unknown result type (might be due to invalid IL or missing references)
		//IL_4782: Unknown result type (might be due to invalid IL or missing references)
		//IL_473c: Unknown result type (might be due to invalid IL or missing references)
		//IL_483c: Unknown result type (might be due to invalid IL or missing references)
		//IL_47f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_4c56: Unknown result type (might be due to invalid IL or missing references)
		//IL_4dae: Unknown result type (might be due to invalid IL or missing references)
		//IL_4dea: Unknown result type (might be due to invalid IL or missing references)
		//IL_533d: Unknown result type (might be due to invalid IL or missing references)
		//IL_5356: Unknown result type (might be due to invalid IL or missing references)
		//IL_535c: Unknown result type (might be due to invalid IL or missing references)
		//IL_53a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_53ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_53b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_543f: Unknown result type (might be due to invalid IL or missing references)
		//IL_545b: Unknown result type (might be due to invalid IL or missing references)
		//IL_5461: Unknown result type (might be due to invalid IL or missing references)
		//IL_54b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_54bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_54c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_556a: Unknown result type (might be due to invalid IL or missing references)
		//IL_5585: Unknown result type (might be due to invalid IL or missing references)
		//IL_558b: Unknown result type (might be due to invalid IL or missing references)
		//IL_55b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_55ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_55bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_5652: Unknown result type (might be due to invalid IL or missing references)
		//IL_566a: Unknown result type (might be due to invalid IL or missing references)
		//IL_5670: Unknown result type (might be due to invalid IL or missing references)
		//IL_5695: Unknown result type (might be due to invalid IL or missing references)
		//IL_569f: Unknown result type (might be due to invalid IL or missing references)
		//IL_56a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_5757: Unknown result type (might be due to invalid IL or missing references)
		//IL_5773: Unknown result type (might be due to invalid IL or missing references)
		//IL_5779: Unknown result type (might be due to invalid IL or missing references)
		//IL_579f: Unknown result type (might be due to invalid IL or missing references)
		//IL_57a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_57ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_5826: Unknown result type (might be due to invalid IL or missing references)
		//IL_5846: Unknown result type (might be due to invalid IL or missing references)
		//IL_584c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5863: Unknown result type (might be due to invalid IL or missing references)
		//IL_586d: Unknown result type (might be due to invalid IL or missing references)
		//IL_5872: Unknown result type (might be due to invalid IL or missing references)
		//IL_58d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_59b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_59cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_59d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_5dc6: Unknown result type (might be due to invalid IL or missing references)
		//IL_5dcb: Unknown result type (might be due to invalid IL or missing references)
		//IL_5dda: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ddf: Unknown result type (might be due to invalid IL or missing references)
		//IL_5bf5: Unknown result type (might be due to invalid IL or missing references)
		//IL_5c15: Unknown result type (might be due to invalid IL or missing references)
		//IL_5c1b: Unknown result type (might be due to invalid IL or missing references)
		//IL_5c4e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5c58: Unknown result type (might be due to invalid IL or missing references)
		//IL_5c5d: Unknown result type (might be due to invalid IL or missing references)
		//IL_5c6b: Unknown result type (might be due to invalid IL or missing references)
		//IL_5c71: Unknown result type (might be due to invalid IL or missing references)
		//IL_5c76: Unknown result type (might be due to invalid IL or missing references)
		//IL_5c7b: Unknown result type (might be due to invalid IL or missing references)
		//IL_5e15: Unknown result type (might be due to invalid IL or missing references)
		//IL_5e4b: Unknown result type (might be due to invalid IL or missing references)
		//IL_5e51: Unknown result type (might be due to invalid IL or missing references)
		//IL_5e84: Unknown result type (might be due to invalid IL or missing references)
		//IL_5e8e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5e93: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ea1: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ea7: Unknown result type (might be due to invalid IL or missing references)
		//IL_5eac: Unknown result type (might be due to invalid IL or missing references)
		//IL_5eb1: Unknown result type (might be due to invalid IL or missing references)
		//IL_5eed: Unknown result type (might be due to invalid IL or missing references)
		//IL_5eef: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d02: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d24: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d2a: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d5d: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d67: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d6c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d7a: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d80: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d85: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d8a: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f58: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f93: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f99: Unknown result type (might be due to invalid IL or missing references)
		//IL_5fcc: Unknown result type (might be due to invalid IL or missing references)
		//IL_5fd6: Unknown result type (might be due to invalid IL or missing references)
		//IL_5fdb: Unknown result type (might be due to invalid IL or missing references)
		//IL_5fe9: Unknown result type (might be due to invalid IL or missing references)
		//IL_5fef: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ff4: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ff9: Unknown result type (might be due to invalid IL or missing references)
		//IL_6035: Unknown result type (might be due to invalid IL or missing references)
		//IL_6037: Unknown result type (might be due to invalid IL or missing references)
		using (new Main.CurrentPlayerOverride(this))
		{
			if (i == Main.myPlayer && Main.netMode != 2)
			{
				LockOnHelper.Update();
			}
			if (i == Main.myPlayer && Main.dontStarveWorld)
			{
				DontStarveDarknessDamageDealer.Update(this);
			}
			maxFallSpeed = 10f;
			gravity = defaultGravity;
			jumpHeight = 15;
			jumpSpeed = 5.01f;
			maxRunSpeed = 3f;
			runAcceleration = 0.08f;
			runSlowdown = 0.2f;
			accRunSpeed = maxRunSpeed;
			if (!mount.Active || !mount.Cart)
			{
				onWrongGround = false;
			}
			heldProj = -1;
			instantMovementAccumulatedThisFrame = Vector2.Zero;
			if (PortalPhysicsEnabled)
			{
				maxFallSpeed = 35f;
			}
			if (shimmerWet || shimmering)
			{
				if (shimmering)
				{
					gravity *= 0.9f;
					maxFallSpeed *= 0.9f;
				}
				else
				{
					gravity = 0.15f;
					jumpHeight = 23;
					jumpSpeed = 5.51f;
				}
			}
			else if (wet)
			{
				if (honeyWet)
				{
					gravity = 0.1f;
					maxFallSpeed = 3f;
				}
				else if (merman)
				{
					gravity = 0.3f;
					maxFallSpeed = 7f;
				}
				else if (trident && !lavaWet)
				{
					gravity = 0.25f;
					maxFallSpeed = 6f;
					jumpHeight = 25;
					jumpSpeed = 5.51f;
					if (controlUp)
					{
						gravity = 0.1f;
						maxFallSpeed = 2f;
					}
				}
				else
				{
					gravity = 0.2f;
					maxFallSpeed = 5f;
					jumpHeight = 30;
					jumpSpeed = 6.01f;
				}
			}
			if (vortexDebuff)
			{
				gravity = 0f;
			}
			maxFallSpeed += 0.01f;
			bool flag = false;
			if (Main.myPlayer == i)
			{
				if (Main.mapFullscreen)
				{
					GamepadEnableGrappleCooldown();
				}
				else if (_quickGrappleCooldown > 0)
				{
					_quickGrappleCooldown--;
				}
				TileObject.objectPreview.Reset();
				if (DD2Event.DownedInvasionAnyDifficulty)
				{
					downedDD2EventAnyDifficulty = true;
				}
				autoReuseAllWeapons = Main.SettingsEnabled_AutoReuseAllItems;
			}
			if (NPC.freeCake && talkNPC >= 0 && Main.npc[talkNPC].type == 208)
			{
				NPC.freeCake = false;
				if (Main.netMode != 1)
				{
					Item.NewItem(new EntitySource_Gift(Main.npc[talkNPC]), (int)position.X, (int)position.Y, width, height, 3750);
				}
			}
			if (emoteTime > 0)
			{
				emoteTime--;
			}
			if (ghostDmg > 0f)
			{
				ghostDmg -= 6.6666665f;
			}
			if (ghostDmg < 0f)
			{
				ghostDmg = 0f;
			}
			if (Main.expertMode)
			{
				if (lifeSteal < 70f)
				{
					lifeSteal += 0.5f;
				}
				if (lifeSteal > 70f)
				{
					lifeSteal = 70f;
				}
			}
			else
			{
				if (lifeSteal < 80f)
				{
					lifeSteal += 0.6f;
				}
				if (lifeSteal > 80f)
				{
					lifeSteal = 80f;
				}
			}
			ResizeHitbox();
			if (mount.Active && mount.Type == 0)
			{
				int num111 = (int)(position.X + (float)(width / 2)) / 16;
				int j = (int)(position.Y + (float)(height / 2) - 14f) / 16;
				Lighting.AddLight(num111, j, 0.5f, 0.2f, 0.05f);
				Lighting.AddLight(num111 + direction, j, 0.5f, 0.2f, 0.05f);
				Lighting.AddLight(num111 + direction * 2, j, 0.5f, 0.2f, 0.05f);
			}
			outOfRange = false;
			if (whoAmI != Main.myPlayer)
			{
				int num27 = (int)(position.X + (float)(width / 2)) / 16;
				int num37 = (int)(position.Y + (float)(height / 2)) / 16;
				if (Main.netMode == 1 && !Main.sectionManager.TilesLoaded(num27 - 3, num37 - 3, num27 + 3, num37 + 3))
				{
					flag = true;
				}
				if (flag)
				{
					outOfRange = true;
					numMinions = 0;
					slotsMinions = 0f;
					itemAnimation = 0;
					UpdateBuffs(i);
					PlayerFrame();
				}
			}
			if (tankPet >= 0)
			{
				if (!tankPetReset)
				{
					tankPetReset = true;
				}
				else
				{
					tankPet = -1;
				}
			}
			if (i == Main.myPlayer)
			{
				IsVoidVaultEnabled = HasItem(4131);
			}
			if (chatOverhead.timeLeft > 0)
			{
				chatOverhead.timeLeft--;
			}
			if (snowBallLauncherInteractionCooldown > 0)
			{
				snowBallLauncherInteractionCooldown--;
			}
			environmentBuffImmunityTimer = Math.Max(0, environmentBuffImmunityTimer - 1);
			if (flag)
			{
				return;
			}
			UpdateHairDyeDust();
			UpdateMiscCounter();
			PlayerLoader.PreUpdate(this);
			infernoCounter++;
			if (infernoCounter >= 180)
			{
				infernoCounter = 0;
			}
			timeSinceLastDashStarted++;
			if (timeSinceLastDashStarted >= 300)
			{
				timeSinceLastDashStarted = 300;
			}
			_framesLeftEligibleForDeadmansChestDeathAchievement--;
			if (_framesLeftEligibleForDeadmansChestDeathAchievement < 0)
			{
				_framesLeftEligibleForDeadmansChestDeathAchievement = 0;
			}
			if (titaniumStormCooldown > 0)
			{
				titaniumStormCooldown--;
			}
			if (starCloakCooldown > 0)
			{
				starCloakCooldown--;
				if (Main.rand.Next(5) == 0)
				{
					for (int k = 0; k < 2; k++)
					{
						Dust dust = Dust.NewDustDirect(position, width, height, 45, 0f, 0f, 255, default(Color), (float)Main.rand.Next(20, 26) * 0.1f);
						dust.noLight = true;
						dust.noGravity = true;
						dust.velocity *= 0.5f;
						dust.velocity.X = 0f;
						dust.velocity.Y -= 0.5f;
					}
				}
				if (starCloakCooldown == 0)
				{
					SoundEngine.PlaySound(25);
				}
			}
			_timeSinceLastImmuneGet++;
			if (_timeSinceLastImmuneGet >= 10000)
			{
				_timeSinceLastImmuneGet = 10000;
			}
			float num47 = (float)Main.maxTilesX / 4200f;
			num47 *= num47;
			float num58 = (float)((double)(position.Y / 16f - (60f + 10f * num47)) / (Main.worldSurface / 6.0));
			if (Main.remixWorld)
			{
				num58 = (float)((double)(position.Y / 16f - (60f + 10f * num47)) / (Main.worldSurface / 1.0));
			}
			if (Main.remixWorld)
			{
				if ((double)num58 < 0.1)
				{
					num58 = 0.1f;
				}
			}
			else if ((double)num58 < 0.25)
			{
				num58 = 0.25f;
			}
			if (num58 > 1f)
			{
				num58 = 1f;
			}
			gravity *= num58;
			maxRegenDelay = (1f - (float)statMana / (float)statManaMax2) * 60f * 4f + 45f;
			maxRegenDelay *= 0.7f;
			UpdateSocialShadow();
			UpdateTeleportVisuals();
			whoAmI = i;
			if (whoAmI == Main.myPlayer)
			{
				if (!DD2Event.Ongoing)
				{
					PurgeDD2EnergyCrystals();
				}
				TryPortalJumping();
				if (whoAmI == Main.myPlayer)
				{
					doorHelper.Update(this);
				}
			}
			if (runSoundDelay > 0)
			{
				runSoundDelay--;
			}
			if (attackCD > 0)
			{
				attackCD--;
			}
			if (itemAnimation == 0)
			{
				attackCD = 0;
			}
			if (potionDelay > 0)
			{
				potionDelay--;
			}
			if (i == Main.myPlayer)
			{
				if (trashItem.type >= 1522 && trashItem.type <= 1527)
				{
					trashItem.SetDefaults();
				}
				if (trashItem.type == 3643)
				{
					trashItem.SetDefaults();
				}
				UpdateBiomes();
				UpdateMinionTarget();
			}
			if (ghost)
			{
				Ghost();
				return;
			}
			if (dead)
			{
				UpdateDead();
				ResetProjectileCaches();
				UpdateProjectileCaches(i);
				return;
			}
			TrySpawningFaelings();
			if (i == Main.myPlayer && hasLucyTheAxe)
			{
				LucyAxeMessage.TryPlayingIdleMessage();
			}
			if (velocity.Y == 0f)
			{
				mount.FatigueRecovery();
			}
			Rectangle val;
			if (i == Main.myPlayer && !isControlledByFilm)
			{
				ResetControls();
				if (Main.hasFocus)
				{
					if (!Main.drawingPlayerChat && !Main.editSign && !Main.editChest && !Main.blockInput)
					{
						PlayerInput.Triggers.Current.CopyInto(this);
						LocalInputCache = new DirectionalInputSyncCache(this);
						if (Main.mapFullscreen)
						{
							if (controlUp)
							{
								Main.mapFullscreenPos.Y -= 1f * (16f / Main.mapFullscreenScale);
							}
							if (controlDown)
							{
								Main.mapFullscreenPos.Y += 1f * (16f / Main.mapFullscreenScale);
							}
							if (controlLeft)
							{
								Main.mapFullscreenPos.X -= 1f * (16f / Main.mapFullscreenScale);
							}
							if (controlRight)
							{
								Main.mapFullscreenPos.X += 1f * (16f / Main.mapFullscreenScale);
							}
							controlUp = false;
							controlLeft = false;
							controlDown = false;
							controlRight = false;
							controlJump = false;
							controlUseItem = false;
							controlUseTile = false;
							controlThrow = false;
							controlHook = false;
							controlTorch = false;
							controlSmart = false;
							controlMount = false;
						}
						if (isOperatingAnotherEntity)
						{
							controlUp = (controlDown = (controlLeft = (controlRight = (controlJump = false))));
						}
						if (controlQuickHeal)
						{
							if (releaseQuickHeal)
							{
								QuickHeal();
							}
							releaseQuickHeal = false;
						}
						else
						{
							releaseQuickHeal = true;
						}
						if (controlQuickMana)
						{
							if (releaseQuickMana)
							{
								QuickMana();
							}
							releaseQuickMana = false;
						}
						else
						{
							releaseQuickMana = true;
						}
						if (controlCreativeMenu)
						{
							if (releaseCreativeMenu)
							{
								ToggleCreativeMenu();
							}
							releaseCreativeMenu = false;
						}
						else
						{
							releaseCreativeMenu = true;
						}
						if (controlLeft && controlRight)
						{
							controlLeft = false;
							controlRight = false;
						}
						if (PlayerInput.UsingGamepad || !mouseInterface || !ItemSlot.Options.DisableLeftShiftTrashCan)
						{
							if (PlayerInput.SteamDeckIsUsed && PlayerInput.SettingsForUI.CurrentCursorMode == CursorMode.Mouse)
							{
								TryToToggleSmartCursor(ref Main.SmartCursorWanted_Mouse);
							}
							else if (PlayerInput.UsingGamepad)
							{
								TryToToggleSmartCursor(ref Main.SmartCursorWanted_GamePad);
							}
							else
							{
								TryToToggleSmartCursor(ref Main.SmartCursorWanted_Mouse);
							}
						}
						if (controlSmart)
						{
							releaseSmart = false;
						}
						else
						{
							releaseSmart = true;
						}
						if (controlMount)
						{
							if (releaseMount)
							{
								QuickMount();
							}
							releaseMount = false;
						}
						else
						{
							releaseMount = true;
						}
						if (Main.mapFullscreen)
						{
							if (mapZoomIn)
							{
								Main.mapFullscreenScale *= 1.05f;
							}
							if (mapZoomOut)
							{
								Main.mapFullscreenScale *= 0.95f;
							}
						}
						else
						{
							if (Main.mapStyle == 1)
							{
								if (mapZoomIn)
								{
									Main.mapMinimapScale *= 1.025f;
								}
								if (mapZoomOut)
								{
									Main.mapMinimapScale *= 0.975f;
								}
								if (mapAlphaUp)
								{
									Main.mapMinimapAlpha += 0.015f;
								}
								if (mapAlphaDown)
								{
									Main.mapMinimapAlpha -= 0.015f;
								}
							}
							else if (Main.mapStyle == 2)
							{
								if (mapZoomIn)
								{
									Main.mapOverlayScale *= 1.05f;
								}
								if (mapZoomOut)
								{
									Main.mapOverlayScale *= 0.95f;
								}
								if (mapAlphaUp)
								{
									Main.mapOverlayAlpha += 0.015f;
								}
								if (mapAlphaDown)
								{
									Main.mapOverlayAlpha -= 0.015f;
								}
							}
							if (mapStyle)
							{
								if (releaseMapStyle)
								{
									SoundEngine.PlaySound(12);
									Main.mapStyle++;
									if (Main.mapStyle > 2)
									{
										Main.mapStyle = 0;
									}
								}
								releaseMapStyle = false;
							}
							else
							{
								releaseMapStyle = true;
							}
						}
						if (mapFullScreen)
						{
							if (releaseMapFullscreen)
							{
								if (Main.mapFullscreen)
								{
									SoundEngine.PlaySound(11);
									Main.mapFullscreen = false;
								}
								else
								{
									TryOpeningFullscreenMap();
								}
							}
							releaseMapFullscreen = false;
						}
						else
						{
							releaseMapFullscreen = true;
						}
					}
					else if (!PlayerInput.UsingGamepad && !Main.editSign && !Main.editChest && !Main.blockInput)
					{
						PlayerInput.Triggers.Current.CopyIntoDuringChat(this);
					}
					if (confused)
					{
						bool flag12 = controlLeft;
						bool flag23 = controlUp;
						controlLeft = controlRight;
						controlRight = flag12;
						controlUp = controlRight;
						controlDown = flag23;
					}
					else if (cartFlip)
					{
						if (controlRight || controlLeft)
						{
							bool flag25 = controlLeft;
							controlLeft = controlRight;
							controlRight = flag25;
						}
						else
						{
							cartFlip = false;
						}
					}
					for (int l = 0; l < doubleTapCardinalTimer.Length; l++)
					{
						doubleTapCardinalTimer[l]--;
						if (doubleTapCardinalTimer[l] < 0)
						{
							doubleTapCardinalTimer[l] = 0;
						}
					}
					for (int m = 0; m < 4; m++)
					{
						bool flag26 = false;
						bool flag27 = false;
						switch (m)
						{
						case 0:
							flag26 = controlDown && releaseDown;
							flag27 = controlDown;
							break;
						case 1:
							flag26 = controlUp && releaseUp;
							flag27 = controlUp;
							break;
						case 2:
							flag26 = controlRight && releaseRight;
							flag27 = controlRight;
							break;
						case 3:
							flag26 = controlLeft && releaseLeft;
							flag27 = controlLeft;
							break;
						}
						if (flag26)
						{
							if (doubleTapCardinalTimer[m] > 0)
							{
								KeyDoubleTap(m);
							}
							else
							{
								doubleTapCardinalTimer[m] = 15;
							}
						}
						if (flag27)
						{
							holdDownCardinalTimer[m]++;
							KeyHoldDown(m, holdDownCardinalTimer[m]);
						}
						else
						{
							holdDownCardinalTimer[m] = 0;
						}
					}
					controlDownHold = holdDownCardinalTimer[0] >= 45;
					PlayerLoader.SetControls(this);
					if (controlInv)
					{
						if (releaseInventory)
						{
							ToggleInv();
						}
						releaseInventory = false;
					}
					else
					{
						releaseInventory = true;
					}
					if (delayUseItem)
					{
						if (!controlUseItem)
						{
							delayUseItem = false;
						}
						controlUseItem = false;
					}
					if (itemAnimation == 0 && ItemTimeIsZero && reuseDelay == 0)
					{
						dropItemCheck();
						int num69 = selectedItem;
						bool flag28 = false;
						if (!Main.drawingPlayerChat && selectedItem != 58 && !Main.editSign && !Main.editChest)
						{
							if (PlayerInput.Triggers.Current.Hotbar1)
							{
								selectedItem = 0;
								flag28 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar2)
							{
								selectedItem = 1;
								flag28 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar3)
							{
								selectedItem = 2;
								flag28 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar4)
							{
								selectedItem = 3;
								flag28 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar5)
							{
								selectedItem = 4;
								flag28 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar6)
							{
								selectedItem = 5;
								flag28 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar7)
							{
								selectedItem = 6;
								flag28 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar8)
							{
								selectedItem = 7;
								flag28 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar9)
							{
								selectedItem = 8;
								flag28 = true;
							}
							if (PlayerInput.Triggers.Current.Hotbar10)
							{
								selectedItem = 9;
								flag28 = true;
							}
							int selectedBinding = DpadRadial.SelectedBinding;
							int selectedBinding2 = CircularRadial.SelectedBinding;
							_ = QuicksRadial.SelectedBinding;
							DpadRadial.Update();
							CircularRadial.Update();
							QuicksRadial.Update();
							if (CircularRadial.SelectedBinding >= 0 && selectedBinding2 != CircularRadial.SelectedBinding)
							{
								DpadRadial.ChangeSelection(-1);
							}
							if (DpadRadial.SelectedBinding >= 0 && selectedBinding != DpadRadial.SelectedBinding)
							{
								CircularRadial.ChangeSelection(-1);
							}
							if (QuicksRadial.SelectedBinding != -1 && PlayerInput.Triggers.JustReleased.RadialQuickbar && !PlayerInput.MiscSettingsTEMP.HotbarRadialShouldBeUsed)
							{
								switch (QuicksRadial.SelectedBinding)
								{
								case 0:
									QuickMount();
									break;
								case 1:
									QuickHeal();
									break;
								case 2:
									QuickBuff();
									break;
								case 3:
									QuickMana();
									break;
								}
							}
							if (controlTorch || flag28)
							{
								DpadRadial.ChangeSelection(-1);
								CircularRadial.ChangeSelection(-1);
							}
							if (nonTorch != -1 && flag28)
							{
								if (selectedItem != nonTorch)
								{
									SoundEngine.PlaySound(12);
								}
								nonTorch = selectedItem;
								selectedItem = num69;
								flag28 = false;
							}
						}
						bool flag29 = Main.hairWindow;
						if (flag29)
						{
							int y = Main.screenHeight / 2 + 60;
							val = new Rectangle(Main.screenWidth / 2 - TextureAssets.HairStyleBack.Width() / 2, y, TextureAssets.HairStyleBack.Width(), TextureAssets.HairStyleBack.Height());
							flag29 = ((Rectangle)(ref val)).Contains(Main.MouseScreen.ToPoint());
						}
						if (flag28 && CaptureManager.Instance.Active)
						{
							CaptureManager.Instance.Active = false;
						}
						if (num69 != selectedItem)
						{
							SoundEngine.PlaySound(12);
						}
						if (Main.mapFullscreen)
						{
							float num80 = PlayerInput.ScrollWheelDelta / 120;
							if (PlayerInput.UsingGamepad)
							{
								num80 += (float)(PlayerInput.Triggers.Current.HotbarPlus.ToInt() - PlayerInput.Triggers.Current.HotbarMinus.ToInt()) * 0.1f;
							}
							Main.mapFullscreenScale *= 1f + num80 * 0.3f;
						}
						else if (CaptureManager.Instance.Active)
						{
							CaptureManager.Instance.Scrolling();
						}
						else if (!flag29)
						{
							if (PlayerInput.MouseInModdedUI.Count <= 0)
							{
								if (!Main.playerInventory)
								{
									HandleHotbar();
								}
								else
								{
									int num90 = GetMouseScrollDelta();
									bool flag30 = true;
									if (Main.recBigList)
									{
										int num100 = 42;
										int num10 = 340;
										int num19 = 310;
										PlayerInput.SetZoom_UI();
										int num20 = (Main.screenWidth - num19 - 280) / num100;
										int num21 = (Main.screenHeight - num10 - 20) / num100;
										val = new Rectangle(num19, num10, num20 * num100, num21 * num100);
										if (((Rectangle)(ref val)).Contains(Main.MouseScreen.ToPoint()))
										{
											num90 *= -1;
											int num22 = Math.Sign(num90);
											while (num90 != 0)
											{
												if (num90 < 0)
												{
													Main.recStart -= num20;
													if (Main.recStart < 0)
													{
														Main.recStart = 0;
													}
												}
												else
												{
													Main.recStart += num20;
													if (Main.recStart > Main.numAvailableRecipes - num20)
													{
														Main.recStart = Main.numAvailableRecipes - num20;
													}
												}
												num90 -= num22;
											}
										}
										PlayerInput.SetZoom_World();
									}
									if (flag30)
									{
										Main.focusRecipe += num90;
										if (Main.focusRecipe > Main.numAvailableRecipes - 1)
										{
											Main.focusRecipe = Main.numAvailableRecipes - 1;
										}
										if (Main.focusRecipe < 0)
										{
											Main.focusRecipe = 0;
										}
									}
								}
							}
							PlayerInput.MouseInModdedUI.Clear();
						}
					}
					else
					{
						bool flag2 = false;
						if (!Main.drawingPlayerChat && selectedItem != 58 && !Main.editSign && !Main.editChest)
						{
							int num23 = -1;
							if (((KeyboardState)(ref Main.keyState)).IsKeyDown((Keys)49))
							{
								num23 = 0;
								flag2 = true;
							}
							if (((KeyboardState)(ref Main.keyState)).IsKeyDown((Keys)50))
							{
								num23 = 1;
								flag2 = true;
							}
							if (((KeyboardState)(ref Main.keyState)).IsKeyDown((Keys)51))
							{
								num23 = 2;
								flag2 = true;
							}
							if (((KeyboardState)(ref Main.keyState)).IsKeyDown((Keys)52))
							{
								num23 = 3;
								flag2 = true;
							}
							if (((KeyboardState)(ref Main.keyState)).IsKeyDown((Keys)53))
							{
								num23 = 4;
								flag2 = true;
							}
							if (((KeyboardState)(ref Main.keyState)).IsKeyDown((Keys)54))
							{
								num23 = 5;
								flag2 = true;
							}
							if (((KeyboardState)(ref Main.keyState)).IsKeyDown((Keys)55))
							{
								num23 = 6;
								flag2 = true;
							}
							if (((KeyboardState)(ref Main.keyState)).IsKeyDown((Keys)56))
							{
								num23 = 7;
								flag2 = true;
							}
							if (((KeyboardState)(ref Main.keyState)).IsKeyDown((Keys)57))
							{
								num23 = 8;
								flag2 = true;
							}
							if (((KeyboardState)(ref Main.keyState)).IsKeyDown((Keys)48))
							{
								num23 = 9;
								flag2 = true;
							}
							if (flag2)
							{
								if (num23 != nonTorch)
								{
									SoundEngine.PlaySound(12);
								}
								selectItemOnNextUse = true;
								nonTorch = num23;
							}
						}
					}
				}
				if (stoned != lastStoned)
				{
					if (whoAmI == Main.myPlayer && stoned)
					{
						int damage = (int)(20.0 * (double)Main.GameModeInfo.EnemyDamageMultiplier);
						Hurt(PlayerDeathReason.ByOther(5), damage, 0);
					}
					SoundEngine.PlaySound(0, (int)position.X, (int)position.Y);
					for (int n = 0; n < 20; n++)
					{
						int num24 = Dust.NewDust(position, width, height, 1);
						if (Main.rand.Next(2) == 0)
						{
							Main.dust[num24].noGravity = true;
						}
					}
				}
				lastStoned = stoned;
				if (frozen || webbed || stoned)
				{
					controlJump = false;
					controlDown = false;
					controlLeft = false;
					controlRight = false;
					controlUp = false;
					controlUseItem = false;
					controlUseTile = false;
					controlThrow = false;
					gravDir = 1f;
				}
				if (!controlThrow)
				{
					releaseThrow = true;
				}
				else
				{
					releaseThrow = false;
				}
				if (controlDown && releaseDown)
				{
					if (tryKeepingHoveringUp)
					{
						tryKeepingHoveringUp = false;
					}
					else
					{
						tryKeepingHoveringDown = true;
					}
				}
				if (controlUp && releaseUp)
				{
					if (tryKeepingHoveringDown)
					{
						tryKeepingHoveringDown = false;
					}
					else
					{
						tryKeepingHoveringUp = true;
					}
				}
				if (velocity.Y == 0f)
				{
					tryKeepingHoveringUp = false;
					tryKeepingHoveringDown = false;
				}
				if (Settings.HoverControl == Settings.HoverControlMode.Hold)
				{
					tryKeepingHoveringUp = false;
					tryKeepingHoveringDown = false;
				}
				TrySyncingInput();
				if (Main.playerInventory)
				{
					AdjTiles();
				}
				HandleBeingInChestRange();
				tileEntityAnchor.GetTileEntity()?.OnPlayerUpdate(this);
			}
			if (i == Main.myPlayer)
			{
				if (velocity.Y <= 0f)
				{
					fallStart2 = (int)(position.Y / 16f);
				}
				if (velocity.Y == 0f)
				{
					int num25 = 25;
					num25 += extraFall;
					int num26 = (int)(position.Y / 16f) - fallStart;
					if (mount.CanFly())
					{
						num26 = 0;
					}
					if (mount.Cart && Minecart.OnTrack(position, width, height))
					{
						num26 = 0;
					}
					if (mount.Type == 1)
					{
						num26 = 0;
					}
					if (num26 > 0 || (gravDir == -1f && num26 < 0))
					{
						int num112 = (int)(position.X / 16f);
						int num28 = (int)((position.X + (float)width) / 16f);
						int num29 = (int)((position.Y + (float)height + 1f) / 16f);
						if (gravDir == -1f)
						{
							num29 = (int)((position.Y - 1f) / 16f);
						}
						for (int num30 = num112; num30 <= num28; num30++)
						{
							if (Main.tile[num30, num29] != null && Main.tile[num30, num29].active() && (Main.tile[num30, num29].type == 189 || Main.tile[num30, num29].type == 196 || Main.tile[num30, num29].type == 460 || Main.tile[num30, num29].type == 666))
							{
								num26 = 0;
								break;
							}
						}
					}
					bool flag3 = equippedWings != null;
					if (stoned)
					{
						int num31 = (int)(((float)num26 * gravDir - 2f) * 20f);
						if (num31 > 0)
						{
							Hurt(PlayerDeathReason.ByOther(5), num31, 0);
							immune = false;
						}
					}
					else if (((gravDir == 1f && num26 > num25) || (gravDir == -1f && num26 < -num25)) && !noFallDmg && !flag3)
					{
						immune = false;
						int num32 = (int)((float)num26 * gravDir - (float)num25) * 10;
						if (mount.Active)
						{
							num32 = (int)((float)num32 * mount.FallDamage);
						}
						Hurt(PlayerDeathReason.ByOther(0), num32, 0);
						if (!dead && statLife <= statLifeMax2 / 10)
						{
							AchievementsHelper.HandleSpecialEvent(this, 8);
						}
					}
					fallStart = (int)(position.Y / 16f);
				}
				if (jump > 0 || rocketDelay > 0 || wet || slowFall || (double)num58 < 0.8 || tongued)
				{
					fallStart = (int)(position.Y / 16f);
				}
			}
			if (Main.netMode != 1)
			{
				if (chest == -1 && lastChest >= 0 && Main.chest[lastChest] != null)
				{
					int x6 = Main.chest[lastChest].x;
					int y2 = Main.chest[lastChest].y;
					NPC.BigMimicSummonCheck(x6, y2, this);
				}
				if (lastChest != chest && chest >= 0 && Main.chest[chest] != null)
				{
					int x7 = Main.chest[chest].x;
					int y3 = Main.chest[chest].y;
					Projectile.GasTrapCheck(x7, y3, this);
					ItemSlot.forceClearGlowsOnChest = true;
				}
				lastChest = chest;
			}
			if (mouseInterface)
			{
				delayUseItem = true;
			}
			tileTargetX = (int)(((float)Main.mouseX + Main.screenPosition.X) / 16f);
			tileTargetY = (int)(((float)Main.mouseY + Main.screenPosition.Y) / 16f);
			if (gravDir == -1f)
			{
				tileTargetY = (int)((Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY) / 16f);
			}
			if (tileTargetX >= Main.maxTilesX - 5)
			{
				tileTargetX = Main.maxTilesX - 5;
			}
			if (tileTargetY >= Main.maxTilesY - 5)
			{
				tileTargetY = Main.maxTilesY - 5;
			}
			if (tileTargetX < 5)
			{
				tileTargetX = 5;
			}
			if (tileTargetY < 5)
			{
				tileTargetY = 5;
			}
			if (Main.tile[tileTargetX - 1, tileTargetY] == null)
			{
				Main.tile[tileTargetX - 1, tileTargetY] = default(Tile);
			}
			if (Main.tile[tileTargetX + 1, tileTargetY] == null)
			{
				Main.tile[tileTargetX + 1, tileTargetY] = default(Tile);
			}
			if (Main.tile[tileTargetX, tileTargetY] == null)
			{
				Main.tile[tileTargetX, tileTargetY] = default(Tile);
			}
			if (inventory[selectedItem].axe > 0 && !Main.tile[tileTargetX, tileTargetY].active() && inventory[selectedItem].createWall <= 0 && (inventory[selectedItem].hammer <= 0 || inventory[selectedItem].axe != 0))
			{
				if (Main.tile[tileTargetX - 1, tileTargetY].active() && Main.tile[tileTargetX - 1, tileTargetY].type == 323)
				{
					if (Main.tile[tileTargetX - 1, tileTargetY].frameY > 4)
					{
						tileTargetX--;
					}
				}
				else if (Main.tile[tileTargetX + 1, tileTargetY].active() && Main.tile[tileTargetX + 1, tileTargetY].type == 323 && Main.tile[tileTargetX + 1, tileTargetY].frameY < -4)
				{
					tileTargetX++;
				}
			}
			if (i == Main.myPlayer)
			{
				UpdateNearbyInteractibleProjectilesList();
			}
			try
			{
				if (whoAmI == Main.myPlayer && ((Game)Main.instance).IsActive)
				{
					SmartCursorHelper.SmartCursorLookup(this);
					SmartInteractLookup();
				}
			}
			catch
			{
				Main.SmartCursorWanted_GamePad = false;
				Main.SmartCursorWanted_Mouse = false;
			}
			UpdateImmunity();
			if (petalTimer > 0)
			{
				petalTimer--;
			}
			if (shadowDodgeTimer > 0)
			{
				shadowDodgeTimer--;
			}
			if (boneGloveTimer > 0)
			{
				boneGloveTimer--;
			}
			if (crystalLeafCooldown > 0)
			{
				crystalLeafCooldown--;
			}
			if (jump > 0 || velocity.Y != 0f)
			{
				ResetFloorFlags();
			}
			bool flag4 = pStone;
			potionDelayTime = Item.potionDelay;
			restorationDelayTime = Item.restorationDelay;
			mushroomDelayTime = Item.mushroomDelay;
			if (pStone)
			{
				potionDelayTime = (int)((float)potionDelayTime * PhilosopherStoneDurationMultiplier);
				restorationDelayTime = (int)((float)restorationDelayTime * PhilosopherStoneDurationMultiplier);
				mushroomDelayTime = (int)((float)mushroomDelayTime * PhilosopherStoneDurationMultiplier);
			}
			if (yoraiz0rEye > 0)
			{
				Yoraiz0rEye();
			}
			ResetEffects();
			UpdateDyes();
			if (CreativePowerManager.Instance.GetPower<CreativePowers.GodmodePower>().IsEnabledForPlayer(whoAmI))
			{
				creativeGodMode = true;
			}
			if (IsStandingStillForSpecialEffects && itemAnimation == 0)
			{
				afkCounter++;
			}
			else
			{
				afkCounter = 0;
			}
			if (whoAmI == Main.myPlayer)
			{
				Main.musicBox2 = -1;
				if (Main.SceneMetrics.WaterCandleCount > 0)
				{
					AddBuff(86, 2, quiet: false);
				}
				if (Main.SceneMetrics.PeaceCandleCount > 0)
				{
					AddBuff(157, 2, quiet: false);
				}
				if (Main.SceneMetrics.ShadowCandleCount > 0)
				{
					AddBuff(350, 2, quiet: false);
				}
				if (Main.SceneMetrics.HasCampfire)
				{
					AddBuff(87, 2, quiet: false);
				}
				if (Main.SceneMetrics.HasCatBast)
				{
					AddBuff(215, 2, quiet: false);
				}
				if (Main.SceneMetrics.HasStarInBottle)
				{
					AddBuff(158, 2, quiet: false);
				}
				if (Main.SceneMetrics.HasHeartLantern)
				{
					AddBuff(89, 2, quiet: false);
				}
				if (Main.SceneMetrics.HasSunflower)
				{
					AddBuff(146, 2, quiet: false);
				}
				if (Main.SceneMetrics.hasBanner)
				{
					AddBuff(147, 2, quiet: false);
				}
				if (!behindBackWall && ZoneSandstorm)
				{
					AddBuff(194, 2, quiet: false);
				}
			}
			PlayerLoader.PreUpdateBuffs(this);
			for (int num33 = 0; num33 < BuffLoader.BuffCount; num33++)
			{
				buffImmune[num33] = false;
			}
			UpdateProjectileCaches(i);
			UpdateBuffs(i);
			PlayerLoader.PostUpdateBuffs(this);
			if (kbBuff)
			{
				allKB *= 1.5f;
			}
			if (whoAmI == Main.myPlayer)
			{
				if (!onFire && !poisoned)
				{
					trapDebuffSource = false;
				}
				UpdatePet(i);
				UpdatePetLight(i);
				isOperatingAnotherEntity = ownedProjectileCounts[1020] > 0;
			}
			bool flag5 = wet && !lavaWet && (!mount.Active || !mount.IsConsideredASlimeMount);
			if (accMerman && flag5)
			{
				releaseJump = true;
				wings = 0;
				merman = true;
				accFlipper = true;
				AddBuff(34, 2);
			}
			else
			{
				merman = false;
			}
			if (!flag5 && forceWerewolf)
			{
				forceMerman = false;
			}
			if (forceMerman && flag5)
			{
				wings = 0;
			}
			accMerman = false;
			hideMerman = false;
			forceMerman = false;
			if (wolfAcc && !merman && !Main.dayTime && !wereWolf)
			{
				AddBuff(28, 60);
			}
			wolfAcc = false;
			hideWolf = false;
			forceWerewolf = false;
			if (whoAmI == Main.myPlayer)
			{
				for (int num34 = 0; num34 < maxBuffs; num34++)
				{
					if (buffType[num34] > 0 && buffTime[num34] <= 0)
					{
						DelBuff(num34);
					}
				}
			}
			beetleDefense = false;
			beetleOffense = false;
			setSolar = false;
			head = armor[0].headSlot;
			body = armor[1].bodySlot;
			legs = armor[2].legSlot;
			ResetVisibleAccessories();
			if (MountFishronSpecialCounter > 0f)
			{
				MountFishronSpecialCounter -= 1f;
			}
			if (_portalPhysicsTime > 0)
			{
				_portalPhysicsTime--;
			}
			UpdateEquips(i);
			if (Main.npcShop <= 0)
			{
				discountAvailable = discountEquipped;
			}
			if (flag4 != pStone)
			{
				AdjustRemainingPotionSickness();
			}
			UpdatePermanentBoosters();
			UpdateLuck();
			shimmerUnstuckHelper.Update(this);
			UpdatePortableStoolUsage();
			if (velocity.Y == 0f || controlJump)
			{
				portalPhysicsFlag = false;
			}
			if (inventory[selectedItem].type == 3384 || portalPhysicsFlag)
			{
				_portalPhysicsTime = 30;
			}
			if (mount.Active)
			{
				mount.UpdateEffects(this);
			}
			gemCount++;
			if (gemCount >= 10)
			{
				gem = -1;
				ownedLargeGems = (byte)0;
				gemCount = 0;
				for (int num35 = 0; num35 <= 58; num35++)
				{
					if (inventory[num35].type == 0 || inventory[num35].stack == 0)
					{
						inventory[num35].TurnToAir();
					}
					if (inventory[num35].type >= 1522 && inventory[num35].type <= 1527)
					{
						gem = inventory[num35].type - 1522;
						ownedLargeGems[gem] = true;
					}
					if (inventory[num35].type == 3643)
					{
						gem = 6;
						ownedLargeGems[gem] = true;
					}
				}
			}
			UpdateArmorLights();
			UpdateArmorSets(i);
			if (shadowDodge && !onHitDodge)
			{
				ClearBuff(59);
			}
			PlayerLoader.PostUpdateEquips(this);
			if (maxTurretsOld != maxTurrets)
			{
				UpdateMaxTurrets();
				maxTurretsOld = maxTurrets;
			}
			if (shieldRaised)
			{
				statDefense += 20;
			}
			if ((merman || forceMerman) && flag5)
			{
				wings = 0;
			}
			if (invis)
			{
				if (itemAnimation == 0 && aggro > -750)
				{
					aggro = -750;
				}
				else if (aggro > -250)
				{
					aggro = -250;
				}
			}
			if (inventory[selectedItem].type == 3106)
			{
				if (itemAnimation > 0)
				{
					stealthTimer = 15;
					if (stealth > 0f)
					{
						stealth += 0.1f;
					}
				}
				else if ((double)velocity.X > -0.1 && (double)velocity.X < 0.1 && (double)velocity.Y > -0.1 && (double)velocity.Y < 0.1 && !mount.Active)
				{
					if (stealthTimer == 0 && stealth > 0f)
					{
						stealth -= 0.02f;
						if ((double)stealth <= 0.0)
						{
							stealth = 0f;
							if (Main.netMode == 1)
							{
								NetMessage.SendData(84, -1, -1, null, whoAmI);
							}
						}
					}
				}
				else
				{
					if (stealth > 0f)
					{
						stealth += 0.1f;
					}
					if (mount.Active)
					{
						stealth = 1f;
					}
				}
				if (stealth > 1f)
				{
					stealth = 1f;
				}
				meleeDamage += (1f - stealth) * 3f;
				meleeCrit += (int)((1f - stealth) * 30f);
				GetKnockback(DamageClass.Melee) *= 1f + (1f - stealth);
				aggro -= (int)((1f - stealth) * 750f);
				if (stealthTimer > 0)
				{
					stealthTimer--;
				}
			}
			else if (shroomiteStealth)
			{
				if (itemAnimation > 0)
				{
					stealthTimer = 5;
				}
				if ((double)velocity.X > -0.1 && (double)velocity.X < 0.1 && (double)velocity.Y > -0.1 && (double)velocity.Y < 0.1 && !mount.Active)
				{
					if (stealthTimer == 0 && stealth > 0f)
					{
						stealth -= 0.015f;
						if ((double)stealth <= 0.0)
						{
							stealth = 0f;
							if (Main.netMode == 1)
							{
								NetMessage.SendData(84, -1, -1, null, whoAmI);
							}
						}
					}
				}
				else
				{
					float num36 = Math.Abs(velocity.X) + Math.Abs(velocity.Y);
					stealth += num36 * 0.0075f;
					if (stealth > 1f)
					{
						stealth = 1f;
					}
					if (mount.Active)
					{
						stealth = 1f;
					}
				}
				rangedDamage += (1f - stealth) * 0.6f;
				rangedCrit += (int)((1f - stealth) * 10f);
				GetKnockback(DamageClass.Ranged) *= 1f + (1f - stealth) * 0.5f;
				aggro -= (int)((1f - stealth) * 750f);
				if (stealthTimer > 0)
				{
					stealthTimer--;
				}
			}
			else if (setVortex)
			{
				bool flag6 = false;
				if (vortexStealthActive)
				{
					float num38 = stealth;
					stealth -= 0.04f;
					if (stealth < 0f)
					{
						stealth = 0f;
					}
					else
					{
						flag6 = true;
					}
					if (stealth == 0f && num38 != stealth && Main.netMode == 1)
					{
						NetMessage.SendData(84, -1, -1, null, whoAmI);
					}
					rangedDamage += (1f - stealth) * 0.8f;
					rangedCrit += (int)((1f - stealth) * 20f);
					GetKnockback(DamageClass.Ranged) *= 1f + (1f - stealth) * 0.5f;
					aggro -= (int)((1f - stealth) * 1200f);
					accRunSpeed *= 0.3f;
					maxRunSpeed *= 0.3f;
					if (mount.Active)
					{
						vortexStealthActive = false;
					}
				}
				else
				{
					float num39 = stealth;
					stealth += 0.04f;
					if (stealth > 1f)
					{
						stealth = 1f;
					}
					else
					{
						flag6 = true;
					}
					if (stealth == 1f && num39 != stealth && Main.netMode == 1)
					{
						NetMessage.SendData(84, -1, -1, null, whoAmI);
					}
				}
				if (flag6)
				{
					if (Main.rand.Next(2) == 0)
					{
						Vector2 vector = Vector2.UnitY.RotatedByRandom(6.2831854820251465);
						Dust obj2 = Main.dust[Dust.NewDust(base.Center - vector * 30f, 0, 0, 229)];
						obj2.noGravity = true;
						obj2.position = base.Center - vector * (float)Main.rand.Next(5, 11);
						obj2.velocity = vector.RotatedBy(1.5707963705062866) * 4f;
						obj2.scale = 0.5f + Main.rand.NextFloat();
						obj2.fadeIn = 0.5f;
					}
					if (Main.rand.Next(2) == 0)
					{
						Vector2 vector2 = Vector2.UnitY.RotatedByRandom(6.2831854820251465);
						Dust obj3 = Main.dust[Dust.NewDust(base.Center - vector2 * 30f, 0, 0, 240)];
						obj3.noGravity = true;
						obj3.position = base.Center - vector2 * 12f;
						obj3.velocity = vector2.RotatedBy(-1.5707963705062866) * 2f;
						obj3.scale = 0.5f + Main.rand.NextFloat();
						obj3.fadeIn = 0.5f;
					}
				}
			}
			else
			{
				stealth = 1f;
			}
			if (manaSick)
			{
				magicDamage *= 1f - manaSickReduction;
			}
			if (tileSpeed > 3f)
			{
				tileSpeed = 3f;
			}
			tileSpeed = 1f / tileSpeed;
			if (wallSpeed > 3f)
			{
				wallSpeed = 3f;
			}
			wallSpeed = 1f / wallSpeed;
			if (slowOgreSpit)
			{
				moveSpeed /= 3f;
				if (velocity.Y == 0f && Math.Abs(velocity.X) > 1f)
				{
					velocity.X /= 2f;
				}
			}
			else if (dazed)
			{
				moveSpeed /= 3f;
			}
			else if (slow)
			{
				moveSpeed /= 2f;
			}
			else if (chilled)
			{
				moveSpeed *= 0.75f;
			}
			if (shieldRaised)
			{
				moveSpeed /= 3f;
				if (velocity.Y == 0f && Math.Abs(velocity.X) > 3f)
				{
					velocity.X /= 2f;
				}
			}
			if (DD2Event.Ongoing)
			{
				DD2Event.FindArenaHitbox();
				if (DD2Event.ShouldBlockBuilding(base.Center))
				{
					noBuilding = true;
					AddBuff(199, 3);
				}
			}
			if ((double)pickSpeed < 0.3)
			{
				pickSpeed = 0.3f;
			}
			CapAttackSpeeds();
			PlayerLoader.PostUpdateMiscEffects(this);
			UpdateLifeRegen();
			soulDrain = 0;
			UpdateManaRegen();
			if (manaRegenCount < 0)
			{
				manaRegenCount = 0;
			}
			if (statMana > statManaMax2)
			{
				statMana = statManaMax2;
			}
			runAcceleration *= moveSpeed;
			maxRunSpeed *= moveSpeed;
			UpdateJumpHeight();
			for (int num40 = 0; num40 < maxBuffs; num40++)
			{
				if (buffType[num40] > 0 && buffTime[num40] > 0 && buffImmune[buffType[num40]])
				{
					DelBuff(num40);
				}
			}
			if (brokenArmor)
			{
				statDefense /= 2f;
			}
			if (witheredArmor)
			{
				statDefense /= 2f;
			}
			if (witheredWeapon)
			{
				allDamage *= 0.5f;
			}
			lastTileRangeX = tileRangeX;
			lastTileRangeY = tileRangeY;
			if (mount.Active)
			{
				movementAbilitiesCache.CopyFrom(this);
			}
			else
			{
				movementAbilitiesCache.PasteInto(this);
			}
			if (mount.Active && mount.BlockExtraJumps)
			{
				ConsumeAllExtraJumps();
			}
			else if (velocity.Y == 0f || sliding)
			{
				RefreshDoubleJumps();
			}
			else
			{
				ExtraJumpLoader.ConsumeAndStopUnavailableJumps(this);
			}
			if (!carpet)
			{
				canCarpet = false;
				carpetFrame = -1;
			}
			else if (velocity.Y == 0f || sliding)
			{
				canCarpet = true;
				carpetTime = 0;
				carpetFrame = -1;
				carpetFrameCounter = 0f;
			}
			if (gravDir == -1f)
			{
				canCarpet = false;
			}
			if (ropeCount > 0)
			{
				ropeCount--;
			}
			if (!pulley && !frozen && !webbed && !stoned && !controlJump && gravDir == 1f && ropeCount == 0 && grappling[0] == -1 && !tongued && !mount.Active)
			{
				FindPulley();
			}
			UpdatePettingAnimal();
			sitting.UpdateSitting(this);
			sleeping.UpdateState(this);
			eyeHelper.Update(this);
			if (pulley)
			{
				if (mount.Active)
				{
					pulley = false;
				}
				sandStorm = false;
				CancelAllJumpVisualEffects();
				int num41 = (int)(position.X + (float)(width / 2)) / 16;
				int num42 = (int)(position.Y - 8f) / 16;
				bool flag7 = false;
				if (pulleyDir == 0)
				{
					pulleyDir = 1;
				}
				if (pulleyDir == 1)
				{
					if (direction == -1 && controlLeft && (releaseLeft || leftTimer == 0))
					{
						pulleyDir = 2;
						flag7 = true;
					}
					else if ((direction == 1 && controlRight && releaseRight) || rightTimer == 0)
					{
						pulleyDir = 2;
						flag7 = true;
					}
					else
					{
						if (direction == 1 && controlLeft)
						{
							direction = -1;
							flag7 = true;
						}
						if (direction == -1 && controlRight)
						{
							direction = 1;
							flag7 = true;
						}
					}
				}
				else if (pulleyDir == 2)
				{
					if (direction == 1 && controlLeft)
					{
						flag7 = true;
						if (!Collision.SolidCollision(new Vector2((float)(num41 * 16 + 8 - width / 2), position.Y), width, height))
						{
							pulleyDir = 1;
							direction = -1;
							flag7 = true;
						}
					}
					if (direction == -1 && controlRight)
					{
						flag7 = true;
						if (!Collision.SolidCollision(new Vector2((float)(num41 * 16 + 8 - width / 2), position.Y), width, height))
						{
							pulleyDir = 1;
							direction = 1;
							flag7 = true;
						}
					}
				}
				int num43 = 1;
				if (controlLeft)
				{
					num43 = -1;
				}
				bool flag8 = CanMoveForwardOnRope(num43, num41, num42);
				if (controlLeft && direction == -1 && flag8)
				{
					instantMovementAccumulatedThisFrame.X += -1f;
				}
				if (controlRight && direction == 1 && flag8)
				{
					instantMovementAccumulatedThisFrame.X += 1f;
				}
				bool flag9 = false;
				if (!flag7 && ((controlLeft && (releaseLeft || leftTimer == 0)) || (controlRight && (releaseRight || rightTimer == 0))))
				{
					int num44 = num41 + num43;
					if (WorldGen.IsRope(num44, num42))
					{
						pulleyDir = 1;
						direction = num43;
						int num45 = num44 * 16 + 8 - width / 2;
						float y4 = position.Y;
						y4 = num42 * 16 + 22;
						if (Main.tile[num44, num42 - 1] == null)
						{
							Main.tile[num44, num42 - 1] = default(Tile);
						}
						if (Main.tile[num44, num42 + 1] == null)
						{
							Main.tile[num44, num42 + 1] = default(Tile);
						}
						if (WorldGen.IsRope(num44, num42 - 1) || WorldGen.IsRope(num44, num42 + 1))
						{
							y4 = num42 * 16 + 22;
						}
						if (Collision.SolidCollision(new Vector2((float)num45, y4), width, height))
						{
							pulleyDir = 2;
							direction = -num43;
							num45 = ((direction != 1) ? (num44 * 16 + 8 - width / 2 + -6) : (num44 * 16 + 8 - width / 2 + 6));
						}
						if (i == Main.myPlayer)
						{
							Main.cameraX = Main.cameraX + position.X - (float)num45;
						}
						position.X = num45;
						gfxOffY = position.Y - y4;
						position.Y = y4;
						flag9 = true;
					}
				}
				if (!flag9 && !flag7 && !controlUp && ((controlLeft && releaseLeft) || (controlRight && releaseRight)))
				{
					pulley = false;
					if (controlLeft && velocity.X == 0f)
					{
						velocity.X = -1f;
					}
					if (controlRight && velocity.X == 0f)
					{
						velocity.X = 1f;
					}
				}
				if (velocity.X != 0f)
				{
					pulley = false;
				}
				if (Main.tile[num41, num42] == null)
				{
					Main.tile[num41, num42] = default(Tile);
				}
				if (!WorldGen.IsRope(num41, num42))
				{
					pulley = false;
				}
				if (gravDir != 1f)
				{
					pulley = false;
				}
				if (frozen || webbed || stoned)
				{
					pulley = false;
				}
				if (!pulley)
				{
					velocity.Y -= gravity;
				}
				if (controlJump)
				{
					pulley = false;
					jump = jumpHeight;
					velocity.Y = 0f - jumpSpeed;
				}
			}
			if (grapCount > 0)
			{
				pulley = false;
			}
			if (NPC.brainOfGravity >= 0 && NPC.brainOfGravity < 200 && Vector2.Distance(base.Center, Main.npc[NPC.brainOfGravity].Center) < 4000f)
			{
				forcedGravity = 10;
			}
			if (forcedGravity > 0)
			{
				gravDir = -1f;
			}
			if (pulley)
			{
				fallStart = (int)position.Y / 16;
				wingFrame = 0;
				if (wings == 4)
				{
					wingFrame = 3;
				}
				int num46 = (int)(position.X + (float)(width / 2)) / 16;
				int num48 = (int)(position.Y - 16f) / 16;
				int num49 = (int)(position.Y - 8f) / 16;
				bool flag10 = true;
				bool flag11 = false;
				if (WorldGen.IsRope(num46, num49 - 1) || WorldGen.IsRope(num46, num49 + 1))
				{
					flag11 = true;
				}
				if (Main.tile[num46, num48] == null)
				{
					Main.tile[num46, num48] = default(Tile);
				}
				if (!WorldGen.IsRope(num46, num48))
				{
					flag10 = false;
					if (velocity.Y < 0f)
					{
						velocity.Y = 0f;
					}
				}
				if (flag11)
				{
					if (controlUp && flag10)
					{
						float x3 = position.X;
						float y5 = position.Y - Math.Abs(velocity.Y) - 2f;
						if (Collision.SolidCollision(new Vector2(x3, y5), width, height))
						{
							x3 = num46 * 16 + 8 - width / 2 + 6;
							if (!Collision.SolidCollision(new Vector2(x3, y5), width, (int)((float)height + Math.Abs(velocity.Y) + 2f)))
							{
								if (i == Main.myPlayer)
								{
									Main.cameraX = Main.cameraX + position.X - x3;
								}
								pulleyDir = 2;
								direction = 1;
								position.X = x3;
								velocity.X = 0f;
							}
							else
							{
								x3 = num46 * 16 + 8 - width / 2 + -6;
								if (!Collision.SolidCollision(new Vector2(x3, y5), width, (int)((float)height + Math.Abs(velocity.Y) + 2f)))
								{
									if (i == Main.myPlayer)
									{
										Main.cameraX = Main.cameraX + position.X - x3;
									}
									pulleyDir = 2;
									direction = -1;
									position.X = x3;
									velocity.X = 0f;
								}
							}
						}
						if (velocity.Y > 0f)
						{
							velocity.Y *= 0.7f;
						}
						if (velocity.Y > -3f)
						{
							velocity.Y -= 0.2f;
						}
						else
						{
							velocity.Y -= 0.02f;
						}
						if (velocity.Y < -8f)
						{
							velocity.Y = -8f;
						}
					}
					else if (controlDown)
					{
						float x4 = position.X;
						float y6 = position.Y;
						if (Collision.SolidCollision(new Vector2(x4, y6), width, (int)((float)height + Math.Abs(velocity.Y) + 2f)))
						{
							x4 = num46 * 16 + 8 - width / 2 + 6;
							if (!Collision.SolidCollision(new Vector2(x4, y6), width, (int)((float)height + Math.Abs(velocity.Y) + 2f)))
							{
								if (i == Main.myPlayer)
								{
									Main.cameraX = Main.cameraX + position.X - x4;
								}
								pulleyDir = 2;
								direction = 1;
								position.X = x4;
								velocity.X = 0f;
							}
							else
							{
								x4 = num46 * 16 + 8 - width / 2 + -6;
								if (!Collision.SolidCollision(new Vector2(x4, y6), width, (int)((float)height + Math.Abs(velocity.Y) + 2f)))
								{
									if (i == Main.myPlayer)
									{
										Main.cameraX = Main.cameraX + position.X - x4;
									}
									pulleyDir = 2;
									direction = -1;
									position.X = x4;
									velocity.X = 0f;
								}
							}
						}
						if (velocity.Y < 0f)
						{
							velocity.Y *= 0.7f;
						}
						if (velocity.Y < 3f)
						{
							velocity.Y += 0.2f;
						}
						else
						{
							velocity.Y += 0.1f;
						}
						if (velocity.Y > maxFallSpeed)
						{
							velocity.Y = maxFallSpeed;
						}
					}
					else
					{
						velocity.Y *= 0.7f;
						if ((double)velocity.Y > -0.1 && (double)velocity.Y < 0.1)
						{
							velocity.Y = 0f;
						}
					}
				}
				else if (controlDown)
				{
					ropeCount = 10;
					pulley = false;
					velocity.Y = 1f;
				}
				else
				{
					velocity.Y = 0f;
					position.Y = num48 * 16 + 22;
				}
				float num50 = num46 * 16 + 8 - width / 2;
				if (pulleyDir == 1)
				{
					num50 = num46 * 16 + 8 - width / 2;
				}
				if (pulleyDir == 2)
				{
					num50 = num46 * 16 + 8 - width / 2 + 6 * direction;
				}
				if (i == Main.myPlayer)
				{
					Main.cameraX += position.X - num50;
					Main.cameraX = MathHelper.Clamp(Main.cameraX, -32f, 32f);
				}
				position.X = num50;
				pulleyFrameCounter += Math.Abs(velocity.Y * 0.75f);
				if (velocity.Y != 0f)
				{
					pulleyFrameCounter += 0.75f;
				}
				if (pulleyFrameCounter > 10f)
				{
					pulleyFrame++;
					pulleyFrameCounter = 0f;
				}
				if (pulleyFrame > 1)
				{
					pulleyFrame = 0;
				}
				canCarpet = true;
				carpetFrame = -1;
				wingTime = wingTimeMax;
				rocketTime = rocketTimeMax;
				rocketDelay = 0;
				rocketFrame = false;
				canRocket = false;
				rocketRelease = false;
				DashMovement();
				UpdateControlHolds();
			}
			else if (grappling[0] == -1 && !tongued)
			{
				if (wingsLogic > 0 && velocity.Y != 0f && !merman && !mount.Active)
				{
					WingAirLogicTweaks();
				}
				if (empressBrooch)
				{
					runAcceleration *= 1.75f;
				}
				if (hasMagiluminescence && velocity.Y == 0f)
				{
					runAcceleration *= 1.75f;
					maxRunSpeed *= 1.15f;
					accRunSpeed *= 1.15f;
					runSlowdown *= 1.75f;
				}
				if (shadowArmor)
				{
					runAcceleration *= 1.75f;
					maxRunSpeed *= 1.15f;
					accRunSpeed *= 1.15f;
					runSlowdown *= 1.75f;
				}
				if (mount.Active && mount.Type == 43 && velocity.Y != 0f)
				{
					runSlowdown = 0f;
				}
				if (sticky)
				{
					maxRunSpeed *= 0.25f;
					runAcceleration *= 0.25f;
					runSlowdown *= 2f;
					if (velocity.X > maxRunSpeed)
					{
						velocity.X = maxRunSpeed;
					}
					if (velocity.X < 0f - maxRunSpeed)
					{
						velocity.X = 0f - maxRunSpeed;
					}
				}
				else if (powerrun)
				{
					maxRunSpeed *= 3.5f;
					runAcceleration *= 1f;
					runSlowdown *= 2f;
				}
				else if (runningOnSand && desertBoots)
				{
					float num51 = 1.75f;
					maxRunSpeed *= num51;
					accRunSpeed *= num51;
					runAcceleration *= num51;
					runSlowdown *= num51;
				}
				else if (slippy2)
				{
					runAcceleration *= 0.6f;
					runSlowdown = 0f;
					if (iceSkate)
					{
						runAcceleration *= 3.5f;
						maxRunSpeed *= 1.25f;
					}
				}
				else if (slippy)
				{
					runAcceleration *= 0.7f;
					if (iceSkate)
					{
						runAcceleration *= 3.5f;
						maxRunSpeed *= 1.25f;
					}
					else
					{
						runSlowdown *= 0.1f;
					}
				}
				ExtraJumpLoader.UpdateHorizontalSpeeds(this);
				if (carpetFrame != -1)
				{
					runAcceleration *= 1.25f;
					maxRunSpeed *= 1.5f;
				}
				if (inventory[selectedItem].type == 3106 && stealth < 1f)
				{
					float num52 = maxRunSpeed / 2f * (1f - stealth);
					maxRunSpeed -= num52;
					accRunSpeed = maxRunSpeed;
				}
				if (mount.Active)
				{
					rocketBoots = 0;
					vanityRocketBoots = 0;
					wings = 0;
					wingsLogic = 0;
					maxRunSpeed = mount.RunSpeed;
					accRunSpeed = mount.DashSpeed;
					runAcceleration = mount.Acceleration;
					if (mount.Type == 12 && !MountFishronSpecial)
					{
						runAcceleration /= 2f;
						maxRunSpeed /= 2f;
					}
					mount.AbilityRecovery();
					if (mount.Cart && velocity.Y == 0f)
					{
						if (!Minecart.OnTrack(position, width, height))
						{
							fullRotation = 0f;
							onWrongGround = true;
							runSlowdown = 0.2f;
							if ((controlLeft && releaseLeft) || (controlRight && releaseRight))
							{
								mount.Dismount(this);
							}
						}
						else
						{
							runSlowdown = runAcceleration;
							onWrongGround = false;
						}
					}
					if (mount.Type == 8)
					{
						mount.UpdateDrill(this, controlUp, controlDown);
					}
				}
				PlayerLoader.PostUpdateRunSpeeds(this);
				HorizontalMovement();
				bool flag13 = !mount.Active;
				if (forcedGravity > 0)
				{
					gravDir = -1f;
				}
				else if (gravControl && flag13)
				{
					if (controlUp && releaseUp)
					{
						if (gravDir == 1f)
						{
							gravDir = -1f;
							fallStart = (int)(position.Y / 16f);
							jump = 0;
							SoundEngine.PlaySound(in SoundID.Item8, position);
						}
						else
						{
							gravDir = 1f;
							fallStart = (int)(position.Y / 16f);
							jump = 0;
							SoundEngine.PlaySound(in SoundID.Item8, position);
						}
					}
				}
				else if (gravControl2 && flag13)
				{
					if (controlUp && releaseUp)
					{
						if (gravDir == 1f)
						{
							gravDir = -1f;
							fallStart = (int)(position.Y / 16f);
							jump = 0;
							SoundEngine.PlaySound(in SoundID.Item8, position);
						}
						else
						{
							gravDir = 1f;
							fallStart = (int)(position.Y / 16f);
							jump = 0;
							SoundEngine.PlaySound(in SoundID.Item8, position);
						}
					}
				}
				else
				{
					gravDir = 1f;
				}
				if (velocity.Y == 0f && mount.Active && mount.CanHover() && controlUp && releaseUp)
				{
					velocity.Y = 0f - (mount.Acceleration + gravity + 0.001f);
				}
				UpdateControlHolds();
				sandStorm = false;
				JumpMovement();
				if (wingsLogic == 0)
				{
					wingTime = 0f;
				}
				if (rocketBoots == 0)
				{
					rocketTime = 0;
				}
				if (jump == 0)
				{
					CancelAllJumpVisualEffects();
				}
				DashMovement();
				WallslideMovement();
				CarpetMovement();
				DoubleJumpVisuals();
				if (wingsLogic > 0 || mount.Active)
				{
					sandStorm = false;
				}
				if (((gravDir == 1f && velocity.Y > 0f - jumpSpeed) || (gravDir == -1f && velocity.Y < jumpSpeed)) && velocity.Y != 0f)
				{
					canRocket = true;
				}
				bool flag14 = false;
				if (((velocity.Y == 0f || sliding) && releaseJump) || (autoJump && justJumped))
				{
					mount.ResetFlightTime(velocity.X);
					wingTime = wingTimeMax;
				}
				if (wingsLogic > 0 && controlJump && wingTime > 0f && jump == 0 && velocity.Y != 0f)
				{
					flag14 = true;
				}
				if ((wingsLogic == 22 || wingsLogic == 28 || wingsLogic == 30 || wingsLogic == 32 || wingsLogic == 29 || wingsLogic == 33 || wingsLogic == 35 || wingsLogic == 37 || wingsLogic == 45) && controlJump && TryingToHoverDown && wingTime > 0f)
				{
					flag14 = true;
				}
				if (frozen || webbed || stoned)
				{
					if (mount.Active)
					{
						mount.Dismount(this);
					}
					velocity.Y += gravity;
					if (velocity.Y > maxFallSpeed)
					{
						velocity.Y = maxFallSpeed;
					}
					sandStorm = false;
					CancelAllJumpVisualEffects();
				}
				else
				{
					bool isCustomWings = ItemLoader.WingUpdate(this, flag14);
					if (flag14)
					{
						WingAirVisuals();
						WingMovement();
					}
					WingFrame(flag14, isCustomWings);
					if (wingsLogic > 0 && rocketBoots != 0 && velocity.Y != 0f && rocketTime != 0)
					{
						int num53 = 6;
						int num54 = rocketTime * num53;
						wingTime += num54;
						if (wingTime > (float)(wingTimeMax + num54))
						{
							wingTime = wingTimeMax + num54;
						}
						rocketTime = 0;
					}
					if (!isCustomWings && flag14 && wings != 4 && wings != 22 && wings != 0 && wings != 24 && wings != 28 && wings != 30 && wings != 33 && wings != 45)
					{
						bool flag15 = wingFrame == 3;
						if (wings == 43 || wings == 44)
						{
							flag15 = wingFrame == 4;
						}
						if (flag15)
						{
							if (!flapSound)
							{
								SoundEngine.PlaySound(in SoundID.Item32, position);
							}
							flapSound = true;
						}
						else
						{
							flapSound = false;
						}
					}
					if (velocity.Y == 0f || sliding || (autoJump && justJumped))
					{
						rocketTime = rocketTimeMax;
					}
					if (empressBrooch)
					{
						rocketTime = rocketTimeMax;
					}
					if ((wingTime == 0f || wingsLogic == 0) && rocketBoots != 0 && controlJump && rocketDelay == 0 && canRocket && rocketRelease && !AnyExtraJumpUsable())
					{
						if (rocketTime > 0)
						{
							rocketTime--;
							rocketDelay = 10;
							if (rocketDelay2 <= 0)
							{
								if (rocketBoots == 1)
								{
									rocketDelay2 = 30;
								}
								else if (rocketBoots == 2 || rocketBoots == 5 || rocketBoots == 3 || rocketBoots == 4)
								{
									rocketDelay2 = 15;
								}
							}
							if (rocketSoundDelay <= 0)
							{
								if (vanityRocketBoots == 1 || vanityRocketBoots == 5)
								{
									rocketSoundDelay = 30;
									SoundEngine.PlaySound(in SoundID.Item13, position);
								}
								else if (vanityRocketBoots == 2 || vanityRocketBoots == 3 || vanityRocketBoots == 4)
								{
									rocketSoundDelay = 15;
									SoundEngine.PlaySound(in SoundID.Item24, position);
								}
							}
						}
						else
						{
							canRocket = false;
						}
					}
					if (rocketSoundDelay > 0)
					{
						rocketSoundDelay--;
					}
					if (rocketDelay2 > 0)
					{
						rocketDelay2--;
					}
					if (rocketDelay == 0)
					{
						rocketFrame = false;
					}
					if (rocketDelay > 0)
					{
						rocketFrame = true;
						RocketBootVisuals();
						if (rocketDelay == 0)
						{
							releaseJump = true;
						}
						rocketDelay--;
						velocity.Y -= 0.1f * gravDir;
						if (gravDir == 1f)
						{
							if (velocity.Y > 0f)
							{
								velocity.Y -= 0.5f;
							}
							else if ((double)velocity.Y > (double)(0f - jumpSpeed) * 0.5)
							{
								velocity.Y -= 0.1f;
							}
							if (velocity.Y < (0f - jumpSpeed) * 1.5f)
							{
								velocity.Y = (0f - jumpSpeed) * 1.5f;
							}
						}
						else
						{
							if (velocity.Y < 0f)
							{
								velocity.Y += 0.5f;
							}
							else if ((double)velocity.Y < (double)jumpSpeed * 0.5)
							{
								velocity.Y += 0.1f;
							}
							if (velocity.Y > jumpSpeed * 1.5f)
							{
								velocity.Y = jumpSpeed * 1.5f;
							}
						}
					}
					else if (!flag14)
					{
						if (mount.CanHover())
						{
							mount.Hover(this);
						}
						else if (mount.CanFly() && controlJump && jump == 0)
						{
							if (mount.Flight())
							{
								if (TryingToHoverDown)
								{
									velocity.Y *= 0.9f;
									if (velocity.Y > -1f && (double)velocity.Y < 0.5)
									{
										velocity.Y = 1E-05f;
									}
								}
								else
								{
									float num55 = jumpSpeed;
									if (mount.Type == 50)
									{
										num55 *= 0.5f;
									}
									if (velocity.Y > 0f)
									{
										velocity.Y -= 0.5f;
									}
									else if ((double)velocity.Y > (double)(0f - num55) * 1.5)
									{
										velocity.Y -= 0.1f;
									}
									if (velocity.Y < (0f - num55) * 1.5f)
									{
										velocity.Y = (0f - num55) * 1.5f;
									}
								}
							}
							else
							{
								velocity.Y += gravity / 3f * gravDir;
								if (gravDir == 1f)
								{
									if (velocity.Y > maxFallSpeed / 3f && !TryingToHoverDown)
									{
										velocity.Y = maxFallSpeed / 3f;
									}
								}
								else if (velocity.Y < (0f - maxFallSpeed) / 3f && !TryingToHoverUp)
								{
									velocity.Y = (0f - maxFallSpeed) / 3f;
								}
							}
						}
						else if (slowFall && !TryingToHoverDown)
						{
							if (TryingToHoverUp)
							{
								gravity = gravity / 10f * gravDir;
							}
							else
							{
								gravity = gravity / 3f * gravDir;
							}
							velocity.Y += gravity;
						}
						else if (wingsLogic > 0 && controlJump && velocity.Y > 0f)
						{
							bool noLightEmittence = wingsLogic != wings;
							fallStart = (int)(position.Y / 16f);
							if (velocity.Y > 0f)
							{
								if (wings == 10 && Main.rand.Next(3) == 0)
								{
									int num56 = 4;
									if (direction == 1)
									{
										num56 = -40;
									}
									int num57 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num56, position.Y + (float)(height / 2) - 15f), 30, 30, 76, 0f, 0f, 50, default(Color), 0.6f);
									Main.dust[num57].fadeIn = 1.1f;
									Main.dust[num57].noGravity = true;
									Main.dust[num57].noLight = true;
									Dust obj4 = Main.dust[num57];
									obj4.velocity *= 0.3f;
									Main.dust[num57].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
								}
								if (wings == 34 && ShouldDrawWingsThatAreAlwaysAnimated() && Main.rand.Next(3) == 0)
								{
									int num59 = 4;
									if (direction == 1)
									{
										num59 = -40;
									}
									int num60 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num59, position.Y + (float)(height / 2) - 15f), 30, 30, 261, 0f, 0f, 50, default(Color), 0.6f);
									Main.dust[num60].fadeIn = 1.1f;
									Main.dust[num60].noGravity = true;
									Main.dust[num60].noLight = true;
									Main.dust[num60].noLightEmittence = noLightEmittence;
									Dust obj5 = Main.dust[num60];
									obj5.velocity *= 0.3f;
									Main.dust[num60].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
								}
								if (wings == 40)
								{
									ShouldDrawWingsThatAreAlwaysAnimated();
								}
								if (wings == 44)
								{
									ShouldDrawWingsThatAreAlwaysAnimated();
								}
								if (wings == 9 && Main.rand.Next(3) == 0)
								{
									int num61 = 8;
									if (direction == 1)
									{
										num61 = -40;
									}
									int num62 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num61, position.Y + (float)(height / 2) - 15f), 30, 30, 6, 0f, 0f, 200, default(Color), 2f);
									Main.dust[num62].noGravity = true;
									Dust obj6 = Main.dust[num62];
									obj6.velocity *= 0.3f;
									Main.dust[num62].noLightEmittence = noLightEmittence;
									Main.dust[num62].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
								}
								if (wings == 29 && Main.rand.Next(3) == 0)
								{
									int num63 = 8;
									if (direction == 1)
									{
										num63 = -40;
									}
									int num64 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num63, position.Y + (float)(height / 2) - 15f), 30, 30, 6, 0f, 0f, 100, default(Color), 2.4f);
									Main.dust[num64].noGravity = true;
									Dust obj7 = Main.dust[num64];
									obj7.velocity *= 0.3f;
									Main.dust[num64].noLightEmittence = noLightEmittence;
									if (Main.rand.Next(10) == 0)
									{
										Main.dust[num64].fadeIn = 2f;
									}
									Main.dust[num64].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
								}
								if (wings == 6)
								{
									if (Main.rand.Next(10) == 0)
									{
										int num65 = 4;
										if (direction == 1)
										{
											num65 = -40;
										}
										int num66 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num65, position.Y + (float)(height / 2) - 12f), 30, 20, 55, 0f, 0f, 200);
										Main.dust[num66].noLightEmittence = noLightEmittence;
										Dust obj8 = Main.dust[num66];
										obj8.velocity *= 0.3f;
										Main.dust[num66].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
									}
								}
								else if (wings == 5 && Main.rand.Next(6) == 0)
								{
									int num67 = 6;
									if (direction == 1)
									{
										num67 = -30;
									}
									int num68 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num67, position.Y), 18, height, 58, 0f, 0f, 255, default(Color), 1.2f);
									Dust obj9 = Main.dust[num68];
									obj9.velocity *= 0.3f;
									Main.dust[num68].noLightEmittence = noLightEmittence;
									Main.dust[num68].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
								}
								if (!isCustomWings)
								{
									if (wings == 4)
									{
										rocketDelay2--;
										if (rocketDelay2 <= 0)
										{
											SoundEngine.PlaySound(in SoundID.Item13, position);
											rocketDelay2 = 60;
										}
										int type = 6;
										float scale = 1.5f;
										int alpha = 100;
										float x5 = position.X + (float)(width / 2) + 16f;
										if (direction > 0)
										{
											x5 = position.X + (float)(width / 2) - 26f;
										}
										float num70 = position.Y + (float)height - 18f;
										if (Main.rand.Next(2) == 1)
										{
											x5 = position.X + (float)(width / 2) + 8f;
											if (direction > 0)
											{
												x5 = position.X + (float)(width / 2) - 20f;
											}
											num70 += 6f;
										}
										int num71 = Dust.NewDust(new Vector2(x5, num70), 8, 8, type, 0f, 0f, alpha, default(Color), scale);
										Main.dust[num71].velocity.X *= 0.3f;
										Main.dust[num71].velocity.Y += 10f;
										Main.dust[num71].noGravity = true;
										Main.dust[num71].noLightEmittence = noLightEmittence;
										Main.dust[num71].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
										wingFrameCounter++;
										if (wingFrameCounter > 4)
										{
											wingFrame++;
											wingFrameCounter = 0;
											if (wingFrame >= 3)
											{
												wingFrame = 0;
											}
										}
									}
									else if (wings != 22 && wings != 28)
									{
										if (wings == 30)
										{
											wingFrameCounter++;
											int num72 = 5;
											if (wingFrameCounter >= num72 * 3)
											{
												wingFrameCounter = 0;
											}
											wingFrame = 1 + wingFrameCounter / num72;
										}
										else if (wings == 34)
										{
											wingFrameCounter++;
											int num73 = 7;
											if (wingFrameCounter >= num73 * 6)
											{
												wingFrameCounter = 0;
											}
											wingFrame = wingFrameCounter / num73;
										}
										else if (wings != 45)
										{
											if (wings == 40)
											{
												wingFrame = 0;
											}
											else if (wings == 44)
											{
												wingFrame = 2;
											}
											else if (wings == 39)
											{
												wingFrameCounter++;
												int num74 = 12;
												if (wingFrameCounter >= num74 * 6)
												{
													wingFrameCounter = 0;
												}
												wingFrame = wingFrameCounter / num74;
											}
											else if (wings == 26)
											{
												int num75 = 6;
												if (direction == 1)
												{
													num75 = -30;
												}
												int num76 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num75, position.Y), 18, height, 217, 0f, 0f, 100, default(Color), 1.4f);
												Main.dust[num76].noGravity = true;
												Main.dust[num76].noLight = true;
												Dust obj10 = Main.dust[num76];
												obj10.velocity /= 4f;
												Dust obj11 = Main.dust[num76];
												obj11.velocity -= velocity;
												Main.dust[num76].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
												if (Main.rand.Next(2) == 0)
												{
													num75 = -24;
													if (direction == 1)
													{
														num75 = 12;
													}
													float num77 = position.Y;
													if (gravDir == -1f)
													{
														num77 += (float)(height / 2);
													}
													num76 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num75, num77), 12, height / 2, 217, 0f, 0f, 100, default(Color), 1.4f);
													Main.dust[num76].noGravity = true;
													Main.dust[num76].noLight = true;
													Dust obj12 = Main.dust[num76];
													obj12.velocity /= 4f;
													Dust obj13 = Main.dust[num76];
													obj13.velocity -= velocity;
													Main.dust[num76].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
												}
												wingFrame = 2;
											}
											else if (wings == 37)
											{
												Color color = Color.Lerp(Color.Black, Color.White, Main.rand.NextFloat());
												int num78 = 6;
												if (direction == 1)
												{
													num78 = -30;
												}
												int num79 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num78, position.Y), 24, height, Utils.SelectRandom<int>(Main.rand, 31, 31, 31), 0f, 0f, 100, default(Color), 0.7f);
												Main.dust[num79].noGravity = true;
												Main.dust[num79].noLight = true;
												Dust obj14 = Main.dust[num79];
												obj14.velocity /= 4f;
												Dust obj15 = Main.dust[num79];
												obj15.velocity -= velocity;
												Main.dust[num79].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
												if (Main.dust[num79].type == 55)
												{
													Main.dust[num79].color = color;
												}
												if (Main.rand.Next(3) == 0)
												{
													num78 = -24;
													if (direction == 1)
													{
														num78 = 12;
													}
													float num81 = position.Y;
													if (gravDir == -1f)
													{
														num81 += (float)(height / 2);
													}
													num79 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num78, num81), 12, height / 2, Utils.SelectRandom<int>(Main.rand, 31, 31, 31), 0f, 0f, 140, default(Color), 0.7f);
													Main.dust[num79].noGravity = true;
													Main.dust[num79].noLight = true;
													Dust obj16 = Main.dust[num79];
													obj16.velocity /= 4f;
													Dust obj17 = Main.dust[num79];
													obj17.velocity -= velocity;
													Main.dust[num79].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
													if (Main.dust[num79].type == 55)
													{
														Main.dust[num79].color = color;
													}
												}
												wingFrame = 2;
											}
											else if (wings != 24)
											{
												if (wings == 43)
												{
													wingFrame = 1;
												}
												else if (wings == 12)
												{
													wingFrame = 3;
												}
												else
												{
													wingFrame = 2;
												}
											}
										}
									}
								}
							}
							velocity.Y += gravity / 3f * gravDir;
							if (gravDir == 1f)
							{
								if (velocity.Y > maxFallSpeed / 3f && !TryingToHoverDown)
								{
									velocity.Y = maxFallSpeed / 3f;
								}
							}
							else if (velocity.Y < (0f - maxFallSpeed) / 3f && !TryingToHoverUp)
							{
								velocity.Y = (0f - maxFallSpeed) / 3f;
							}
						}
						else if (cartRampTime <= 0)
						{
							velocity.Y += gravity * gravDir;
						}
						else
						{
							cartRampTime--;
						}
					}
					if (!mount.Active || mount.Type != 5)
					{
						if (gravDir == 1f)
						{
							if (velocity.Y > maxFallSpeed)
							{
								velocity.Y = maxFallSpeed;
							}
							if (slowFall && velocity.Y > maxFallSpeed / 3f && !TryingToHoverDown)
							{
								velocity.Y = maxFallSpeed / 3f;
							}
							if (slowFall && velocity.Y > maxFallSpeed / 5f && TryingToHoverUp)
							{
								velocity.Y = maxFallSpeed / 10f;
							}
						}
						else
						{
							if (velocity.Y < 0f - maxFallSpeed)
							{
								velocity.Y = 0f - maxFallSpeed;
							}
							if (slowFall && velocity.Y < (0f - maxFallSpeed) / 3f && !TryingToHoverDown)
							{
								velocity.Y = (0f - maxFallSpeed) / 3f;
							}
							if (slowFall && velocity.Y < (0f - maxFallSpeed) / 5f && TryingToHoverUp)
							{
								velocity.Y = (0f - maxFallSpeed) / 10f;
							}
						}
					}
				}
			}
			else
			{
				UpdateControlHolds();
			}
			if (mount.Active)
			{
				wingFrame = 0;
			}
			if ((wingsLogic == 22 || wingsLogic == 28 || wingsLogic == 30 || wingsLogic == 31 || wingsLogic == 33 || wingsLogic == 35 || wingsLogic == 37 || wingsLogic == 45) && TryingToHoverDown && controlJump && wingTime > 0f && !merman)
			{
				float num82 = 0.9f;
				if (wingsLogic == 45)
				{
					num82 = 0.8f;
				}
				velocity.Y *= num82;
				if (velocity.Y > -2f && velocity.Y < 1f)
				{
					velocity.Y = 1E-05f;
				}
			}
			if (wingsLogic == 37 && TryingToHoverDown && controlJump && wingTime > 0f && !merman)
			{
				velocity.Y *= 0.92f;
				if (velocity.Y > -2f && velocity.Y < 1f)
				{
					velocity.Y = 1E-05f;
				}
			}
			GrabItems(i);
			LookForTileInteractions();
			if (tongued)
			{
				StopVanityActions();
				bool flag16 = false;
				if (Main.wofNPCIndex >= 0)
				{
					NPC nPC = Main.npc[Main.wofNPCIndex];
					float num113 = nPC.Center.X + (float)(nPC.direction * 200);
					float y7 = nPC.Center.Y;
					Vector2 center = base.Center;
					float num83 = num113 - center.X;
					float num84 = y7 - center.Y;
					float num85 = (float)Math.Sqrt(num83 * num83 + num84 * num84);
					float num86 = 11f;
					if (Main.expertMode)
					{
						float value = 22f;
						float amount = Math.Min(1f, ((Vector2)(ref nPC.velocity)).Length() / 5f);
						num86 = MathHelper.Lerp(num86, value, amount);
					}
					float num87 = num85;
					if (num85 > num86)
					{
						num87 = num86 / num85;
					}
					else
					{
						num87 = 1f;
						flag16 = true;
					}
					num83 *= num87;
					num84 *= num87;
					velocity.X = num83;
					velocity.Y = num84;
				}
				else
				{
					flag16 = true;
				}
				if (flag16 && Main.myPlayer == whoAmI)
				{
					for (int num88 = 0; num88 < maxBuffs; num88++)
					{
						if (buffType[num88] == 38)
						{
							DelBuff(num88);
						}
					}
				}
			}
			if (Main.myPlayer == whoAmI)
			{
				WOFTongue();
				if (controlHook)
				{
					if (releaseHook)
					{
						QuickGrapple();
					}
					releaseHook = false;
				}
				else
				{
					releaseHook = true;
				}
				if (talkNPC >= 0)
				{
					Rectangle rectangle = default(Rectangle);
					((Rectangle)(ref rectangle))._002Ector((int)(position.X + (float)(width / 2) - (float)(tileRangeX * 16)), (int)(position.Y + (float)(height / 2) - (float)(tileRangeY * 16)), tileRangeX * 16 * 2, tileRangeY * 16 * 2);
					Rectangle value2 = default(Rectangle);
					((Rectangle)(ref value2))._002Ector((int)Main.npc[talkNPC].position.X, (int)Main.npc[talkNPC].position.Y, Main.npc[talkNPC].width, Main.npc[talkNPC].height);
					if (!((Rectangle)(ref rectangle)).Intersects(value2) || chest != -1 || !Main.npc[talkNPC].active || tileEntityAnchor.InUse)
					{
						if (chest == -1)
						{
							SoundEngine.PlaySound(11);
						}
						SetTalkNPC(-1);
						Main.npcChatCornerItem = 0;
						Main.npcChatText = "";
					}
				}
				if (sign >= 0)
				{
					Rectangle value3 = default(Rectangle);
					((Rectangle)(ref value3))._002Ector((int)(position.X + (float)(width / 2) - (float)(tileRangeX * 16)), (int)(position.Y + (float)(height / 2) - (float)(tileRangeY * 16)), tileRangeX * 16 * 2, tileRangeY * 16 * 2);
					try
					{
						bool flag17 = false;
						if (Main.sign[sign] == null)
						{
							flag17 = true;
						}
						if (!flag17)
						{
							val = new Rectangle(Main.sign[sign].x * 16, Main.sign[sign].y * 16, 32, 32);
							if (!((Rectangle)(ref val)).Intersects(value3))
							{
								flag17 = true;
							}
						}
						if (flag17)
						{
							SoundEngine.PlaySound(11);
							sign = -1;
							Main.editSign = false;
							Main.npcChatText = "";
						}
					}
					catch
					{
						SoundEngine.PlaySound(11);
						sign = -1;
						Main.editSign = false;
						Main.npcChatText = "";
					}
				}
				if (Main.editSign)
				{
					if (sign == -1)
					{
						Main.editSign = false;
					}
					else
					{
						Main.InputTextSign();
					}
				}
				else if (Main.editChest)
				{
					Main.InputTextChest();
					if (Main.player[Main.myPlayer].chest == -1)
					{
						Main.editChest = false;
					}
				}
				if (mount.Active && mount.Cart && ((Vector2)(ref velocity)).Length() > 4f)
				{
					Rectangle rectangle2 = default(Rectangle);
					((Rectangle)(ref rectangle2))._002Ector((int)position.X, (int)position.Y, width, height);
					if (velocity.X < -1f)
					{
						rectangle2.X -= 15;
					}
					if (velocity.X > 1f)
					{
						rectangle2.Width += 15;
					}
					if (velocity.X < -10f)
					{
						rectangle2.X -= 10;
					}
					if (velocity.X > 10f)
					{
						rectangle2.Width += 10;
					}
					if (velocity.Y < -1f)
					{
						rectangle2.Y -= 10;
					}
					if (velocity.Y > 1f)
					{
						rectangle2.Height += 10;
					}
					for (int num89 = 0; num89 < 200; num89++)
					{
						if (Main.npc[num89].active && !Main.npc[num89].dontTakeDamage && !Main.npc[num89].friendly && Main.npc[num89].immune[i] == 0 && CanNPCBeHitByPlayerOrPlayerProjectile(Main.npc[num89]) && ((Rectangle)(ref rectangle2)).Intersects(new Rectangle((int)Main.npc[num89].position.X, (int)Main.npc[num89].position.Y, Main.npc[num89].width, Main.npc[num89].height)))
						{
							float num91 = DamageClassLoader.DamageClasses.Select((DamageClass t) => GetTotalCritChance(t)).Max();
							bool crit = false;
							if ((float)Main.rand.Next(1, 101) <= num91)
							{
								crit = true;
							}
							float currentSpeed = ((Vector2)(ref velocity)).Length() / maxRunSpeed;
							GetMinecartDamage(currentSpeed, out var damage2, out var knockback);
							int num92 = 1;
							if (velocity.X < 0f)
							{
								num92 = -1;
							}
							if (Main.npc[num89].knockBackResist < 1f && Main.npc[num89].knockBackResist > 0f)
							{
								knockback /= Main.npc[num89].knockBackResist;
							}
							if (whoAmI == Main.myPlayer)
							{
								ApplyDamageToNPC(Main.npc[num89], damage2, knockback, num92, crit);
							}
							Main.npc[num89].immune[i] = 30;
							if (!Main.npc[num89].active)
							{
								AchievementsHelper.HandleSpecialEvent(this, 9);
							}
						}
					}
				}
				Update_NPCCollision();
				if (!shimmering)
				{
					Collision.HurtTile hurtTile = GetHurtTile();
					if (hurtTile.type >= 0)
					{
						ApplyTouchDamage(hurtTile.type, hurtTile.x, hurtTile.y);
					}
				}
				TryToShimmerUnstuck();
			}
			if (controlRight)
			{
				releaseRight = false;
			}
			else
			{
				releaseRight = true;
				rightTimer = 7;
			}
			if (controlLeft)
			{
				releaseLeft = false;
			}
			else
			{
				releaseLeft = true;
				leftTimer = 7;
			}
			releaseDown = !controlDown;
			if (rightTimer > 0)
			{
				rightTimer--;
			}
			else if (controlRight)
			{
				rightTimer = 7;
			}
			if (leftTimer > 0)
			{
				leftTimer--;
			}
			else if (controlLeft)
			{
				leftTimer = 7;
			}
			GrappleMovement();
			StickyMovement();
			CheckDrowning();
			if (gravDir == -1f)
			{
				waterWalk = false;
				waterWalk2 = false;
			}
			int num93 = height;
			if (waterWalk)
			{
				num93 -= 6;
			}
			bool flag18 = false;
			if (!shimmering)
			{
				flag18 = Collision.LavaCollision(position, width, num93);
			}
			if (flag18)
			{
				if (!lavaImmune && Main.myPlayer == i && hurtCooldowns[4] <= 0)
				{
					if (lavaTime > 0)
					{
						lavaTime--;
					}
					else
					{
						int num94 = 80;
						int num95 = 420;
						if (Main.remixWorld)
						{
							num94 = 200;
							num95 = 630;
						}
						if (!ashWoodBonus || !lavaRose)
						{
							if (ashWoodBonus)
							{
								if (Main.remixWorld)
								{
									num94 = 145;
								}
								num94 /= 2;
								num95 -= 210;
							}
							if (lavaRose)
							{
								num94 -= 45;
								num95 -= 210;
							}
							if (num94 > 0)
							{
								Hurt(PlayerDeathReason.ByOther(2), num94, 0, pvp: false, quiet: false, Crit: false, 4);
							}
							if (num95 > 0)
							{
								AddBuff(24, num95);
							}
						}
					}
				}
				lavaWet = true;
			}
			else
			{
				lavaWet = false;
				if (lavaTime < lavaMax)
				{
					lavaTime++;
				}
			}
			if (lavaTime > lavaMax)
			{
				lavaTime = lavaMax;
			}
			if (waterWalk2 && !waterWalk)
			{
				num93 -= 6;
			}
			bool num114 = Collision.WetCollision(position, width, height);
			bool flag19 = Collision.honey;
			bool shimmer = Collision.shimmer;
			if (shimmer)
			{
				shimmerWet = true;
				if (whoAmI == Main.myPlayer && !shimmerImmune && !shimmerUnstuckHelper.ShouldUnstuck)
				{
					int num96 = (int)(base.Center.X / 16f);
					int num97 = (int)((position.Y + 1f) / 16f);
					if (Main.tile[num96, num97] != null && Main.tile[num96, num97].shimmer() && Main.tile[num96, num97].liquid >= 0 && position.Y / 16f < (float)Main.UnderworldLayer)
					{
						AddBuff(353, 60);
					}
				}
			}
			if (flag19 && !shimmering)
			{
				AddBuff(48, 1800);
				honeyWet = true;
			}
			if (num114)
			{
				if ((onFire || onFire3) && !lavaWet)
				{
					for (int num98 = 0; num98 < maxBuffs; num98++)
					{
						int num99 = buffType[num98];
						if (num99 == 24 || num99 == 323)
						{
							DelBuff(num98);
						}
					}
				}
				if (!wet)
				{
					if (wetCount == 0)
					{
						wetCount = 10;
						if (!shimmering)
						{
							if (!flag18)
							{
								if (shimmerWet)
								{
									for (int num101 = 0; num101 < 50; num101++)
									{
										int num102 = Dust.NewDust(new Vector2(position.X - 6f, position.Y + (float)(height / 2)), width + 12, 24, 308);
										Main.dust[num102].velocity.Y -= 4f;
										Main.dust[num102].velocity.X *= 2.5f;
										Main.dust[num102].scale = 0.8f;
										Main.dust[num102].noGravity = true;
										switch (Main.rand.Next(6))
										{
										case 0:
											Main.dust[num102].color = new Color(255, 255, 210);
											break;
										case 1:
											Main.dust[num102].color = new Color(190, 245, 255);
											break;
										case 2:
											Main.dust[num102].color = new Color(255, 150, 255);
											break;
										default:
											Main.dust[num102].color = new Color(190, 175, 255);
											break;
										}
									}
									SoundEngine.PlaySound(19, (int)position.X, (int)position.Y, 2);
								}
								else if (honeyWet)
								{
									for (int num103 = 0; num103 < 20; num103++)
									{
										int num104 = Dust.NewDust(new Vector2(position.X - 6f, position.Y + (float)(height / 2) - 8f), width + 12, 24, 152);
										Main.dust[num104].velocity.Y -= 1f;
										Main.dust[num104].velocity.X *= 2.5f;
										Main.dust[num104].scale = 1.3f;
										Main.dust[num104].alpha = 100;
										Main.dust[num104].noGravity = true;
									}
									SoundEngine.PlaySound(19, (int)position.X, (int)position.Y);
								}
								else
								{
									for (int num105 = 0; num105 < 50; num105++)
									{
										int num106 = Dust.NewDust(new Vector2(position.X - 6f, position.Y + (float)(height / 2) - 8f), width + 12, 24, Dust.dustWater());
										Main.dust[num106].velocity.Y -= 3f;
										Main.dust[num106].velocity.X *= 2.5f;
										Main.dust[num106].scale = 0.8f;
										Main.dust[num106].alpha = 100;
										Main.dust[num106].noGravity = true;
									}
									SoundEngine.PlaySound(19, (int)position.X, (int)position.Y, 0);
								}
							}
							else
							{
								for (int num107 = 0; num107 < 20; num107++)
								{
									int num108 = Dust.NewDust(new Vector2(position.X - 6f, position.Y + (float)(height / 2) - 8f), width + 12, 24, 35);
									Main.dust[num108].velocity.Y -= 1.5f;
									Main.dust[num108].velocity.X *= 2.5f;
									Main.dust[num108].scale = 1.3f;
									Main.dust[num108].alpha = 100;
									Main.dust[num108].noGravity = true;
								}
								SoundEngine.PlaySound(19, (int)position.X, (int)position.Y);
							}
						}
					}
					wet = true;
					if (ShouldFloatInWater)
					{
						velocity.Y /= 2f;
						if (velocity.Y > 3f)
						{
							velocity.Y = 3f;
						}
					}
				}
			}
			else if (wet)
			{
				wet = false;
				if (jump > jumpHeight / 5 && wetSlime == 0)
				{
					jump = jumpHeight / 5;
				}
				if (wetCount == 0)
				{
					wetCount = 10;
					if (!shimmering)
					{
						if (!lavaWet)
						{
							if (shimmerWet)
							{
								for (int num109 = 0; num109 < 50; num109++)
								{
									int num110 = Dust.NewDust(new Vector2(position.X - 6f, position.Y + (float)(height / 2)), width + 12, 24, 308);
									Main.dust[num110].velocity.Y -= 4f;
									Main.dust[num110].velocity.X *= 2.5f;
									Main.dust[num110].scale = 0.75f;
									Main.dust[num110].noGravity = true;
									switch (Main.rand.Next(6))
									{
									case 0:
										Main.dust[num110].color = new Color(255, 255, 210);
										break;
									case 1:
										Main.dust[num110].color = new Color(190, 245, 255);
										break;
									case 2:
										Main.dust[num110].color = new Color(255, 150, 255);
										break;
									default:
										Main.dust[num110].color = new Color(190, 175, 255);
										break;
									}
								}
								SoundEngine.PlaySound(19, (int)position.X, (int)position.Y, 3);
							}
							else if (honeyWet)
							{
								for (int num11 = 0; num11 < 20; num11++)
								{
									int num12 = Dust.NewDust(new Vector2(position.X - 6f, position.Y + (float)(height / 2) - 8f), width + 12, 24, 152);
									Main.dust[num12].velocity.Y -= 1f;
									Main.dust[num12].velocity.X *= 2.5f;
									Main.dust[num12].scale = 1.3f;
									Main.dust[num12].alpha = 100;
									Main.dust[num12].noGravity = true;
								}
								SoundEngine.PlaySound(19, (int)position.X, (int)position.Y);
							}
							else
							{
								for (int num13 = 0; num13 < 50; num13++)
								{
									int num14 = Dust.NewDust(new Vector2(position.X - 6f, position.Y + (float)(height / 2)), width + 12, 24, Dust.dustWater());
									Main.dust[num14].velocity.Y -= 4f;
									Main.dust[num14].velocity.X *= 2.5f;
									Main.dust[num14].scale = 0.8f;
									Main.dust[num14].alpha = 100;
									Main.dust[num14].noGravity = true;
								}
								SoundEngine.PlaySound(19, (int)position.X, (int)position.Y, 0);
							}
						}
						else
						{
							for (int num15 = 0; num15 < 20; num15++)
							{
								int num16 = Dust.NewDust(new Vector2(position.X - 6f, position.Y + (float)(height / 2) - 8f), width + 12, 24, 35);
								Main.dust[num16].velocity.Y -= 1.5f;
								Main.dust[num16].velocity.X *= 2.5f;
								Main.dust[num16].scale = 1.3f;
								Main.dust[num16].alpha = 100;
								Main.dust[num16].noGravity = true;
							}
							SoundEngine.PlaySound(19, (int)position.X, (int)position.Y);
						}
					}
				}
			}
			if (!flag19)
			{
				honeyWet = false;
			}
			if (!shimmer)
			{
				shimmerWet = false;
			}
			if (!wet)
			{
				lavaWet = false;
				honeyWet = false;
				shimmerWet = false;
			}
			if (wetCount > 0)
			{
				wetCount--;
			}
			if (wetSlime > 0)
			{
				wetSlime--;
			}
			if (wet && mount.Active)
			{
				switch (mount.Type)
				{
				case 5:
				case 7:
					if (whoAmI == Main.myPlayer)
					{
						mount.Dismount(this);
					}
					break;
				case 3:
				case 50:
					wetSlime = 30;
					if (velocity.Y > 2f)
					{
						velocity.Y *= 0.9f;
					}
					velocity.Y -= 0.5f;
					if (velocity.Y < -4f)
					{
						velocity.Y = -4f;
					}
					break;
				}
			}
			if (Main.expertMode && ZoneSnow && wet && !lavaWet && !honeyWet && !arcticDivingGear && environmentBuffImmunityTimer == 0)
			{
				AddBuff(46, 150);
			}
			float num17 = 1f + Math.Abs(velocity.X) / 3f;
			if (gfxOffY > 0f)
			{
				gfxOffY -= num17 * stepSpeed;
				if (gfxOffY < 0f)
				{
					gfxOffY = 0f;
				}
			}
			else if (gfxOffY < 0f)
			{
				gfxOffY += num17 * stepSpeed;
				if (gfxOffY > 0f)
				{
					gfxOffY = 0f;
				}
			}
			if (gfxOffY > 32f)
			{
				gfxOffY = 32f;
			}
			if (gfxOffY < -32f)
			{
				gfxOffY = -32f;
			}
			if (Main.myPlayer == i)
			{
				if (!iceSkate)
				{
					CheckIceBreak();
				}
				CheckCrackedBrickBreak();
			}
			if (!shimmering)
			{
				SlopeDownMovement();
				bool flag20 = mount.Type == 7 || mount.Type == 8 || mount.Type == 12 || mount.Type == 44 || mount.Type == 49;
				if (velocity.Y == gravity && (!mount.Active || (!mount.Cart && mount.Type != 48 && !flag20)))
				{
					Collision.StepDown(ref position, ref velocity, width, height, ref stepSpeed, ref gfxOffY, (int)gravDir, waterWalk || waterWalk2);
				}
				if (gravDir == -1f)
				{
					if ((carpetFrame != -1 || velocity.Y <= gravity) && !controlUp)
					{
						Collision.StepUp(ref position, ref velocity, width, height, ref stepSpeed, ref gfxOffY, (int)gravDir, controlUp);
					}
				}
				else if ((carpetFrame != -1 || velocity.Y >= gravity) && !controlDown && !mount.Cart && !flag20 && grappling[0] == -1)
				{
					Collision.StepUp(ref position, ref velocity, width, height, ref stepSpeed, ref gfxOffY, (int)gravDir, controlUp);
				}
			}
			oldPosition = position;
			oldDirection = direction;
			bool falling = false;
			if (velocity.Y > gravity)
			{
				falling = true;
			}
			if (velocity.Y < 0f - gravity)
			{
				falling = true;
			}
			Vector2 vector3 = velocity;
			slideDir = 0;
			bool ignorePlats = false;
			bool fallThrough = controlDown;
			if ((gravDir == -1f) | (mount.Active && (mount.Cart || mount.Type == 12 || mount.Type == 7 || mount.Type == 8 || mount.Type == 23 || mount.Type == 44 || mount.Type == 48)) | GoingDownWithGrapple | pulley)
			{
				ignorePlats = true;
				fallThrough = true;
			}
			bool flag21 = onTrack;
			onTrack = false;
			bool flag22 = false;
			if (mount.Active && mount.Cart)
			{
				fartKartCloudDelay = Math.Max(0, fartKartCloudDelay - 1);
				float num18 = ((ignoreWater || merman) ? 1f : (shimmerWet ? 0.25f : (honeyWet ? 0.25f : ((!wet) ? 1f : 0.5f))));
				velocity *= num18;
				DelegateMethods.Minecart.rotation = fullRotation;
				DelegateMethods.Minecart.rotationOrigin = fullRotationOrigin;
				BitsByte bitsByte = Minecart.TrackCollision(this, ref position, ref velocity, ref lastBoost, width, height, controlDown, controlUp, fallStart2, trackOnly: false, mount.Delegations);
				if (bitsByte[0])
				{
					onTrack = true;
					gfxOffY = Minecart.TrackRotation(this, ref fullRotation, position + velocity, width, height, controlDown, controlUp, mount.Delegations);
					fullRotationOrigin = new Vector2((float)(width / 2), (float)height);
				}
				if (flag21 && !onTrack)
				{
					mount.Delegations.MinecartJumpingSound(this, position, width, height);
				}
				if (bitsByte[1])
				{
					if (controlLeft || controlRight)
					{
						if (cartFlip)
						{
							cartFlip = false;
						}
						else
						{
							cartFlip = true;
						}
					}
					if (velocity.X > 0f)
					{
						direction = 1;
					}
					else if (velocity.X < 0f)
					{
						direction = -1;
					}
					mount.Delegations.MinecartBumperSound(this, position, width, height);
				}
				velocity /= num18;
				if (bitsByte[3] && whoAmI == Main.myPlayer)
				{
					flag22 = true;
				}
				if (bitsByte[2])
				{
					cartRampTime = (int)(Math.Abs(velocity.X) / mount.RunSpeed * 20f);
				}
				if (bitsByte[4])
				{
					trackBoost -= 4f;
				}
				if (bitsByte[5])
				{
					trackBoost += 4f;
				}
			}
			bool flag24 = whoAmI == Main.myPlayer && !mount.Active;
			Vector2 vector4 = position;
			if (vortexDebuff)
			{
				velocity.Y = velocity.Y * 0.8f + (float)Math.Cos(base.Center.X % 120f / 120f * ((float)Math.PI * 2f)) * 5f * 0.2f;
			}
			PlayerLoader.PreUpdateMovement(this);
			if (tongued)
			{
				position += velocity;
				flag24 = false;
			}
			else if (shimmerWet || shimmering)
			{
				ShimmerCollision(fallThrough, ignorePlats, shimmering);
			}
			else if (honeyWet && !ignoreWater)
			{
				HoneyCollision(fallThrough, ignorePlats);
			}
			else if (wet && !merman && !ignoreWater && !trident)
			{
				WaterCollision(fallThrough, ignorePlats);
			}
			else
			{
				DryCollision(fallThrough, ignorePlats);
				if (mount.Active && mount.IsConsideredASlimeMount && velocity.Y != 0f && !SlimeDontHyperJump)
				{
					Vector2 vector5 = velocity;
					velocity.X = 0f;
					DryCollision(fallThrough, ignorePlats);
					velocity.X = vector5.X;
				}
				if (mount.Active && mount.Type == 43 && velocity.Y != 0f)
				{
					Vector2 vector6 = velocity;
					velocity.X = 0f;
					DryCollision(fallThrough, ignorePlats);
					velocity.X = vector6.X;
				}
			}
			UpdateTouchingTiles();
			TryBouncingBlocks(falling);
			TryLandingOnDetonator();
			if (!shimmering && !tongued)
			{
				SlopingCollision(fallThrough, ignorePlats);
				if (!isLockedToATile)
				{
					Collision.StepConveyorBelt(this, gravDir);
				}
			}
			if (flag24 && velocity.Y == 0f)
			{
				AchievementsHelper.HandleRunning(Math.Abs(position.X - vector4.X));
			}
			if (flag22)
			{
				NetMessage.SendData(13, -1, -1, null, whoAmI);
				Minecart.HitTrackSwitch(new Vector2(position.X, position.Y), width, height);
			}
			if (vector3.X != velocity.X)
			{
				if (vector3.X < 0f)
				{
					slideDir = -1;
				}
				else if (vector3.X > 0f)
				{
					slideDir = 1;
				}
			}
			if (gravDir == 1f && Collision.up)
			{
				velocity.Y = 0.01f;
				if (!merman)
				{
					jump = 0;
				}
			}
			else if (gravDir == -1f && Collision.down)
			{
				velocity.Y = -0.01f;
				if (!merman)
				{
					jump = 0;
				}
			}
			if (velocity.Y == 0f && grappling[0] == -1)
			{
				FloorVisuals(falling);
			}
			if (whoAmI == Main.myPlayer && !shimmering)
			{
				Collision.SwitchTiles(position, width, height, oldPosition, 1);
			}
			PressurePlateHelper.UpdatePlayerPosition(this);
			BordersMovement();
			numMinions = 0;
			slotsMinions = 0f;
			if (Main.netMode != 2 && mount.Type != 8)
			{
				ItemCheck_ManageRightClickFeatures();
			}
			ItemCheckWrapped(i);
			PlayerFrame();
			if (mount.Type == 8)
			{
				mount.UseDrill(this);
			}
			if (statLife > statLifeMax2)
			{
				statLife = statLifeMax2;
			}
			if (statMana > statManaMax2)
			{
				statMana = statManaMax2;
			}
			grappling[0] = -1;
			grapCount = 0;
			UpdateReleaseUseTile();
			UpdateAdvancedShadows();
			PlayerLoader.PostUpdate(this);
		}
	}

	private void TryToToggleSmartCursor(ref bool smartCursorWanted)
	{
		if (Main.cSmartCursorModeIsToggleAndNotHold)
		{
			if (controlSmart && releaseSmart)
			{
				SoundEngine.PlaySound(12);
				smartCursorWanted = !smartCursorWanted;
			}
			return;
		}
		if (controlSmart && releaseSmart)
		{
			SoundEngine.PlaySound(12);
		}
		if (SmartCursorSettings.SmartCursorHoldCanReleaseMidUse)
		{
			smartCursorWanted = controlSmart;
		}
		else if (smartCursorWanted)
		{
			if (!controlSmart && !controlUseItem)
			{
				smartCursorWanted = false;
			}
		}
		else
		{
			smartCursorWanted = controlSmart;
		}
	}

	private void TryToShimmerUnstuck()
	{
		timeShimmering = Utils.Clamp(timeShimmering + (shimmering ? 1 : (-10)), 0, 7200);
		bool flag = timeShimmering >= 3600;
		if ((LocalInputCache.controlLeft || LocalInputCache.controlRight || LocalInputCache.controlUp || LocalInputCache.controlDown) && timeShimmering >= 1200)
		{
			flag = true;
		}
		if (flag)
		{
			ShimmerUnstuck();
		}
	}

	private void ShimmerUnstuck()
	{
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		timeShimmering = 0;
		Vector2? vector = TryFindingShimmerFreeSpot();
		if (vector.HasValue)
		{
			velocity = new Vector2(0f, 0.0001f);
			Teleport(vector.Value + new Vector2(0f, -2f), 12);
			shimmering = false;
			shimmerWet = false;
			wet = false;
			ClearBuff(353);
			ParticleOrchestrator.BroadcastOrRequestParticleSpawn(ParticleOrchestraType.ShimmerTownNPC, new ParticleOrchestraSettings
			{
				PositionInWorld = base.Bottom
			});
		}
		else
		{
			if (Collision.WetCollision(position, width, height) && Collision.shimmer)
			{
				shimmerUnstuckHelper.StartUnstuck();
			}
			ClearBuff(353);
			ParticleOrchestrator.BroadcastOrRequestParticleSpawn(ParticleOrchestraType.ShimmerTownNPC, new ParticleOrchestraSettings
			{
				PositionInWorld = base.Bottom
			});
		}
	}

	private Vector2? TryFindingShimmerFreeSpot()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		Point point = base.Top.ToTileCoordinates();
		int num = 60;
		Vector2? result = null;
		bool allowSolidTop = true;
		for (int i = 1; i < num; i += 2)
		{
			Vector2? vector = ShimmerHelper.FindSpotWithoutShimmer(this, point.X, point.Y, i, allowSolidTop);
			if (vector.HasValue)
			{
				result = vector.Value;
				break;
			}
		}
		FindSpawn();
		if (!CheckSpawn(SpawnX, SpawnY))
		{
			SpawnX = -1;
			SpawnY = -1;
		}
		if (!result.HasValue && SpawnX != -1 && SpawnY != -1)
		{
			for (int j = 1; j < num; j += 2)
			{
				Vector2? vector2 = ShimmerHelper.FindSpotWithoutShimmer(this, SpawnX, SpawnY, j, allowSolidTop);
				if (vector2.HasValue)
				{
					result = vector2.Value;
					break;
				}
			}
		}
		if (!result.HasValue)
		{
			for (int k = 1; k < num; k += 2)
			{
				Vector2? vector3 = ShimmerHelper.FindSpotWithoutShimmer(this, Main.spawnTileX, Main.spawnTileY, k, allowSolidTop);
				if (vector3.HasValue)
				{
					result = vector3.Value;
					break;
				}
			}
		}
		return result;
	}

	private void AdjustRemainingPotionSickness()
	{
		if (whoAmI == Main.myPlayer)
		{
			int num = FindBuffIndex(21);
			if (num != -1)
			{
				float num2 = buffTime[num];
				float philosopherStoneDurationMultiplier = PhilosopherStoneDurationMultiplier;
				num2 = ((!pStone) ? (num2 / philosopherStoneDurationMultiplier) : (num2 * philosopherStoneDurationMultiplier));
				buffTime[num] = (int)num2;
			}
		}
	}

	private Collision.HurtTile GetHurtTile()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		Collision.HurtTile result = Collision.HurtTiles(position, width, (!mount.Active || !mount.Cart) ? height : (height - 16), this);
		if (result.type >= 0)
		{
			return result;
		}
		foreach (Point touchedTile in TouchedTiles)
		{
			Tile tile = Main.tile[touchedTile.X, touchedTile.Y];
			if (tile != null && tile.active() && tile.nactive() && !TileID.Sets.Suffocate[tile.type] && Collision.CanTileHurt(tile.type, touchedTile.X, touchedTile.Y, this))
			{
				Collision.HurtTile result2 = default(Collision.HurtTile);
				result2.type = tile.type;
				result2.x = touchedTile.X;
				result2.y = touchedTile.Y;
				return result2;
			}
		}
		return result;
	}

	private void ApplyTouchDamage(int tileId, int x, int y)
	{
		if (TileID.Sets.TouchDamageHot[tileId])
		{
			AddBuff(67, 20);
		}
		if (TileID.Sets.Suffocate[tileId])
		{
			if (suffocateDelay < 5)
			{
				suffocateDelay++;
			}
			else
			{
				AddBuff(68, 1);
			}
		}
		else
		{
			suffocateDelay = 0;
		}
		if (TileID.Sets.TouchDamageBleeding[tileId])
		{
			AddBuff(30, Main.rand.Next(240, 600));
		}
		int num = TileID.Sets.TouchDamageImmediate[tileId];
		if (num > 0)
		{
			num = Main.DamageVar(num, 0f - luck);
			Hurt(PlayerDeathReason.ByOther(3), num, 0, pvp: false, quiet: false, Crit: false, 0);
		}
		if (TileID.Sets.TouchDamageDestroyTile[tileId])
		{
			WorldGen.KillTile(x, y);
			if (Main.netMode == 1 && !Main.tile[x, y].active())
			{
				NetMessage.SendData(17, -1, -1, null, 4, x, y);
			}
		}
	}

	private void CapAttackSpeeds()
	{
	}

	private float TurnAttackSpeedToUseTimeMultiplier(float speed)
	{
		if (speed > 3f)
		{
			speed = 3f;
		}
		if (speed != 0f)
		{
			speed = 1f / speed;
		}
		return speed;
	}

	public void UpdateLuck()
	{
		UpdateLuckFactors();
		RecalculateLuck();
		if (luckNeedsSync && whoAmI == Main.myPlayer)
		{
			luckNeedsSync = false;
			NetMessage.SendData(134, -1, -1, null, whoAmI);
		}
	}

	private void ResetControls()
	{
		controlUp = false;
		controlLeft = false;
		controlDown = false;
		controlRight = false;
		controlJump = false;
		controlUseItem = false;
		controlUseTile = false;
		controlThrow = false;
		controlInv = false;
		controlHook = false;
		controlTorch = false;
		controlSmart = false;
		controlMount = false;
		controlQuickHeal = false;
		controlQuickMana = false;
		controlCreativeMenu = false;
		mapStyle = false;
		mapAlphaDown = false;
		mapAlphaUp = false;
		mapFullScreen = false;
		mapZoomIn = false;
		mapZoomOut = false;
	}

	private void UpdateControlHolds()
	{
		if (whoAmI == Main.myPlayer)
		{
			if (controlUp && releaseUp)
			{
				FlexibleWandCycleOffset--;
			}
			if (controlDown && releaseDown)
			{
				FlexibleWandCycleOffset++;
			}
		}
		if (controlUp)
		{
			releaseUp = false;
		}
		else
		{
			releaseUp = true;
		}
	}

	public void TryOpeningFullscreenMap()
	{
		if (Main.mapEnabled)
		{
			Main.playerInventory = false;
			sign = -1;
			Main.editSign = false;
			SetTalkNPC(-1);
			Main.npcChatCornerItem = 0;
			SoundEngine.PlaySound(10);
			Main.mapFullscreenScale = 2.5f;
			Main.mapFullscreen = true;
			Main.resetMapFull = true;
			Main.buffString = string.Empty;
			releaseInventory = false;
		}
	}

	public void UpdateLuckFactors()
	{
		UpdateLadyBugLuckTime();
		UpdateCoinLuck();
		if (whoAmI == Main.myPlayer)
		{
			float num = torchLuck;
			TryRecalculatingTorchLuck();
			if (torchLuck != num)
			{
				luckNeedsSync = true;
			}
		}
	}

	public void RecalculateLuck()
	{
		if (PlayerLoader.PreModifyLuck(this, ref luck))
		{
			luck = GetLadyBugLuck() * 0.2f + torchLuck * 0.2f;
			luck += (float)(int)luckPotion * 0.1f;
			if (usedGalaxyPearl)
			{
				luck += 0.03f;
			}
			if (LanternNight.LanternsUp)
			{
				luck += 0.3f;
			}
			if (HasGardenGnomeNearby)
			{
				luck += 0.2f;
			}
			luck += equipmentBasedLuckBonus;
			luck += CalculateCoinLuck();
		}
		PlayerLoader.ModifyLuck(this, ref luck);
	}

	public static int GetMouseScrollDelta()
	{
		return PlayerInput.ScrollWheelDelta / 120;
	}

	private void UpdatePortableStoolUsage()
	{
		bool flag = portableStoolInfo.HasAStool && controlUp && !gravControl && !mount.Active && velocity.X == 0f && velocity.Y == 0f && !pulley && grappling[0] == -1;
		if (flag)
		{
			flag = CanFitSpace(portableStoolInfo.HeightBoost);
		}
		if (flag)
		{
			portableStoolInfo.IsInUse = true;
			ResizeHitbox();
		}
	}

	private void ResizeHitbox()
	{
		position.Y += height;
		height = 42 + HeightOffsetBoost;
		position.Y -= height;
	}

	private void UpdateReleaseUseTile()
	{
		bool flag = !tileInteractAttempted;
		if (_lockTileInteractionsTimer > 0 && !releaseUseTile)
		{
			flag = false;
		}
		releaseUseTile = flag;
		if (_lockTileInteractionsTimer > 0)
		{
			_lockTileInteractionsTimer--;
		}
	}

	private void GetMinecartDamage(float currentSpeed, out int damage, out float knockback)
	{
		switch (mount.Type)
		{
		default:
			damage = Main.DamageVar(25f + 55f * currentSpeed, luck);
			break;
		case 11:
		case 15:
		case 16:
		case 18:
		case 19:
		case 20:
		case 21:
		case 22:
		case 24:
		case 25:
		case 26:
		case 27:
		case 28:
		case 29:
		case 30:
		case 31:
		case 32:
		case 33:
		case 34:
		case 35:
		case 36:
		case 38:
		case 39:
		case 51:
		case 53:
			damage = Main.DamageVar(25f + 55f * currentSpeed, luck);
			break;
		case 13:
			damage = Main.DamageVar(15f + 30f * currentSpeed, luck);
			break;
		}
		if (UsingSuperCart)
		{
			damage = Main.DamageVar(50f + 100f * currentSpeed, luck);
		}
		knockback = 10f + 40f * currentSpeed;
		if (Main.hardMode)
		{
			damage = (int)((double)damage * 1.5);
		}
		if (Main.expertMode)
		{
			damage = (int)((double)damage * 1.5);
		}
	}

	public void UpdateMiscCounter()
	{
		miscCounter++;
		if (miscCounter >= 300)
		{
			miscCounter = 0;
		}
	}

	private void WingAirLogicTweaks()
	{
		if (wingsLogic < 1)
		{
			return;
		}
		WingStats wingStats = GetWingStats(wingsLogic);
		bool flag = TryingToHoverDown && controlJump && wingTime > 0f;
		if (wingStats.HasDownHoverStats && flag)
		{
			if (wingStats.DownHoverSpeedOverride != -1f)
			{
				accRunSpeed = wingStats.DownHoverSpeedOverride;
			}
			runAcceleration *= wingStats.DownHoverAccelerationMult;
		}
		else
		{
			if (wingStats.AccRunSpeedOverride != -1f && wingStats.AccRunSpeedOverride > accRunSpeed)
			{
				accRunSpeed = wingStats.AccRunSpeedOverride;
			}
			runAcceleration *= wingStats.AccRunAccelerationMult;
		}
		if (wingsLogic == 45 && (float)timeSinceLastDashStarted >= 60f)
		{
			runSlowdown *= 6f;
		}
		ItemLoader.HorizontalWingSpeeds(this);
	}

	private void RocketBootVisuals()
	{
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0314: Unknown result type (might be due to invalid IL or missing references)
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0346: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0355: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03af: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c8: Unknown result type (might be due to invalid IL or missing references)
		int num = height;
		if (gravDir == -1f)
		{
			num = 4;
		}
		Vector2 vector = default(Vector2);
		for (int i = 0; i < 2; i++)
		{
			int num2 = ((i == 0) ? 2 : (-2));
			Rectangle r = ((i != 0) ? new Rectangle((int)position.X + width - 4, (int)position.Y + num - 10, 8, 8) : new Rectangle((int)position.X - 4, (int)position.Y + num - 10, 8, 8));
			if (direction == -1)
			{
				r.X -= 4;
			}
			int type = 6;
			float scale = 2.5f;
			int alpha = 100;
			float num3 = 1f;
			((Vector2)(ref vector))._002Ector((float)(-num2) - velocity.X * 0.3f, 2f * gravDir - velocity.Y * 0.3f);
			Dust dust;
			switch (vanityRocketBoots)
			{
			case 5:
				type = 6;
				scale = 2.5f;
				break;
			case 1:
				if (socialShadowRocketBoots)
				{
					type = 27;
					scale = 1.5f;
				}
				break;
			case 3:
				type = 76;
				scale = 1f;
				alpha = 20;
				break;
			case 2:
				if (fairyBoots)
				{
					type = Main.rand.NextFromList(new short[6] { 61, 61, 61, 242, 64, 63 });
					scale = 2f;
					alpha = 120;
				}
				else
				{
					type = 16;
					scale = 1.5f;
					alpha = 20;
				}
				break;
			case 4:
			{
				int num4 = Main.rand.Next(6);
				r.Y += 2 * (int)gravDir;
				if (num4 == 0 || num4 == 1)
				{
					dust = Dust.NewDustDirect(r.TopLeft(), r.Width, r.Height, 278, 0f, 0f, 100, Color.Lerp(Color.LimeGreen, Color.White, Main.rand.NextFloat() * 0.3f));
					dust.shader = GameShaders.Armor.GetSecondaryShader(cShoe, this);
					dust.scale = 0.66f;
					dust.noGravity = true;
					Dust dust2 = dust;
					dust2.velocity *= 0.25f;
					Dust dust3 = dust;
					dust3.velocity -= velocity * 0.5f;
					Dust dust4 = dust;
					dust4.velocity += vector * 0.5f;
					Dust dust5 = dust;
					dust5.position += dust.velocity * 4f;
					if (Main.rand.Next(5) == 0)
					{
						dust.fadeIn = 0.8f;
					}
					continue;
				}
				type = 107;
				alpha = 100;
				scale = 0.7f;
				num3 = 0.5f;
				break;
			}
			}
			dust = Dust.NewDustDirect(r.TopLeft(), r.Width, r.Height, type, 0f, 0f, alpha, default(Color), scale);
			dust.shader = GameShaders.Armor.GetSecondaryShader(cShoe, this);
			Dust dust6 = dust;
			dust6.velocity += vector;
			Dust dust7 = dust;
			dust7.velocity *= num3;
			switch (vanityRocketBoots)
			{
			case 5:
				dust.noGravity = true;
				break;
			case 1:
				dust.noGravity = true;
				break;
			case 2:
			{
				Dust dust9 = dust;
				dust9.velocity *= 0.1f;
				break;
			}
			case 3:
			{
				Dust dust8 = dust;
				dust8.velocity *= 0.05f;
				dust.velocity.Y += 0.15f;
				dust.noLight = true;
				if (Main.rand.Next(2) == 0)
				{
					dust.noGravity = true;
					dust.scale = 1.75f;
				}
				break;
			}
			}
			if (fairyBoots)
			{
				dust.noGravity = true;
				dust.noLightEmittence = true;
			}
		}
	}

	public void WingFrame(bool wingFlap, bool isCustomWings = false)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b67: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_07de: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0803: Unknown result type (might be due to invalid IL or missing references)
		//IL_0828: Unknown result type (might be due to invalid IL or missing references)
		//IL_082d: Unknown result type (might be due to invalid IL or missing references)
		//IL_082f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0834: Unknown result type (might be due to invalid IL or missing references)
		//IL_083e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0843: Unknown result type (might be due to invalid IL or missing references)
		//IL_084d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0852: Unknown result type (might be due to invalid IL or missing references)
		//IL_1003: Unknown result type (might be due to invalid IL or missing references)
		//IL_1008: Unknown result type (might be due to invalid IL or missing references)
		//IL_1021: Unknown result type (might be due to invalid IL or missing references)
		//IL_1026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c01: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c06: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c0b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c15: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c1a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c1f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c2e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c33: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c38: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c3a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c3c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c41: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c48: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c5c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c66: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c82: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c88: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c8d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c92: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c99: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ca3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ca8: Unknown result type (might be due to invalid IL or missing references)
		//IL_08d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_08eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0903: Unknown result type (might be due to invalid IL or missing references)
		//IL_0908: Unknown result type (might be due to invalid IL or missing references)
		//IL_090d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0915: Unknown result type (might be due to invalid IL or missing references)
		//IL_092d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0952: Unknown result type (might be due to invalid IL or missing references)
		//IL_0957: Unknown result type (might be due to invalid IL or missing references)
		//IL_0959: Unknown result type (might be due to invalid IL or missing references)
		//IL_095e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0967: Unknown result type (might be due to invalid IL or missing references)
		//IL_096d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0972: Unknown result type (might be due to invalid IL or missing references)
		//IL_098a: Unknown result type (might be due to invalid IL or missing references)
		//IL_098f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0994: Unknown result type (might be due to invalid IL or missing references)
		//IL_099e: Unknown result type (might be due to invalid IL or missing references)
		//IL_09a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_09ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_09b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_09bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_09c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_09c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_13b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_13bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_13c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ef5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f04: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f09: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ed9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ee8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0eed: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f18: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f1d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f22: Unknown result type (might be due to invalid IL or missing references)
		//IL_13e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_13e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_13f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_13fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_1403: Unknown result type (might be due to invalid IL or missing references)
		//IL_105e: Unknown result type (might be due to invalid IL or missing references)
		//IL_108c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f2c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f2e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f33: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f3a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f4e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f6a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f74: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f79: Unknown result type (might be due to invalid IL or missing references)
		//IL_1423: Unknown result type (might be due to invalid IL or missing references)
		//IL_1428: Unknown result type (might be due to invalid IL or missing references)
		//IL_142a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1439: Unknown result type (might be due to invalid IL or missing references)
		//IL_1450: Unknown result type (might be due to invalid IL or missing references)
		//IL_1456: Unknown result type (might be due to invalid IL or missing references)
		//IL_1458: Unknown result type (might be due to invalid IL or missing references)
		//IL_145d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1462: Unknown result type (might be due to invalid IL or missing references)
		//IL_1465: Unknown result type (might be due to invalid IL or missing references)
		//IL_146a: Unknown result type (might be due to invalid IL or missing references)
		//IL_146c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1471: Unknown result type (might be due to invalid IL or missing references)
		//IL_1473: Unknown result type (might be due to invalid IL or missing references)
		//IL_147a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1483: Unknown result type (might be due to invalid IL or missing references)
		//IL_14d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_14d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_14d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_14e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_14ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_1505: Unknown result type (might be due to invalid IL or missing references)
		//IL_1507: Unknown result type (might be due to invalid IL or missing references)
		//IL_150c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1511: Unknown result type (might be due to invalid IL or missing references)
		//IL_1514: Unknown result type (might be due to invalid IL or missing references)
		//IL_1519: Unknown result type (might be due to invalid IL or missing references)
		//IL_151b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1520: Unknown result type (might be due to invalid IL or missing references)
		//IL_1522: Unknown result type (might be due to invalid IL or missing references)
		//IL_1529: Unknown result type (might be due to invalid IL or missing references)
		//IL_1532: Unknown result type (might be due to invalid IL or missing references)
		//IL_1581: Unknown result type (might be due to invalid IL or missing references)
		//IL_1586: Unknown result type (might be due to invalid IL or missing references)
		//IL_1588: Unknown result type (might be due to invalid IL or missing references)
		//IL_1597: Unknown result type (might be due to invalid IL or missing references)
		//IL_15ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_15b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_15b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_15bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_15c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_15c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_15c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_15ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_15cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_15d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_15d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_15e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1408: Unknown result type (might be due to invalid IL or missing references)
		//IL_1412: Unknown result type (might be due to invalid IL or missing references)
		//IL_1417: Unknown result type (might be due to invalid IL or missing references)
		//IL_1114: Unknown result type (might be due to invalid IL or missing references)
		//IL_1119: Unknown result type (might be due to invalid IL or missing references)
		//IL_11be: Unknown result type (might be due to invalid IL or missing references)
		//IL_11c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_1760: Unknown result type (might be due to invalid IL or missing references)
		//IL_1778: Unknown result type (might be due to invalid IL or missing references)
		//IL_177e: Unknown result type (might be due to invalid IL or missing references)
		//IL_17b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_17bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_17c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_1288: Unknown result type (might be due to invalid IL or missing references)
		//IL_128d: Unknown result type (might be due to invalid IL or missing references)
		bool flag = wingsLogic != wings;
		if (wings == 4)
		{
			if (wingFlap || jump > 0)
			{
				rocketDelay2--;
				if (rocketDelay2 <= 0)
				{
					SoundEngine.PlaySound(in SoundID.Item13, position);
					rocketDelay2 = 60;
				}
				int num = 2;
				if (TryingToHoverUp)
				{
					num = 4;
				}
				for (int i = 0; i < num; i++)
				{
					int type = 6;
					if (head == 41)
					{
						_ = body;
					}
					float scale = 1.75f;
					int alpha = 100;
					float x = position.X + (float)(width / 2) + 16f;
					if (direction > 0)
					{
						x = position.X + (float)(width / 2) - 26f;
					}
					float num12 = position.Y + (float)height - 18f;
					if (i == 1 || i == 3)
					{
						x = position.X + (float)(width / 2) + 8f;
						if (direction > 0)
						{
							x = position.X + (float)(width / 2) - 20f;
						}
						num12 += 6f;
					}
					if (i > 1)
					{
						num12 += velocity.Y;
					}
					int num23 = Dust.NewDust(new Vector2(x, num12), 8, 8, type, 0f, 0f, alpha, default(Color), scale);
					Main.dust[num23].velocity.X *= 0.1f;
					Main.dust[num23].velocity.Y = Main.dust[num23].velocity.Y * 1f + 2f * gravDir - velocity.Y * 0.3f;
					Main.dust[num23].noGravity = true;
					Main.dust[num23].noLightEmittence = flag;
					Main.dust[num23].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
					if (num == 4)
					{
						Main.dust[num23].velocity.Y += 6f;
					}
				}
				wingFrameCounter++;
				if (wingFrameCounter > 4)
				{
					wingFrame++;
					wingFrameCounter = 0;
					if (wingFrame >= 3)
					{
						wingFrame = 0;
					}
				}
			}
			else if (!controlJump || velocity.Y == 0f)
			{
				wingFrame = 3;
			}
			return;
		}
		if (wings == 28 && ShouldDrawWingsThatAreAlwaysAnimated())
		{
			if (!flag && velocity.Y != 0f)
			{
				Lighting.AddLight(base.Bottom, 0.3f, 0.1f, 0.4f);
			}
			return;
		}
		if (wings == 22)
		{
			if (!controlJump)
			{
				wingFrame = 0;
				wingFrameCounter = 0;
			}
			else if (wingTime > 0f)
			{
				if (TryingToHoverDown)
				{
					if (velocity.X != 0f)
					{
						wingFrameCounter++;
						int num26 = 2;
						if (wingFrameCounter < num26)
						{
							wingFrame = 1;
							return;
						}
						if (wingFrameCounter < num26 * 2)
						{
							wingFrame = 2;
							return;
						}
						if (wingFrameCounter < num26 * 3)
						{
							wingFrame = 3;
							return;
						}
						if (wingFrameCounter < num26 * 4 - 1)
						{
							wingFrame = 2;
							return;
						}
						wingFrame = 2;
						wingFrameCounter = 0;
					}
					else
					{
						wingFrameCounter++;
						int num27 = 6;
						if (wingFrameCounter < num27)
						{
							wingFrame = 4;
							return;
						}
						if (wingFrameCounter < num27 * 2)
						{
							wingFrame = 5;
							return;
						}
						if (wingFrameCounter < num27 * 3 - 1)
						{
							wingFrame = 4;
							return;
						}
						wingFrame = 4;
						wingFrameCounter = 0;
					}
				}
				else
				{
					wingFrameCounter++;
					int num28 = 2;
					if (wingFrameCounter < num28)
					{
						wingFrame = 4;
						return;
					}
					if (wingFrameCounter < num28 * 2)
					{
						wingFrame = 5;
						return;
					}
					if (wingFrameCounter < num28 * 3)
					{
						wingFrame = 6;
						return;
					}
					if (wingFrameCounter < num28 * 4 - 1)
					{
						wingFrame = 5;
						return;
					}
					wingFrame = 5;
					wingFrameCounter = 0;
				}
			}
			else
			{
				wingFrameCounter++;
				int num29 = 6;
				if (wingFrameCounter < num29)
				{
					wingFrame = 4;
					return;
				}
				if (wingFrameCounter < num29 * 2)
				{
					wingFrame = 5;
					return;
				}
				if (wingFrameCounter < num29 * 3 - 1)
				{
					wingFrame = 4;
					return;
				}
				wingFrame = 4;
				wingFrameCounter = 0;
			}
			return;
		}
		if (wings == 12)
		{
			if (wingFlap || jump > 0)
			{
				wingFrameCounter++;
				int num30 = 5;
				if (wingFrameCounter < num30)
				{
					wingFrame = 1;
					return;
				}
				if (wingFrameCounter < num30 * 2)
				{
					wingFrame = 2;
					return;
				}
				if (wingFrameCounter < num30 * 3)
				{
					wingFrame = 3;
					return;
				}
				if (wingFrameCounter < num30 * 4 - 1)
				{
					wingFrame = 2;
					return;
				}
				wingFrame = 2;
				wingFrameCounter = 0;
			}
			else if (velocity.Y != 0f)
			{
				wingFrame = 2;
			}
			else
			{
				wingFrame = 0;
			}
			return;
		}
		if (wings == 24)
		{
			if (wingFlap || jump > 0)
			{
				wingFrameCounter++;
				int num31 = 1;
				if (wingFrameCounter < num31)
				{
					wingFrame = 1;
					return;
				}
				if (wingFrameCounter < num31 * 2)
				{
					wingFrame = 2;
					return;
				}
				if (wingFrameCounter < num31 * 3)
				{
					wingFrame = 3;
					return;
				}
				wingFrame = 2;
				if (wingFrameCounter >= num31 * 4 - 1)
				{
					wingFrameCounter = 0;
				}
			}
			else if (velocity.Y != 0f)
			{
				if (controlJump)
				{
					wingFrameCounter++;
					int num2 = 3;
					if (wingFrameCounter < num2)
					{
						wingFrame = 1;
						return;
					}
					if (wingFrameCounter < num2 * 2)
					{
						wingFrame = 2;
						return;
					}
					if (wingFrameCounter < num2 * 3)
					{
						wingFrame = 3;
						return;
					}
					wingFrame = 2;
					if (wingFrameCounter >= num2 * 4 - 1)
					{
						wingFrameCounter = 0;
					}
				}
				else if (wingTime == 0f)
				{
					wingFrame = 0;
				}
				else
				{
					wingFrame = 1;
				}
			}
			else
			{
				wingFrame = 0;
			}
			return;
		}
		if (wings == 30)
		{
			bool flag2 = false;
			if (wingFlap || jump > 0)
			{
				wingFrameCounter++;
				int num3 = 2;
				if (wingFrameCounter >= num3 * 3)
				{
					wingFrameCounter = 0;
				}
				wingFrame = 1 + wingFrameCounter / num3;
				flag2 = true;
			}
			else if (velocity.Y != 0f)
			{
				if (controlJump)
				{
					wingFrameCounter++;
					int num4 = 2;
					if (wingFrameCounter >= num4 * 3)
					{
						wingFrameCounter = 0;
					}
					wingFrame = 1 + wingFrameCounter / num4;
					flag2 = true;
				}
				else if (wingTime == 0f)
				{
					wingFrame = 0;
				}
				else
				{
					wingFrame = 0;
				}
			}
			else
			{
				wingFrame = 0;
			}
			if (!flag2)
			{
				return;
			}
			for (int j = 0; j < 4; j++)
			{
				if (Main.rand.Next(4) == 0)
				{
					Vector2 vector = (-0.74539816f + (float)Math.PI / 8f * (float)j + 0.03f * (float)j).ToRotationVector2() * new Vector2((float)(-direction * 20), 20f);
					Dust dust = Main.dust[Dust.NewDust(base.Center, 0, 0, 229, 0f, 0f, 100, Color.White, 0.8f)];
					dust.noGravity = true;
					dust.noLightEmittence = flag;
					dust.position = base.Center + vector;
					dust.velocity = DirectionTo(dust.position) * 2f;
					if (Main.rand.Next(10) != 0)
					{
						dust.customData = this;
					}
					else
					{
						dust.fadeIn = 0.5f;
					}
					dust.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
				}
			}
			for (int k = 0; k < 4; k++)
			{
				if (Main.rand.Next(8) == 0)
				{
					Vector2 vector2 = (-0.7053982f + (float)Math.PI / 8f * (float)k + 0.03f * (float)k).ToRotationVector2() * new Vector2((float)(direction * 20), 24f) + new Vector2((float)(-direction) * 16f, 0f);
					Dust dust2 = Main.dust[Dust.NewDust(base.Center, 0, 0, 229, 0f, 0f, 100, Color.White, 0.5f)];
					dust2.noGravity = true;
					dust2.noLightEmittence = flag;
					dust2.position = base.Center + vector2;
					dust2.velocity = Vector2.Normalize(dust2.position - base.Center - new Vector2((float)(-direction) * 16f, 0f)) * 2f;
					dust2.position += dust2.velocity * 5f;
					if (Main.rand.Next(10) != 0)
					{
						dust2.customData = this;
					}
					else
					{
						dust2.fadeIn = 0.5f;
					}
					dust2.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
				}
			}
			return;
		}
		if (wings == 34 && ShouldDrawWingsThatAreAlwaysAnimated())
		{
			if (wingFlap || jump > 0)
			{
				wingFrameCounter++;
				int num5 = 4;
				if (wingFrameCounter >= num5 * 6)
				{
					wingFrameCounter = 0;
				}
				wingFrame = wingFrameCounter / num5;
			}
			else if (velocity.Y != 0f)
			{
				if (controlJump)
				{
					wingFrameCounter++;
					int num6 = 9;
					if (wingFrameCounter >= num6 * 6)
					{
						wingFrameCounter = 0;
					}
					wingFrame = wingFrameCounter / num6;
				}
				else
				{
					wingFrameCounter++;
					int num7 = 6;
					if (wingFrameCounter >= num7 * 6)
					{
						wingFrameCounter = 0;
					}
					wingFrame = wingFrameCounter / num7;
				}
			}
			else
			{
				wingFrameCounter++;
				int num8 = 4;
				if (wingFrameCounter >= num8 * 6)
				{
					wingFrameCounter = 0;
				}
				wingFrame = wingFrameCounter / num8;
			}
			return;
		}
		if (wings == 45 && ShouldDrawWingsThatAreAlwaysAnimated())
		{
			if (wingTime > 0f)
			{
				rocketDelay2--;
				if (rocketDelay2 <= 0)
				{
					SoundEngine.PlaySound(in SoundID.Item24, position);
					rocketDelay2 = 30;
				}
			}
			if (velocity.Y == 0f)
			{
				wingFrameCounter = 0;
				wingFrame = 0;
			}
			else
			{
				wingFrameCounter++;
				int num9 = 3;
				if (wingTime == 0f)
				{
					num9 = 5;
				}
				if (wingFrameCounter >= num9 * 6)
				{
					wingFrameCounter = 0;
				}
				wingFrame = wingFrameCounter / num9;
			}
			if (Main.netMode != 2 && Main.rand.Next(8) == 0)
			{
				Rectangle r = Utils.CenteredRectangle(Main.ReverseGravitySupport(base.Bottom - Main.screenPosition) + Main.screenPosition, new Vector2(40f, 24f));
				Dust dust4 = Dust.NewDustDirect(r.TopLeft(), r.Width, r.Height, 43, 0f, 0f, 0, Color.White * 0.5f, 0.2f);
				dust4.fadeIn = 0.4f;
				dust4.velocity += velocity;
				dust4.velocity *= 0.35f;
				dust4.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
			}
			return;
		}
		if (wings == 44 && ShouldDrawWingsThatAreAlwaysAnimated())
		{
			int num10 = 5;
			if (wingFlap || jump > 0)
			{
				wingFrameCounter++;
				if (wingFrameCounter >= num10 * 6)
				{
					wingFrameCounter = 0;
				}
				wingFrame = 1 + wingFrameCounter / num10;
			}
			else if (velocity.Y != 0f)
			{
				if (controlJump)
				{
					wingFrame = 2;
				}
				else if (ShouldFloatInWater && wet)
				{
					wingFrame = 0;
				}
				else
				{
					wingFrame = 3;
				}
			}
			else
			{
				wingFrameCounter++;
				if (wingFrameCounter >= num10 * 6)
				{
					wingFrameCounter = 0;
				}
				wingFrame = 1 + wingFrameCounter / num10;
			}
			return;
		}
		if (wings == 39 && ShouldDrawWingsThatAreAlwaysAnimated())
		{
			if (wingFlap || jump > 0)
			{
				wingFrameCounter++;
				int num11 = 4;
				if (wingFrameCounter >= num11 * 6)
				{
					wingFrameCounter = 0;
				}
				wingFrame = wingFrameCounter / num11;
			}
			else if (velocity.Y != 0f)
			{
				if (controlJump)
				{
					wingFrameCounter++;
					int num13 = 9;
					if (wingFrameCounter >= num13 * 6)
					{
						wingFrameCounter = 0;
					}
					wingFrame = wingFrameCounter / num13;
				}
				else
				{
					wingFrameCounter++;
					int num14 = 6;
					if (wingFrameCounter >= num14 * 6)
					{
						wingFrameCounter = 0;
					}
					wingFrame = wingFrameCounter / num14;
				}
			}
			else
			{
				wingFrameCounter++;
				int num15 = 4;
				if (wingFrameCounter >= num15 * 6)
				{
					wingFrameCounter = 0;
				}
				wingFrame = wingFrameCounter / num15;
			}
			int num16 = 1;
			if (wingFrame == 3)
			{
				num16 = 5;
			}
			if (velocity.Y == 0f)
			{
				num16 = 0;
			}
			Rectangle r2 = Utils.CenteredRectangle((gravDir == 1f) ? (base.Bottom + new Vector2(0f, -10f)) : (base.Top + new Vector2(0f, 10f)), new Vector2(50f, 20f));
			for (int l = 0; l < num16; l++)
			{
				Dust dust5 = Dust.NewDustDirect(r2.TopLeft(), r2.Width, r2.Height, 31, 0f, 0f, 0, Color.Black);
				dust5.scale = 0.7f;
				dust5.velocity *= 0.4f;
				dust5.velocity.Y += gravDir * 0.5f;
				dust5.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
			}
			return;
		}
		if (wings == 33)
		{
			bool flag3 = false;
			if (wingFlap || jump > 0)
			{
				flag3 = true;
			}
			else if (velocity.Y != 0f && controlJump)
			{
				flag3 = true;
			}
			if (!flag3)
			{
				return;
			}
			Color newColor = Main.hslToRgb(Main.rgbToHsl(eyeColor).X, 1f, 0.5f);
			int num17 = ((direction != 1) ? (-4) : 0);
			int num18 = ((gravDir == 1f) ? height : 0);
			for (int m = 0; m < 2; m++)
			{
				Dust dust3 = Main.dust[Dust.NewDust(position, width, height, 182, velocity.X, velocity.Y, 127, newColor)];
				dust3.noGravity = true;
				dust3.fadeIn = 1f;
				dust3.scale = 1f;
				dust3.noLight = true;
				dust3.noLightEmittence = flag;
				dust3.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
				switch (m)
				{
				case 0:
					dust3.position = new Vector2(position.X + (float)num17, position.Y + (float)num18);
					dust3.velocity.X = dust3.velocity.X * 1f - 2f - velocity.X * 0.3f;
					dust3.velocity.Y = dust3.velocity.Y * 1f + 2f * gravDir - velocity.Y * 0.3f;
					break;
				case 1:
					dust3.position = new Vector2(position.X + (float)width + (float)num17, position.Y + (float)num18);
					dust3.velocity.X = dust3.velocity.X * 1f + 2f - velocity.X * 0.3f;
					dust3.velocity.Y = dust3.velocity.Y * 1f + 2f * gravDir - velocity.Y * 0.3f;
					break;
				}
				if (dust3.dustIndex != 6000)
				{
					Dust dust6 = Dust.CloneDust(dust3);
					dust6.scale *= 0.65f;
					dust6.fadeIn *= 0.65f;
					dust6.color = new Color(255, 255, 255, 255);
					dust3.noLight = true;
					dust3.noLightEmittence = flag;
					dust3.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
				}
			}
			return;
		}
		if (wings == 38)
		{
			bool flag4 = false;
			if (wingFlap || jump > 0)
			{
				wingFrameCounter++;
				if (wingFrameCounter >= 32)
				{
					wingFrameCounter = 0;
				}
				wingFrame = 1 + wingFrameCounter / 8;
				if (wingFrame == 4)
				{
					wingFrame = 2;
				}
				flag4 = true;
			}
			else if (velocity.Y != 0f)
			{
				if (controlJump)
				{
					wingFrameCounter++;
					if (wingFrameCounter >= 32)
					{
						wingFrameCounter = 0;
					}
					wingFrame = 1 + wingFrameCounter / 8;
					if (wingFrame == 4)
					{
						wingFrame = 2;
					}
					flag4 = true;
				}
				else
				{
					wingFrame = 0;
				}
			}
			else
			{
				wingFrame = 0;
			}
			if (!flag4)
			{
				return;
			}
			Vector2 vector3 = default(Vector2);
			((Vector2)(ref vector3))._002Ector((float)direction, gravDir);
			Vector2 value = velocity * 0.5f;
			int type2 = 267;
			int num19 = miscCounter * direction;
			for (int n = 0; n < 3; n++)
			{
				Vector2 vector4 = Vector2.Zero;
				switch (n)
				{
				case 1:
					vector4 = velocity * -0.33f;
					break;
				case 2:
					vector4 = velocity * -0.66f;
					break;
				}
				Vector2 vector5 = new Vector2(-39f, 6f) * vector3 + Utils.RotatedBy(new Vector2(2f, 0f), (float)num19 / -15f * ((float)Math.PI * 2f));
				Dust dust7 = Dust.NewDustPerfect(base.Center + vector5 + vector4, type2, value, 0, underShirtColor);
				dust7.noGravity = true;
				dust7.noLight = true;
				dust7.noLightEmittence = flag;
				dust7.scale = 0.47f;
				dust7.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
				vector5 = new Vector2(-23f, 2f) * vector3 + Utils.RotatedBy(new Vector2(2f, 0f), (float)num19 / -15f * ((float)Math.PI * 2f));
				Dust dust8 = Dust.NewDustPerfect(base.Center + vector5 + vector4, type2, value, 0, underShirtColor);
				dust8.noGravity = true;
				dust8.noLight = true;
				dust8.noLightEmittence = flag;
				dust8.scale = 0.35f;
				dust8.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
				vector5 = new Vector2(-31f, -6f) * vector3 + Utils.RotatedBy(new Vector2(2f, 0f), (float)num19 / -20f * ((float)Math.PI * 2f));
				Dust dust9 = Dust.NewDustPerfect(base.Center + vector5 + vector4, type2, value, 0, underShirtColor);
				dust9.noGravity = true;
				dust9.noLight = true;
				dust9.noLightEmittence = flag;
				dust9.scale = 0.49f;
				dust9.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
			}
			return;
		}
		int num20 = 4;
		int num21 = 4;
		int num22 = 0;
		if (wings == 43)
		{
			num21 = 7;
			num22 = 1;
			num20 = 3;
		}
		if (isCustomWings)
		{
			return;
		}
		if (wings == 32)
		{
			num20 = 3;
		}
		if (wingFlap || jump > 0)
		{
			wingFrameCounter++;
			if (wingFrameCounter > num20)
			{
				wingFrame++;
				wingFrameCounter = 0;
				if (wingFrame >= num21)
				{
					wingFrame = num22;
				}
			}
		}
		else if (velocity.Y != 0f)
		{
			wingFrame = 1;
			if (wings == 32)
			{
				wingFrame = 3;
			}
			if (wings == 43)
			{
				wingFrame = 2;
				if (ShouldFloatInWater && wet)
				{
					wingFrame = 0;
				}
			}
			if (wings == 29 && Main.rand.Next(5) == 0)
			{
				int num24 = 4;
				if (direction == 1)
				{
					num24 = -40;
				}
				int num25 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num24, position.Y + (float)(height / 2) - 15f), 30, 30, 6, 0f, 0f, 100, default(Color), 2.4f);
				Main.dust[num25].noGravity = true;
				Main.dust[num25].noLightEmittence = flag;
				Dust obj = Main.dust[num25];
				obj.velocity *= 0.3f;
				if (Main.rand.Next(10) == 0)
				{
					Main.dust[num25].fadeIn = 2f;
				}
				Main.dust[num25].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
			}
		}
		else
		{
			wingFrame = 0;
		}
	}

	public bool ShouldDrawWingsThatAreAlwaysAnimated()
	{
		if ((velocity.Y != 0f || grappling[0] != -1) && (!wet || !ShouldFloatInWater))
		{
			return !mount.Active;
		}
		return false;
	}

	private void WingAirVisuals()
	{
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_037c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0392: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04df: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0505: Unknown result type (might be due to invalid IL or missing references)
		//IL_0537: Unknown result type (might be due to invalid IL or missing references)
		//IL_0541: Unknown result type (might be due to invalid IL or missing references)
		//IL_0546: Unknown result type (might be due to invalid IL or missing references)
		//IL_0554: Unknown result type (might be due to invalid IL or missing references)
		//IL_055a: Unknown result type (might be due to invalid IL or missing references)
		//IL_055f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0564: Unknown result type (might be due to invalid IL or missing references)
		//IL_0422: Unknown result type (might be due to invalid IL or missing references)
		//IL_0442: Unknown result type (might be due to invalid IL or missing references)
		//IL_0448: Unknown result type (might be due to invalid IL or missing references)
		//IL_046c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0476: Unknown result type (might be due to invalid IL or missing references)
		//IL_047b: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_070c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0712: Unknown result type (might be due to invalid IL or missing references)
		//IL_0732: Unknown result type (might be due to invalid IL or missing references)
		//IL_073c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0741: Unknown result type (might be due to invalid IL or missing references)
		//IL_0749: Unknown result type (might be due to invalid IL or missing references)
		//IL_074f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0759: Unknown result type (might be due to invalid IL or missing references)
		//IL_075e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0763: Unknown result type (might be due to invalid IL or missing references)
		//IL_0796: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_095d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0975: Unknown result type (might be due to invalid IL or missing references)
		//IL_097b: Unknown result type (might be due to invalid IL or missing references)
		//IL_099f: Unknown result type (might be due to invalid IL or missing references)
		//IL_09a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_09ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_05eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_060d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0613: Unknown result type (might be due to invalid IL or missing references)
		//IL_0645: Unknown result type (might be due to invalid IL or missing references)
		//IL_064f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0654: Unknown result type (might be due to invalid IL or missing references)
		//IL_0662: Unknown result type (might be due to invalid IL or missing references)
		//IL_0668: Unknown result type (might be due to invalid IL or missing references)
		//IL_066d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0672: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a63: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a7b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a81: Unknown result type (might be due to invalid IL or missing references)
		//IL_0aac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ab6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0abb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b36: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b51: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b57: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b77: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b81: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b86: Unknown result type (might be due to invalid IL or missing references)
		//IL_081a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0852: Unknown result type (might be due to invalid IL or missing references)
		//IL_0858: Unknown result type (might be due to invalid IL or missing references)
		//IL_0878: Unknown result type (might be due to invalid IL or missing references)
		//IL_0882: Unknown result type (might be due to invalid IL or missing references)
		//IL_0887: Unknown result type (might be due to invalid IL or missing references)
		//IL_088f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0895: Unknown result type (might be due to invalid IL or missing references)
		//IL_089f: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_08dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_08eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_08f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_08f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c23: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c41: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c47: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c72: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c7c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c81: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d0c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d2d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d33: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d53: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d5d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d62: Unknown result type (might be due to invalid IL or missing references)
		bool noLightEmittence = wingsLogic != wings;
		if (wings == 10 && Main.rand.Next(2) == 0)
		{
			int num = 4;
			if (direction == 1)
			{
				num = -40;
			}
			int num12 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num, position.Y + (float)(height / 2) - 15f), 30, 30, 76, 0f, 0f, 50, default(Color), 0.6f);
			Main.dust[num12].fadeIn = 1.1f;
			Main.dust[num12].noGravity = true;
			Main.dust[num12].noLight = true;
			Dust obj = Main.dust[num12];
			obj.velocity *= 0.3f;
			Main.dust[num12].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
		}
		if (wings == 34 && Main.rand.Next(2) == 0)
		{
			int num17 = 4;
			if (direction == 1)
			{
				num17 = -40;
			}
			int num18 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num17, position.Y + (float)(height / 2) - 15f), 30, 30, 261, 0f, 0f, 50, default(Color), 0.6f);
			Main.dust[num18].fadeIn = 1.1f;
			Main.dust[num18].noGravity = true;
			Main.dust[num18].noLight = true;
			Main.dust[num18].noLightEmittence = noLightEmittence;
			Dust obj2 = Main.dust[num18];
			obj2.velocity *= 0.3f;
			Main.dust[num18].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
		}
		_ = wings;
		_ = wings;
		if (wings == 9 && Main.rand.Next(2) == 0)
		{
			int num19 = 4;
			if (direction == 1)
			{
				num19 = -40;
			}
			int num20 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num19, position.Y + (float)(height / 2) - 15f), 30, 30, 6, 0f, 0f, 200, default(Color), 2f);
			Main.dust[num20].noGravity = true;
			Main.dust[num20].noLightEmittence = noLightEmittence;
			Dust obj3 = Main.dust[num20];
			obj3.velocity *= 0.3f;
			Main.dust[num20].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
		}
		if (wings == 6 && Main.rand.Next(4) == 0)
		{
			int num21 = 4;
			if (direction == 1)
			{
				num21 = -40;
			}
			int num22 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num21, position.Y + (float)(height / 2) - 15f), 30, 30, 55, 0f, 0f, 200);
			Dust obj4 = Main.dust[num22];
			obj4.velocity *= 0.3f;
			Main.dust[num22].noLightEmittence = noLightEmittence;
			Main.dust[num22].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
		}
		if (wings == 5 && Main.rand.Next(3) == 0)
		{
			int num23 = 6;
			if (direction == 1)
			{
				num23 = -30;
			}
			int num2 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num23, position.Y), 18, height, 58, 0f, 0f, 255, default(Color), 1.2f);
			Main.dust[num2].noLightEmittence = noLightEmittence;
			Dust obj5 = Main.dust[num2];
			obj5.velocity *= 0.3f;
			Main.dust[num2].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
		}
		if (wings == 26)
		{
			int num3 = 6;
			if (direction == 1)
			{
				num3 = -30;
			}
			int num4 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num3, position.Y), 18, height, 217, 0f, 0f, 100, default(Color), 1.4f);
			Main.dust[num4].noGravity = true;
			Main.dust[num4].noLight = true;
			Dust obj6 = Main.dust[num4];
			obj6.velocity /= 4f;
			Dust obj7 = Main.dust[num4];
			obj7.velocity -= velocity;
			Main.dust[num4].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
			if (Main.rand.Next(2) == 0)
			{
				num3 = -24;
				if (direction == 1)
				{
					num3 = 12;
				}
				float num5 = position.Y;
				if (gravDir == -1f)
				{
					num5 += (float)(height / 2);
				}
				num4 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num3, num5), 12, height / 2, 217, 0f, 0f, 100, default(Color), 1.4f);
				Main.dust[num4].noGravity = true;
				Main.dust[num4].noLight = true;
				Dust obj8 = Main.dust[num4];
				obj8.velocity /= 4f;
				Dust obj9 = Main.dust[num4];
				obj9.velocity -= velocity;
				Main.dust[num4].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
			}
		}
		if (wings == 37)
		{
			int num6 = 6;
			if (direction == 1)
			{
				num6 = -30;
			}
			Dust dust = Dust.NewDustDirect(new Vector2(position.X + (float)(width / 2) + (float)num6, position.Y), 24, height, Utils.SelectRandom<int>(Main.rand, 31, 31, 31), 0f, 0f, 100);
			dust.noGravity = true;
			dust.noLight = true;
			Dust dust2 = dust;
			dust2.velocity /= 4f;
			Dust dust3 = dust;
			dust3.velocity -= velocity / 2f;
			dust.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
			if (dust.type == 55)
			{
				dust.noGravity = true;
				Dust dust4 = dust;
				dust4.velocity *= 2f;
				dust.color = Color.Red;
			}
			if (Main.rand.Next(3) == 0)
			{
				num6 = -24;
				if (direction == 1)
				{
					num6 = 12;
				}
				float num7 = position.Y;
				if (gravDir == -1f)
				{
					num7 += (float)(height / 2);
				}
				dust = Dust.NewDustDirect(new Vector2(position.X + (float)(width / 2) + (float)num6, num7), 16, height / 2, Utils.SelectRandom<int>(Main.rand, 31, 31, 31), 0f, 0f, 100);
				dust.noGravity = true;
				dust.noLight = true;
				Dust dust5 = dust;
				dust5.velocity /= 4f;
				Dust dust6 = dust;
				dust6.velocity -= velocity / 2f;
				dust.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
				if (dust.type == 55)
				{
					dust.noGravity = true;
					Dust dust7 = dust;
					dust7.velocity *= 2f;
					dust.color = Color.Red;
				}
			}
		}
		if (wings == 29 && Main.rand.Next(3) == 0)
		{
			int num8 = 4;
			if (direction == 1)
			{
				num8 = -40;
			}
			int num9 = Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num8, position.Y + (float)(height / 2) - 15f), 30, 30, 6, 0f, 0f, 100, default(Color), 2.4f);
			Main.dust[num9].noGravity = true;
			Dust obj10 = Main.dust[num9];
			obj10.velocity *= 0.3f;
			Main.dust[num9].noLightEmittence = noLightEmittence;
			if (Main.rand.Next(10) == 0)
			{
				Main.dust[num9].fadeIn = 2f;
			}
			Main.dust[num9].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
		}
		if (wings != 31)
		{
			return;
		}
		if (Main.rand.Next(6) == 0)
		{
			int num10 = 4;
			if (direction == 1)
			{
				num10 = -40;
			}
			Dust obj11 = Main.dust[Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num10, position.Y + (float)(height / 2) - 15f), 30, 30, 86)];
			obj11.noGravity = true;
			obj11.scale = 1f;
			obj11.fadeIn = 1.2f;
			obj11.velocity *= 0.2f;
			obj11.noLight = true;
			obj11.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
		}
		if (Main.rand.Next(3) == 0)
		{
			int num11 = 4;
			if (direction == 1)
			{
				num11 = -40;
			}
			Dust obj12 = Main.dust[Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num11, position.Y + (float)(height / 2) - 15f), 30, 30, 240)];
			obj12.noGravity = true;
			obj12.scale = 1.2f;
			obj12.velocity *= 0.2f;
			obj12.alpha = 200;
			obj12.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
		}
		if (Main.rand.Next(2) != 0)
		{
			return;
		}
		if (Main.rand.Next(6) == 0)
		{
			int num14 = -24;
			if (direction == 1)
			{
				num14 = 12;
			}
			float num15 = position.Y;
			if (gravDir == -1f)
			{
				num15 += (float)(height / 2);
			}
			Dust obj13 = Main.dust[Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num14, num15), 12, height / 2, 86)];
			obj13.noGravity = true;
			obj13.scale = 1f;
			obj13.fadeIn = 1.2f;
			obj13.velocity *= 0.2f;
			obj13.noLight = true;
			obj13.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
		}
		if (Main.rand.Next(3) == 0)
		{
			int num13 = -24;
			if (direction == 1)
			{
				num13 = 12;
			}
			float num16 = position.Y;
			if (gravDir == -1f)
			{
				num16 += (float)(height / 2);
			}
			Dust obj14 = Main.dust[Dust.NewDust(new Vector2(position.X + (float)(width / 2) + (float)num13, num16), 12, height / 2, 240)];
			obj14.noGravity = true;
			obj14.scale = 1.2f;
			obj14.velocity *= 0.2f;
			obj14.alpha = 200;
			obj14.shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
		}
	}

	private void HandleBeingInChestRange()
	{
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		if (chest != -1)
		{
			if (chest != -2)
			{
				piggyBankProjTracker.Clear();
			}
			if (chest != -5)
			{
				voidLensChest.Clear();
			}
			bool flag = false;
			int projectileLocalIndex = piggyBankProjTracker.ProjectileLocalIndex;
			if (projectileLocalIndex >= 0)
			{
				flag = true;
				if (!Main.projectile[projectileLocalIndex].active || (Main.projectile[projectileLocalIndex].type != 525 && Main.projectile[projectileLocalIndex].type != 960))
				{
					Main.PlayInteractiveProjectileOpenCloseSound(Main.projectile[projectileLocalIndex].type, open: false);
					chest = -1;
					Recipe.FindRecipes();
				}
				else
				{
					int num = (int)(((double)position.X + (double)width * 0.5) / 16.0);
					int num2 = (int)(((double)position.Y + (double)height * 0.5) / 16.0);
					Vector2 vector = Main.projectile[projectileLocalIndex].Hitbox.ClosestPointInRect(base.Center);
					chestX = (int)vector.X / 16;
					chestY = (int)vector.Y / 16;
					if (num < chestX - tileRangeX || num > chestX + tileRangeX + 1 || num2 < chestY - tileRangeY || num2 > chestY + tileRangeY + 1)
					{
						if (chest != -1)
						{
							Main.PlayInteractiveProjectileOpenCloseSound(Main.projectile[projectileLocalIndex].type, open: false);
						}
						chest = -1;
						Recipe.FindRecipes();
					}
				}
			}
			int projectileLocalIndex2 = voidLensChest.ProjectileLocalIndex;
			if (projectileLocalIndex2 >= 0)
			{
				flag = true;
				if (!Main.projectile[projectileLocalIndex2].active || Main.projectile[projectileLocalIndex2].type != 734)
				{
					SoundEngine.PlaySound(in SoundID.Item130);
					chest = -1;
					Recipe.FindRecipes();
				}
				else
				{
					int num3 = (int)(((double)position.X + (double)width * 0.5) / 16.0);
					int num4 = (int)(((double)position.Y + (double)height * 0.5) / 16.0);
					Vector2 vector2 = Main.projectile[projectileLocalIndex2].Hitbox.ClosestPointInRect(base.Center);
					chestX = (int)vector2.X / 16;
					chestY = (int)vector2.Y / 16;
					if (num3 < chestX - tileRangeX || num3 > chestX + tileRangeX + 1 || num4 < chestY - tileRangeY || num4 > chestY + tileRangeY + 1)
					{
						if (chest != -1)
						{
							SoundEngine.PlaySound(in SoundID.Item130);
						}
						chest = -1;
						Recipe.FindRecipes();
					}
				}
			}
			if (flag)
			{
				return;
			}
			if (!IsInInteractionRangeToMultiTileHitbox(chestX, chestY))
			{
				if (chest != -1)
				{
					SoundEngine.PlaySound(11);
				}
				chest = -1;
				Recipe.FindRecipes();
			}
			else if (!Main.tile[chestX, chestY].active())
			{
				SoundEngine.PlaySound(11);
				chest = -1;
				Recipe.FindRecipes();
			}
		}
		else
		{
			piggyBankProjTracker.Clear();
			voidLensChest.Clear();
		}
	}

	public bool IsInInteractionRangeToMultiTileHitbox(int chestPointX, int chestPointY)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		int num = (int)(((double)position.X + (double)width * 0.5) / 16.0);
		int num2 = (int)(((double)position.Y + (double)height * 0.5) / 16.0);
		Rectangle r = Rectangle.Empty;
		Tile tile = Main.tile[chestPointX, chestPointY];
		if (tile.type == 463 || tile.type == 491)
		{
			((Rectangle)(ref r))._002Ector(chestPointX * 16 - 16, chestPointY * 16 - 32, 48, 64);
		}
		if (TileID.Sets.BasicChest[tile.type] || tile.type == 97)
		{
			((Rectangle)(ref r))._002Ector(chestPointX * 16, chestPointY * 16, 32, 32);
		}
		if (TileID.Sets.BasicDresser[tile.type])
		{
			((Rectangle)(ref r))._002Ector(chestPointX * 16, chestPointY * 16, 48, 32);
		}
		if (tile.type == 29)
		{
			((Rectangle)(ref r))._002Ector(chestPointX * 16, chestPointY * 16, 32, 16);
		}
		((Rectangle)(ref r)).Inflate(-1, -1);
		Point val = r.ClosestPointInRect(base.Center).ToTileCoordinates();
		chestPointX = val.X;
		chestPointY = val.Y;
		if (num >= chestPointX - tileRangeX && num <= chestPointX + tileRangeX + 1 && num2 >= chestPointY - tileRangeY)
		{
			return num2 <= chestPointY + tileRangeY + 1;
		}
		return false;
	}

	public void ResetVisibleAccessories()
	{
		handon = -1;
		handoff = -1;
		back = -1;
		front = -1;
		shoe = -1;
		waist = -1;
		shield = -1;
		neck = -1;
		face = -1;
		balloon = -1;
		backpack = -1;
		tail = -1;
		faceHead = -1;
		faceFlower = -1;
		balloonFront = -1;
		beard = -1;
	}

	public void UpdateArmorLights()
	{
		//IL_030a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bc: Unknown result type (might be due to invalid IL or missing references)
		if (vortexStealthActive)
		{
			return;
		}
		float num = 0f;
		float num5 = 0f;
		float num6 = 0f;
		switch (head)
		{
		case 11:
			num = 0.92f;
			num5 = 0.8f;
			num6 = 0.65f;
			break;
		case 216:
			num = 0.7f;
			num5 = 0.95f;
			num6 = 0.82f;
			break;
		case 169:
			num = 0f;
			num5 = 0.36f;
			num6 = 0.4f;
			break;
		case 170:
			num = 0.4f;
			num5 = 0.16f;
			num6 = 0.36f;
			break;
		case 171:
			num = 0.5f;
			num5 = 0.25f;
			num6 = 0.05f;
			break;
		case 189:
			num = 0.9f;
			num5 = 0.9f;
			num6 = 0.7f;
			break;
		case 178:
			num = 0.1f;
			num5 = 0.2f;
			num6 = 0.3f;
			break;
		case 211:
			num = 0.2f;
			num5 = 0.4f;
			num6 = 0.8f;
			break;
		}
		float num7 = 0f;
		float num8 = 0f;
		float num9 = 0f;
		switch (body)
		{
		case 175:
			num7 = 0f;
			num8 = 0.36f;
			num9 = 0.4f;
			break;
		case 176:
			num7 = 0.4f;
			num8 = 0.16f;
			num9 = 0.36f;
			break;
		case 177:
			num7 = 0.5f;
			num8 = 0.25f;
			num9 = 0.05f;
			break;
		case 190:
			num = 0.9f;
			num5 = 0.9f;
			num6 = 0.7f;
			break;
		case 205:
			num7 = 0.2f;
			num8 = 0.4f;
			num9 = 0.8f;
			break;
		}
		float num10 = 0f;
		float num11 = 0f;
		float num12 = 0f;
		switch (legs)
		{
		case 110:
			num10 = 0f;
			num11 = 0.36f;
			num12 = 0.4f;
			break;
		case 111:
			num10 = 0.4f;
			num11 = 0.16f;
			num12 = 0.36f;
			break;
		case 112:
			num10 = 0.5f;
			num11 = 0.25f;
			num12 = 0.05f;
			break;
		case 130:
			num = 0.9f;
			num5 = 0.9f;
			num6 = 0.7f;
			break;
		}
		if (num != 0f || num5 != 0f || num6 != 0f)
		{
			float num2 = 1f;
			if (num == num7 && num5 == num8 && num6 == num9)
			{
				num2 += 0.5f;
			}
			if (num == num10 && num5 == num11 && num6 == num12)
			{
				num2 += 0.5f;
			}
			Vector2 spinningpoint = default(Vector2);
			((Vector2)(ref spinningpoint))._002Ector((float)(width / 2 + 8 * direction), 2f);
			if (fullRotation != 0f)
			{
				spinningpoint = spinningpoint.RotatedBy(fullRotation, fullRotationOrigin);
			}
			int i2 = (int)(position.X + spinningpoint.X) / 16;
			int i = (int)(position.Y + spinningpoint.Y) / 16;
			Lighting.AddLight(i2, i, num * num2, num5 * num2, num6 * num2);
		}
		if (num7 != 0f || num8 != 0f || num9 != 0f)
		{
			float num3 = 1f;
			if (num7 == num && num8 == num5 && num9 == num6)
			{
				num3 += 0.5f;
			}
			if (num7 == num10 && num8 == num11 && num9 == num12)
			{
				num3 += 0.5f;
			}
			Vector2 spinningpoint2 = default(Vector2);
			((Vector2)(ref spinningpoint2))._002Ector((float)(width / 2 + 8), (float)(height / 2));
			if (fullRotation != 0f)
			{
				spinningpoint2 = spinningpoint2.RotatedBy(fullRotation, fullRotationOrigin);
			}
			int i3 = (int)(position.X + spinningpoint2.X) / 16;
			int j2 = (int)(position.Y + spinningpoint2.Y) / 16;
			Lighting.AddLight(i3, j2, num7 * num3, num8 * num3, num9 * num3);
		}
		if (num10 != 0f || num11 != 0f || num12 != 0f)
		{
			float num4 = 1f;
			if (num10 == num7 && num11 == num8 && num12 == num9)
			{
				num4 += 0.5f;
			}
			if (num10 == num && num11 == num5 && num12 == num6)
			{
				num4 += 0.5f;
			}
			Vector2 spinningpoint3 = default(Vector2);
			((Vector2)(ref spinningpoint3))._002Ector((float)(width / 2 + 8 * direction), (float)height * 0.75f);
			if (fullRotation != 0f)
			{
				spinningpoint3 = spinningpoint3.RotatedBy(fullRotation, fullRotationOrigin);
			}
			int i4 = (int)(position.X + spinningpoint3.X) / 16;
			int j3 = (int)(position.Y + spinningpoint3.Y) / 16;
			Lighting.AddLight(i4, j3, num10 * num4, num11 * num4, num12 * num4);
		}
	}

	public void Update_NPCCollision()
	{
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		if (creativeGodMode)
		{
			return;
		}
		Rectangle rectangle = default(Rectangle);
		((Rectangle)(ref rectangle))._002Ector((int)position.X, (int)position.Y, width, height);
		Rectangle npcRect = default(Rectangle);
		for (int i = 0; i < 200; i++)
		{
			if (!Main.npc[i].active || Main.npc[i].friendly || Main.npc[i].damage <= 0)
			{
				continue;
			}
			int specialHitSetter = -1;
			switch (Main.npc[i].type)
			{
			case 396:
			case 397:
			case 398:
			case 400:
			case 401:
				specialHitSetter = 1;
				break;
			case 636:
				specialHitSetter = 1;
				if (Main.npc[i].ai[0] == 0f || Main.npc[i].ai[0] == 10f)
				{
					continue;
				}
				break;
			}
			if (!CombinedHooks.CanNPCHitPlayer(Main.npc[i], this, ref specialHitSetter) || (specialHitSetter == -1 && immune) || (dash == 2 && i == eocHit && eocDash > 0) || npcTypeNoAggro[Main.npc[i].type])
			{
				continue;
			}
			float damageMultiplier = 1f;
			NPC obj = Main.npc[i];
			obj.position += Main.npc[i].netOffset;
			((Rectangle)(ref npcRect))._002Ector((int)Main.npc[i].position.X, (int)Main.npc[i].position.Y, Main.npc[i].width, Main.npc[i].height);
			NPC.GetMeleeCollisionData(rectangle, i, ref specialHitSetter, ref damageMultiplier, ref npcRect);
			if (((Rectangle)(ref rectangle)).Intersects(npcRect))
			{
				if (npcTypeNoAggro[Main.npc[i].type])
				{
					continue;
				}
				bool flag = true;
				bool flag2 = false;
				bool num6 = CanParryAgainst(rectangle, npcRect, Main.npc[i].velocity);
				float num2 = thorns;
				float knockback = 10f;
				if (turtleThorns)
				{
					num2 = 2f;
				}
				if (num6)
				{
					num2 = 2f;
					knockback = 5f;
					flag = false;
					flag2 = true;
				}
				int num3 = -1;
				if (Main.npc[i].position.X + (float)(Main.npc[i].width / 2) < position.X + (float)(width / 2))
				{
					num3 = 1;
				}
				int num4 = Main.DamageVar((float)Main.npc[i].damage * damageMultiplier, 0f - luck);
				bool flag3 = !immune;
				if (specialHitSetter >= 0)
				{
					flag3 = hurtCooldowns[specialHitSetter] == 0;
				}
				if (whoAmI == Main.myPlayer && num2 > 0f && flag3 && !Main.npc[i].dontTakeDamage)
				{
					int num5 = (int)((float)num4 * num2);
					if (num5 > 1000)
					{
						num5 = 1000;
					}
					ApplyDamageToNPC(Main.npc[i], num5, knockback, -num3);
				}
				if (whoAmI == Main.myPlayer && cactusThorns && flag3 && !Main.npc[i].dontTakeDamage)
				{
					int damage = 15;
					if (Main.masterMode)
					{
						damage = 45;
					}
					else if (Main.expertMode)
					{
						damage = 30;
					}
					ApplyDamageToNPC(Main.npc[i], damage, knockback, -num3);
				}
				if (flag && Hurt(dodgeable: Main.npc[i].IsDamageDodgeable(), damageSource: PlayerDeathReason.ByNPC(i), Damage: num4, hitDirection: num3, pvp: false, quiet: false, Crit: false, cooldownCounter: specialHitSetter) > 0.0 && !dead && !flag2)
				{
					StatusFromNPC(Main.npc[i]);
				}
				if (num6)
				{
					GiveImmuneTimeForCollisionAttack(longInvince ? 60 : 30);
					AddBuff(198, 300, quiet: false);
				}
			}
			NPC obj2 = Main.npc[i];
			obj2.position -= Main.npc[i].netOffset;
		}
	}

	public bool CanParryAgainst(Rectangle blockingPlayerRect, Rectangle enemyRect, Vector2 enemyVelocity)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (shieldParryTimeLeft > 0 && Math.Sign(((Rectangle)(ref enemyRect)).Center.X - ((Rectangle)(ref blockingPlayerRect)).Center.X) == direction && enemyVelocity != Vector2.Zero)
		{
			return !immune;
		}
		return false;
	}

	private void PurgeDD2EnergyCrystals()
	{
		if (trashItem.type == 3822)
		{
			trashItem.TurnToAir();
		}
		if (Main.myPlayer == whoAmI && Main.mouseItem.type == 3822)
		{
			Main.mouseItem.TurnToAir();
		}
		for (int i = 0; i < 59; i++)
		{
			Item item = inventory[i];
			if (item.stack > 0 && item.type == 3822)
			{
				item.TurnToAir();
			}
		}
		if (this.chest == -2)
		{
			Chest chest = bank;
			for (int j = 0; j < 40; j++)
			{
				if (chest.item[j].stack > 0 && chest.item[j].type == 3822)
				{
					chest.item[j].TurnToAir();
				}
			}
		}
		if (this.chest == -4)
		{
			Chest chest2 = bank3;
			for (int k = 0; k < 40; k++)
			{
				if (chest2.item[k].stack > 0 && chest2.item[k].type == 3822)
				{
					chest2.item[k].TurnToAir();
				}
			}
		}
		if (this.chest == -5)
		{
			Chest chest3 = bank4;
			for (int l = 0; l < 40; l++)
			{
				if (chest3.item[l].stack > 0 && chest3.item[l].type == 3822)
				{
					chest3.item[l].TurnToAir();
				}
			}
		}
		if (this.chest == -3)
		{
			Chest chest4 = bank2;
			for (int m = 0; m < 40; m++)
			{
				if (chest4.item[m].stack > 0 && chest4.item[m].type == 3822)
				{
					chest4.item[m].TurnToAir();
				}
			}
		}
		if (this.chest <= -1)
		{
			return;
		}
		Chest chest5 = Main.chest[this.chest];
		for (int n = 0; n < 40; n++)
		{
			if (chest5.item[n].stack > 0 && chest5.item[n].type == 3822)
			{
				chest5.item[n].TurnToAir();
				if (Main.netMode == 1)
				{
					NetMessage.SendData(32, -1, -1, null, this.chest, n);
				}
			}
		}
	}

	public void ItemCheck_ManageRightClickFeatures()
	{
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		bool flag = selectedItem != 58 && controlUseTile && Main.myPlayer == whoAmI && !tileInteractionHappened && releaseUseItem && !controlUseItem && !mouseInterface && !CaptureManager.Instance.Active && !Main.HoveringOverAnNPC && !Main.SmartInteractShowingGenuine;
		bool flag2 = flag;
		if (!ItemID.Sets.ItemsThatAllowRepeatedRightClick[inventory[selectedItem].type] && !Main.mouseRightRelease)
		{
			flag2 = false;
		}
		if (flag2 && altFunctionUse == 0)
		{
			for (int i = 0; i < _projectilesToInteractWith.Count; i++)
			{
				Projectile projectile = Main.projectile[_projectilesToInteractWith[i]];
				Rectangle hitbox = projectile.Hitbox;
				if (((Rectangle)(ref hitbox)).Contains(Main.MouseWorld.ToPoint()) || Main.SmartInteractProj == projectile.whoAmI)
				{
					flag = false;
					flag2 = false;
					break;
				}
			}
		}
		if (flag2 && altFunctionUse == 0 && itemTime == 0 && itemAnimation == 0)
		{
			int num = -1;
			int type = 7;
			switch (inventory[selectedItem].type)
			{
			case 5324:
				num = 5329;
				type = 22;
				break;
			case 5329:
				num = 5330;
				type = 22;
				break;
			case 5330:
				num = 5324;
				type = 22;
				break;
			case 4346:
				num = 5391;
				type = 22;
				break;
			case 5391:
				num = 4346;
				type = 22;
				break;
			case 5325:
				num = 4131;
				break;
			case 4131:
				num = 5325;
				break;
			case 5323:
				num = 5455;
				break;
			case 5455:
				num = 5323;
				break;
			case 4767:
				num = 5453;
				break;
			case 5453:
				num = 4767;
				break;
			case 5309:
				num = 5454;
				break;
			case 5454:
				num = 5309;
				break;
			case 5358:
				num = 5360;
				type = 22;
				break;
			case 5360:
				num = 5361;
				type = 22;
				break;
			case 5361:
				num = 5359;
				type = 22;
				break;
			case 5359:
				num = 5358;
				type = 22;
				break;
			case 5437:
				num = 5358;
				type = 22;
				break;
			}
			if (num != -1)
			{
				releaseUseTile = false;
				Main.mouseRightRelease = false;
				SoundEngine.PlaySound(type);
				inventory[selectedItem].ChangeItemType(num);
				Recipe.FindRecipes();
			}
		}
		if (flag2 && altFunctionUse == 0 && inventory[selectedItem].type == 3384)
		{
			altFunctionUse = 1;
			controlUseItem = true;
		}
		if (flag2 && altFunctionUse == 0 && inventory[selectedItem].type == 3858)
		{
			altFunctionUse = 1;
			controlUseItem = true;
		}
		if (flag2 && altFunctionUse == 0 && inventory[selectedItem].type == 4673)
		{
			altFunctionUse = 1;
			controlUseItem = true;
		}
		if (flag2 && altFunctionUse == 0 && inventory[selectedItem].type == 3852 && itemAnimation == 0)
		{
			altFunctionUse = 1;
			controlUseItem = true;
		}
		if (flag2 && altFunctionUse == 0 && inventory[selectedItem].shoot > 0 && ProjectileID.Sets.TurretFeature[inventory[selectedItem].shoot])
		{
			altFunctionUse = 1;
			controlUseItem = true;
		}
		if (flag2 && altFunctionUse == 0 && inventory[selectedItem].shoot > 0 && ProjectileID.Sets.MinionTargettingFeature[inventory[selectedItem].shoot])
		{
			altFunctionUse = 1;
			controlUseItem = true;
		}
		if (flag2 && altFunctionUse == 0 && ItemLoader.AltFunctionUse(inventory[selectedItem], this))
		{
			altFunctionUse = 1;
			controlUseItem = true;
		}
		if (!controlUseItem && altFunctionUse == 1)
		{
			altFunctionUse = 0;
		}
		ItemCheck_ManageRightClickFeatures_ShieldRaise(flag);
	}

	public void ItemCheck_ManageRightClickFeatures_ShieldRaise(bool theGeneralCheck)
	{
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		bool mouseRight = PlayerInput.Triggers.JustPressed.MouseRight;
		if (whoAmI != Main.myPlayer)
		{
			mouseRight = shieldRaised;
			theGeneralCheck = shieldRaised;
		}
		bool shouldGuard = false;
		bool flag = inventory[selectedItem].type == 3823 || inventory[selectedItem].type == 4760;
		if (theGeneralCheck && flag && hasRaisableShield && !mount.Active && (itemAnimation == 0 || mouseRight))
		{
			shouldGuard = true;
		}
		if (shield_parry_cooldown > 0)
		{
			shield_parry_cooldown--;
			if (shield_parry_cooldown == 0)
			{
				SoundEngine.PlaySound(25, base.Center);
				for (int i = 0; i < 10; i++)
				{
					int num = Dust.NewDust(base.Center + new Vector2((float)(direction * 6 + ((direction == -1) ? (-10) : 0)), -14f), 10, 16, 45, 0f, 0f, 255, new Color(255, 100, 0, 127), (float)Main.rand.Next(10, 16) * 0.1f);
					Main.dust[num].noLight = true;
					Main.dust[num].noGravity = true;
					Dust obj = Main.dust[num];
					obj.velocity *= 0.5f;
				}
			}
		}
		if (shieldParryTimeLeft > 0 && ++shieldParryTimeLeft > 20)
		{
			shieldParryTimeLeft = 0;
		}
		TryTogglingShield(shouldGuard);
	}

	public void TryTogglingShield(bool shouldGuard)
	{
		if (shouldGuard == shieldRaised)
		{
			return;
		}
		shieldRaised = shouldGuard;
		if (shieldRaised)
		{
			if (shield_parry_cooldown == 0)
			{
				shieldParryTimeLeft = 1;
			}
			itemAnimation = 0;
			itemTime = 0;
			reuseDelay = 0;
		}
		else
		{
			shield_parry_cooldown = 15;
			shieldParryTimeLeft = 0;
			ApplyAttackCooldown(20);
		}
	}

	private void HandleHotbar()
	{
		int num = PlayerInput.Triggers.Current.HotbarPlus.ToInt() - PlayerInput.Triggers.Current.HotbarMinus.ToInt();
		if (PlayerInput.CurrentProfile.HotbarAllowsRadial && num != 0 && PlayerInput.Triggers.Current.HotbarHoldTime > PlayerInput.CurrentProfile.HotbarRadialHoldTimeRequired && PlayerInput.CurrentProfile.HotbarRadialHoldTimeRequired != -1)
		{
			PlayerInput.MiscSettingsTEMP.HotbarRadialShouldBeUsed = true;
			PlayerInput.Triggers.Current.HotbarScrollCD = 2;
		}
		if (PlayerInput.CurrentProfile.HotbarRadialHoldTimeRequired != -1)
		{
			num = PlayerInput.Triggers.JustReleased.HotbarPlus.ToInt() - PlayerInput.Triggers.JustReleased.HotbarMinus.ToInt();
			if (PlayerInput.Triggers.Current.HotbarScrollCD == 1 && num != 0)
			{
				num = 0;
			}
		}
		if (PlayerInput.Triggers.Current.HotbarScrollCD == 0 && num != 0)
		{
			HotbarOffset += num;
			PlayerInput.Triggers.Current.HotbarScrollCD = 8;
		}
		if (!Main.inFancyUI && !Main.ingameOptionsWindow)
		{
			HotbarOffset += PlayerInput.ScrollWheelDelta / -120;
		}
		ScrollHotbar(HotbarOffset);
		HotbarOffset = 0;
	}

	private void ItemCheckWrapped(int i)
	{
		int num;
		if (!controlLeft && !controlRight && !controlUp && !controlDown && PlayerInput.UsingGamepad && Main.SmartCursorIsUsed)
		{
			num = ((((Vector2)(ref PlayerInput.GamepadThumbstickRight)).Length() < 0.05f) ? 1 : 0);
			if (num != 0)
			{
				ForceForwardCursor(state: true);
			}
		}
		else
		{
			num = 0;
		}
		int num2;
		if (PlayerInput.smartSelectPointer.ShouldBeUsed())
		{
			num2 = ((!Main.SmartCursorIsUsed) ? 1 : 0);
			if (num2 != 0)
			{
				ForceSmartSelectCursor(state: true);
			}
		}
		else
		{
			num2 = 0;
		}
		LockOnHelper.SetUP();
		int stack = inventory[selectedItem].stack;
		if (Main.ignoreErrors)
		{
			ItemCheck();
		}
		else
		{
			ItemCheck();
		}
		if (stack != inventory[selectedItem].stack)
		{
			Recipe.FindRecipes();
		}
		LockOnHelper.SetDOWN();
		if (num2 != 0)
		{
			ForceSmartSelectCursor(state: false);
		}
		if (num != 0)
		{
			ForceForwardCursor(state: false);
		}
		if (itemAnimation == 0)
		{
			lastVisualizedSelectedItem = HeldItem.Clone();
		}
	}

	private void ForceForwardCursor(bool state)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		if (state != _forceForwardCursor)
		{
			_forceForwardCursor = state;
			if (state)
			{
				_inputMouseCoordsForward = new Point(PlayerInput.MouseX, PlayerInput.MouseY);
				_mainMouseCoordsForward = new Point(Main.mouseX, Main.mouseY);
				Point val = (base.Center - Main.screenPosition + new Vector2((float)(direction * 200), 0f)).ToPoint();
				Main.mouseX = (PlayerInput.MouseX = val.X);
				Main.mouseY = (PlayerInput.MouseY = val.Y);
			}
			else
			{
				PlayerInput.MouseX = _inputMouseCoordsForward.X;
				PlayerInput.MouseY = _inputMouseCoordsForward.Y;
				Main.mouseX = _mainMouseCoordsForward.X;
				Main.mouseY = _mainMouseCoordsForward.Y;
			}
		}
	}

	private void ForceSmartSelectCursor(bool state)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		if (state != _forceSmartSelectCursor)
		{
			_forceSmartSelectCursor = state;
			if (state)
			{
				_inputMouseCoordsSmartSelect = new Point(PlayerInput.MouseX, PlayerInput.MouseY);
				_mainMouseCoordsSmartSelect = new Point(Main.mouseX, Main.mouseY);
				_tileTargetSmartSelect = new Point(tileTargetX, tileTargetY);
				Point val = PlayerInput.smartSelectPointer.GetPointerPosition().ToPoint();
				Main.mouseX = (PlayerInput.MouseX = val.X);
				Main.mouseY = (PlayerInput.MouseY = val.Y);
				Point val2 = (val.ToVector2() + Main.screenPosition).ToTileCoordinates();
				tileTargetX = val2.X;
				tileTargetY = val2.Y;
			}
			else
			{
				PlayerInput.MouseX = _inputMouseCoordsSmartSelect.X;
				PlayerInput.MouseY = _inputMouseCoordsSmartSelect.Y;
				Main.mouseX = _mainMouseCoordsSmartSelect.X;
				Main.mouseY = _mainMouseCoordsSmartSelect.Y;
				tileTargetX = _tileTargetSmartSelect.X;
				tileTargetY = _tileTargetSmartSelect.Y;
			}
		}
	}

	public void ScrollHotbar(int Offset)
	{
		if (selectedItem >= 10)
		{
			return;
		}
		Offset = ClampHotbarOffset(Offset);
		selectedItem += Offset;
		if (Offset != 0)
		{
			SoundEngine.PlaySound(12);
			int num = selectedItem - Offset;
			DpadRadial.ChangeSelection(-1);
			CircularRadial.ChangeSelection(-1);
			selectedItem = num + Offset;
			nonTorch = -1;
		}
		if (changeItem >= 0)
		{
			if (selectedItem != changeItem)
			{
				SoundEngine.PlaySound(12);
			}
			selectedItem = changeItem;
			changeItem = -1;
		}
		if (itemAnimation == 0 && selectedItem != 58)
		{
			while (selectedItem > 9)
			{
				selectedItem -= 10;
			}
			while (selectedItem < 0)
			{
				selectedItem += 10;
			}
		}
	}

	private static int ClampHotbarOffset(int Offset)
	{
		while (Offset > 9)
		{
			Offset -= 10;
		}
		while (Offset < 0)
		{
			Offset += 10;
		}
		return Offset;
	}

	public List<int> GetListOfProjectilesToInteractWithHack()
	{
		return _projectilesToInteractWith;
	}

	public void LockGamepadTileInteractions()
	{
		releaseUseTile = false;
		_lockTileInteractionsTimer = 3;
		PlayerInput.LockGamepadTileUseButton = true;
	}

	public void LookForTileInteractions()
	{
		if (Main.netMode == 2 || Main.myPlayer != whoAmI || Main.mapFullscreen || Main.InGameUI.CurrentState == Main.BestiaryUI)
		{
			return;
		}
		int smartInteractX = tileTargetX;
		int smartInteractY = tileTargetY;
		if (Main.SmartInteractShowingGenuine && Main.SmartInteractNPC == -1 && Main.SmartInteractProj == -1)
		{
			smartInteractX = Main.SmartInteractX;
			smartInteractY = Main.SmartInteractY;
		}
		bool flag = controlUseTile;
		if (PlayerInput.UsingGamepad && Main.HoveringOverAnNPC)
		{
			flag = false;
		}
		if (Main.gamePaused)
		{
			flag = false;
		}
		if (releaseUseTile)
		{
			tileInteractionHappened = false;
		}
		tileInteractAttempted = flag;
		if (tileInteractAttempted && releaseUseTile)
		{
			if (Main.instance.currentNPCShowingChatBubble > -1 && (talkNPC == -1 || !Main.npcChatRelease))
			{
				tileInteractAttempted = true;
				releaseUseTile = false;
			}
			if (Main.HasInteractibleObjectThatIsNotATile)
			{
				tileInteractAttempted = true;
				releaseUseTile = false;
			}
		}
		if (IsInTileInteractionRange(smartInteractX, smartInteractY, TileReachCheckSettings.Simple))
		{
			TileInteractionsCheckLongDistance(tileTargetX, tileTargetY);
			TileInteractionsCheck(smartInteractX, smartInteractY);
		}
		else
		{
			TileInteractionsCheckLongDistance(smartInteractX, smartInteractY);
		}
		TryInteractingWithMinecartTrackInNearbyArea(smartInteractX, smartInteractY);
	}

	private void TryInteractingWithMinecartTrackInNearbyArea(int selectedTargetX, int selectedTargetY)
	{
		if ((mount.Active && MountID.Sets.Cart[mount.Type]) || !botherWithUnaimedMinecartTracks || tileInteractionHappened || Main.SmartInteractShowingGenuine || Main.SmartInteractNPC != -1 || Main.SmartInteractProj != -1 || !WorldGen.InWorld(selectedTargetX, selectedTargetY, 10) || gravDir != 1f)
		{
			return;
		}
		int num = 2;
		for (int i = selectedTargetX - num; i <= selectedTargetX + num; i++)
		{
			for (int j = selectedTargetY - num; j <= selectedTargetY + num; j++)
			{
				if (!IsInTileInteractionRange(i, j, TileReachCheckSettings.Simple))
				{
					continue;
				}
				Tile tile = Main.tile[i, j];
				if (tile == null)
				{
					continue;
				}
				if (tile.active() && tile.type == 314)
				{
					if (!cursorItemIconEnabled)
					{
						noThrow = 2;
						cursorItemIconEnabled = true;
						cursorItemIconID = 2343;
					}
					if (tileInteractAttempted)
					{
						TileInteractionsCheck(i, j);
					}
				}
				if (tileInteractionHappened)
				{
					return;
				}
			}
		}
	}

	public bool InInteractionRange(int interactX, int interactY, TileReachCheckSettings settings)
	{
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		int num = (int)(((double)position.X + (double)width * 0.5) / 16.0);
		int num2 = (int)(((double)position.Y + (double)height * 0.5) / 16.0);
		Tile tile = Main.tile[interactX, interactY];
		settings.GetRanges(this, out var x, out var y);
		if (tile.type == 597)
		{
			if (interactX < num)
			{
				interactX += 2;
			}
			if (interactY < num2)
			{
				interactY += 3;
			}
			Point point = position.ToTileCoordinates();
			Point point2 = base.BottomRight.ToTileCoordinates();
			if (point2.X >= interactX - x + 1 && point.X <= interactX + x - 1 && point2.Y >= interactY - y + 2)
			{
				return point.Y <= interactY + y - 1;
			}
			return false;
		}
		if (tile.type == 475)
		{
			if (num >= interactX - x - 1 && num <= interactX + x + 2 && num2 >= interactY - y - 1)
			{
				return num2 <= interactY + y + 2;
			}
			return false;
		}
		if (tile.type == 470)
		{
			if (num >= interactX - x - 1 && num <= interactX + x + 1 && num2 >= interactY - y - 1)
			{
				return num2 <= interactY + y + 2;
			}
			return false;
		}
		if (num >= interactX - x && num <= interactX + x + 1 && num2 >= interactY - y)
		{
			return num2 <= interactY + y + 1;
		}
		return false;
	}

	public bool IsInTileInteractionRange(int targetX, int targetY, TileReachCheckSettings settings)
	{
		settings.GetRanges(this, out var x, out var y);
		if (position.X / 16f - (float)x <= (float)targetX && (position.X + (float)width) / 16f + (float)x - 1f >= (float)targetX && position.Y / 16f - (float)y <= (float)targetY)
		{
			return (position.Y + (float)height) / 16f + (float)y - 2f >= (float)targetY;
		}
		return false;
	}

	public void TileInteractionsCheck(int myX, int myY)
	{
		if (Main.tile[myX, myY] == null)
		{
			Main.tile[myX, myY] = default(Tile);
		}
		if (Main.tile[myX, myY].active())
		{
			TileInteractionsMouseOver(myX, myY);
			TileInteractionsUse(myX, myY);
		}
	}

	private void TileInteractionsCheckLongDistance(int myX, int myY)
	{
		if (!WorldGen.InWorld(myX, myY, 10) || Main.tile[myX, myY] == null || !Main.tile[myX, myY].active())
		{
			return;
		}
		if (TileID.Sets.BasicChest[Main.tile[myX, myY].type])
		{
			TileInteractionsMouseOver_Containers(myX, myY);
			if (cursorItemIconText == "")
			{
				cursorItemIconEnabled = false;
				cursorItemIconID = 0;
			}
		}
		if (Main.tile[myX, myY].type == 88)
		{
			Tile tile = Main.tile[myX, myY];
			int num = myY;
			int x = myX - tile.frameX % 54 / 18;
			if (tile.frameY % 36 != 0)
			{
				num--;
			}
			int num2 = Chest.FindChest(x, num);
			cursorItemIconID = -1;
			if (num2 < 0)
			{
				cursorItemIconText = Lang.dresserType[0].Value;
			}
			else
			{
				if (Main.chest[num2].name != "")
				{
					cursorItemIconText = Main.chest[num2].name;
				}
				else
				{
					cursorItemIconText = Lang.dresserType[tile.frameX / 54].Value;
				}
				if (cursorItemIconText == Lang.dresserType[tile.frameX / 54].Value)
				{
					cursorItemIconID = Chest.dresserTypeToIcon[tile.frameX / 54];
					cursorItemIconText = "";
				}
			}
			noThrow = 2;
			cursorItemIconEnabled = true;
			if (cursorItemIconText == "")
			{
				cursorItemIconEnabled = false;
				cursorItemIconID = 0;
			}
		}
		if (Main.tileSign[Main.tile[myX, myY].type])
		{
			noThrow = 2;
			int num3 = Main.tile[myX, myY].frameX / 18;
			int num4 = Main.tile[myX, myY].frameY / 18;
			num3 %= 2;
			int num5 = myX - num3;
			int num6 = myY - num4;
			Main.signBubble = true;
			Main.signX = num5 * 16 + 16;
			Main.signY = num6 * 16;
			int num7 = Sign.ReadSign(num5, num6, CreateIfMissing: false);
			if (num7 != -1 && tileTargetX >= num5 && tileTargetY >= num6 && tileTargetX <= num5 + 1 && tileTargetY <= num6 + 1)
			{
				Main.signHover = num7;
				cursorItemIconEnabled = false;
				cursorItemIconID = -1;
			}
		}
		TileLoader.MouseOverFar(myX, myY);
	}

	private void TileInteractionsUse(int myX, int myY)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0738: Unknown result type (might be due to invalid IL or missing references)
		//IL_11bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_1207: Unknown result type (might be due to invalid IL or missing references)
		//IL_1253: Unknown result type (might be due to invalid IL or missing references)
		//IL_129f: Unknown result type (might be due to invalid IL or missing references)
		//IL_12eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_1334: Unknown result type (might be due to invalid IL or missing references)
		//IL_138f: Unknown result type (might be due to invalid IL or missing references)
		//IL_13ea: Unknown result type (might be due to invalid IL or missing references)
		if (WiresUI.Open || ownedProjectileCounts[651] > 0)
		{
			return;
		}
		bool flag = releaseUseTile;
		if (!tileInteractAttempted)
		{
			return;
		}
		bool flag10 = false;
		Tile tile4 = Main.tile[myX, myY];
		if (tile4.type == 212 && snowBallLauncherInteractionCooldown <= 0)
		{
			flag10 = true;
			snowBallLauncherInteractionCooldown = 7;
			SoundEngine.PlaySound(in SoundID.Item11, position);
			tile4 = Main.tile[myX, myY];
			int num = tile4.frameX / 18;
			int num12 = 0;
			while (num >= 3)
			{
				num12++;
				num -= 3;
			}
			num = myX - num;
			tile4 = Main.tile[myX, myY];
			int num23;
			for (num23 = tile4.frameY / 18; num23 >= 3; num23 -= 3)
			{
			}
			num23 = myY - num23;
			float num73 = 12f + (float)Main.rand.Next(450) * 0.01f;
			float num43 = Main.rand.Next(85, 105);
			float num74 = Main.rand.Next(-35, 11);
			int type = 166;
			int damage = 35;
			float knockBack = 3.5f;
			Vector2 vector = default(Vector2);
			((Vector2)(ref vector))._002Ector((float)((num + 2) * 16 - 8), (float)((num23 + 2) * 16 - 8 - 4));
			if (num12 == 0)
			{
				num43 *= -1f;
				vector.X -= 14f;
				vector.X -= 2f;
			}
			else
			{
				vector.X += 14f;
			}
			float num63 = num43;
			float num71 = num74;
			float num72 = (float)Math.Sqrt(num63 * num63 + num71 * num71);
			num72 = num73 / num72;
			num63 *= num72;
			num71 *= num72;
			int num2 = Projectile.NewProjectile(GetProjectileSource_TileInteraction(num, num23), vector.X, vector.Y, num63, num71, type, damage, knockBack, Main.myPlayer, -Main.rand.Next(0, 16));
			Main.projectile[num2].originatedFromActivableTile = true;
		}
		if (flag)
		{
			tile4 = Main.tile[myX, myY];
			if (tile4.type != 132)
			{
				tile4 = Main.tile[myX, myY];
				if (tile4.type != 136)
				{
					tile4 = Main.tile[myX, myY];
					if (tile4.type != 144)
					{
						tile4 = Main.tile[myX, myY];
						if (tile4.type == 597)
						{
							flag10 = true;
							TryOpeningFullscreenMap();
						}
						else
						{
							tile4 = Main.tile[myX, myY];
							if (tile4.type != 441)
							{
								tile4 = Main.tile[myX, myY];
								if (tile4.type != 468)
								{
									tile4 = Main.tile[myX, myY];
									if (tile4.type == 139 || TileLoader.IsModMusicBox(Main.tile[myX, myY]))
									{
										flag10 = true;
										SoundEngine.PlaySound(28, myX * 16, myY * 16, 0);
										WorldGen.SwitchMB(myX, myY);
									}
									else
									{
										tile4 = Main.tile[myX, myY];
										if (tile4.type == 215)
										{
											flag10 = true;
											SoundEngine.PlaySound(28, myX * 16, myY * 16, 0);
											tile4 = Main.tile[myX, myY];
											int num5 = tile4.frameX % 54 / 18;
											tile4 = Main.tile[myX, myY];
											int num6 = tile4.frameY % 36 / 18;
											int num7 = myX - num5;
											int num8 = myY - num6;
											int num9 = 36;
											tile4 = Main.tile[num7, num8];
											if (tile4.frameY >= 36)
											{
												num9 = -36;
											}
											for (int i = num7; i < num7 + 3; i++)
											{
												for (int j = num8; j < num8 + 2; j++)
												{
													tile4 = Main.tile[i, j];
													ref short frameY = ref tile4.frameY;
													tile4 = Main.tile[i, j];
													frameY = (short)(tile4.frameY + num9);
												}
											}
											NetMessage.SendTileSquare(-1, num7, num8, 3, 2);
										}
										else
										{
											tile4 = Main.tile[myX, myY];
											if (tile4.type == 207)
											{
												flag10 = true;
												SoundEngine.PlaySound(28, myX * 16, myY * 16, 0);
												WorldGen.SwitchFountain(myX, myY);
											}
											else
											{
												tile4 = Main.tile[myX, myY];
												if (tile4.type != 410)
												{
													tile4 = Main.tile[myX, myY];
													if (tile4.type != 480)
													{
														tile4 = Main.tile[myX, myY];
														if (tile4.type != 509)
														{
															tile4 = Main.tile[myX, myY];
															if (tile4.type != 657)
															{
																tile4 = Main.tile[myX, myY];
																if (tile4.type != 658)
																{
																	tile4 = Main.tile[myX, myY];
																	if (tile4.type == 455)
																	{
																		flag10 = true;
																		SoundEngine.PlaySound(28, myX * 16, myY * 16, 0);
																		GamepadEnableGrappleCooldown();
																		BirthdayParty.ToggleManualParty();
																	}
																	else
																	{
																		tile4 = Main.tile[myX, myY];
																		if (tile4.type == 216)
																		{
																			flag10 = true;
																			WorldGen.LaunchRocket(myX, myY, fromWiring: false);
																		}
																		else
																		{
																			tile4 = Main.tile[myX, myY];
																			if (tile4.type != 386)
																			{
																				tile4 = Main.tile[myX, myY];
																				if (tile4.type != 387)
																				{
																					tile4 = Main.tile[myX, myY];
																					if (tile4.type != 388)
																					{
																						tile4 = Main.tile[myX, myY];
																						if (tile4.type != 389)
																						{
																							tile4 = Main.tile[myX, myY];
																							if (tile4.type != 15)
																							{
																								tile4 = Main.tile[myX, myY];
																								if (tile4.type != 497)
																								{
																									tile4 = Main.tile[myX, myY];
																									if (tile4.type != 89)
																									{
																										tile4 = Main.tile[myX, myY];
																										if (tile4.type != 102)
																										{
																											tile4 = Main.tile[myX, myY];
																											if (tile4.type != 487)
																											{
																												tile4 = Main.tile[myX, myY];
																												if (tile4.type == 335)
																												{
																													flag10 = true;
																													WorldGen.LaunchRocketSmall(myX, myY, fromWiring: false);
																												}
																												else
																												{
																													tile4 = Main.tile[myX, myY];
																													if (tile4.type == 411)
																													{
																														tile4 = Main.tile[myX, myY];
																														if (tile4.frameX < 36)
																														{
																															flag10 = true;
																															Wiring.HitSwitch(myX, myY);
																															NetMessage.SendData(59, -1, -1, null, myX, myY);
																															goto IL_295e;
																														}
																													}
																													tile4 = Main.tile[myX, myY];
																													if (tile4.type == 494)
																													{
																														flag10 = true;
																														for (int k = 0; k < 1000; k++)
																														{
																															if (ProjectileID.Sets.IsAGolfBall[Main.projectile[k].type] && Main.projectile[k].owner == whoAmI)
																															{
																																Main.projectile[k].Kill();
																															}
																														}
																														GetPreferredGolfBallToUse(out var projType);
																														Projectile.NewProjectile(GetProjectileSource_TileInteraction(myX, myY), (float)(myX * 16) + 8.5f, myY * 16 + 6, 0f, 0f, projType, 0, 0f, whoAmI, 0f, -1f);
																													}
																													else
																													{
																														tile4 = Main.tile[myX, myY];
																														if (tile4.type == 338)
																														{
																															flag10 = true;
																															int num11 = myY;
																															tile4 = Main.tile[myX, num11];
																															if (tile4.frameY == 18)
																															{
																																num11--;
																															}
																															bool flag13 = false;
																															for (int l = 0; l < 1000; l++)
																															{
																																if (Main.projectile[l].active && Main.projectile[l].aiStyle == 73 && Main.projectile[l].ai[0] == (float)myX && Main.projectile[l].ai[1] == (float)num11)
																																{
																																	flag13 = true;
																																	break;
																																}
																															}
																															if (!flag13)
																															{
																																int num13 = Projectile.NewProjectile(GetProjectileSource_TileInteraction(myX, num11), myX * 16 + 8, num11 * 16 + 2, 0f, 0f, 419 + Main.rand.Next(4), 0, 0f, whoAmI, myX, num11);
																																Main.projectile[num13].originatedFromActivableTile = true;
																															}
																														}
																														else
																														{
																															tile4 = Main.tile[myX, myY];
																															if (tile4.type != 33)
																															{
																																tile4 = Main.tile[myX, myY];
																																if (tile4.type != 49)
																																{
																																	tile4 = Main.tile[myX, myY];
																																	if (tile4.type != 372)
																																	{
																																		tile4 = Main.tile[myX, myY];
																																		if (tile4.type != 174)
																																		{
																																			tile4 = Main.tile[myX, myY];
																																			if (tile4.type != 646)
																																			{
																																				bool[] torch = TileID.Sets.Torch;
																																				tile4 = Main.tile[myX, myY];
																																				if (!torch[tile4.type])
																																				{
																																					tile4 = Main.tile[myX, myY];
																																					if (tile4.type != 13)
																																					{
																																						tile4 = Main.tile[myX, myY];
																																						if (tile4.type == 50)
																																						{
																																							tile4 = Main.tile[myX, myY];
																																							if (tile4.frameX == 90)
																																							{
																																								goto IL_0c62;
																																							}
																																						}
																																						bool[] canDropFromRightClick = TileID.Sets.CanDropFromRightClick;
																																						tile4 = Main.tile[myX, myY];
																																						if (!canDropFromRightClick[tile4.type])
																																						{
																																							tile4 = Main.tile[myX, myY];
																																							if (tile4.type == 466)
																																							{
																																								flag10 = true;
																																								GamepadEnableGrappleCooldown();
																																								int num15 = myY;
																																								Tile tileSafely = Framing.GetTileSafely(myX, myY);
																																								if (tileSafely.frameY == 0)
																																								{
																																									num15 += 3;
																																								}
																																								if (tileSafely.frameY == 18)
																																								{
																																									num15 += 2;
																																								}
																																								if (tileSafely.frameY == 36)
																																								{
																																									num15++;
																																								}
																																								if (DD2Event.Ongoing)
																																								{
																																									DD2Event.RequestToSkipWaitTime(myX, myY);
																																								}
																																								else
																																								{
																																									bool flag14 = !DD2Event.Ongoing && !NPC.AnyNPCs(548) && !Main.pumpkinMoon && !Main.snowMoon;
																																									if (flag14)
																																									{
																																										flag14 = HasItem(3828);
																																									}
																																									if (flag14)
																																									{
																																										flag14 = !DD2Event.WouldFailSpawningHere(myX, num15);
																																										if (!flag14)
																																										{
																																											DD2Event.FailureMessage(-1);
																																										}
																																									}
																																									if (flag14)
																																									{
																																										flag14 = ConsumeItem(3828, reverseOrder: true);
																																									}
																																									if (flag14)
																																									{
																																										DD2Event.SummonCrystal(myX, num15, whoAmI);
																																									}
																																								}
																																							}
																																							else
																																							{
																																								tile4 = Main.tile[myX, myY];
																																								if (tile4.type == 334)
																																								{
																																									flag10 = true;
																																									if (ItemFitsWeaponRack(inventory[selectedItem]))
																																									{
																																										GamepadEnableGrappleCooldown();
																																										PlaceWeapon(myX, myY);
																																									}
																																									else
																																									{
																																										int num16 = myX;
																																										int num17 = myY;
																																										tile4 = Main.tile[myX, myY];
																																										if (tile4.frameY == 0)
																																										{
																																											num17++;
																																										}
																																										tile4 = Main.tile[myX, myY];
																																										if (tile4.frameY == 36)
																																										{
																																											num17--;
																																										}
																																										tile4 = Main.tile[myX, num17];
																																										int frameX = tile4.frameX;
																																										tile4 = Main.tile[myX, num17];
																																										int num18 = tile4.frameX;
																																										int num19 = 0;
																																										while (num18 >= 5000)
																																										{
																																											num18 -= 5000;
																																											num19++;
																																										}
																																										if (num19 != 0)
																																										{
																																											num18 = (num19 - 1) * 18;
																																										}
																																										num18 %= 54;
																																										if (num18 == 18)
																																										{
																																											tile4 = Main.tile[myX - 1, num17];
																																											frameX = tile4.frameX;
																																											num16--;
																																										}
																																										if (num18 == 36)
																																										{
																																											tile4 = Main.tile[myX - 2, num17];
																																											frameX = tile4.frameX;
																																											num16 -= 2;
																																										}
																																										if (frameX >= 5000)
																																										{
																																											GamepadEnableGrappleCooldown();
																																											WorldGen.KillTile(myX, num17, fail: true);
																																											if (Main.netMode == 1)
																																											{
																																												NetMessage.SendData(17, -1, -1, null, 0, myX, num17, 1f);
																																											}
																																										}
																																									}
																																								}
																																								else
																																								{
																																									tile4 = Main.tile[myX, myY];
																																									if (tile4.type == 440)
																																									{
																																										flag10 = true;
																																										tile4 = Main.tile[myX, myY];
																																										int num20 = tile4.frameX / 54;
																																										tile4 = Main.tile[myX, myY];
																																										int num21 = tile4.frameY / 54;
																																										tile4 = Main.tile[myX, myY];
																																										_ = tile4.frameX % 54 / 18;
																																										tile4 = Main.tile[myX, myY];
																																										_ = tile4.frameY % 54 / 18;
																																										int num22 = -1;
																																										switch (num20)
																																										{
																																										case 0:
																																											num22 = 1526;
																																											break;
																																										case 1:
																																											num22 = 1524;
																																											break;
																																										case 2:
																																											num22 = 1525;
																																											break;
																																										case 3:
																																											num22 = 1523;
																																											break;
																																										case 4:
																																											num22 = 1522;
																																											break;
																																										case 5:
																																											num22 = 1527;
																																											break;
																																										case 6:
																																											num22 = 3643;
																																											break;
																																										}
																																										if (num22 != -1)
																																										{
																																											if (num21 == 0 && HasItem(num22) && selectedItem != 58)
																																											{
																																												GamepadEnableGrappleCooldown();
																																												if (Main.netMode != 1)
																																												{
																																													ConsumeItem(num22);
																																													WorldGen.ToggleGemLock(myX, myY, on: true);
																																												}
																																												else
																																												{
																																													ConsumeItem(num22);
																																													NetMessage.SendData(105, -1, -1, null, myX, myY, 1f);
																																												}
																																											}
																																											else if (num21 == 1)
																																											{
																																												GamepadEnableGrappleCooldown();
																																												if (Main.netMode != 1)
																																												{
																																													WorldGen.ToggleGemLock(myX, myY, on: false);
																																												}
																																												else
																																												{
																																													NetMessage.SendData(105, -1, -1, null, myX, myY);
																																												}
																																											}
																																										}
																																									}
																																									else
																																									{
																																										tile4 = Main.tile[myX, myY];
																																										if (tile4.type == 395)
																																										{
																																											flag10 = true;
																																											TEItemFrame.OnPlayerInteraction(this, myX, myY);
																																										}
																																										else
																																										{
																																											tile4 = Main.tile[myX, myY];
																																											if (tile4.type == 520)
																																											{
																																												flag10 = true;
																																												TEFoodPlatter.OnPlayerInteraction(this, myX, myY);
																																											}
																																											else
																																											{
																																												tile4 = Main.tile[myX, myY];
																																												if (tile4.type == 471)
																																												{
																																													flag10 = true;
																																													TEWeaponsRack.OnPlayerInteraction(this, myX, myY);
																																												}
																																												else
																																												{
																																													tile4 = Main.tile[myX, myY];
																																													if (tile4.type == 470)
																																													{
																																														flag10 = true;
																																														TEDisplayDoll.OnPlayerInteraction(this, myX, myY);
																																													}
																																													else
																																													{
																																														tile4 = Main.tile[myX, myY];
																																														if (tile4.type == 475)
																																														{
																																															flag10 = true;
																																															TEHatRack.OnPlayerInteraction(this, myX, myY);
																																														}
																																														else
																																														{
																																															tile4 = Main.tile[myX, myY];
																																															if (tile4.type == 125)
																																															{
																																																flag10 = true;
																																																AddBuff(29, 108000);
																																																SoundEngine.PlaySound(in SoundID.Item4, position);
																																															}
																																															else
																																															{
																																																tile4 = Main.tile[myX, myY];
																																																if (tile4.type == 621)
																																																{
																																																	flag10 = true;
																																																	AddBuff(192, 7200);
																																																	SoundEngine.PlaySound(in SoundID.Item2, position);
																																																}
																																																else
																																																{
																																																	tile4 = Main.tile[myX, myY];
																																																	if (tile4.type == 464)
																																																	{
																																																		flag10 = true;
																																																		AddBuff(348, 108000);
																																																		SoundEngine.PlaySound(in SoundID.Item4, position);
																																																	}
																																																	else
																																																	{
																																																		tile4 = Main.tile[myX, myY];
																																																		if (tile4.type == 377)
																																																		{
																																																			flag10 = true;
																																																			AddBuff(159, 108000);
																																																			SoundEngine.PlaySound(in SoundID.Item37, position);
																																																		}
																																																		else
																																																		{
																																																			tile4 = Main.tile[myX, myY];
																																																			if (tile4.type == 354)
																																																			{
																																																				flag10 = true;
																																																				AddBuff(150, 108000);
																																																				SoundEngine.PlaySound(in SoundID.Item4, position);
																																																			}
																																																			else
																																																			{
																																																				tile4 = Main.tile[myX, myY];
																																																				if (tile4.type == 287)
																																																				{
																																																					flag10 = true;
																																																					AddBuff(93, 108000);
																																																					SoundEngine.PlaySound(in SoundID.Item149, position);
																																																				}
																																																				else
																																																				{
																																																					tile4 = Main.tile[myX, myY];
																																																					if (tile4.type == 356)
																																																					{
																																																						flag10 = true;
																																																						if (!Main.fastForwardTimeToDawn && (Main.netMode == 1 || Main.sundialCooldown == 0))
																																																						{
																																																							Main.Sundialing();
																																																							SoundEngine.PlaySound(in SoundID.Item4, position);
																																																						}
																																																					}
																																																					else
																																																					{
																																																						tile4 = Main.tile[myX, myY];
																																																						if (tile4.type == 663)
																																																						{
																																																							flag10 = true;
																																																							if (!Main.fastForwardTimeToDusk && (Main.netMode == 1 || Main.moondialCooldown == 0))
																																																							{
																																																								Main.Moondialing();
																																																								SoundEngine.PlaySound(in SoundID.Item4, position);
																																																							}
																																																						}
																																																						else
																																																						{
																																																							tile4 = Main.tile[myX, myY];
																																																							if (tile4.type == 79)
																																																							{
																																																								flag10 = true;
																																																								int num24 = myX;
																																																								int num25 = myY;
																																																								int num75 = num24;
																																																								tile4 = Main.tile[myX, myY];
																																																								num24 = num75 + tile4.frameX / 18 * -1;
																																																								tile4 = Main.tile[myX, myY];
																																																								if (tile4.frameX >= 72)
																																																								{
																																																									num24 += 4;
																																																									num24++;
																																																								}
																																																								else
																																																								{
																																																									num24 += 2;
																																																								}
																																																								tile4 = Main.tile[myX, myY];
																																																								int num26 = tile4.frameY / 18;
																																																								int num27 = 0;
																																																								while (num26 > 1)
																																																								{
																																																									num26 -= 2;
																																																									num27++;
																																																								}
																																																								num25 -= num26;
																																																								num25 += 2;
																																																								if (!IsHoveringOverABottomSideOfABed(myX, myY))
																																																								{
																																																									if (IsWithinSnappngRangeToTile(myX, myY, 96))
																																																									{
																																																										flag10 = true;
																																																										GamepadEnableGrappleCooldown();
																																																										sleeping.StartSleeping(this, myX, myY);
																																																									}
																																																								}
																																																								else
																																																								{
																																																									FindSpawn();
																																																									if (SpawnX == num24 && SpawnY == num25)
																																																									{
																																																										RemoveSpawn();
																																																										Main.NewText(Language.GetTextValue("Game.SpawnPointRemoved"), byte.MaxValue, 240, 20);
																																																									}
																																																									else if (CheckSpawn(num24, num25))
																																																									{
																																																										ChangeSpawn(num24, num25);
																																																										Main.NewText(Language.GetTextValue("Game.SpawnPointSet"), byte.MaxValue, 240, 20);
																																																									}
																																																								}
																																																							}
																																																							else
																																																							{
																																																								bool[] tileSign = Main.tileSign;
																																																								tile4 = Main.tile[myX, myY];
																																																								if (tileSign[tile4.type])
																																																								{
																																																									flag10 = true;
																																																									bool flag15 = true;
																																																									if (sign >= 0 && Sign.ReadSign(myX, myY, CreateIfMissing: false) == sign)
																																																									{
																																																										sign = -1;
																																																										Main.npcChatText = "";
																																																										Main.editSign = false;
																																																										SoundEngine.PlaySound(11);
																																																										flag15 = false;
																																																									}
																																																									if (flag15)
																																																									{
																																																										if (Main.netMode == 0)
																																																										{
																																																											SetTalkNPC(-1);
																																																											Main.npcChatCornerItem = 0;
																																																											Main.playerInventory = false;
																																																											Main.editSign = false;
																																																											int num28 = Sign.ReadSign(myX, myY);
																																																											if (num28 < 0)
																																																											{
																																																												return;
																																																											}
																																																											SoundEngine.PlaySound(10);
																																																											sign = num28;
																																																											Main.npcChatText = Main.sign[num28].text;
																																																										}
																																																										else
																																																										{
																																																											tile4 = Main.tile[myX, myY];
																																																											int num29 = tile4.frameX / 18;
																																																											tile4 = Main.tile[myX, myY];
																																																											int num30 = tile4.frameY / 18;
																																																											while (num29 > 1)
																																																											{
																																																												num29 -= 2;
																																																											}
																																																											int num31 = myX - num29;
																																																											int num32 = myY - num30;
																																																											bool[] tileSign2 = Main.tileSign;
																																																											tile4 = Main.tile[num31, num32];
																																																											if (tileSign2[tile4.type])
																																																											{
																																																												NetMessage.SendData(46, -1, -1, null, num31, num32);
																																																											}
																																																										}
																																																									}
																																																								}
																																																								else
																																																								{
																																																									tile4 = Main.tile[myX, myY];
																																																									if (tile4.type == 104)
																																																									{
																																																										flag10 = true;
																																																										string textValue = Language.GetTextValue("GameUI.TimeAtMorning");
																																																										double num33 = Main.time;
																																																										if (!Main.dayTime)
																																																										{
																																																											num33 += 54000.0;
																																																										}
																																																										num33 = num33 / 86400.0 * 24.0;
																																																										double num34 = 7.5;
																																																										num33 = num33 - num34 - 12.0;
																																																										if (num33 < 0.0)
																																																										{
																																																											num33 += 24.0;
																																																										}
																																																										if (num33 >= 12.0)
																																																										{
																																																											textValue = Language.GetTextValue("GameUI.TimePastMorning");
																																																										}
																																																										int num35 = (int)num33;
																																																										double num76 = (int)((num33 - (double)num35) * 60.0);
																																																										string text = string.Concat(num76);
																																																										if (num76 < 10.0)
																																																										{
																																																											text = "0" + text;
																																																										}
																																																										if (num35 > 12)
																																																										{
																																																											num35 -= 12;
																																																										}
																																																										if (num35 == 0)
																																																										{
																																																											num35 = 12;
																																																										}
																																																										Main.NewText(Language.GetTextValue("Game.Time", num35 + ":" + text + " " + textValue), byte.MaxValue, 240, 20);
																																																									}
																																																									else
																																																									{
																																																										tile4 = Main.tile[myX, myY];
																																																										if (tile4.type == 237)
																																																										{
																																																											flag10 = true;
																																																											bool flag16 = false;
																																																											if (!NPC.AnyNPCs(245) && Main.hardMode && NPC.downedPlantBoss)
																																																											{
																																																												for (int m = 0; m < 58; m++)
																																																												{
																																																													if (inventory[m].type == 1293)
																																																													{
																																																														if (ItemLoader.ConsumeItem(inventory[m], this))
																																																														{
																																																															inventory[m].stack--;
																																																														}
																																																														if (inventory[m].stack <= 0)
																																																														{
																																																															inventory[m].SetDefaults();
																																																														}
																																																														flag16 = true;
																																																														break;
																																																													}
																																																												}
																																																											}
																																																											if (flag16)
																																																											{
																																																												SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
																																																												if (Main.netMode != 1)
																																																												{
																																																													NPC.SpawnOnPlayer(whoAmI, 245);
																																																												}
																																																												else
																																																												{
																																																													NetMessage.SendData(61, -1, -1, null, whoAmI, 245f);
																																																												}
																																																											}
																																																										}
																																																										else if (TileLoader.IsClosedDoor(Main.tile[myX, myY]))
																																																										{
																																																											flag10 = true;
																																																											if (WorldGen.IsLockedDoor(myX, myY))
																																																											{
																																																												int num36 = 1141;
																																																												bool flag17 = false;
																																																												for (int n = 0; n < 58; n++)
																																																												{
																																																													if (inventory[n].type == num36 && inventory[n].stack > 0)
																																																													{
																																																														flag17 = true;
																																																														if (ItemLoader.ConsumeItem(inventory[n], this))
																																																														{
																																																															inventory[n].stack--;
																																																														}
																																																														if (inventory[n].stack <= 0)
																																																														{
																																																															inventory[n] = new Item();
																																																														}
																																																														WorldGen.UnlockDoor(myX, myY);
																																																														if (Main.netMode == 1)
																																																														{
																																																															NetMessage.SendData(52, -1, -1, null, whoAmI, 2f, myX, myY);
																																																														}
																																																														break;
																																																													}
																																																												}
																																																												if (!flag17 && useVoidBag())
																																																												{
																																																													for (int num37 = 0; num37 < 40; num37++)
																																																													{
																																																														if (bank4.item[num37].type == num36 && bank4.item[num37].stack > 0)
																																																														{
																																																															bank4.item[num37].stack--;
																																																															if (bank4.item[num37].stack <= 0)
																																																															{
																																																																bank4.item[num37] = new Item();
																																																															}
																																																															WorldGen.UnlockDoor(myX, myY);
																																																															if (Main.netMode == 1)
																																																															{
																																																																NetMessage.SendData(52, -1, -1, null, whoAmI, 2f, myX, myY);
																																																															}
																																																														}
																																																													}
																																																												}
																																																											}
																																																											else
																																																											{
																																																												tile4 = Main.tile[myX, myY];
																																																												int originalClosedDoorType = tile4.type;
																																																												WorldGen.OpenDoor(myX, myY, direction);
																																																												tile4 = Main.tile[myX, myY];
																																																												if (tile4.type != originalClosedDoorType)
																																																												{
																																																													NetMessage.SendData(19, -1, -1, null, 0, myX, myY, direction);
																																																												}
																																																												else
																																																												{
																																																													WorldGen.OpenDoor(myX, myY, -direction);
																																																													tile4 = Main.tile[myX, myY];
																																																													if (tile4.type != originalClosedDoorType)
																																																													{
																																																														NetMessage.SendData(19, -1, -1, null, 0, myX, myY, -direction);
																																																													}
																																																												}
																																																											}
																																																										}
																																																										else if (TileLoader.CloseDoorID(Main.tile[myX, myY]) >= 0)
																																																										{
																																																											flag10 = true;
																																																											if (WorldGen.CloseDoor(myX, myY))
																																																											{
																																																												NetMessage.SendData(19, -1, -1, null, 1, myX, myY, direction);
																																																											}
																																																										}
																																																										else
																																																										{
																																																											tile4 = Main.tile[myX, myY];
																																																											if (tile4.type == 88)
																																																											{
																																																												flag10 = true;
																																																												tile4 = Main.tile[myX, myY];
																																																												int num38 = tile4.frameX / 18;
																																																												num38 %= 3;
																																																												num38 = myX - num38;
																																																												tile4 = Main.tile[myX, myY];
																																																												int num39 = myY - tile4.frameY / 18;
																																																												tile4 = Main.tile[myX, myY];
																																																												if (tile4.frameY == 0)
																																																												{
																																																													Main.CancelClothesWindow(quiet: true);
																																																													Main.mouseRightRelease = false;
																																																													CloseSign();
																																																													SetTalkNPC(-1);
																																																													Main.npcChatCornerItem = 0;
																																																													Main.npcChatText = "";
																																																													if (Main.editChest)
																																																													{
																																																														SoundEngine.PlaySound(12);
																																																														Main.editChest = false;
																																																														Main.npcChatText = string.Empty;
																																																													}
																																																													if (editedChestName)
																																																													{
																																																														NetMessage.SendData(33, -1, -1, NetworkText.FromLiteral(Main.chest[chest].name), chest, 1f);
																																																														editedChestName = false;
																																																													}
																																																													if (Main.netMode == 1)
																																																													{
																																																														if (num38 == chestX && num39 == chestY && chest != -1)
																																																														{
																																																															chest = -1;
																																																															Recipe.FindRecipes();
																																																															SoundEngine.PlaySound(11);
																																																														}
																																																														else
																																																														{
																																																															NetMessage.SendData(31, -1, -1, null, num38, num39);
																																																															Main.stackSplit = 600;
																																																														}
																																																													}
																																																													else
																																																													{
																																																														piggyBankProjTracker.Clear();
																																																														voidLensChest.Clear();
																																																														int num40 = Chest.FindChest(num38, num39);
																																																														if (num40 != -1)
																																																														{
																																																															Main.stackSplit = 600;
																																																															if (num40 == chest)
																																																															{
																																																																chest = -1;
																																																																Recipe.FindRecipes();
																																																																SoundEngine.PlaySound(11);
																																																															}
																																																															else if (num40 != chest && chest == -1)
																																																															{
																																																																OpenChest(num38, num39, num40);
																																																																SoundEngine.PlaySound(10);
																																																															}
																																																															else
																																																															{
																																																																OpenChest(num38, num39, num40);
																																																																SoundEngine.PlaySound(12);
																																																															}
																																																															Recipe.FindRecipes();
																																																														}
																																																													}
																																																												}
																																																												else
																																																												{
																																																													Main.playerInventory = false;
																																																													chest = -1;
																																																													Recipe.FindRecipes();
																																																													SetTalkNPC(-1);
																																																													Main.npcChatCornerItem = 0;
																																																													Main.npcChatText = "";
																																																													Main.interactedDresserTopLeftX = num38;
																																																													Main.interactedDresserTopLeftY = num39;
																																																													Main.OpenClothesWindow();
																																																												}
																																																											}
																																																											else
																																																											{
																																																												tile4 = Main.tile[myX, myY];
																																																												if (tile4.type == 209)
																																																												{
																																																													flag10 = true;
																																																													Tile tile2 = Main.tile[myX, myY];
																																																													int num41 = tile2.frameX % 72 / 18;
																																																													int num42 = tile2.frameY % 54 / 18;
																																																													int num44 = myX - num41;
																																																													int num45 = myY - num42;
																																																													int num46 = tile2.frameY / 54;
																																																													int num47 = tile2.frameX / 72;
																																																													int num48 = -1;
																																																													if (num41 == 1 || num41 == 2)
																																																													{
																																																														num48 = num42;
																																																													}
																																																													int num49 = 0;
																																																													if (num41 == 3 || (num41 == 2 && num47 != 3 && num47 != 4))
																																																													{
																																																														num49 = -54;
																																																													}
																																																													if (num41 == 0 || (num41 == 1 && num47 != 3 && num47 != 4))
																																																													{
																																																														num49 = 54;
																																																													}
																																																													if (num46 >= 8 && num49 > 0)
																																																													{
																																																														num49 = 0;
																																																													}
																																																													if (num46 == 0 && num49 < 0)
																																																													{
																																																														num49 = 0;
																																																													}
																																																													bool flag2 = false;
																																																													if (num49 != 0)
																																																													{
																																																														for (int num50 = num44; num50 < num44 + 4; num50++)
																																																														{
																																																															for (int num51 = num45; num51 < num45 + 3; num51++)
																																																															{
																																																																tile4 = Main.tile[num50, num51];
																																																																ref short frameY2 = ref tile4.frameY;
																																																																tile4 = Main.tile[num50, num51];
																																																																frameY2 = (short)(tile4.frameY + num49);
																																																															}
																																																														}
																																																														flag2 = true;
																																																													}
																																																													if ((num47 == 3 || num47 == 4) && (num48 == 1 || num48 == 0))
																																																													{
																																																														num49 = ((num47 == 3) ? 72 : (-72));
																																																														for (int num52 = num44; num52 < num44 + 4; num52++)
																																																														{
																																																															for (int num53 = num45; num53 < num45 + 3; num53++)
																																																															{
																																																																tile4 = Main.tile[num52, num53];
																																																																ref short frameX2 = ref tile4.frameX;
																																																																tile4 = Main.tile[num52, num53];
																																																																frameX2 = (short)(tile4.frameX + num49);
																																																															}
																																																														}
																																																														flag2 = true;
																																																													}
																																																													if (flag2)
																																																													{
																																																														NetMessage.SendTileSquare(-1, num44, num45, 4, 3);
																																																													}
																																																													if (num48 != -1)
																																																													{
																																																														bool flag3 = false;
																																																														if ((num47 == 3 || num47 == 4) && num48 == 2)
																																																														{
																																																															flag3 = true;
																																																														}
																																																														if (flag3)
																																																														{
																																																															WorldGen.ShootFromCannon(num44, num45, num46, num47 + 1, 0, 0f, whoAmI, fromWire: false);
																																																														}
																																																													}
																																																												}
																																																												else
																																																												{
																																																													tile4 = Main.tile[myX, myY];
																																																													if (tile4.type != 510)
																																																													{
																																																														tile4 = Main.tile[myX, myY];
																																																														if (tile4.type != 511)
																																																														{
																																																															bool[] basicChest = TileID.Sets.BasicChest;
																																																															tile4 = Main.tile[myX, myY];
																																																															if (basicChest[tile4.type])
																																																															{
																																																																tile4 = Main.tile[myX, myY];
																																																																if (tile4.type < TileID.Count)
																																																																{
																																																																	goto IL_224c;
																																																																}
																																																															}
																																																															tile4 = Main.tile[myX, myY];
																																																															if (tile4.type != 29)
																																																															{
																																																																tile4 = Main.tile[myX, myY];
																																																																if (tile4.type != 97)
																																																																{
																																																																	tile4 = Main.tile[myX, myY];
																																																																	if (tile4.type != 463)
																																																																	{
																																																																		tile4 = Main.tile[myX, myY];
																																																																		if (tile4.type != 491)
																																																																		{
																																																																			tile4 = Main.tile[myX, myY];
																																																																			if (tile4.type == 314 && gravDir == 1f)
																																																																			{
																																																																				flag10 = true;
																																																																				bool flag9 = true;
																																																																				if (mount.Active)
																																																																				{
																																																																					if (mount.Cart)
																																																																					{
																																																																						flag9 = false;
																																																																					}
																																																																					else
																																																																					{
																																																																						mount.Dismount(this);
																																																																					}
																																																																				}
																																																																				if (flag9)
																																																																				{
																																																																					LaunchMinecartHook(myX, myY);
																																																																				}
																																																																			}
																																																																			goto IL_295e;
																																																																		}
																																																																	}
																																																																}
																																																															}
																																																															goto IL_224c;
																																																														}
																																																													}
																																																													flag10 = true;
																																																													Tile tile3 = Main.tile[myX, myY];
																																																													int num54 = tile3.frameX % 36 / 18;
																																																													int num55 = tile3.frameY % 36 / 18;
																																																													int num56 = myX - num54;
																																																													int num57 = myY - num55;
																																																													int num77 = tile3.frameY / 36;
																																																													_ = tile3.frameX / 36;
																																																													int num58 = 0;
																																																													if (num54 == 0)
																																																													{
																																																														num58 = -36;
																																																													}
																																																													if (num54 == 1)
																																																													{
																																																														num58 = 36;
																																																													}
																																																													if (num77 >= 7 && num58 > 0)
																																																													{
																																																														num58 = -252;
																																																													}
																																																													if (num77 == 0 && num58 < 0)
																																																													{
																																																														num58 = 252;
																																																													}
																																																													bool flag4 = false;
																																																													if (num58 != 0)
																																																													{
																																																														for (int num59 = num56; num59 < num56 + 2; num59++)
																																																														{
																																																															for (int num60 = num57; num60 < num57 + 2; num60++)
																																																															{
																																																																tile4 = Main.tile[num59, num60];
																																																																ref short frameY3 = ref tile4.frameY;
																																																																tile4 = Main.tile[num59, num60];
																																																																frameY3 = (short)(tile4.frameY + num58);
																																																															}
																																																														}
																																																														flag4 = true;
																																																													}
																																																													if (flag4)
																																																													{
																																																														NetMessage.SendTileSquare(-1, num56, num57, 2, 2);
																																																													}
																																																												}
																																																											}
																																																										}
																																																									}
																																																								}
																																																							}
																																																						}
																																																					}
																																																				}
																																																			}
																																																		}
																																																	}
																																																}
																																															}
																																														}
																																													}
																																												}
																																											}
																																										}
																																									}
																																								}
																																							}
																																							goto IL_295e;
																																						}
																																					}
																																				}
																																				goto IL_0c62;
																																			}
																																		}
																																	}
																																}
																															}
																															short num14 = 18;
																															Tile tile = Main.tile[myX, myY];
																															if (tile.frameX > 0)
																															{
																																num14 = -18;
																															}
																															tile.frameX += num14;
																															NetMessage.SendTileSquare(-1, myX, myY);
																															flag10 = true;
																															GamepadEnableGrappleCooldown();
																														}
																													}
																												}
																												goto IL_295e;
																											}
																										}
																									}
																									if (IsWithinSnappngRangeToTile(myX, myY, 40))
																									{
																										flag10 = true;
																										GamepadEnableGrappleCooldown();
																										sitting.SitDown(this, myX, myY);
																									}
																									goto IL_295e;
																								}
																							}
																							if (IsWithinSnappngRangeToTile(myX, myY, 40))
																							{
																								flag10 = true;
																								GamepadEnableGrappleCooldown();
																								sitting.SitDown(this, myX, myY);
																							}
																							goto IL_295e;
																						}
																					}
																					flag10 = true;
																					tile4 = Main.tile[myX, myY];
																					bool flag12 = tile4.type == 389;
																					if (WorldGen.ShiftTallGate(myX, myY, flag12))
																					{
																						NetMessage.SendData(19, -1, -1, null, 4 + flag12.ToInt(), myX, myY);
																					}
																					goto IL_295e;
																				}
																			}
																			flag10 = true;
																			tile4 = Main.tile[myX, myY];
																			bool flag11 = tile4.type == 387;
																			int num10 = WorldGen.ShiftTrapdoor(myX, myY, (float)(myY * 16) > base.Center.Y).ToInt();
																			if (num10 == 0)
																			{
																				num10 = -WorldGen.ShiftTrapdoor(myX, myY, (float)(myY * 16) <= base.Center.Y).ToInt();
																			}
																			if (num10 != 0)
																			{
																				NetMessage.SendData(19, -1, -1, null, 2 + (!flag11).ToInt(), myX, myY, num10 * Math.Sign((float)(myY * 16) - base.Center.Y));
																			}
																		}
																	}
																	goto IL_295e;
																}
															}
														}
													}
												}
												flag10 = true;
												SoundEngine.PlaySound(28, myX * 16, myY * 16, 0);
												GamepadEnableGrappleCooldown();
												WorldGen.SwitchMonolith(myX, myY);
											}
										}
									}
									goto IL_295e;
								}
							}
							flag10 = true;
							tile4 = Main.tile[myX, myY];
							int num3;
							for (num3 = tile4.frameX / 18; num3 > 1; num3 -= 2)
							{
							}
							num3 = myX - num3;
							tile4 = Main.tile[myX, myY];
							int num4 = myY - tile4.frameY / 18;
							tile4 = Main.tile[myX, myY];
							Animation.NewTemporaryAnimation(2, tile4.type, num3, num4);
							tile4 = Main.tile[myX, myY];
							NetMessage.SendTemporaryAnimation(-1, 2, tile4.type, num3, num4);
							Wiring.HitSwitch(myX, myY);
							NetMessage.SendData(59, -1, -1, null, myX, myY);
						}
						goto IL_295e;
					}
				}
			}
			flag10 = true;
			Wiring.HitSwitch(myX, myY);
			NetMessage.SendData(59, -1, -1, null, myX, myY);
			goto IL_295e;
		}
		goto IL_2969;
		IL_295e:
		if (TileLoader.RightClick(myX, myY))
		{
			flag10 = true;
		}
		goto IL_2969;
		IL_224c:
		flag10 = true;
		Main.mouseRightRelease = false;
		int num61 = 0;
		tile4 = Main.tile[myX, myY];
		int num62;
		for (num62 = tile4.frameX / 18; num62 > 1; num62 -= 2)
		{
		}
		num62 = myX - num62;
		tile4 = Main.tile[myX, myY];
		int num64 = myY - tile4.frameY / 18;
		tile4 = Main.tile[myX, myY];
		if (tile4.type == 29)
		{
			num61 = 1;
		}
		else
		{
			tile4 = Main.tile[myX, myY];
			if (tile4.type == 97)
			{
				num61 = 2;
			}
			else
			{
				tile4 = Main.tile[myX, myY];
				if (tile4.type == 463)
				{
					num61 = 3;
					tile4 = Main.tile[myX, myY];
					num62 = ((tile4.frameX != 36) ? (num62 + 1) : (num62 - 1));
					num64 += 2;
				}
				else
				{
					tile4 = Main.tile[myX, myY];
					if (tile4.type == 491)
					{
						num61 = 4;
						tile4 = Main.tile[myX, myY];
						num62 = ((tile4.frameX != 36) ? (num62 + 1) : (num62 - 1));
						num64 += 2;
					}
				}
			}
		}
		CloseSign();
		SetTalkNPC(-1);
		Main.npcChatCornerItem = 0;
		Main.npcChatText = "";
		if (Main.editChest)
		{
			SoundEngine.PlaySound(12);
			Main.editChest = false;
			Main.npcChatText = string.Empty;
		}
		if (editedChestName)
		{
			NetMessage.SendData(33, -1, -1, NetworkText.FromLiteral(Main.chest[chest].name), chest, 1f);
			editedChestName = false;
		}
		bool flag5 = Chest.IsLocked(num62, num64);
		if (Main.netMode == 1 && num61 == 0 && !flag5)
		{
			if (num62 == chestX && num64 == chestY && chest != -1)
			{
				chest = -1;
				Recipe.FindRecipes();
				SoundEngine.PlaySound(11);
			}
			else
			{
				if (WorldGen.IsChestRigged(num62, num64))
				{
					_framesLeftEligibleForDeadmansChestDeathAchievement = 600;
				}
				NetMessage.SendData(31, -1, -1, null, num62, num64);
				Main.stackSplit = 600;
			}
		}
		else
		{
			int num65 = -1;
			switch (num61)
			{
			case 1:
				num65 = -2;
				break;
			case 2:
				num65 = -3;
				break;
			case 3:
				num65 = -4;
				break;
			case 4:
				if (disableVoidBag < 0)
				{
					num65 = -5;
				}
				break;
			default:
			{
				bool flag6 = false;
				if (Chest.IsLocked(num62, num64))
				{
					tile4 = Main.tile[num62, num64];
					int type2 = tile4.type;
					int num66 = 327;
					switch (type2)
					{
					case 21:
						tile4 = Main.tile[num62, num64];
						if (tile4.frameX >= 144)
						{
							tile4 = Main.tile[num62, num64];
							if (tile4.frameX <= 178)
							{
								num66 = 329;
							}
						}
						tile4 = Main.tile[num62, num64];
						if (tile4.frameX < 828)
						{
							break;
						}
						tile4 = Main.tile[num62, num64];
						if (tile4.frameX <= 1006)
						{
							tile4 = Main.tile[num62, num64];
							int num67 = tile4.frameX / 18;
							int num68 = 0;
							while (num67 >= 2)
							{
								num67 -= 2;
								num68++;
							}
							num68 -= 23;
							num66 = 1533 + num68;
						}
						break;
					case 467:
						tile4 = Main.tile[num62, num64];
						if (tile4.frameX / 36 == 13)
						{
							num66 = 4714;
						}
						break;
					}
					flag6 = true;
					bool flag7 = false;
					bool flag8 = num66 != 329;
					for (int num69 = 0; num69 < 58; num69++)
					{
						if (inventory[num69].type != num66 || inventory[num69].stack <= 0 || !Chest.Unlock(num62, num64))
						{
							continue;
						}
						flag7 = true;
						if (flag8)
						{
							if (ItemLoader.ConsumeItem(inventory[num69], this))
							{
								inventory[num69].stack--;
							}
							if (inventory[num69].stack <= 0)
							{
								inventory[num69] = new Item();
							}
						}
						if (Main.netMode == 1)
						{
							NetMessage.SendData(52, -1, -1, null, whoAmI, 1f, num62, num64);
						}
					}
					if (!flag7 && useVoidBag())
					{
						for (int num70 = 0; num70 < 40; num70++)
						{
							if (bank4.item[num70].type != num66 || bank4.item[num70].stack <= 0 || !Chest.Unlock(num62, num64))
							{
								continue;
							}
							if (num66 != 329)
							{
								bank4.item[num70].stack--;
								if (bank4.item[num70].stack <= 0)
								{
									bank4.item[num70] = new Item();
								}
							}
							if (Main.netMode == 1)
							{
								NetMessage.SendData(52, -1, -1, null, whoAmI, 1f, num62, num64);
							}
						}
					}
				}
				if (!flag6)
				{
					num65 = Chest.FindChest(num62, num64);
				}
				break;
			}
			}
			if (num65 != -1)
			{
				Main.stackSplit = 600;
				bool num78 = WorldGen.IsChestRigged(num62, num64);
				if (num65 == chest)
				{
					chest = -1;
					SoundEngine.PlaySound(11);
				}
				else if (num65 != chest && chest == -1)
				{
					OpenChest(num62, num64, num65);
					SoundEngine.PlaySound(10);
					tile4 = Main.tile[num62, num64];
					if (tile4.frameX >= 36)
					{
						tile4 = Main.tile[num62, num64];
						if (tile4.frameX < 72)
						{
							AchievementsHelper.HandleSpecialEvent(this, 16);
						}
					}
				}
				else
				{
					OpenChest(num62, num64, num65);
					SoundEngine.PlaySound(12);
				}
				if (num78)
				{
					Wiring.HitSwitch(myX, myY);
					NetMessage.SendData(59, -1, -1, null, myX, myY);
					_framesLeftEligibleForDeadmansChestDeathAchievement = 600;
				}
				Recipe.FindRecipes();
			}
		}
		goto IL_295e;
		IL_2969:
		if (flag10)
		{
			tileInteractionHappened = true;
		}
		return;
		IL_0c62:
		WorldGen.KillTile(myX, myY);
		if (Main.netMode == 1)
		{
			NetMessage.SendData(17, -1, -1, null, 0, myX, myY);
		}
		flag10 = true;
		GamepadEnableGrappleCooldown();
		goto IL_295e;
	}

	public static bool IsHoveringOverABottomSideOfABed(int myX, int myY)
	{
		short frameX = Main.tile[myX, myY].frameX;
		bool flag = frameX / 72 == 1;
		bool flag2 = frameX % 72 < 36;
		if (flag)
		{
			flag2 = !flag2;
		}
		return flag2;
	}

	public void PetAnimal(int animalNpcIndex)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		GetPettingInfo(animalNpcIndex, out var targetDirection, out var playerPositionWhenPetting, out var isPetSmall);
		playerPositionWhenPetting = playerPositionWhenPetting.Floor();
		Vector2 offset = playerPositionWhenPetting - base.Bottom;
		bool flag = CanSnapToPosition(offset);
		if (flag && !WorldGen.SolidTileAllowBottomSlope((int)playerPositionWhenPetting.X / 16, (int)playerPositionWhenPetting.Y / 16))
		{
			flag = false;
		}
		if (!flag)
		{
			return;
		}
		if (isPettingAnimal && base.Bottom == playerPositionWhenPetting)
		{
			StopPettingAnimal();
			return;
		}
		StopVanityActions();
		RemoveAllGrapplingHooks();
		if (mount.Active)
		{
			mount.Dismount(this);
		}
		base.Bottom = playerPositionWhenPetting;
		ChangeDir(targetDirection);
		isPettingAnimal = true;
		isTheAnimalBeingPetSmall = isPetSmall;
		velocity = Vector2.Zero;
		gravDir = 1f;
		if (whoAmI == Main.myPlayer)
		{
			AchievementsHelper.HandleSpecialEvent(this, 21);
		}
	}

	private void GetPettingInfo(int animalNpcIndex, out int targetDirection, out Vector2 playerPositionWhenPetting, out bool isPetSmall)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		NPC nPC = Main.npc[animalNpcIndex];
		targetDirection = ((nPC.Center.X > base.Center.X) ? 1 : (-1));
		int num = 36;
		isPetSmall = false;
		switch (nPC.type)
		{
		case 637:
			isPetSmall = true;
			num = 28;
			break;
		case 656:
			isPetSmall = true;
			num = 24;
			break;
		case 670:
		case 678:
		case 679:
		case 680:
		case 681:
		case 683:
			isPetSmall = true;
			num = 26;
			break;
		case 682:
			isPetSmall = true;
			num = 22;
			break;
		case 684:
			isPetSmall = true;
			num = 20;
			break;
		}
		playerPositionWhenPetting = nPC.Bottom + new Vector2((float)(-targetDirection * num), 0f);
	}

	public bool CanSnapToPosition(Vector2 offset)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		if (Collision.SolidCollision(position + offset, width, height))
		{
			return false;
		}
		bool canSnapToPosition = Collision.CanHit(position, width, height, position + offset, width, height);
		if (!canSnapToPosition)
		{
			TryAllowingSnappingToPosition(ref canSnapToPosition, position, position + offset);
			if (!canSnapToPosition)
			{
				int num = Math.Sign(offset.X);
				if (num != 0)
				{
					Vector2 vector = default(Vector2);
					((Vector2)(ref vector))._002Ector((float)(num * width), 0f);
					if (Collision.TileCollision(position, vector, width, height, fallThrough: true, fall2: true, (int)gravDir) == vector)
					{
						TryAllowingSnappingToPosition(ref canSnapToPosition, position + vector, position + offset);
					}
				}
			}
		}
		return canSnapToPosition;
	}

	private void TryAllowingSnappingToPosition(ref bool canSnapToPosition, Vector2 pos1, Vector2 pos2)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		Vector2 vector = default(Vector2);
		((Vector2)(ref vector))._002Ector((float)(width - 2), 0f);
		canSnapToPosition = Collision.CanHit(pos1 + vector, 2, height, pos2, 2, height);
		if (!canSnapToPosition)
		{
			canSnapToPosition = Collision.CanHit(pos1 + vector, 2, height, pos2 + vector, 2, height);
		}
		if (!canSnapToPosition)
		{
			canSnapToPosition = Collision.CanHit(pos1, 2, height, pos2, 2, height);
		}
		if (!canSnapToPosition)
		{
			canSnapToPosition = Collision.CanHit(pos1, 2, height, pos2 + vector, 2, height);
		}
	}

	public void StopVanityActions(bool multiplayerBroadcast = true)
	{
		StopPettingAnimal();
		sitting.SitUp(this, multiplayerBroadcast);
		sleeping.StopSleeping(this, multiplayerBroadcast);
	}

	private void StopPettingAnimal()
	{
		isPettingAnimal = false;
		isTheAnimalBeingPetSmall = false;
	}

	private void UpdatePettingAnimal()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		if (!isPettingAnimal)
		{
			return;
		}
		if (talkNPC == -1)
		{
			StopPettingAnimal();
			return;
		}
		int num = Math.Sign(Main.npc[talkNPC].Center.X - base.Center.X);
		if (controlLeft || controlRight || controlUp || controlDown || controlJump || pulley || mount.Active || num != direction)
		{
			StopPettingAnimal();
			return;
		}
		GetPettingInfo(talkNPC, out var _, out var playerPositionWhenPetting, out var _);
		if (base.Bottom.Distance(playerPositionWhenPetting) > 2f)
		{
			StopPettingAnimal();
		}
	}

	/// <summary>
	/// Handles boilerplate for gamepad and UI when opening or closing a container.
	/// <br />Sets <see cref="F:Terraria.Player.chestX" />, and <see cref="F:Terraria.Player.chestY" />, and <see cref="F:Terraria.Player.chest" /> to the given coordinates.
	/// </summary>
	/// <param name="x">The top-left X coordinate of the container.</param>
	/// <param name="y">The top-left Y coordinate of the container.</param>
	/// <param name="newChest">The container index in <see cref="F:Terraria.Main.chest" /> if opening, or -1 if closing.</param>
	public void OpenChest(int x, int y, int newChest)
	{
		if (chest != -1 && Main.myPlayer == whoAmI)
		{
			for (int i = 0; i < 40; i++)
			{
				ItemSlot.SetGlow(i, -1f, chest: true);
			}
		}
		chest = newChest;
		Main.playerInventory = true;
		UILinkPointNavigator.ForceMovementCooldown(120);
		if (PlayerInput.GrappleAndInteractAreShared)
		{
			PlayerInput.Triggers.JustPressed.Grapple = false;
		}
		Main.recBigList = false;
		chestX = x;
		chestY = y;
	}

	public void CloseSign()
	{
		if (sign > -1)
		{
			SoundEngine.PlaySound(11);
			sign = -1;
			Main.editSign = false;
			Main.npcChatText = string.Empty;
		}
	}

	private void LaunchMinecartHook(int myX, int myY)
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		Vector2 vector = default(Vector2);
		((Vector2)(ref vector))._002Ector((float)Main.mouseX + Main.screenPosition.X, (float)Main.mouseY + Main.screenPosition.Y);
		((Vector2)(ref vector))._002Ector((float)(myX * 16 + 8), (float)(myY * 16 + 8));
		if (direction > 0)
		{
			minecartLeft = false;
		}
		else
		{
			minecartLeft = true;
		}
		RemoveAllGrapplingHooks();
		Projectile.NewProjectile(GetProjectileSource_TileInteraction(myX, myY), vector.X, vector.Y, 0f, 0f, 403, 0, 0f, whoAmI);
		releaseHook = false;
	}

	public void RemoveAllGrapplingHooks()
	{
		ClearGrapplingBlacklist();
		grappling[0] = -1;
		grapCount = 0;
		for (int i = 0; i < 1000; i++)
		{
			if (Main.projectile[i].active && Main.projectile[i].owner == whoAmI && Main.projectile[i].aiStyle == 7)
			{
				Main.projectile[i].Kill();
			}
		}
	}

	public void RemoveAllFishingBobbers()
	{
		for (int i = 0; i < 1000; i++)
		{
			if (Main.projectile[i].active && Main.projectile[i].owner == whoAmI && Main.projectile[i].bobber)
			{
				Main.projectile[i].Kill();
			}
		}
	}

	private void TileInteractionsMouseOver(int myX, int myY)
	{
		//IL_1432: Unknown result type (might be due to invalid IL or missing references)
		if (myX != tileTargetX || myY != tileTargetY)
		{
			return;
		}
		if (Main.tile[myX, myY].type == 79)
		{
			if (!IsHoveringOverABottomSideOfABed(myX, myY))
			{
				if (IsWithinSnappngRangeToTile(myX, myY, 96))
				{
					noThrow = 2;
					cursorItemIconEnabled = true;
					cursorItemIconID = 5013;
				}
			}
			else
			{
				noThrow = 2;
				cursorItemIconEnabled = true;
				int num = Main.tile[myX, myY].frameY / 36;
				switch (num)
				{
				case 0:
					cursorItemIconID = 224;
					break;
				case 1:
					cursorItemIconID = 644;
					break;
				case 2:
					cursorItemIconID = 645;
					break;
				case 3:
					cursorItemIconID = 646;
					break;
				case 4:
					cursorItemIconID = 920;
					break;
				case 5:
					cursorItemIconID = 1470;
					break;
				case 6:
					cursorItemIconID = 1471;
					break;
				case 7:
					cursorItemIconID = 1472;
					break;
				case 8:
					cursorItemIconID = 1473;
					break;
				case 9:
					cursorItemIconID = 1719;
					break;
				case 10:
					cursorItemIconID = 1720;
					break;
				case 11:
					cursorItemIconID = 1721;
					break;
				case 12:
					cursorItemIconID = 1722;
					break;
				case 13:
				case 14:
				case 15:
				case 16:
				case 17:
				case 18:
					cursorItemIconID = 2066 + num - 13;
					break;
				case 19:
				case 20:
					cursorItemIconID = 2139 + num - 19;
					break;
				default:
					switch (num)
					{
					case 21:
						cursorItemIconID = 2231;
						break;
					case 22:
						cursorItemIconID = 2520;
						break;
					case 23:
						cursorItemIconID = 2538;
						break;
					case 24:
						cursorItemIconID = 2553;
						break;
					case 25:
						cursorItemIconID = 2568;
						break;
					case 26:
						cursorItemIconID = 2669;
						break;
					case 27:
						cursorItemIconID = 2811;
						break;
					case 28:
						cursorItemIconID = 3162;
						break;
					case 29:
						cursorItemIconID = 3164;
						break;
					case 30:
						cursorItemIconID = 3163;
						break;
					case 31:
						cursorItemIconID = 3897;
						break;
					case 32:
						cursorItemIconID = 3932;
						break;
					case 33:
						cursorItemIconID = 3959;
						break;
					case 34:
						cursorItemIconID = 4146;
						break;
					case 35:
						cursorItemIconID = 4167;
						break;
					case 36:
						cursorItemIconID = 4188;
						break;
					case 37:
						cursorItemIconID = 4209;
						break;
					case 38:
						cursorItemIconID = 4299;
						break;
					case 39:
						cursorItemIconID = 4567;
						break;
					case 40:
						cursorItemIconID = 5149;
						break;
					case 41:
						cursorItemIconID = 5170;
						break;
					case 42:
						cursorItemIconID = 5191;
						break;
					default:
						cursorItemIconID = 646;
						break;
					}
					break;
				}
			}
		}
		if (Main.tile[myX, myY].type == 597)
		{
			int pylonStyleFromTile = TETeleportationPylon.GetPylonStyleFromTile(Main.tile[myX, myY]);
			int pylonItemTypeFromTileStyle = TETeleportationPylon.GetPylonItemTypeFromTileStyle(pylonStyleFromTile);
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = pylonItemTypeFromTileStyle;
			if (pylonStyleFromTile == 1)
			{
				cursorItemIconID = 4875;
			}
			if (pylonStyleFromTile == 2)
			{
				cursorItemIconID = 4916;
			}
			if (pylonStyleFromTile == 3)
			{
				cursorItemIconID = 4917;
			}
			if (pylonStyleFromTile == 4)
			{
				cursorItemIconID = 4918;
			}
			if (pylonStyleFromTile == 5)
			{
				cursorItemIconID = 4919;
			}
			if (pylonStyleFromTile == 6)
			{
				cursorItemIconID = 4920;
			}
			if (pylonStyleFromTile == 7)
			{
				cursorItemIconID = 4921;
			}
			if (pylonStyleFromTile == 8)
			{
				cursorItemIconID = 4951;
			}
		}
		if (Main.tile[myX, myY].type == 621)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3750;
		}
		if (Main.tile[myX, myY].type == 464)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3814;
		}
		if (Main.tile[myX, myY].type == 33)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 105;
			int num12 = Main.tile[myX, myY].frameY / 22;
			if (num12 == 1)
			{
				cursorItemIconID = 1405;
			}
			if (num12 == 2)
			{
				cursorItemIconID = 1406;
			}
			if (num12 == 3)
			{
				cursorItemIconID = 1407;
			}
			if (num12 >= 4 && num12 <= 13)
			{
				cursorItemIconID = 2045 + num12 - 4;
			}
			if (num12 >= 14 && num12 <= 16)
			{
				cursorItemIconID = 2153 + num12 - 14;
			}
			if (num12 == 17)
			{
				cursorItemIconID = 2236;
			}
			if (num12 == 18)
			{
				cursorItemIconID = 2523;
			}
			if (num12 == 19)
			{
				cursorItemIconID = 2542;
			}
			if (num12 == 20)
			{
				cursorItemIconID = 2556;
			}
			if (num12 == 21)
			{
				cursorItemIconID = 2571;
			}
			if (num12 == 22)
			{
				cursorItemIconID = 2648;
			}
			if (num12 == 23)
			{
				cursorItemIconID = 2649;
			}
			if (num12 == 24)
			{
				cursorItemIconID = 2650;
			}
			switch (num12)
			{
			case 25:
				cursorItemIconID = 2651;
				break;
			case 26:
				cursorItemIconID = 2818;
				break;
			case 27:
				cursorItemIconID = 3171;
				break;
			case 28:
				cursorItemIconID = 3173;
				break;
			case 29:
				cursorItemIconID = 3172;
				break;
			case 30:
				cursorItemIconID = 3890;
				break;
			case 31:
				cursorItemIconID = 3936;
				break;
			case 32:
				cursorItemIconID = 3962;
				break;
			case 33:
				cursorItemIconID = 4150;
				break;
			case 34:
				cursorItemIconID = 4171;
				break;
			case 35:
				cursorItemIconID = 4192;
				break;
			case 36:
				cursorItemIconID = 4213;
				break;
			case 37:
				cursorItemIconID = 4303;
				break;
			case 38:
				cursorItemIconID = 4571;
				break;
			case 39:
				cursorItemIconID = 5153;
				break;
			case 40:
				cursorItemIconID = 5174;
				break;
			case 41:
				cursorItemIconID = 5195;
				break;
			}
		}
		if (Main.tile[myX, myY].type == 21)
		{
			TileInteractionsMouseOver_Containers(myX, myY);
		}
		if (Main.tile[myX, myY].type == 467)
		{
			TileInteractionsMouseOver_Containers(myX, myY);
		}
		if (Main.tile[myX, myY].type == 441)
		{
			Tile tile = Main.tile[myX, myY];
			int num22 = myX;
			int num33 = myY;
			if (tile.frameX % 36 != 0)
			{
				num22--;
			}
			if (tile.frameY % 36 != 0)
			{
				num33--;
			}
			cursorItemIconID = -1;
			cursorItemIconID = Chest.chestTypeToIcon[tile.frameX / 36];
			noThrow = 2;
			cursorItemIconEnabled = true;
		}
		if (Main.tile[myX, myY].type == 468)
		{
			Tile tile2 = Main.tile[myX, myY];
			int num37 = myX;
			int num38 = myY;
			if (tile2.frameX % 36 != 0)
			{
				num37--;
			}
			if (tile2.frameY % 36 != 0)
			{
				num38--;
			}
			cursorItemIconID = -1;
			cursorItemIconID = Chest.chestTypeToIcon2[tile2.frameX / 36];
			noThrow = 2;
			cursorItemIconEnabled = true;
		}
		if (Main.tile[myX, myY].type == 88)
		{
			Tile tile3 = Main.tile[myX, myY];
			int num39 = myY;
			int x3 = myX - tile3.frameX % 54 / 18;
			if (tile3.frameY % 36 != 0)
			{
				num39--;
			}
			int num40 = Chest.FindChest(x3, num39);
			cursorItemIconID = -1;
			if (num40 < 0)
			{
				cursorItemIconText = Lang.dresserType[0].Value;
			}
			else
			{
				if (Main.chest[num40].name != "")
				{
					cursorItemIconText = Main.chest[num40].name;
				}
				else
				{
					cursorItemIconText = Lang.dresserType[tile3.frameX / 54].Value;
				}
				if (cursorItemIconText == Lang.dresserType[tile3.frameX / 54].Value)
				{
					cursorItemIconID = Chest.dresserTypeToIcon[tile3.frameX / 54];
					cursorItemIconText = "";
				}
			}
			noThrow = 2;
			cursorItemIconEnabled = true;
			if (Main.tile[myX, myY].frameY > 0)
			{
				cursorItemIconID = 269;
				cursorItemIconText = "";
			}
		}
		if (Main.tile[myX, myY].type == 10 || Main.tile[myX, myY].type == 11)
		{
			Tile tile4 = Main.tile[myX, myY];
			noThrow = 2;
			cursorItemIconEnabled = true;
			int num41 = tile4.frameY;
			int num2 = 0;
			while (num41 >= 54)
			{
				num41 -= 54;
				num2++;
			}
			if (tile4.type == 10)
			{
				num2 += 36 * (tile4.frameX / 54);
			}
			if (tile4.type == 11)
			{
				num2 += 36 * (tile4.frameX / 72);
			}
			switch (num2)
			{
			case 0:
				cursorItemIconID = 25;
				break;
			case 9:
				cursorItemIconID = 837;
				break;
			case 10:
				cursorItemIconID = 912;
				break;
			case 11:
				cursorItemIconID = 1141;
				break;
			case 12:
				cursorItemIconID = 1137;
				break;
			case 13:
				cursorItemIconID = 1138;
				break;
			case 14:
				cursorItemIconID = 1139;
				break;
			case 15:
				cursorItemIconID = 1140;
				break;
			case 16:
				cursorItemIconID = 1411;
				break;
			case 17:
				cursorItemIconID = 1412;
				break;
			case 18:
				cursorItemIconID = 1413;
				break;
			case 19:
				cursorItemIconID = 1458;
				break;
			case 20:
			case 21:
			case 22:
			case 23:
				cursorItemIconID = 1709 + num2 - 20;
				break;
			case 24:
				cursorItemIconID = 1793;
				break;
			case 25:
				cursorItemIconID = 1815;
				break;
			case 26:
				cursorItemIconID = 1924;
				break;
			case 27:
				cursorItemIconID = 2044;
				break;
			case 28:
				cursorItemIconID = 2265;
				break;
			case 29:
				cursorItemIconID = 2528;
				break;
			case 30:
				cursorItemIconID = 2561;
				break;
			case 31:
				cursorItemIconID = 2576;
				break;
			case 32:
				cursorItemIconID = 2815;
				break;
			case 33:
				cursorItemIconID = 3129;
				break;
			case 34:
				cursorItemIconID = 3131;
				break;
			case 35:
				cursorItemIconID = 3130;
				break;
			case 36:
				cursorItemIconID = 3888;
				break;
			case 37:
				cursorItemIconID = 3941;
				break;
			case 38:
				cursorItemIconID = 3967;
				break;
			case 39:
				cursorItemIconID = 4155;
				break;
			case 40:
				cursorItemIconID = 4176;
				break;
			case 41:
				cursorItemIconID = 4197;
				break;
			case 42:
				cursorItemIconID = 4218;
				break;
			case 43:
				cursorItemIconID = 4307;
				break;
			case 44:
				cursorItemIconID = 4415;
				break;
			case 45:
				cursorItemIconID = 4576;
				break;
			case 46:
				cursorItemIconID = 5158;
				break;
			case 47:
				cursorItemIconID = 5179;
				break;
			case 48:
				cursorItemIconID = 5200;
				break;
			case 4:
			case 5:
			case 6:
			case 7:
			case 8:
				cursorItemIconID = 812 + num2;
				break;
			default:
				cursorItemIconID = 649 + num2;
				break;
			}
		}
		if (Main.tile[myX, myY].type == 104)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			switch (Main.tile[myX, myY].frameX / 36)
			{
			case 0:
				cursorItemIconID = 359;
				break;
			case 1:
				cursorItemIconID = 2237;
				break;
			case 2:
				cursorItemIconID = 2238;
				break;
			case 3:
				cursorItemIconID = 2239;
				break;
			case 4:
				cursorItemIconID = 2240;
				break;
			case 5:
				cursorItemIconID = 2241;
				break;
			case 6:
				cursorItemIconID = 2560;
				break;
			case 7:
				cursorItemIconID = 2575;
				break;
			case 8:
				cursorItemIconID = 2591;
				break;
			case 9:
				cursorItemIconID = 2592;
				break;
			case 10:
				cursorItemIconID = 2593;
				break;
			case 11:
				cursorItemIconID = 2594;
				break;
			case 12:
				cursorItemIconID = 2595;
				break;
			case 13:
				cursorItemIconID = 2596;
				break;
			case 14:
				cursorItemIconID = 2597;
				break;
			case 15:
				cursorItemIconID = 2598;
				break;
			case 16:
				cursorItemIconID = 2599;
				break;
			case 17:
				cursorItemIconID = 2600;
				break;
			case 18:
				cursorItemIconID = 2601;
				break;
			case 19:
				cursorItemIconID = 2602;
				break;
			case 20:
				cursorItemIconID = 2603;
				break;
			case 21:
				cursorItemIconID = 2604;
				break;
			case 22:
				cursorItemIconID = 2605;
				break;
			case 23:
				cursorItemIconID = 2606;
				break;
			case 24:
				cursorItemIconID = 2809;
				break;
			case 25:
				cursorItemIconID = 3126;
				break;
			case 26:
				cursorItemIconID = 3128;
				break;
			case 27:
				cursorItemIconID = 3127;
				break;
			case 28:
				cursorItemIconID = 3898;
				break;
			case 29:
				cursorItemIconID = 3899;
				break;
			case 30:
				cursorItemIconID = 3900;
				break;
			case 31:
				cursorItemIconID = 3901;
				break;
			case 32:
				cursorItemIconID = 3902;
				break;
			case 33:
				cursorItemIconID = 3940;
				break;
			case 34:
				cursorItemIconID = 3966;
				break;
			case 35:
				cursorItemIconID = 4154;
				break;
			case 36:
				cursorItemIconID = 4175;
				break;
			case 37:
				cursorItemIconID = 4196;
				break;
			case 38:
				cursorItemIconID = 4217;
				break;
			case 39:
				cursorItemIconID = 4306;
				break;
			case 40:
				cursorItemIconID = 4575;
				break;
			case 41:
				cursorItemIconID = 5157;
				break;
			case 42:
				cursorItemIconID = 5178;
				break;
			case 43:
				cursorItemIconID = 5199;
				break;
			}
		}
		if (Main.tile[myX, myY].type == 356)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3064;
		}
		if (Main.tile[myX, myY].type == 663)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 5381;
		}
		if (Main.tile[myX, myY].type == 377)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3198;
		}
		if (Main.tile[myX, myY].type == 209)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			if (Main.tile[myX, myY].frameX < 72)
			{
				cursorItemIconID = 928;
			}
			else if (Main.tile[myX, myY].frameX < 144)
			{
				cursorItemIconID = 1337;
			}
			else if (Main.tile[myX, myY].frameX < 216)
			{
				cursorItemIconID = 3369;
			}
			else if (Main.tile[myX, myY].frameX < 360)
			{
				cursorItemIconID = 3664;
			}
			int num3;
			for (num3 = Main.tile[myX, myY].frameX / 18; num3 >= 4; num3 -= 4)
			{
			}
			if (num3 < 2)
			{
				cursorItemIconReversed = true;
			}
			else
			{
				cursorItemIconReversed = false;
			}
		}
		if (Main.tile[myX, myY].type == 216)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			int num4 = Main.tile[myX, myY].frameY;
			int num5 = 0;
			while (num4 >= 40)
			{
				num4 -= 40;
				num5++;
			}
			cursorItemIconID = 970 + num5;
		}
		if (Main.tile[myX, myY].type == 387 || Main.tile[myX, myY].type == 386)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			int x2 = 0;
			int y = 0;
			WorldGen.GetTopLeftAndStyles(ref x2, ref y, 2, 1 + (Main.tile[myX, myY].type == 386).ToInt(), 18, 18);
			cursorItemIconID = 3239;
		}
		if (Main.tile[myX, myY].type == 389 || Main.tile[myX, myY].type == 388)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3240;
		}
		if (Main.tile[myX, myY].type == 335)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 2700;
		}
		if (Main.tile[myX, myY].type == 15 && IsWithinSnappngRangeToTile(myX, myY, 40))
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = WorldGen.GetItemDrop_Chair(Main.tile[myX, myY].frameY / 40);
			if (Main.tile[myX, myY].frameX / 18 < 1)
			{
				cursorItemIconReversed = true;
			}
		}
		if (Main.tile[myX, myY].type == 102 && IsWithinSnappngRangeToTile(myX, myY, 40))
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 355;
		}
		if (Main.tile[myX, myY].type == 89 && IsWithinSnappngRangeToTile(myX, myY, 40))
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = WorldGen.GetItemDrop_Benches(Main.tile[myX, myY].frameX / 54);
		}
		if (Main.tile[myX, myY].type == 487 && IsWithinSnappngRangeToTile(myX, myY, 40))
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = WorldGen.GetItemDrop_PicnicTables(Main.tile[myX, myY].frameX / 72);
		}
		if (Main.tile[myX, myY].type == 497 && IsWithinSnappngRangeToTile(myX, myY, 40))
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = WorldGen.GetItemDrop_Toilet(Main.tile[myX, myY].frameY / 40);
			if (Main.tile[myX, myY].frameX / 18 < 1)
			{
				cursorItemIconReversed = true;
			}
		}
		if (Main.tile[myX, myY].type == 410)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3536 + Math.Min(Main.tile[myX, myY].frameX / 36, 3);
		}
		if (Main.tile[myX, myY].type == 480)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 4054;
		}
		if (Main.tile[myX, myY].type == 509)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 4318;
		}
		if (Main.tile[myX, myY].type == 657)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 5345;
		}
		if (Main.tile[myX, myY].type == 658)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 5347;
		}
		if (Main.tile[myX, myY].type == 463)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3813;
		}
		if (Main.tile[myX, myY].type == 491)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 4076;
		}
		if (Main.tile[myX, myY].type == 494)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 4089;
		}
		if (Main.tile[myX, myY].type == 411 && Main.tile[myX, myY].frameX < 36)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3545;
		}
		if (Main.tile[myX, myY].type == 338)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 2738;
		}
		if (Main.tile[myX, myY].type == 455)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3747;
		}
		if ((Main.tile[myX, myY].type == 219 || Main.tile[myX, myY].type == 642) && ItemID.Sets.ExtractinatorMode[inventory[selectedItem].type] > -1)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = inventory[selectedItem].type;
		}
		if (Main.tile[myX, myY].type == 212)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 949;
		}
		if (Main.tile[myX, myY].type == 314 && gravDir == 1f)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 2343;
		}
		if (Main.tile[myX, myY].type == 215)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			int num6 = Main.tile[myX, myY].frameX / 54;
			switch (num6)
			{
			case 0:
				cursorItemIconID = 966;
				break;
			case 14:
				cursorItemIconID = 5299;
				break;
			case 15:
				cursorItemIconID = 5357;
				break;
			case 8:
			case 9:
			case 10:
			case 11:
			case 12:
			case 13:
				cursorItemIconID = 4689 + num6 - 8;
				break;
			case 7:
				cursorItemIconID = 3724;
				break;
			case 6:
				cursorItemIconID = 3723;
				break;
			case 5:
				cursorItemIconID = 3050;
				break;
			default:
				cursorItemIconID = 3046 + num6 - 1;
				break;
			}
		}
		if (Main.tile[myX, myY].type == 4)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			int num7 = Main.tile[myX, myY].frameY / 22;
			switch (num7)
			{
			case 0:
				cursorItemIconID = 8;
				break;
			case 8:
				cursorItemIconID = 523;
				break;
			case 9:
				cursorItemIconID = 974;
				break;
			case 10:
				cursorItemIconID = 1245;
				break;
			case 11:
				cursorItemIconID = 1333;
				break;
			case 12:
				cursorItemIconID = 2274;
				break;
			case 13:
				cursorItemIconID = 3004;
				break;
			case 14:
				cursorItemIconID = 3045;
				break;
			case 15:
				cursorItemIconID = 3114;
				break;
			case 16:
				cursorItemIconID = 4383;
				break;
			case 17:
				cursorItemIconID = 4384;
				break;
			case 18:
				cursorItemIconID = 4385;
				break;
			case 19:
				cursorItemIconID = 4386;
				break;
			case 20:
				cursorItemIconID = 4387;
				break;
			case 21:
				cursorItemIconID = 4388;
				break;
			case 22:
				cursorItemIconID = 5293;
				break;
			case 23:
				cursorItemIconID = 5353;
				break;
			default:
				cursorItemIconID = 426 + num7;
				break;
			}
		}
		if (Main.tile[myX, myY].type == 13)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			switch (Main.tile[myX, myY].frameX / 18)
			{
			case 1:
				cursorItemIconID = 28;
				break;
			case 2:
				cursorItemIconID = 110;
				break;
			case 3:
				cursorItemIconID = 350;
				break;
			case 4:
				cursorItemIconID = 351;
				break;
			case 5:
				cursorItemIconID = 2234;
				break;
			case 6:
				cursorItemIconID = 2244;
				break;
			case 7:
				cursorItemIconID = 2257;
				break;
			case 8:
				cursorItemIconID = 2258;
				break;
			default:
				cursorItemIconID = 31;
				break;
			}
		}
		if (Main.tile[myX, myY].type == 29)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 87;
		}
		if (Main.tile[myX, myY].type == 97)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 346;
		}
		if (Main.tile[myX, myY].type == 510)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 4319;
			int num8;
			for (num8 = Main.tile[myX, myY].frameX / 18; num8 >= 2; num8 -= 2)
			{
			}
			if (num8 == 0)
			{
				cursorItemIconReversed = true;
			}
			else
			{
				cursorItemIconReversed = false;
			}
		}
		if (Main.tile[myX, myY].type == 511)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 4320;
			int num9;
			for (num9 = Main.tile[myX, myY].frameX / 18; num9 >= 2; num9 -= 2)
			{
			}
			if (num9 == 0)
			{
				cursorItemIconReversed = true;
			}
			else
			{
				cursorItemIconReversed = false;
			}
		}
		if (Main.tile[myX, myY].type == 49)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 148;
		}
		if (Main.tile[myX, myY].type == 372)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3117;
		}
		if (Main.tile[myX, myY].type == 646)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 5322;
		}
		if (Main.tile[myX, myY].type == 174)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 713;
		}
		if (Main.tile[myX, myY].type == 50)
		{
			noThrow = 2;
			if (Main.tile[myX, myY].frameX == 90)
			{
				cursorItemIconEnabled = true;
				cursorItemIconID = 165;
			}
		}
		if (Main.tile[myX, myY].type == 139)
		{
			noThrow = 2;
			int num10 = 0;
			for (int num11 = Main.tile[myX, myY].frameY / 18; num11 >= 2; num11 -= 2)
			{
				num10++;
			}
			cursorItemIconEnabled = true;
			if (num10 == 28)
			{
				cursorItemIconID = 1963;
			}
			else if (num10 == 29)
			{
				cursorItemIconID = 1964;
			}
			else if (num10 == 30)
			{
				cursorItemIconID = 1965;
			}
			else if (num10 == 31)
			{
				cursorItemIconID = 2742;
			}
			else if (num10 == 32)
			{
				cursorItemIconID = 3044;
			}
			else if (num10 == 33)
			{
				cursorItemIconID = 3235;
			}
			else if (num10 == 34)
			{
				cursorItemIconID = 3236;
			}
			else if (num10 == 35)
			{
				cursorItemIconID = 3237;
			}
			else if (num10 == 36)
			{
				cursorItemIconID = 3370;
			}
			else if (num10 == 37)
			{
				cursorItemIconID = 3371;
			}
			else if (num10 == 38)
			{
				cursorItemIconID = 3796;
			}
			else if (num10 == 39)
			{
				cursorItemIconID = 3869;
			}
			else if (num10 == 40)
			{
				cursorItemIconID = 4082;
			}
			else if (num10 == 41)
			{
				cursorItemIconID = 4078;
			}
			else if (num10 == 42)
			{
				cursorItemIconID = 4079;
			}
			else if (num10 == 43)
			{
				cursorItemIconID = 4077;
			}
			else if (num10 == 44)
			{
				cursorItemIconID = 4080;
			}
			else if (num10 == 45)
			{
				cursorItemIconID = 4081;
			}
			else if (num10 == 46)
			{
				cursorItemIconID = 4237;
			}
			else if (num10 == 47)
			{
				cursorItemIconID = 4356;
			}
			else if (num10 == 48)
			{
				cursorItemIconID = 4357;
			}
			else if (num10 == 49)
			{
				cursorItemIconID = 4358;
			}
			else if (num10 == 50)
			{
				cursorItemIconID = 4421;
			}
			else if (num10 == 51)
			{
				cursorItemIconID = 4606;
			}
			else if (num10 == 52)
			{
				cursorItemIconID = 4979;
			}
			else if (num10 == 53)
			{
				cursorItemIconID = 4985;
			}
			else if (num10 == 54)
			{
				cursorItemIconID = 4990;
			}
			else if (num10 == 55)
			{
				cursorItemIconID = 4991;
			}
			else if (num10 == 56)
			{
				cursorItemIconID = 4992;
			}
			else if (num10 == 57)
			{
				cursorItemIconID = 5006;
			}
			else if (num10 == 58)
			{
				cursorItemIconID = 5014;
			}
			else if (num10 == 59)
			{
				cursorItemIconID = 5015;
			}
			else if (num10 == 60)
			{
				cursorItemIconID = 5016;
			}
			else if (num10 == 61)
			{
				cursorItemIconID = 5017;
			}
			else if (num10 == 62)
			{
				cursorItemIconID = 5018;
			}
			else if (num10 == 63)
			{
				cursorItemIconID = 5019;
			}
			else if (num10 == 64)
			{
				cursorItemIconID = 5020;
			}
			else if (num10 == 65)
			{
				cursorItemIconID = 5021;
			}
			else if (num10 == 66)
			{
				cursorItemIconID = 5022;
			}
			else if (num10 == 67)
			{
				cursorItemIconID = 5023;
			}
			else if (num10 == 68)
			{
				cursorItemIconID = 5024;
			}
			else if (num10 == 69)
			{
				cursorItemIconID = 5025;
			}
			else if (num10 == 70)
			{
				cursorItemIconID = 5026;
			}
			else if (num10 == 71)
			{
				cursorItemIconID = 5027;
			}
			else if (num10 == 72)
			{
				cursorItemIconID = 5028;
			}
			else if (num10 == 73)
			{
				cursorItemIconID = 5029;
			}
			else if (num10 == 74)
			{
				cursorItemIconID = 5030;
			}
			else if (num10 == 75)
			{
				cursorItemIconID = 5031;
			}
			else if (num10 == 76)
			{
				cursorItemIconID = 5032;
			}
			else if (num10 == 77)
			{
				cursorItemIconID = 5033;
			}
			else if (num10 == 78)
			{
				cursorItemIconID = 5034;
			}
			else if (num10 == 79)
			{
				cursorItemIconID = 5035;
			}
			else if (num10 == 80)
			{
				cursorItemIconID = 5036;
			}
			else if (num10 == 81)
			{
				cursorItemIconID = 5037;
			}
			else if (num10 == 82)
			{
				cursorItemIconID = 5038;
			}
			else if (num10 == 83)
			{
				cursorItemIconID = 5039;
			}
			else if (num10 == 84)
			{
				cursorItemIconID = 5040;
			}
			else if (num10 == 85)
			{
				cursorItemIconID = 5044;
			}
			else if (num10 == 86)
			{
				cursorItemIconID = 5112;
			}
			else if (num10 == 87)
			{
				cursorItemIconID = 5362;
			}
			else if (num10 >= 13)
			{
				cursorItemIconID = 1596 + num10 - 13;
			}
			else
			{
				cursorItemIconID = 562 + num10;
			}
		}
		if (Main.tile[myX, myY].type == 207)
		{
			noThrow = 2;
			int num13 = 0;
			for (int num14 = Main.tile[myX, myY].frameX / 18; num14 >= 2; num14 -= 2)
			{
				num13++;
			}
			cursorItemIconEnabled = true;
			switch (num13)
			{
			case 0:
				cursorItemIconID = 909;
				break;
			case 1:
				cursorItemIconID = 910;
				break;
			case 2:
				cursorItemIconID = 940;
				break;
			case 3:
				cursorItemIconID = 941;
				break;
			case 4:
				cursorItemIconID = 942;
				break;
			case 5:
				cursorItemIconID = 943;
				break;
			case 6:
				cursorItemIconID = 944;
				break;
			case 7:
				cursorItemIconID = 945;
				break;
			case 8:
				cursorItemIconID = 4922;
				break;
			case 9:
				cursorItemIconID = 4417;
				break;
			}
		}
		if (Main.tileSign[Main.tile[myX, myY].type])
		{
			noThrow = 2;
			int num15 = Main.tile[myX, myY].frameX / 18;
			int num16 = Main.tile[myX, myY].frameY / 18;
			num15 %= 2;
			int num42 = myX - num15;
			int num17 = myY - num16;
			Main.signBubble = true;
			Main.signX = num42 * 16 + 16;
			Main.signY = num17 * 16;
			int num18 = Sign.ReadSign(num42, num17, CreateIfMissing: false);
			if (num18 != -1)
			{
				Main.signHover = num18;
			}
			if (num18 != -1)
			{
				Main.signHover = num18;
				cursorItemIconEnabled = false;
				cursorItemIconID = -1;
			}
		}
		if (Main.tile[myX, myY].type == 237)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 1293;
		}
		if (Main.tile[myX, myY].type == 466)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3828;
		}
		if (Main.tile[myX, myY].type == 125)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 487;
		}
		if (Main.tile[myX, myY].type == 354)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 2999;
		}
		if (Main.tile[myX, myY].type == 287)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 2177;
		}
		if (Main.tile[myX, myY].type == 132)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 513;
		}
		if (Main.tile[myX, myY].type == 136)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 538;
		}
		if (Main.tile[myX, myY].type == 144)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			int num19 = Main.tile[myX, myY].frameX / 18;
			if (num19 < 3)
			{
				cursorItemIconID = 583 + num19;
			}
			else
			{
				cursorItemIconID = 4484 + (num19 - 3);
			}
		}
		if (Main.tile[myX, myY].type == 440)
		{
			int num20 = Main.tile[myX, myY].frameX / 54;
			int num21 = Main.tile[myX, myY].frameY / 54;
			int num23 = -1;
			switch (num20)
			{
			case 0:
				num23 = 1526;
				break;
			case 1:
				num23 = 1524;
				break;
			case 2:
				num23 = 1525;
				break;
			case 3:
				num23 = 1523;
				break;
			case 4:
				num23 = 1522;
				break;
			case 5:
				num23 = 1527;
				break;
			case 6:
				num23 = 3643;
				break;
			}
			if (num23 != -1 && (num21 == 1 || HasItem(num23)))
			{
				noThrow = 2;
				cursorItemIconEnabled = true;
				cursorItemIconID = num23;
			}
		}
		else if (Main.tile[myX, myY].type == 470)
		{
			noThrow = 2;
			int num24 = Main.tile[myX, myY].frameX % 136 / 34;
			if (num24 < 2)
			{
				cursorItemIconEnabled = true;
				cursorItemIconID = 498;
			}
			else if (num24 < 4)
			{
				cursorItemIconEnabled = true;
				cursorItemIconID = 1989;
			}
		}
		else if (Main.tile[myX, myY].type == 475)
		{
			noThrow = 2;
			cursorItemIconEnabled = true;
			cursorItemIconID = 3977;
		}
		else if (Main.tile[myX, myY].type == 520)
		{
			noThrow = 2;
			int num25 = TEFoodPlatter.Find(myX, myY);
			if (num25 != -1)
			{
				cursorItemIconEnabled = true;
				TEFoodPlatter tEFoodPlatter = (TEFoodPlatter)TileEntity.ByID[num25];
				cursorItemIconID = tEFoodPlatter.item.type;
			}
		}
		else if (Main.tile[myX, myY].type == 395)
		{
			noThrow = 2;
			int num26 = myX;
			int num27 = myY;
			int num28 = Main.tile[myX, myY].frameX;
			int num29 = Main.tile[myX, myY].frameY;
			while (num29 > 0)
			{
				num29 -= 18;
				num27--;
			}
			while (num28 >= 36)
			{
				num28 -= 36;
			}
			while (num28 > 0)
			{
				num28 -= 18;
				num26--;
			}
			int num30 = TEItemFrame.Find(num26, num27);
			if (num30 != -1)
			{
				cursorItemIconEnabled = true;
				TEItemFrame tEItemFrame = (TEItemFrame)TileEntity.ByID[num30];
				cursorItemIconID = tEItemFrame.item.type;
			}
		}
		else if (Main.tile[myX, myY].type == 471)
		{
			noThrow = 2;
			int num31 = myX;
			int num32 = myY;
			int num34 = Main.tile[myX, myY].frameX;
			int num35 = Main.tile[myX, myY].frameY;
			while (num35 > 0)
			{
				num35 -= 18;
				num32--;
			}
			while (num34 >= 54)
			{
				num34 -= 54;
			}
			while (num34 > 0)
			{
				num34 -= 18;
				num31--;
			}
			int num36 = TEWeaponsRack.Find(num31, num32);
			if (num36 != -1)
			{
				cursorItemIconEnabled = true;
				TEWeaponsRack tEWeaponsRack = (TEWeaponsRack)TileEntity.ByID[num36];
				cursorItemIconID = tEWeaponsRack.item.type;
			}
		}
		else if (Main.tile[myX, myY].type == 334)
		{
			noThrow = 2;
		}
		TileLoader.MouseOver(myX, myY);
		if (PlayerInput.UsingGamepad && cursorItemIconText.Length == 0)
		{
			cursorItemIconEnabled = false;
			cursorItemIconID = 0;
		}
	}

	public Color ChatColor()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		return (Color)(difficulty switch
		{
			1 => Main.mcColor, 
			2 => Main.hcColor, 
			_ => Color.White, 
		});
	}

	private void TileInteractionsMouseOver_Containers(int myX, int myY)
	{
		LocalizedText[] array = Lang.chestType;
		int[] array2 = Chest.chestTypeToIcon;
		Tile tile = Main.tile[myX, myY];
		if (tile.type == 467)
		{
			array = Lang.chestType2;
			array2 = Chest.chestTypeToIcon2;
		}
		int num = myX;
		int num2 = myY;
		if (tile.frameX % 36 != 0)
		{
			num--;
		}
		if (tile.frameY % 36 != 0)
		{
			num2--;
		}
		int num3 = Chest.FindChest(num, num2);
		cursorItemIconID = -1;
		if (num3 < 0)
		{
			cursorItemIconText = array[0].Value;
		}
		else
		{
			if (Main.chest[num3].name != "")
			{
				cursorItemIconText = Main.chest[num3].name;
			}
			else
			{
				cursorItemIconText = array[tile.frameX / 36].Value;
			}
			if (cursorItemIconText == array[tile.frameX / 36].Value)
			{
				cursorItemIconID = array2[tile.frameX / 36];
				cursorItemIconText = "";
			}
		}
		if (cursorItemIconID == 3988)
		{
			cursorItemIconID = 306;
		}
		noThrow = 2;
		cursorItemIconEnabled = true;
	}

	private void TryLandingOnDetonator()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		if (whoAmI == Main.myPlayer && velocity.Y >= 3f)
		{
			Point point = (base.Bottom + new Vector2(0f, 0.01f)).ToTileCoordinates();
			Tile tileSafely = Framing.GetTileSafely(point.X, point.Y);
			if (tileSafely.active() && tileSafely.type == 411 && tileSafely.frameY == 0 && tileSafely.frameX < 36)
			{
				Wiring.HitSwitch(point.X, point.Y);
				NetMessage.SendData(59, -1, -1, null, point.X, point.Y);
			}
		}
	}

	private void TryBouncingBlocks(bool Falling)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		bool num7 = !wet && !shimmering && (velocity.Y >= 5f || velocity.Y <= -5f);
		bool flag = false;
		bool flag2 = false;
		float num2 = 1f;
		if (!num7)
		{
			return;
		}
		bool flag3 = false;
		int num3 = 0;
		foreach (Point touchedTile in TouchedTiles)
		{
			Tile tile = Main.tile[touchedTile.X, touchedTile.Y];
			if (tile != null && tile.active() && tile.nactive() && (flag || Main.tileBouncy[tile.type]))
			{
				flag3 = true;
				num3 = touchedTile.Y;
				break;
			}
		}
		if (!flag3)
		{
			return;
		}
		velocity.Y *= -0.8f;
		if (controlJump)
		{
			velocity.Y = MathHelper.Clamp(velocity.Y, -13f, 13f);
		}
		position.Y = num3 * 16 - ((velocity.Y < 0f) ? height : (-16));
		FloorVisuals(Falling);
		if (flag2)
		{
			Vector2 vector = (fullRotation - (float)Math.PI / 2f).ToRotationVector2();
			if (vector.Y > 0f)
			{
				vector.Y *= -1f;
			}
			vector.Y = vector.Y * 0.5f + -0.5f;
			float num4 = 0f - vector.Y;
			if (num4 < 0f)
			{
				num4 = 0f;
			}
			float num5 = num4 * 1.5f + 1f;
			float value = Math.Abs(velocity.Y) * num5 * num2;
			value = MathHelper.Clamp(value, 2f, 16f);
			velocity = vector * value;
			float num6 = 20f;
			Vector2 vector2 = base.Center + (fullRotation + (float)Math.PI / 2f).ToRotationVector2() * num6;
			vector2 = base.Bottom;
			ParticleOrchestrator.RequestParticleSpawn(clientOnly: true, ParticleOrchestraType.Keybrand, new ParticleOrchestraSettings
			{
				PositionInWorld = vector2
			}, whoAmI);
		}
		velocity.Y = MathHelper.Clamp(velocity.Y, -20f, 20f);
		if (velocity.Y * gravDir < 0f)
		{
			fallStart = (int)position.Y / 16;
		}
	}

	public bool CanAcceptItemIntoInventory(Item item)
	{
		if (preventAllItemPickups)
		{
			return ItemID.Sets.IgnoresEncumberingStone[item.type];
		}
		return true;
	}

	private void GrabItems(int i)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		for (int j = 0; j < 400; j++)
		{
			Item item = Main.item[j];
			if (!item.active || item.shimmerTime != 0f || item.noGrabDelay != 0 || item.playerIndexTheItemIsReservedFor != i || !CanAcceptItemIntoInventory(item) || (item.shimmered && !((double)((Vector2)(ref item.velocity)).Length() < 0.2)) || !ItemLoader.CanPickup(item, this))
			{
				continue;
			}
			int itemGrabRange = GetItemGrabRange(item);
			Rectangle hitbox = item.Hitbox;
			Rectangle val = base.Hitbox;
			if (((Rectangle)(ref val)).Intersects(hitbox))
			{
				if (i != Main.myPlayer || (inventory[selectedItem].type == 0 && itemAnimation > 0))
				{
					continue;
				}
				if (!CombinedHooks.OnPickup(Main.item[j], this))
				{
					Main.item[j] = new Item();
					if (Main.netMode == 1)
					{
						NetMessage.SendData(21, -1, -1, null, j);
					}
				}
				else
				{
					item = PickupItem(i, j, item);
				}
				continue;
			}
			val = new Rectangle((int)position.X - itemGrabRange, (int)position.Y - itemGrabRange, width + itemGrabRange * 2, height + itemGrabRange * 2);
			if (!((Rectangle)(ref val)).Intersects(hitbox))
			{
				continue;
			}
			ItemSpaceStatus status = ItemSpace(item);
			if (!CanPullItem(item, status))
			{
				continue;
			}
			item.shimmered = false;
			item.beingGrabbed = true;
			bool flag = false;
			if (difficulty == 3 && CreativePowerManager.Instance.GetPower<CreativePowers.FarPlacementRangePower>().IsEnabledForPlayer(whoAmI))
			{
				flag = true;
			}
			if (!ItemLoader.GrabStyle(item, this))
			{
				if (flag)
				{
					PullItem_Pickup(item, 7f, 1);
				}
				else if (manaMagnet && (item.type == 184 || item.type == 1735 || item.type == 1868))
				{
					PullItem_Pickup(item, 12f, 5);
				}
				else if (lifeMagnet && (item.type == 58 || item.type == 1734 || item.type == 1867))
				{
					PullItem_Pickup(item, 15f, 5);
				}
				else if (ItemID.Sets.NebulaPickup[item.type])
				{
					PullItem_Pickup(item, 12f, 5);
				}
				else if (status.ItemIsGoingToVoidVault)
				{
					PullItem_ToVoidVault(item);
				}
				else if (goldRing && item.IsACoin)
				{
					PullItem_Pickup(item, 12f, 5);
				}
				else
				{
					PullItem_Common(item, 0.75f);
				}
			}
		}
	}

	private void PullItem_ToVoidVault(Item itemToPickUp)
	{
		PullItem_Pickup(itemToPickUp, 12f, 5);
	}

	private void PullItem_Common(Item itemToPickUp, float xPullSpeed)
	{
		if ((double)position.X + (double)width * 0.5 > (double)itemToPickUp.position.X + (double)itemToPickUp.width * 0.5)
		{
			if (itemToPickUp.velocity.X < itemGrabSpeedMax + velocity.X)
			{
				itemToPickUp.velocity.X += itemGrabSpeed;
			}
			if (itemToPickUp.velocity.X < 0f)
			{
				itemToPickUp.velocity.X += itemGrabSpeed * xPullSpeed;
			}
		}
		else
		{
			if (itemToPickUp.velocity.X > 0f - itemGrabSpeedMax + velocity.X)
			{
				itemToPickUp.velocity.X -= itemGrabSpeed;
			}
			if (itemToPickUp.velocity.X > 0f)
			{
				itemToPickUp.velocity.X -= itemGrabSpeed * xPullSpeed;
			}
		}
		if ((double)position.Y + (double)height * 0.5 > (double)itemToPickUp.position.Y + (double)itemToPickUp.height * 0.5)
		{
			if (itemToPickUp.velocity.Y < itemGrabSpeedMax)
			{
				itemToPickUp.velocity.Y += itemGrabSpeed;
			}
			if (itemToPickUp.velocity.Y < 0f)
			{
				itemToPickUp.velocity.Y += itemGrabSpeed * xPullSpeed;
			}
		}
		else
		{
			if (itemToPickUp.velocity.Y > 0f - itemGrabSpeedMax)
			{
				itemToPickUp.velocity.Y -= itemGrabSpeed;
			}
			if (itemToPickUp.velocity.Y > 0f)
			{
				itemToPickUp.velocity.Y -= itemGrabSpeed * xPullSpeed;
			}
		}
	}

	private void PullItem_Pickup(Item itemToPickUp, float speed, int acc)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		Vector2 vector = default(Vector2);
		((Vector2)(ref vector))._002Ector(itemToPickUp.position.X + (float)(itemToPickUp.width / 2), itemToPickUp.position.Y + (float)(itemToPickUp.height / 2));
		float num = base.Center.X - vector.X;
		float num2 = base.Center.Y - vector.Y;
		float num3 = (float)Math.Sqrt(num * num + num2 * num2);
		num3 = speed / num3;
		num *= num3;
		num2 *= num3;
		itemToPickUp.velocity.X = (itemToPickUp.velocity.X * (float)(acc - 1) + num) / (float)acc;
		itemToPickUp.velocity.Y = (itemToPickUp.velocity.Y * (float)(acc - 1) + num2) / (float)acc;
	}

	private Item PickupItem(int playerIndex, int worldItemArrayIndex, Item itemToPickUp)
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		if (ItemID.Sets.NebulaPickup[itemToPickUp.type])
		{
			SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
			int num = itemToPickUp.buffType;
			itemToPickUp = new Item();
			if (Main.netMode == 1)
			{
				NetMessage.SendData(102, -1, -1, null, playerIndex, num, base.Center.X, base.Center.Y);
			}
			else
			{
				NebulaLevelup(num);
			}
		}
		if (itemToPickUp.type == 58 || itemToPickUp.type == 1734 || itemToPickUp.type == 1867)
		{
			SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
			Heal(20);
			itemToPickUp = new Item();
		}
		else if (itemToPickUp.type == 184 || itemToPickUp.type == 1735 || itemToPickUp.type == 1868)
		{
			SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
			statMana += 100;
			if (Main.myPlayer == whoAmI)
			{
				ManaEffect(100);
			}
			if (statMana > statManaMax2)
			{
				statMana = statManaMax2;
			}
			itemToPickUp = new Item();
		}
		else if (itemToPickUp.type == 4143)
		{
			SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
			statMana += 50;
			if (Main.myPlayer == whoAmI)
			{
				ManaEffect(50);
			}
			if (statMana > statManaMax2)
			{
				statMana = statManaMax2;
			}
			itemToPickUp = new Item();
		}
		else
		{
			itemToPickUp = GetItem(playerIndex, itemToPickUp, GetItemSettings.PickupItemFromWorld);
		}
		Main.item[worldItemArrayIndex] = itemToPickUp;
		if (Main.netMode == 1)
		{
			NetMessage.SendData(21, -1, -1, null, worldItemArrayIndex);
		}
		return itemToPickUp;
	}

	/// <summary>
	/// Heals the player for a certain amount.
	/// </summary>
	/// <param name="amount">The amount to heal the player by.</param>
	public void Heal(int amount)
	{
		statLife += amount;
		if (Main.myPlayer == whoAmI)
		{
			HealEffect(amount);
		}
		if (statLife > statLifeMax2)
		{
			statLife = statLifeMax2;
		}
	}

	/// <summary>
	/// Fetches the range at which the given item begins to gravitate towards the player.<br />
	/// This range, referred to as item grab range, is measured in pixels.
	/// </summary>
	/// <param name="item">The item whose grab range is being evaluated.</param>
	/// <returns>The item grab range of the player, in pixels.</returns>
	public int GetItemGrabRange(Item item)
	{
		int num = defaultItemGrabRange;
		if (goldRing && item.IsACoin)
		{
			num += Item.coinGrabRange;
		}
		if (manaMagnet && (item.type == 184 || item.type == 1735 || item.type == 1868))
		{
			num += Item.manaGrabRange;
		}
		if (item.type == 4143)
		{
			num += Item.manaGrabRange;
		}
		if (lifeMagnet && (item.type == 58 || item.type == 1734 || item.type == 1867))
		{
			num += Item.lifeGrabRange;
		}
		if (treasureMagnet)
		{
			num += Item.treasureGrabRange;
		}
		if (item.type == 3822)
		{
			num += 50;
		}
		if (ItemID.Sets.NebulaPickup[item.type])
		{
			num += 100;
		}
		if (difficulty == 3 && CreativePowerManager.Instance.GetPower<CreativePowers.FarPlacementRangePower>().IsEnabledForPlayer(whoAmI))
		{
			num += 240;
		}
		ItemLoader.GrabRange(item, this, ref num);
		return num;
	}

	public bool SellItem(Item item, int stack = -1)
	{
		GetItemExpectedPrice(item, out var calcForSelling, out var calcForBuying);
		if (calcForSelling <= 0)
		{
			return false;
		}
		if (stack == -1)
		{
			stack = item.stack;
		}
		Item[] array = new Item[58];
		for (int i = 0; i < 58; i++)
		{
			array[i] = new Item();
			array[i] = inventory[i].Clone();
		}
		long num = calcForSelling / 5;
		if (num < 1)
		{
			num = 1L;
		}
		long num3 = num;
		num *= stack;
		int amount = Main.shopSellbackHelper.GetAmount(item);
		if (amount > 0)
		{
			num += (-num3 + calcForBuying) * Math.Min(amount, item.stack);
		}
		bool flag = false;
		while (num >= 1000000 && !flag)
		{
			int num4 = -1;
			for (int num5 = 53; num5 >= 0; num5--)
			{
				if (num4 == -1 && (inventory[num5].type == 0 || inventory[num5].stack == 0))
				{
					num4 = num5;
				}
				while (inventory[num5].type == 74 && inventory[num5].stack < inventory[num5].maxStack && num >= 1000000)
				{
					inventory[num5].stack++;
					num -= 1000000;
					DoCoins(num5);
					if (inventory[num5].stack == 0 && num4 == -1)
					{
						num4 = num5;
					}
				}
			}
			if (num >= 1000000)
			{
				if (num4 == -1)
				{
					flag = true;
					continue;
				}
				inventory[num4].SetDefaults(74);
				num -= 1000000;
			}
		}
		while (num >= 10000 && !flag)
		{
			int num6 = -1;
			for (int num7 = 53; num7 >= 0; num7--)
			{
				if (num6 == -1 && (inventory[num7].type == 0 || inventory[num7].stack == 0))
				{
					num6 = num7;
				}
				while (inventory[num7].type == 73 && inventory[num7].stack < inventory[num7].maxStack && num >= 10000)
				{
					inventory[num7].stack++;
					num -= 10000;
					DoCoins(num7);
					if (inventory[num7].stack == 0 && num6 == -1)
					{
						num6 = num7;
					}
				}
			}
			if (num >= 10000)
			{
				if (num6 == -1)
				{
					flag = true;
					continue;
				}
				inventory[num6].SetDefaults(73);
				num -= 10000;
			}
		}
		while (num >= 100 && !flag)
		{
			int num8 = -1;
			for (int num9 = 53; num9 >= 0; num9--)
			{
				if (num8 == -1 && (inventory[num9].type == 0 || inventory[num9].stack == 0))
				{
					num8 = num9;
				}
				while (inventory[num9].type == 72 && inventory[num9].stack < inventory[num9].maxStack && num >= 100)
				{
					inventory[num9].stack++;
					num -= 100;
					DoCoins(num9);
					if (inventory[num9].stack == 0 && num8 == -1)
					{
						num8 = num9;
					}
				}
			}
			if (num >= 100)
			{
				if (num8 == -1)
				{
					flag = true;
					continue;
				}
				inventory[num8].SetDefaults(72);
				num -= 100;
			}
		}
		while (num >= 1 && !flag)
		{
			int num10 = -1;
			for (int num2 = 53; num2 >= 0; num2--)
			{
				if (num10 == -1 && (inventory[num2].type == 0 || inventory[num2].stack == 0))
				{
					num10 = num2;
				}
				while (inventory[num2].type == 71 && inventory[num2].stack < inventory[num2].maxStack && num >= 1)
				{
					inventory[num2].stack++;
					num--;
					DoCoins(num2);
					if (inventory[num2].stack == 0 && num10 == -1)
					{
						num10 = num2;
					}
				}
			}
			if (num >= 1)
			{
				if (num10 == -1)
				{
					flag = true;
					continue;
				}
				inventory[num10].SetDefaults(71);
				num--;
			}
		}
		if (flag)
		{
			for (int j = 0; j < 58; j++)
			{
				inventory[j] = array[j].Clone();
			}
			return false;
		}
		return true;
	}

	public void RefreshItems(bool onlyIfVariantChanged = true)
	{
		if (onlyIfVariantChanged && whoAmI == Main.myPlayer)
		{
			Recipe.UpdateItemVariants();
		}
		RefreshItems(inventory, onlyIfVariantChanged);
		RefreshItems(armor, onlyIfVariantChanged);
		RefreshItems(dye, onlyIfVariantChanged);
		RefreshItems(miscEquips, onlyIfVariantChanged);
		RefreshItems(miscDyes, onlyIfVariantChanged);
		RefreshItems(bank.item, onlyIfVariantChanged);
		RefreshItems(bank2.item, onlyIfVariantChanged);
		RefreshItems(bank3.item, onlyIfVariantChanged);
		RefreshItems(bank4.item, onlyIfVariantChanged);
		RefreshItems(_temporaryItemSlots, onlyIfVariantChanged);
	}

	private void RefreshItems(Item[] array, bool onlyIfVariantChanged)
	{
		for (int i = 0; i < array.Length; i++)
		{
			array[i]?.Refresh(onlyIfVariantChanged);
		}
	}

	public void GetItemExpectedPrice(Item item, out long calcForSelling, out long calcForBuying)
	{
		if (item.shopSpecialCurrency != -1)
		{
			CustomCurrencyManager.GetPrices(item, out calcForSelling, out calcForBuying);
			return;
		}
		int storeValue = item.GetStoreValue();
		calcForSelling = storeValue;
		calcForBuying = storeValue;
		if (discountAvailable)
		{
			if (!item.buyOnce)
			{
				calcForBuying = (int)((float)calcForBuying * 0.8f);
			}
			if (item.isAShopItem)
			{
				calcForSelling = calcForBuying;
			}
		}
		if (item.buyOnce)
		{
			calcForBuying = (int)Math.Round((double)calcForBuying / currentShoppingSettings.PriceAdjustment);
			calcForSelling = (int)Math.Round((double)calcForSelling / currentShoppingSettings.PriceAdjustment);
		}
		else
		{
			calcForBuying = (int)Math.Round((double)calcForBuying * currentShoppingSettings.PriceAdjustment);
			calcForSelling = (int)Math.Round((double)calcForSelling / currentShoppingSettings.PriceAdjustment);
		}
		if (item.buyOnce)
		{
			calcForBuying /= 5L;
			if (storeValue != 0 && calcForBuying < 1)
			{
				calcForBuying = 1L;
			}
		}
	}

	/// <summary>
	/// Attempts to "purchase" something that costs the given <paramref name="price" />.<br />
	/// Items will be taken from all of the player inventories and banks combined.<br />
	/// If <paramref name="customCurrency" /> is provided, the price will be in terms of the custom currency instead of coins.<br />
	/// If the player has enough currency, the currency will be taken from the inventories.<br />
	/// </summary>
	/// <param name="price"></param>
	/// <param name="customCurrency"></param>
	/// <returns>true if the player had enough currency to pay the price.</returns>
	public bool BuyItem(long price, int customCurrency = -1)
	{
		if (CanAfford(price, customCurrency))
		{
			return PayCurrency(price, customCurrency);
		}
		return false;
	}

	public bool CanAfford(long price, int customCurrency = -1)
	{
		if (customCurrency != -1)
		{
			return CustomCurrencyManager.CanAfford(this, price, customCurrency);
		}
		bool overFlowing;
		long num = Utils.CoinsCount(out overFlowing, inventory, 58, 57, 56, 55, 54);
		long num2 = Utils.CoinsCount(out overFlowing, bank.item);
		long num3 = Utils.CoinsCount(out overFlowing, bank2.item);
		long num4 = Utils.CoinsCount(out overFlowing, bank3.item);
		long num5 = Utils.CoinsCount(out overFlowing, bank4.item);
		if (Utils.CoinsCombineStacks(out overFlowing, num, num2, num3, num4, num5) < price)
		{
			return false;
		}
		return true;
	}

	public bool PayCurrency(long price, int customCurrency = -1)
	{
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		if (customCurrency != -1)
		{
			return CustomCurrencyManager.PayCurrency(this, price, customCurrency);
		}
		List<Item[]> list = new List<Item[]>();
		Dictionary<int, List<int>> dictionary = new Dictionary<int, List<int>>();
		List<Point> list2 = new List<Point>();
		List<Point> list3 = new List<Point>();
		List<Point> list4 = new List<Point>();
		List<Point> list5 = new List<Point>();
		List<Point> list6 = new List<Point>();
		List<Point> list7 = new List<Point>();
		list.Add(inventory);
		list.Add(bank.item);
		list.Add(bank2.item);
		list.Add(bank3.item);
		list.Add(bank4.item);
		for (int i = 0; i < list.Count; i++)
		{
			dictionary[i] = new List<int>();
		}
		dictionary[0] = new List<int> { 58, 57, 56, 55, 54 };
		for (int j = 0; j < list.Count; j++)
		{
			for (int k = 0; k < list[j].Length; k++)
			{
				if (!dictionary[j].Contains(k) && list[j][k].IsACoin)
				{
					list3.Add(new Point(j, k));
				}
			}
		}
		int num12 = 0;
		for (int num13 = list[num12].Length - 1; num13 >= 0; num13--)
		{
			if (!dictionary[num12].Contains(num13) && (list[num12][num13].type == 0 || list[num12][num13].stack == 0))
			{
				list2.Add(new Point(num12, num13));
			}
		}
		num12 = 1;
		for (int num14 = list[num12].Length - 1; num14 >= 0; num14--)
		{
			if (!dictionary[num12].Contains(num14) && (list[num12][num14].type == 0 || list[num12][num14].stack == 0))
			{
				list4.Add(new Point(num12, num14));
			}
		}
		num12 = 2;
		for (int num15 = list[num12].Length - 1; num15 >= 0; num15--)
		{
			if (!dictionary[num12].Contains(num15) && (list[num12][num15].type == 0 || list[num12][num15].stack == 0))
			{
				list5.Add(new Point(num12, num15));
			}
		}
		num12 = 3;
		for (int num10 = list[num12].Length - 1; num10 >= 0; num10--)
		{
			if (!dictionary[num12].Contains(num10) && (list[num12][num10].type == 0 || list[num12][num10].stack == 0))
			{
				list6.Add(new Point(num12, num10));
			}
		}
		num12 = 4;
		for (int num11 = list[num12].Length - 1; num11 >= 0; num11--)
		{
			if (!dictionary[num12].Contains(num11) && (list[num12][num11].type == 0 || list[num12][num11].stack == 0))
			{
				list7.Add(new Point(num12, num11));
			}
		}
		if (TryPurchasing(price, list, list3, list2, list4, list5, list6, list7))
		{
			return false;
		}
		return true;
	}

	private static bool TryPurchasing(long price, List<Item[]> inv, List<Point> slotCoins, List<Point> slotsEmpty, List<Point> slotEmptyBank, List<Point> slotEmptyBank2, List<Point> slotEmptyBank3, List<Point> slotEmptyBank4)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0612: Unknown result type (might be due to invalid IL or missing references)
		//IL_0623: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0356: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		//IL_056b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_0575: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0580: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_03af: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_0314: Unknown result type (might be due to invalid IL or missing references)
		//IL_0329: Unknown result type (might be due to invalid IL or missing references)
		//IL_032e: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_0458: Unknown result type (might be due to invalid IL or missing references)
		//IL_0464: Unknown result type (might be due to invalid IL or missing references)
		//IL_04aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04de: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0509: Unknown result type (might be due to invalid IL or missing references)
		//IL_051b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0530: Unknown result type (might be due to invalid IL or missing references)
		//IL_0535: Unknown result type (might be due to invalid IL or missing references)
		//IL_0483: Unknown result type (might be due to invalid IL or missing references)
		//IL_048f: Unknown result type (might be due to invalid IL or missing references)
		//IL_049f: Unknown result type (might be due to invalid IL or missing references)
		long num = price;
		Dictionary<Point, Item> dictionary = new Dictionary<Point, Item>();
		bool result = false;
		Point item = default(Point);
		while (num > 0)
		{
			long num2 = 1000000L;
			for (int i = 0; i < 4; i++)
			{
				if (num >= num2)
				{
					foreach (Point slotCoin in slotCoins)
					{
						if (inv[slotCoin.X][slotCoin.Y].type == 74 - i)
						{
							long num3 = num / num2;
							dictionary[slotCoin] = inv[slotCoin.X][slotCoin.Y].Clone();
							if (num3 < inv[slotCoin.X][slotCoin.Y].stack)
							{
								inv[slotCoin.X][slotCoin.Y].stack -= (int)num3;
							}
							else
							{
								inv[slotCoin.X][slotCoin.Y].SetDefaults();
								slotsEmpty.Add(slotCoin);
							}
							num -= num2 * (dictionary[slotCoin].stack - inv[slotCoin.X][slotCoin.Y].stack);
						}
					}
				}
				num2 /= 100;
			}
			if (num <= 0)
			{
				continue;
			}
			if (slotsEmpty.Count > 0)
			{
				slotsEmpty.Sort(DelegateMethods.CompareYReverse);
				((Point)(ref item))._002Ector(-1, -1);
				for (int j = 0; j < inv.Count; j++)
				{
					num2 = 10000L;
					for (int k = 0; k < 3; k++)
					{
						if (num >= num2)
						{
							foreach (Point slotCoin2 in slotCoins)
							{
								if (slotCoin2.X == j && inv[slotCoin2.X][slotCoin2.Y].type == 74 - k && inv[slotCoin2.X][slotCoin2.Y].stack >= 1)
								{
									List<Point> list = slotsEmpty;
									if (j == 1 && slotEmptyBank.Count > 0)
									{
										list = slotEmptyBank;
									}
									if (j == 2 && slotEmptyBank2.Count > 0)
									{
										list = slotEmptyBank2;
									}
									if (j == 3 && slotEmptyBank3.Count > 0)
									{
										list = slotEmptyBank3;
									}
									if (j == 4 && slotEmptyBank4.Count > 0)
									{
										list = slotEmptyBank4;
									}
									if (--inv[slotCoin2.X][slotCoin2.Y].stack <= 0)
									{
										inv[slotCoin2.X][slotCoin2.Y].SetDefaults();
										list.Add(slotCoin2);
									}
									dictionary[list[0]] = inv[list[0].X][list[0].Y].Clone();
									inv[list[0].X][list[0].Y].SetDefaults(73 - k);
									inv[list[0].X][list[0].Y].stack = 100;
									item = list[0];
									list.RemoveAt(0);
									break;
								}
							}
						}
						if (item.X != -1 || item.Y != -1)
						{
							break;
						}
						num2 /= 100;
					}
					for (int l = 0; l < 2; l++)
					{
						if (item.X != -1 || item.Y != -1)
						{
							continue;
						}
						foreach (Point slotCoin3 in slotCoins)
						{
							if (slotCoin3.X == j && inv[slotCoin3.X][slotCoin3.Y].type == 73 + l && inv[slotCoin3.X][slotCoin3.Y].stack >= 1)
							{
								List<Point> list2 = slotsEmpty;
								if (j == 1 && slotEmptyBank.Count > 0)
								{
									list2 = slotEmptyBank;
								}
								if (j == 2 && slotEmptyBank2.Count > 0)
								{
									list2 = slotEmptyBank2;
								}
								if (j == 3 && slotEmptyBank3.Count > 0)
								{
									list2 = slotEmptyBank3;
								}
								if (j == 4 && slotEmptyBank4.Count > 0)
								{
									list2 = slotEmptyBank4;
								}
								if (--inv[slotCoin3.X][slotCoin3.Y].stack <= 0)
								{
									inv[slotCoin3.X][slotCoin3.Y].SetDefaults();
									list2.Add(slotCoin3);
								}
								dictionary[list2[0]] = inv[list2[0].X][list2[0].Y].Clone();
								inv[list2[0].X][list2[0].Y].SetDefaults(72 + l);
								inv[list2[0].X][list2[0].Y].stack = 100;
								item = list2[0];
								list2.RemoveAt(0);
								break;
							}
						}
					}
					if (item.X != -1 && item.Y != -1)
					{
						slotCoins.Add(item);
						break;
					}
				}
				slotsEmpty.Sort(DelegateMethods.CompareYReverse);
				slotEmptyBank.Sort(DelegateMethods.CompareYReverse);
				slotEmptyBank2.Sort(DelegateMethods.CompareYReverse);
				slotEmptyBank3.Sort(DelegateMethods.CompareYReverse);
				slotEmptyBank4.Sort(DelegateMethods.CompareYReverse);
				continue;
			}
			foreach (KeyValuePair<Point, Item> item2 in dictionary)
			{
				inv[item2.Key.X][item2.Key.Y] = item2.Value.Clone();
			}
			result = true;
			break;
		}
		return result;
	}

	public void AdjTiles()
	{
		int num = 4;
		int num2 = 3;
		if (ateArtisanBread)
		{
			num += 4;
			num2 += 4;
		}
		for (int i = 0; i < adjTile.Length; i++)
		{
			oldAdjTile[i] = adjTile[i];
			adjTile[i] = false;
		}
		oldAdjWater = adjWater;
		adjWater = false;
		oldAdjHoney = adjHoney;
		adjHoney = false;
		oldAdjLava = adjLava;
		adjLava = false;
		oldAdjShimmer = adjShimmer;
		adjShimmer = false;
		alchemyTable = false;
		int num3 = (int)((position.X + (float)(width / 2)) / 16f);
		int num4 = (int)((position.Y + (float)height) / 16f);
		for (int j = num3 - num; j <= num3 + num; j++)
		{
			for (int k = num4 - num2; k < num4 + num2; k++)
			{
				if (Main.tile[j, k].active())
				{
					adjTile[Main.tile[j, k].type] = true;
					switch (Main.tile[j, k].type)
					{
					case 77:
					case 302:
						adjTile[17] = true;
						break;
					case 133:
						adjTile[17] = true;
						adjTile[77] = true;
						break;
					case 134:
						adjTile[16] = true;
						break;
					case 354:
					case 469:
					case 487:
						adjTile[14] = true;
						break;
					case 355:
						adjTile[13] = true;
						adjTile[14] = true;
						alchemyTable = true;
						break;
					}
					TileLoader.AdjTiles(this, Main.tile[j, k].type);
				}
				if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 0) || TileID.Sets.CountsAsWaterSource[Main.tile[j, k].type])
				{
					adjWater = true;
				}
				if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 2) || TileID.Sets.CountsAsHoneySource[Main.tile[j, k].type])
				{
					adjHoney = true;
				}
				if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 1) || TileID.Sets.CountsAsLavaSource[Main.tile[j, k].type])
				{
					adjLava = true;
				}
				if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 3) || TileID.Sets.CountsAsShimmerSource[Main.tile[j, k].type])
				{
					adjShimmer = true;
				}
			}
		}
		if (!Main.playerInventory)
		{
			return;
		}
		bool flag = false;
		for (int l = 0; l < adjTile.Length; l++)
		{
			if (oldAdjTile[l] != adjTile[l])
			{
				flag = true;
				break;
			}
		}
		if (adjWater != oldAdjWater)
		{
			flag = true;
		}
		if (adjHoney != oldAdjHoney)
		{
			flag = true;
		}
		if (adjLava != oldAdjLava)
		{
			flag = true;
		}
		if (adjShimmer != oldAdjShimmer)
		{
			flag = true;
		}
		if (flag)
		{
			Recipe.FindRecipes();
		}
	}

	public bool IsTileTypeInInteractionRange(int targetTileType, TileReachCheckSettings settings)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		Point val = position.ToTileCoordinates();
		Point point2 = base.BottomRight.ToTileCoordinates();
		settings.GetRanges(this, out var x, out var y);
		int num = Utils.Clamp(val.X - x + 1, 0, Main.maxTilesX - 1);
		int num2 = Utils.Clamp(point2.X + x - 1, 0, Main.maxTilesX - 1);
		int num3 = Utils.Clamp(val.Y - y + 1, 0, Main.maxTilesY - 1);
		int num4 = Utils.Clamp(point2.Y + y - 2, 0, Main.maxTilesY - 1);
		for (int i = num; i <= num2; i++)
		{
			for (int j = num3; j <= num4; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile != null && tile.active() && tile.type == targetTileType)
				{
					return true;
				}
			}
		}
		return false;
	}

	public void DisplayDollUpdate()
	{
		if (!Main.gamePaused)
		{
			UpdateMiscCounter();
		}
	}

	public bool IsColorfulDye(int dye)
	{
		if (dye > 0)
		{
			return ItemID.Sets.ColorfulDyeValues[dye];
		}
		return false;
	}

	public bool ShouldDrawFootball()
	{
		bool result = hasFootball && !pulley && !compositeBackArm.enabled;
		if (HeldItem.type == 4743 && itemAnimation > 0)
		{
			result = false;
		}
		return result;
	}

	public void PlayerFrame()
	{
		//IL_1635: Unknown result type (might be due to invalid IL or missing references)
		//IL_16ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0714: Unknown result type (might be due to invalid IL or missing references)
		//IL_0719: Unknown result type (might be due to invalid IL or missing references)
		//IL_1d83: Unknown result type (might be due to invalid IL or missing references)
		//IL_0950: Unknown result type (might be due to invalid IL or missing references)
		//IL_095f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0893: Unknown result type (might be due to invalid IL or missing references)
		//IL_08bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_08f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0901: Unknown result type (might be due to invalid IL or missing references)
		//IL_0906: Unknown result type (might be due to invalid IL or missing references)
		//IL_074a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0759: Unknown result type (might be due to invalid IL or missing references)
		//IL_075e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0763: Unknown result type (might be due to invalid IL or missing references)
		//IL_076a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0781: Unknown result type (might be due to invalid IL or missing references)
		//IL_0787: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a91: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ebc: Unknown result type (might be due to invalid IL or missing references)
		//IL_1d58: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a62: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a3d: Unknown result type (might be due to invalid IL or missing references)
		//IL_09eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a0f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a15: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c5c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a11: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ad3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0af7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0afd: Unknown result type (might be due to invalid IL or missing references)
		//IL_18b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_18db: Unknown result type (might be due to invalid IL or missing references)
		//IL_190f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1915: Unknown result type (might be due to invalid IL or missing references)
		//IL_192c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1936: Unknown result type (might be due to invalid IL or missing references)
		//IL_193b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1753: Unknown result type (might be due to invalid IL or missing references)
		//IL_177c: Unknown result type (might be due to invalid IL or missing references)
		//IL_17b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_17b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_17cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_17d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_17dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_195f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1988: Unknown result type (might be due to invalid IL or missing references)
		//IL_19bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_19c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_19d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_19e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_19e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1800: Unknown result type (might be due to invalid IL or missing references)
		//IL_1829: Unknown result type (might be due to invalid IL or missing references)
		//IL_185d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1863: Unknown result type (might be due to invalid IL or missing references)
		//IL_187a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1884: Unknown result type (might be due to invalid IL or missing references)
		//IL_1889: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ba6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bd0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c07: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c11: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c16: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c24: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c2a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c34: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c39: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c3e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e5c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e7d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e83: Unknown result type (might be due to invalid IL or missing references)
		//IL_10fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_111f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1125: Unknown result type (might be due to invalid IL or missing references)
		//IL_114e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1158: Unknown result type (might be due to invalid IL or missing references)
		//IL_115d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d03: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d23: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d29: Unknown result type (might be due to invalid IL or missing references)
		//IL_267b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0fa8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0fc8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0fce: Unknown result type (might be due to invalid IL or missing references)
		//IL_1291: Unknown result type (might be due to invalid IL or missing references)
		//IL_12b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_12b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_12e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_12eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_12f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_27f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_27fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_2929: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c25: Unknown result type (might be due to invalid IL or missing references)
		//IL_2968: Unknown result type (might be due to invalid IL or missing references)
		//IL_1390: Unknown result type (might be due to invalid IL or missing references)
		//IL_13ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_13b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_13e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_13f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_13f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1518: Unknown result type (might be due to invalid IL or missing references)
		//IL_1535: Unknown result type (might be due to invalid IL or missing references)
		//IL_153b: Unknown result type (might be due to invalid IL or missing references)
		//IL_14b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_14d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_14db: Unknown result type (might be due to invalid IL or missing references)
		//IL_159d: Unknown result type (might be due to invalid IL or missing references)
		//IL_15a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_15ac: Unknown result type (might be due to invalid IL or missing references)
		if (swimTime > 0)
		{
			swimTime--;
			if (!wet)
			{
				swimTime = 0;
			}
		}
		head = armor[0].headSlot;
		body = armor[1].bodySlot;
		legs = armor[2].legSlot;
		if (armor[10].headSlot >= 0)
		{
			head = armor[10].headSlot;
		}
		if (armor[11].bodySlot >= 0)
		{
			body = armor[11].bodySlot;
		}
		if (armor[12].legSlot >= 0)
		{
			legs = armor[12].legSlot;
		}
		if (!dead)
		{
			UpdateVisibleAccessories();
		}
		wearsRobe = false;
		bool somethingSpecial = false;
		SetMatchRequest request = default(SetMatchRequest);
		request.Head = head;
		request.Body = body;
		request.Legs = legs;
		request.Male = Male;
		request.ArmorSlotRequested = 1;
		int num = SetMatch(request, ref wearsRobe);
		if (num != -1)
		{
			legs = num;
		}
		request = default(SetMatchRequest);
		request.Head = head;
		request.Body = body;
		request.Legs = legs;
		request.Male = Male;
		request.ArmorSlotRequested = 2;
		num = SetMatch(request, ref somethingSpecial);
		if (num != -1)
		{
			legs = num;
		}
		request = default(SetMatchRequest);
		request.Head = head;
		request.Body = body;
		request.Legs = legs;
		request.Male = Male;
		request.ArmorSlotRequested = 0;
		num = SetMatch(request, ref somethingSpecial);
		if (num != -1)
		{
			head = num;
		}
		if (body == 93)
		{
			shield = 0;
			handoff = 0;
		}
		if (body > 0 && ArmorIDs.Body.Sets.DisableHandOnAndOffAccDraw[body])
		{
			handon = 0;
			handoff = 0;
		}
		if (body > 0 && waist > 0 && ArmorIDs.Body.Sets.DisableBeltAccDraw[body] && ArmorIDs.Waist.Sets.IsABelt[waist])
		{
			waist = 0;
		}
		if (!dead && body >= 0)
		{
			int b = (Male ? ArmorIDs.Body.Sets.IncludedCapeBack : ArmorIDs.Body.Sets.IncludedCapeBackFemale)[body];
			if (b != -1)
			{
				if (ArmorIDs.Back.Sets.DrawInBackpackLayer[b])
				{
					backpack = b;
					cBackpack = cBody;
				}
				else if (ArmorIDs.Back.Sets.DrawInTailLayer[b])
				{
					tail = b;
					cTail = cBody;
				}
				else if (back == -1)
				{
					back = b;
					cBack = cBody;
				}
			}
			int b2 = ArmorIDs.Body.Sets.IncludedCapeFront[body];
			if (b2 != -1 && front == -1)
			{
				front = b2;
				cFront = cBody;
			}
			ArmorIDs.Body.Sets.IncludeCapeFrontAndBackInfo includeCapeFrontAndBackInfo = ArmorIDs.Body.Sets.IncludeCapeFrontAndBack[body];
			if (!includeCapeFrontAndBackInfo.Invalid && back == -1 && front == -1)
			{
				front = includeCapeFrontAndBackInfo.frontCape;
				cFront = cBody;
				int backCape = includeCapeFrontAndBackInfo.backCape;
				if (ArmorIDs.Back.Sets.DrawInBackpackLayer[backCape])
				{
					backpack = backCape;
					cBackpack = cBody;
				}
				else if (ArmorIDs.Back.Sets.DrawInTailLayer[backCape])
				{
					tail = backCape;
					cTail = cBody;
				}
				else if (!sitting.isSitting)
				{
					back = backCape;
					cBack = cBody;
				}
			}
		}
		if (legs == 67)
		{
			shoe = 0;
		}
		if (legs == 140)
		{
			shoe = 0;
		}
		bool flag = false;
		if ((wereWolf || forceWerewolf) && !hideWolf)
		{
			legs = 20;
			body = 21;
			head = 38;
			flag = true;
		}
		bool flag2 = wet && !lavaWet && (!mount.Active || !mount.IsConsideredASlimeMount);
		if (merman || forceMerman)
		{
			if (!hideMerman)
			{
				head = 39;
				legs = 21;
				body = 22;
				flag = true;
			}
			if (flag2)
			{
				wings = 0;
			}
		}
		socialShadowRocketBoots = false;
		socialIgnoreLight = false;
		socialGhost = false;
		armorEffectDrawShadow = false;
		armorEffectDrawShadowSubtle = false;
		armorEffectDrawOutlines = false;
		armorEffectDrawShadowLokis = false;
		armorEffectDrawShadowBasilisk = false;
		armorEffectDrawOutlinesForbidden = false;
		armorEffectDrawShadowEOCShield = false;
		if (!isDisplayDollOrInanimate)
		{
			if (head == 101 && body == 66 && legs == 55)
			{
				socialGhost = true;
			}
			if (head == 156 && body == 66 && legs == 55)
			{
				socialGhost = true;
			}
			SetArmorEffectVisuals(this);
		}
		hermesStepSound.Style = SoundID.Run;
		hermesStepSound.IntendedCooldown = 9;
		if (head == 99 && body == 65 && legs == 54)
		{
			turtleArmor = true;
		}
		if (head == 162 && body == 170 && legs == 105)
		{
			spiderArmor = true;
		}
		ApplyArmorSoundAndDustChanges();
		if (legs == 140)
		{
			hermesStepSound.Style = SoundID.Item24;
			hermesStepSound.IntendedCooldown = 6;
		}
		if (flag)
		{
			face = -1;
			faceFlower = -1;
			faceHead = -1;
		}
		ItemLoader.PreUpdateVanitySet(this);
		if (head > 0 && face > 0)
		{
			if (ArmorIDs.Face.Sets.OverrideHelmet[face])
			{
				head = -1;
				faceHead = -1;
			}
			else if (!ArmorIDs.Face.Sets.DrawInFaceUnderHairLayer[face])
			{
				face = -1;
			}
		}
		if (head > 0 && faceHead > 0 && ArmorIDs.Head.Sets.UseAltFaceHeadDraw[head])
		{
			int b3 = ArmorIDs.Face.Sets.AltFaceHead[faceHead];
			if (b3 > 0)
			{
				faceHead = b3;
			}
		}
		if (webbed || frozen || stoned || (Main.gamePaused && !Main.gameMenu))
		{
			return;
		}
		if (head == 267 && body == 236 && (legs == 219 || legs == 220) && miscCounter % 15 == 0 && Main.rand.Next(3) == 0)
		{
			Vector2 center = base.Center;
			float num12 = 1f + Main.rand.NextFloat() * 0.5f;
			if (Main.rand.Next(2) == 0)
			{
				num12 *= -1f;
			}
			center += new Vector2(num12 * -25f, -8f);
			Dust obj = Main.dust[Dust.NewDust(center, 2, 2, 304, 0f, 0f, 100)];
			obj.rotation = Main.rand.NextFloat() * ((float)Math.PI * 2f);
			obj.alpha = 254;
			obj.velocity.X = num12 * 0.2f;
			obj.noGravity = true;
			obj.customData = this;
			obj.shader = GameShaders.Armor.GetSecondaryShader(cBody, this);
		}
		CombinedHooks.PlayerFrameEffects(this);
		if (!isDisplayDollOrInanimate)
		{
			if (((body == 68 && legs == 57 && head == 106) || (body == 74 && legs == 63 && head == 106)) && Main.rand.Next(10) == 0)
			{
				int num16 = Dust.NewDust(new Vector2(position.X - velocity.X * 2f, position.Y - 2f - velocity.Y * 2f), width, height, 43, 0f, 0f, 100, new Color(255, 0, 255), 0.3f);
				Main.dust[num16].fadeIn = 0.8f;
				Main.dust[num16].noGravity = true;
				Dust obj2 = Main.dust[num16];
				obj2.velocity *= 2f;
				Main.dust[num16].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
			}
			if (wings == 27 && wingsLogic == wings)
			{
				float num17 = 0.4f * stealth;
				Lighting.AddLight((int)base.Center.X / 16, (int)base.Center.Y / 16, num17, num17 * 0.9f, num17 * 0.2f);
			}
			if (head == 5 && body == 5 && legs == 5)
			{
				socialShadowRocketBoots = true;
			}
			if (head == 5 && body == 5 && legs == 5 && Main.rand.Next(10) == 0)
			{
				int num18 = Dust.NewDust(new Vector2(position.X, position.Y), width, height, 14, 0f, 0f, 200, default(Color), 1.2f);
				Main.dust[num18].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
			}
			if (head == 76 && body == 49 && legs == 45)
			{
				socialShadowRocketBoots = true;
			}
			if (head == 74 && body == 48 && legs == 44)
			{
				socialShadowRocketBoots = true;
			}
			if (head == 74 && body == 48 && legs == 44 && Main.rand.Next(10) == 0)
			{
				int num19 = Dust.NewDust(new Vector2(position.X, position.Y), width, height, 14, 0f, 0f, 200, default(Color), 1.2f);
				Main.dust[num19].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
			}
			if (head == 57 && body == 37 && legs == 35)
			{
				int maxValue = 10;
				if (Math.Abs(velocity.X) + Math.Abs(velocity.Y) > 1f)
				{
					maxValue = 2;
				}
				if (Main.rand.Next(maxValue) == 0)
				{
					int num20 = Dust.NewDust(new Vector2(position.X, position.Y), width, height, 115, 0f, 0f, 140, default(Color), 0.75f);
					Main.dust[num20].noGravity = true;
					Main.dust[num20].fadeIn = 1.5f;
					Dust obj3 = Main.dust[num20];
					obj3.velocity *= 0.3f;
					Dust obj4 = Main.dust[num20];
					obj4.velocity += velocity * 0.2f;
					Main.dust[num20].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
				}
			}
			if (head == 6 && body == 6 && legs == 6 && Math.Abs(velocity.X) + Math.Abs(velocity.Y) > 1f && !rocketFrame)
			{
				for (int i = 0; i < 2; i++)
				{
					int num21 = Dust.NewDust(new Vector2(position.X - velocity.X * 2f, position.Y - 2f - velocity.Y * 2f), width, height, 6, 0f, 0f, 100, default(Color), 2f);
					Main.dust[num21].noGravity = true;
					Main.dust[num21].noLight = true;
					Main.dust[num21].velocity.X -= velocity.X * 0.5f;
					Main.dust[num21].velocity.Y -= velocity.Y * 0.5f;
					Main.dust[num21].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
				}
			}
			if (head == 8 && body == 8 && legs == 8 && Math.Abs(velocity.X) + Math.Abs(velocity.Y) > 1f)
			{
				int num22 = Dust.NewDust(new Vector2(position.X - velocity.X * 2f, position.Y - 2f - velocity.Y * 2f), width, height, 40, 0f, 0f, 50, default(Color), 1.4f);
				Main.dust[num22].noGravity = true;
				Main.dust[num22].velocity.X = velocity.X * 0.25f;
				Main.dust[num22].velocity.Y = velocity.Y * 0.25f;
				Main.dust[num22].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
			}
			if (head == 9 && body == 9 && legs == 9 && Math.Abs(velocity.X) + Math.Abs(velocity.Y) > 1f && !rocketFrame)
			{
				for (int j = 0; j < 2; j++)
				{
					int num2 = Dust.NewDust(new Vector2(position.X - velocity.X * 2f, position.Y - 2f - velocity.Y * 2f), width, height, 6, 0f, 0f, 100, default(Color), 2f);
					Main.dust[num2].noGravity = true;
					Main.dust[num2].noLight = true;
					Main.dust[num2].velocity.X -= velocity.X * 0.5f;
					Main.dust[num2].velocity.Y -= velocity.Y * 0.5f;
					Main.dust[num2].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
				}
			}
			if (body == 18 && legs == 17 && (head == 32 || head == 33 || head == 34) && Main.rand.Next(10) == 0)
			{
				int num3 = Dust.NewDust(new Vector2(position.X - velocity.X * 2f, position.Y - 2f - velocity.Y * 2f), width, height, 43, 0f, 0f, 100, default(Color), 0.3f);
				Main.dust[num3].fadeIn = 0.8f;
				Dust obj5 = Main.dust[num3];
				obj5.velocity *= 0f;
				Main.dust[num3].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
			}
			if ((body == 24 || body == 229) && (legs == 23 || legs == 212) && (head == 43 || head == 41 || head == 42 || head == 254 || head == 255 || head == 256 || head == 257 || head == 258) && velocity.X != 0f && velocity.Y != 0f && Main.rand.Next(10) == 0)
			{
				int num4 = Dust.NewDust(new Vector2(position.X - velocity.X * 2f, position.Y - 2f - velocity.Y * 2f), width, height, 43, 0f, 0f, 100, default(Color), 0.3f);
				Main.dust[num4].fadeIn = 0.8f;
				Dust obj6 = Main.dust[num4];
				obj6.velocity *= 0f;
				Main.dust[num4].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
			}
			if (body == 36 && head == 56 && velocity.X != 0f && velocity.Y == 0f)
			{
				for (int k = 0; k < 2; k++)
				{
					int num5 = Dust.NewDust(new Vector2(position.X, position.Y + (float)((gravDir == 1f) ? (height - 2) : (-4))), width, 6, 106, 0f, 0f, 100, default(Color), 0.1f);
					Main.dust[num5].fadeIn = 1f;
					Main.dust[num5].noGravity = true;
					Dust obj7 = Main.dust[num5];
					obj7.velocity *= 0.2f;
					Main.dust[num5].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
				}
			}
			if (body == 27 && head == 46 && legs == 26 && velocity.X != 0f && velocity.Y == 0f && miscCounter % 2 == 0)
			{
				for (int l = 0; l < 2; l++)
				{
					int num6 = ((l != 0) ? Dust.NewDust(new Vector2(position.X + (float)(width / 2), position.Y + (float)height + gfxOffY), width / 2, 6, 76, 0f, 0f, 0, default(Color), 1.35f) : Dust.NewDust(new Vector2(position.X, position.Y + (float)height + gfxOffY), width / 2, 6, 76, 0f, 0f, 0, default(Color), 1.35f));
					Main.dust[num6].scale *= 1f + (float)Main.rand.Next(20, 40) * 0.01f;
					Main.dust[num6].noGravity = true;
					Main.dust[num6].noLight = true;
					Dust obj8 = Main.dust[num6];
					obj8.velocity *= 0.001f;
					Main.dust[num6].velocity.Y -= 0.003f;
					Main.dust[num6].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
				}
			}
		}
		drawingFootball = false;
		if (ShouldDrawFootball())
		{
			SetCompositeArmBack(enabled: true, CompositeArmStretchAmount.Full, (float)Math.PI / 10f * (float)direction * -1f);
			drawingFootball = true;
		}
		Item.GetDrawHitbox(HeldItem.type, this);
		bool flag3 = CanVisuallyHoldItem(HeldItem);
		bool flag4 = HeldItem.useStyle != 14;
		ItemLoader.UpdateVanitySet(this);
		if (mount.Active)
		{
			legFrameCounter = 0.0;
			legFrame.Y = legFrame.Height * 6;
			if (mount.Type == 23 || mount.Type == 45 || mount.Type == 48)
			{
				ref Rectangle reference = ref legFrame;
				_ = legFrame;
				reference.Y = 0;
			}
			if (velocity.Y != 0f)
			{
				if (mount.FlyTime > 0 && jump == 0 && controlJump && !mount.CanHover())
				{
					if (mount.Type == 0)
					{
						if (direction > 0)
						{
							if (Main.rand.Next(4) == 0)
							{
								int num7 = Dust.NewDust(new Vector2(base.Center.X - 22f, position.Y + (float)height - 6f), 20, 10, 64, velocity.X * 0.25f, velocity.Y * 0.25f, 255);
								Dust obj9 = Main.dust[num7];
								obj9.velocity *= 0.1f;
								Main.dust[num7].noLight = true;
							}
							if (Main.rand.Next(4) == 0)
							{
								int num8 = Dust.NewDust(new Vector2(base.Center.X + 12f, position.Y + (float)height - 6f), 20, 10, 64, velocity.X * 0.25f, velocity.Y * 0.25f, 255);
								Dust obj10 = Main.dust[num8];
								obj10.velocity *= 0.1f;
								Main.dust[num8].noLight = true;
							}
						}
						else
						{
							if (Main.rand.Next(4) == 0)
							{
								int num9 = Dust.NewDust(new Vector2(base.Center.X - 32f, position.Y + (float)height - 6f), 20, 10, 64, velocity.X * 0.25f, velocity.Y * 0.25f, 255);
								Dust obj11 = Main.dust[num9];
								obj11.velocity *= 0.1f;
								Main.dust[num9].noLight = true;
							}
							if (Main.rand.Next(4) == 0)
							{
								int num10 = Dust.NewDust(new Vector2(base.Center.X + 2f, position.Y + (float)height - 6f), 20, 10, 64, velocity.X * 0.25f, velocity.Y * 0.25f, 255);
								Dust obj12 = Main.dust[num10];
								obj12.velocity *= 0.1f;
								Main.dust[num10].noLight = true;
							}
						}
					}
					mount.TryBeginningFlight(this, 3);
					mount.UpdateFrame(this, 3, velocity);
					mount.TryLanding(this);
				}
				else if (wet)
				{
					mount.UpdateFrame(this, 4, velocity);
				}
				else
				{
					mount.TryBeginningFlight(this, 2);
					mount.UpdateFrame(this, 2, velocity);
					mount.TryLanding(this);
				}
			}
			else
			{
				mount.UpdateFrame(this, mount.GetIntendedGroundedFrame(this), velocity);
			}
		}
		else if (legs != 140)
		{
			if (swimTime > 0)
			{
				legFrameCounter += 2.0;
				while (legFrameCounter > 8.0)
				{
					legFrameCounter -= 8.0;
					legFrame.Y += legFrame.Height;
				}
				if (legFrame.Y < legFrame.Height * 7)
				{
					legFrame.Y = legFrame.Height * 19;
				}
				else if (legFrame.Y > legFrame.Height * 19)
				{
					legFrame.Y = legFrame.Height * 7;
				}
			}
			else if (velocity.Y != 0f || grappling[0] > -1)
			{
				legFrameCounter = 0.0;
				legFrame.Y = legFrame.Height * 5;
				if ((wings == 22 || wings == 28 || wings == 45) && ShouldDrawWingsThatAreAlwaysAnimated())
				{
					legFrame.Y = 0;
				}
			}
			else if (velocity.X != 0f)
			{
				if ((slippy || slippy2 || windPushed) && !controlLeft && !controlRight)
				{
					legFrameCounter = 0.0;
					ref Rectangle reference2 = ref legFrame;
					_ = legFrame;
					reference2.Y = 0;
				}
				else
				{
					legFrameCounter += (double)Math.Abs(velocity.X) * 1.3;
					while (legFrameCounter > 8.0)
					{
						legFrameCounter -= 8.0;
						legFrame.Y += legFrame.Height;
					}
					if (legFrame.Y < legFrame.Height * 7)
					{
						legFrame.Y = legFrame.Height * 19;
					}
					else if (legFrame.Y > legFrame.Height * 19)
					{
						legFrame.Y = legFrame.Height * 7;
					}
				}
			}
			else
			{
				legFrameCounter = 0.0;
				ref Rectangle reference3 = ref legFrame;
				_ = legFrame;
				reference3.Y = 0;
			}
		}
		if (carpetFrame >= 0)
		{
			legFrameCounter = 0.0;
			ref Rectangle reference4 = ref legFrame;
			_ = legFrame;
			reference4.Y = 0;
		}
		if (sandStorm)
		{
			if (grappling[0] >= 0)
			{
				sandStorm = false;
			}
			if (miscCounter % 4 == 0 && itemAnimation == 0)
			{
				ChangeDir(direction * -1);
				if (inventory[selectedItem].holdStyle == 2)
				{
					if (inventory[selectedItem].type == 946 || inventory[selectedItem].type == 4707)
					{
						itemLocation.X = position.X + (float)width * 0.5f - (float)(16 * direction);
					}
					if (inventory[selectedItem].type == 186)
					{
						itemLocation.X = position.X + (float)width * 0.5f + (float)(6 * direction);
						itemRotation = 0.79f * (float)(-direction);
					}
				}
			}
			legFrameCounter = 0.0;
			ref Rectangle reference5 = ref legFrame;
			_ = legFrame;
			reference5.Y = 0;
		}
		else if (itemAnimation > 0 && inventory[selectedItem].useStyle != 10 && flag4)
		{
			if (inventory[selectedItem].useStyle == 1 || inventory[selectedItem].type == 0)
			{
				if ((double)itemAnimation < (double)itemAnimationMax * 0.333)
				{
					bodyFrame.Y = bodyFrame.Height * 3;
				}
				else if ((double)itemAnimation < (double)itemAnimationMax * 0.666)
				{
					bodyFrame.Y = bodyFrame.Height * 2;
				}
				else
				{
					bodyFrame.Y = bodyFrame.Height;
				}
			}
			else if (inventory[selectedItem].useStyle == 7)
			{
				if ((double)itemAnimation > (double)itemAnimationMax * 0.5)
				{
					bodyFrame.Y = bodyFrame.Height * 3;
				}
				else
				{
					bodyFrame.Y = bodyFrame.Height * 2;
				}
			}
			else if (inventory[selectedItem].useStyle == 2)
			{
				bodyFrame.Y = bodyFrame.Height * 3;
			}
			else if (inventory[selectedItem].useStyle == 11)
			{
				if ((double)itemAnimation > (double)itemAnimationMax * 0.5)
				{
					bodyFrame.Y = bodyFrame.Height * 4;
				}
				else if ((double)itemAnimation > (double)itemAnimationMax * 0.15)
				{
					bodyFrame.Y = bodyFrame.Height * 3;
				}
				else
				{
					bodyFrame.Y = bodyFrame.Height * 2;
				}
			}
			else if (inventory[selectedItem].useStyle == 9)
			{
				bodyFrame.Y = 0;
			}
			else if (inventory[selectedItem].useStyle == 6)
			{
				float num11 = 1f - (float)itemAnimation / (float)itemAnimationMax;
				num11 *= 6f;
				if (num11 > 1f)
				{
					num11 = 1f;
				}
				if (num11 >= 0.5f)
				{
					bodyFrame.Y = bodyFrame.Height * 3;
				}
				else
				{
					bodyFrame.Y = bodyFrame.Height * 2;
				}
			}
			else if (inventory[selectedItem].useStyle == 3)
			{
				if ((double)itemAnimation > (double)itemAnimationMax * 0.666)
				{
					bodyFrame.Y = bodyFrame.Height * 3;
				}
				else
				{
					bodyFrame.Y = bodyFrame.Height * 3;
				}
			}
			else if (inventory[selectedItem].useStyle == 4)
			{
				bodyFrame.Y = bodyFrame.Height * 2;
			}
			else if (inventory[selectedItem].useStyle == 8)
			{
				bodyFrame.Y = 0;
			}
			else if (inventory[selectedItem].useStyle == 12)
			{
				bodyFrame.Y = bodyFrame.Height * 3;
			}
			else if (inventory[selectedItem].useStyle == 13)
			{
				if ((double)itemAnimation < (double)itemAnimationMax * 0.333)
				{
					bodyFrame.Y = bodyFrame.Height * 3;
				}
				else if ((double)itemAnimation < (double)itemAnimationMax * 0.666)
				{
					bodyFrame.Y = bodyFrame.Height * 2;
				}
				else
				{
					bodyFrame.Y = bodyFrame.Height;
				}
			}
			else if (inventory[selectedItem].useStyle == 5)
			{
				if (inventory[selectedItem].type == 281 || inventory[selectedItem].type == 986)
				{
					bodyFrame.Y = bodyFrame.Height * 2;
				}
				else
				{
					float num23 = itemRotation * (float)direction;
					bodyFrame.Y = bodyFrame.Height * 3;
					if ((double)num23 < -0.75)
					{
						bodyFrame.Y = bodyFrame.Height * 2;
						if (gravDir == -1f)
						{
							bodyFrame.Y = bodyFrame.Height * 4;
						}
					}
					if ((double)num23 > 0.6)
					{
						bodyFrame.Y = bodyFrame.Height * 4;
						if (gravDir == -1f)
						{
							bodyFrame.Y = bodyFrame.Height * 2;
						}
					}
				}
			}
			ItemLoader.UseItemFrame(inventory[selectedItem], this);
		}
		else if (pulley)
		{
			if (pulleyDir == 2)
			{
				bodyFrame.Y = bodyFrame.Height;
			}
			else
			{
				bodyFrame.Y = bodyFrame.Height * 2;
			}
		}
		else if (flag3 && inventory[selectedItem].holdStyle == 1 && (!wet || !inventory[selectedItem].noWet || ItemID.Sets.WaterTorches[BiomeTorchHoldStyle(inventory[selectedItem].type)]) && (!happyFunTorchTime || inventory[selectedItem].createTile != 4))
		{
			bodyFrame.Y = bodyFrame.Height * 3;
		}
		else if (flag3 && inventory[selectedItem].holdStyle == 2 && (!wet || !inventory[selectedItem].noWet))
		{
			bodyFrame.Y = bodyFrame.Height * 2;
		}
		else if (flag3 && inventory[selectedItem].holdStyle == 3)
		{
			bodyFrame.Y = bodyFrame.Height * 3;
		}
		else if (flag3 && inventory[selectedItem].holdStyle == 5)
		{
			bodyFrame.Y = bodyFrame.Height * 3;
		}
		else if (flag3 && inventory[selectedItem].holdStyle == 7)
		{
			bodyFrame.Y = bodyFrame.Height * 11;
		}
		else if (flag3 && inventory[selectedItem].holdStyle == 4 && velocity.Y == 0f && gravDir == 1f)
		{
			ref Rectangle reference6 = ref bodyFrame;
			_ = bodyFrame;
			reference6.Y = 0;
		}
		else if (shieldRaised)
		{
			bodyFrame.Y = bodyFrame.Height * 10;
		}
		else if (mount.Active)
		{
			bodyFrameCounter = 0.0;
			bodyFrame.Y = bodyFrame.Height * mount.BodyFrame;
		}
		else if (grappling[0] >= 0)
		{
			sandStorm = false;
			CancelAllJumpVisualEffects();
			Vector2 vector = default(Vector2);
			((Vector2)(ref vector))._002Ector(position.X + (float)width * 0.5f, position.Y + (float)height * 0.5f);
			float num13 = 0f;
			float num14 = 0f;
			for (int m = 0; m < grapCount; m++)
			{
				num13 += Main.projectile[grappling[m]].position.X + (float)(Main.projectile[grappling[m]].width / 2);
				num14 += Main.projectile[grappling[m]].position.Y + (float)(Main.projectile[grappling[m]].height / 2);
			}
			num13 /= (float)grapCount;
			num14 /= (float)grapCount;
			num13 -= vector.X;
			num14 -= vector.Y;
			if (num14 < 0f && Math.Abs(num14) > Math.Abs(num13))
			{
				bodyFrame.Y = bodyFrame.Height * 2;
				if (gravDir == -1f)
				{
					bodyFrame.Y = bodyFrame.Height * 4;
				}
			}
			else if (num14 > 0f && Math.Abs(num14) > Math.Abs(num13))
			{
				bodyFrame.Y = bodyFrame.Height * 4;
				if (gravDir == -1f)
				{
					bodyFrame.Y = bodyFrame.Height * 2;
				}
			}
			else
			{
				bodyFrame.Y = bodyFrame.Height * 3;
			}
		}
		else if (wet && ShouldFloatInWater)
		{
			bodyFrame.Y = bodyFrame.Height * 10;
		}
		else if (swimTime > 0)
		{
			if (swimTime > 20)
			{
				ref Rectangle reference7 = ref bodyFrame;
				_ = bodyFrame;
				reference7.Y = 0;
			}
			else if (swimTime > 10)
			{
				bodyFrame.Y = bodyFrame.Height * 5;
			}
			else
			{
				ref Rectangle reference8 = ref bodyFrame;
				_ = bodyFrame;
				reference8.Y = 0;
			}
		}
		else if (velocity.Y != 0f)
		{
			if (sliding)
			{
				bodyFrame.Y = bodyFrame.Height * 3;
			}
			else if (sandStorm || carpetFrame >= 0)
			{
				bodyFrame.Y = bodyFrame.Height * 6;
			}
			else if (eocDash > 0)
			{
				bodyFrame.Y = bodyFrame.Height * 6;
			}
			else if (wings > 0)
			{
				if (wings == 22 || wings == 28 || wings == 45)
				{
					bodyFrame.Y = 0;
				}
				else if (velocity.Y > 0f)
				{
					if (controlJump)
					{
						bodyFrame.Y = bodyFrame.Height * 6;
					}
					else
					{
						bodyFrame.Y = bodyFrame.Height * 5;
					}
				}
				else
				{
					bodyFrame.Y = bodyFrame.Height * 6;
				}
			}
			else
			{
				bodyFrame.Y = bodyFrame.Height * 5;
			}
			bodyFrameCounter = 0.0;
		}
		else if (velocity.X != 0f)
		{
			if (legs == 140)
			{
				bodyFrameCounter += Math.Abs(velocity.X) * 0.5f;
				while (bodyFrameCounter > 8.0)
				{
					bodyFrameCounter -= 8.0;
					bodyFrame.Y += bodyFrame.Height;
				}
				if (bodyFrame.Y < bodyFrame.Height * 7)
				{
					bodyFrame.Y = bodyFrame.Height * 19;
				}
				else if (bodyFrame.Y > bodyFrame.Height * 19)
				{
					bodyFrame.Y = bodyFrame.Height * 7;
				}
			}
			else
			{
				bodyFrameCounter += (double)Math.Abs(velocity.X) * 1.5;
				bodyFrame.Y = legFrame.Y;
			}
		}
		else
		{
			bodyFrameCounter = 0.0;
			ref Rectangle reference9 = ref bodyFrame;
			_ = bodyFrame;
			reference9.Y = 0;
		}
		if (flag3 && itemAnimation <= 0)
		{
			ItemLoader.HoldItemFrame(inventory[selectedItem], this);
		}
		if (legs == 140)
		{
			legFrameCounter = 0.0;
			legFrame.Y = legFrame.Height * (velocity.Y != 0f).ToInt();
			int num15 = bodyFrame.Y / bodyFrame.Height;
			if (Main.OffsetsPlayerHeadgear[num15].Y == 0f)
			{
				legFrame.Y = legFrame.Height * 7;
			}
			if (wings == 22 || wings == 28)
			{
				legFrame.Y = 0;
			}
		}
		if (legs == 217 && (sitting.isSitting || sleeping.isSleeping))
		{
			legFrameCounter = 0.0;
			legFrame.Y = legFrame.Height * 5;
		}
		if (head == 259 && !skipAnimatingValuesInPlayerFrame)
		{
			rabbitOrderFrame.Update();
		}
	}

	private void CancelAllJumpVisualEffects()
	{
		ExtraJumpLoader.StopActiveJump(this, out var _);
	}

	private void CancelAllBootRunVisualEffects()
	{
		sailDash = false;
		coldDash = false;
		desertDash = false;
		fairyBoots = false;
		hellfireTreads = false;
	}

	private void UpdateFishingBobber(Item item)
	{
		switch (item.type)
		{
		case 5139:
			overrideFishingBobber = 986;
			break;
		case 5140:
			overrideFishingBobber = 987;
			break;
		case 5141:
			overrideFishingBobber = 988;
			break;
		case 5142:
			overrideFishingBobber = 989;
			break;
		case 5143:
			overrideFishingBobber = 990;
			break;
		case 5144:
			overrideFishingBobber = 991;
			break;
		case 5145:
			overrideFishingBobber = 992;
			break;
		case 5146:
			overrideFishingBobber = 993;
			break;
		}
	}

	private void UpdateBootVisualEffects(Item item)
	{
		switch (item.type)
		{
		case 128:
			vanityRocketBoots = 1;
			break;
		case 54:
			CancelAllBootRunVisualEffects();
			break;
		case 405:
		case 898:
			CancelAllBootRunVisualEffects();
			vanityRocketBoots = 2;
			break;
		case 4874:
			CancelAllBootRunVisualEffects();
			vanityRocketBoots = 5;
			hellfireTreads = true;
			break;
		case 1862:
			CancelAllBootRunVisualEffects();
			vanityRocketBoots = 3;
			break;
		case 5000:
			CancelAllBootRunVisualEffects();
			vanityRocketBoots = 4;
			break;
		case 3200:
		case 3990:
			CancelAllBootRunVisualEffects();
			sailDash = true;
			break;
		case 1579:
			CancelAllBootRunVisualEffects();
			coldDash = true;
			break;
		case 4055:
			CancelAllBootRunVisualEffects();
			desertDash = true;
			break;
		case 3993:
			CancelAllBootRunVisualEffects();
			fairyBoots = true;
			vanityRocketBoots = 2;
			break;
		}
	}

	private void UpdateVisibleAccessories()
	{
		for (int i = 3; i < 10; i++)
		{
			if (IsItemSlotUnlockedAndUsable(i))
			{
				UpdateVisibleAccessories(armor[i], hideVisibleAccessory[i], i);
			}
		}
		PlayerLoader.UpdateVisibleAccessories(this);
		for (int j = 13; j < 20; j++)
		{
			if (IsItemSlotUnlockedAndUsable(j))
			{
				Item item2 = armor[j];
				if (!ItemIsVisuallyIncompatible(item2))
				{
					UpdateVisibleAccessory(j, item2);
				}
			}
		}
		PlayerLoader.UpdateVisibleVanityAccessories(this);
		if (HeldItem.type == 4760 && ownedProjectileCounts[866] < 1)
		{
			shield = 9;
			cShield = 0;
		}
	}

	public bool ItemIsVisuallyIncompatible(Item item)
	{
		if (compositeBackArm.enabled && item.shieldSlot > 0)
		{
			return true;
		}
		if (item.shieldSlot > 0 && ItemID.Sets.IsFood[HeldItem.type])
		{
			return true;
		}
		if (body == 96 && item.backSlot > 0 && item.backSlot < ArmorIDs.Back.Count && ArmorIDs.Back.Sets.DrawInTailLayer[item.backSlot])
		{
			return true;
		}
		if (legs > 0 && ArmorIDs.Legs.Sets.IncompatibleWithFrogLeg[legs] && item.shoeSlot == 15)
		{
			return true;
		}
		if (item.balloonSlot == 18 && (body == 93 || body == 83))
		{
			return true;
		}
		return false;
	}

	private bool IsVisibleCapeBad(int accFrontSlot)
	{
		if ((uint)(accFrontSlot - 1) <= 4u || accFrontSlot == 8)
		{
			return true;
		}
		return false;
	}

	public void UpdateVisibleAccessory(int itemSlot, Item item, bool modded = false)
	{
		if (item.stringColor > 0)
		{
			stringColor = item.stringColor;
		}
		if (item.handOnSlot > 0)
		{
			handon = item.handOnSlot;
		}
		if (item.handOffSlot > 0)
		{
			handoff = item.handOffSlot;
		}
		if (item.backSlot > 0)
		{
			if (ArmorIDs.Back.Sets.DrawInBackpackLayer[item.backSlot])
			{
				backpack = item.backSlot;
			}
			else if (ArmorIDs.Back.Sets.DrawInTailLayer[item.backSlot])
			{
				tail = item.backSlot;
			}
			else
			{
				back = item.backSlot;
				front = -1;
			}
		}
		if (item.frontSlot > 0)
		{
			front = item.frontSlot;
		}
		if (sitting.isSitting)
		{
			back = -1;
		}
		if (item.shoeSlot > 0)
		{
			shoe = item.shoeSlot;
			if (!Male && ArmorIDs.Shoe.Sets.MaleToFemaleID[shoe] > 0)
			{
				shoe = ArmorIDs.Shoe.Sets.MaleToFemaleID[shoe];
			}
		}
		if (item.waistSlot > 0)
		{
			waist = item.waistSlot;
		}
		if (item.shieldSlot > 0)
		{
			shield = item.shieldSlot;
		}
		if (item.neckSlot > 0)
		{
			neck = item.neckSlot;
		}
		if (item.faceSlot > 0)
		{
			if (ArmorIDs.Face.Sets.DrawInFaceHeadLayer[item.faceSlot])
			{
				faceHead = item.faceSlot;
			}
			else if (ArmorIDs.Face.Sets.DrawInFaceFlowerLayer[item.faceSlot])
			{
				faceFlower = item.faceSlot;
			}
			else
			{
				face = item.faceSlot;
			}
		}
		if (item.balloonSlot > 0)
		{
			if (ArmorIDs.Balloon.Sets.DrawInFrontOfBackArmLayer[item.balloonSlot])
			{
				balloonFront = item.balloonSlot;
			}
			else
			{
				balloon = item.balloonSlot;
			}
		}
		if (item.beardSlot > 0)
		{
			beard = item.beardSlot;
		}
		if (item.wingSlot > 0)
		{
			wings = item.wingSlot;
		}
		if (item.type == 3580)
		{
			yoraiz0rEye = itemSlot - 2;
			if (modded)
			{
				yoraiz0rEye += 5;
			}
		}
		if (item.type == 3581)
		{
			yoraiz0rDarkness = true;
		}
		if (item.type == 3929)
		{
			leinforsHair = true;
		}
		if (item.type == 4404)
		{
			hasFloatingTube = true;
		}
		if (item.type == 4563)
		{
			hasUnicornHorn = true;
		}
		if (item.type == 1987)
		{
			hasAngelHalo = true;
		}
		if (item.type == 5075)
		{
			hasRainbowCursor = true;
		}
	}

	public void SetArmorEffectVisuals(Player drawPlayer)
	{
		if (drawPlayer.head == 111 && drawPlayer.body == 73 && drawPlayer.legs == 62)
		{
			armorEffectDrawShadowSubtle = true;
			armorEffectDrawOutlines = true;
		}
		if (drawPlayer.head == 134 && drawPlayer.body == 95 && drawPlayer.legs == 79)
		{
			armorEffectDrawShadowSubtle = true;
			armorEffectDrawOutlines = true;
		}
		if (drawPlayer.head == 107 && drawPlayer.body == 69 && drawPlayer.legs == 58)
		{
			armorEffectDrawShadowSubtle = true;
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.head == 108 && drawPlayer.body == 70 && drawPlayer.legs == 59)
		{
			armorEffectDrawShadowSubtle = true;
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.head == 109 && drawPlayer.body == 71 && drawPlayer.legs == 60)
		{
			armorEffectDrawShadowSubtle = true;
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.head == 110 && drawPlayer.body == 72 && drawPlayer.legs == 61)
		{
			armorEffectDrawShadowSubtle = true;
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.head == 193 && drawPlayer.body == 194 && drawPlayer.legs == 134)
		{
			armorEffectDrawShadowSubtle = true;
			armorEffectDrawShadowLokis = true;
			armorEffectDrawOutlines = true;
		}
		if (drawPlayer.mount.Active && drawPlayer.mount.Type == 3 && drawPlayer.velocity.Y != 0f && !drawPlayer.SlimeDontHyperJump)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.mount.Active && drawPlayer.mount.Type == 10 && Math.Abs(drawPlayer.velocity.X) > drawPlayer.mount.DashSpeed - drawPlayer.mount.RunSpeed / 2f)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.mount.Active && drawPlayer.mount.Type == 44 && Math.Abs(drawPlayer.velocity.X) > drawPlayer.mount.DashSpeed - drawPlayer.mount.RunSpeed / 4f)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.mount.Active && drawPlayer.mount.Type == 45 && Math.Abs(drawPlayer.velocity.X) > drawPlayer.mount.DashSpeed * 0.9f)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.mount.Active && drawPlayer.mount.Type == 14 && Math.Abs(drawPlayer.velocity.X) > drawPlayer.mount.RunSpeed / 2f)
		{
			armorEffectDrawShadowBasilisk = true;
		}
		if (drawPlayer.mount.Active && drawPlayer.mount.Type == 48)
		{
			armorEffectDrawOutlines = true;
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.body == 67 && drawPlayer.legs == 56 && drawPlayer.head >= 103 && drawPlayer.head <= 105)
		{
			armorEffectDrawShadow = true;
		}
		if ((drawPlayer.head == 78 || drawPlayer.head == 79 || drawPlayer.head == 80) && drawPlayer.body == 51 && drawPlayer.legs == 47)
		{
			armorEffectDrawShadowSubtle = true;
		}
		if (drawPlayer.head == 200 && drawPlayer.body == 198 && drawPlayer.legs == 142)
		{
			armorEffectDrawShadowLokis = true;
			armorEffectDrawOutlinesForbidden = true;
		}
		if (drawPlayer.head == 171 && drawPlayer.body == 177 && drawPlayer.legs == 112)
		{
			armorEffectDrawShadow = true;
			armorEffectDrawOutlines = true;
		}
		if (drawPlayer.head == 169 && drawPlayer.body == 175 && drawPlayer.legs == 110)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.head == 170 && drawPlayer.body == 176 && drawPlayer.legs == 111)
		{
			armorEffectDrawShadowLokis = true;
			armorEffectDrawOutlines = true;
		}
		if (drawPlayer.body == 209 && drawPlayer.legs == 159)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.eocDash > 0)
		{
			armorEffectDrawShadowEOCShield = true;
		}
		else if (drawPlayer.dashDelay < 0)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.head == 5 && drawPlayer.body == 5 && drawPlayer.legs == 5)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.head == 74 && drawPlayer.body == 48 && drawPlayer.legs == 44)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.head == 76 && drawPlayer.body == 49 && drawPlayer.legs == 45)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.head == 7 && drawPlayer.body == 7 && drawPlayer.legs == 7)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.head == 22 && drawPlayer.body == 14 && drawPlayer.legs == 14)
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.dye[0].dye == 30 && drawPlayer.dye[1].dye == 30 && drawPlayer.dye[2].dye == 30 && drawPlayer.head == 4 && drawPlayer.body == 27 && drawPlayer.legs == 26)
		{
			armorEffectDrawShadow = true;
			armorEffectDrawOutlines = true;
		}
		if (drawPlayer.head == 189 && drawPlayer.body == 190 && drawPlayer.legs == 130)
		{
			armorEffectDrawOutlines = true;
		}
		if (drawPlayer.body == 17 && drawPlayer.legs == 16 && (drawPlayer.head == 29 || drawPlayer.head == 30 || drawPlayer.head == 31))
		{
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.body == 19 && drawPlayer.legs == 18 && (drawPlayer.head == 35 || drawPlayer.head == 36 || drawPlayer.head == 37))
		{
			armorEffectDrawOutlines = true;
		}
		if ((drawPlayer.body == 24 || drawPlayer.body == 229) && (drawPlayer.legs == 23 || drawPlayer.legs == 212) && (drawPlayer.head == 43 || drawPlayer.head == 41 || drawPlayer.head == 42 || drawPlayer.head == 254 || drawPlayer.head == 255 || drawPlayer.head == 256 || drawPlayer.head == 257 || drawPlayer.head == 258))
		{
			armorEffectDrawOutlines = true;
			armorEffectDrawShadow = true;
		}
		if (drawPlayer.head == 157 && drawPlayer.legs == 98 && drawPlayer.body != 105)
		{
			_ = drawPlayer.body;
		}
		if (drawPlayer.body == 36 && drawPlayer.head == 56)
		{
			armorEffectDrawOutlines = true;
		}
		if (drawPlayer.head == 267)
		{
			yoraiz0rDarkness = true;
		}
		ItemLoader.ArmorSetShadows(drawPlayer);
		if (drawPlayer.stoned || drawPlayer.stealth != 1f)
		{
			armorEffectDrawOutlines = false;
			armorEffectDrawShadow = false;
			armorEffectDrawShadowSubtle = false;
		}
	}

	public static int SetMatch(SetMatchRequest request, ref bool somethingSpecial)
	{
		int armorSlotRequested = request.ArmorSlotRequested;
		int num = -1;
		bool male = request.Male;
		num = armorSlotRequested switch
		{
			1 => request.Body, 
			2 => request.Legs, 
			_ => request.Head, 
		};
		int num2 = -1;
		if (armorSlotRequested == 0 && num == 201)
		{
			num2 = (male ? 201 : 202);
		}
		if (armorSlotRequested == 1)
		{
			bool flag = true;
			switch (num)
			{
			case 15:
				num2 = 88;
				break;
			case 36:
				num2 = 89;
				break;
			case 41:
				num2 = 97;
				break;
			case 42:
				num2 = 90;
				break;
			case 58:
				num2 = 91;
				break;
			case 59:
				num2 = 92;
				break;
			case 60:
				num2 = 93;
				break;
			case 61:
				num2 = 94;
				break;
			case 62:
				num2 = 95;
				break;
			case 63:
				num2 = 96;
				break;
			case 77:
				num2 = 121;
				break;
			case 165:
				num2 = ((!male) ? 99 : 118);
				break;
			case 166:
				flag = false;
				num2 = ((!male) ? 100 : 119);
				break;
			case 167:
				num2 = (male ? 101 : 102);
				break;
			case 180:
				num2 = 115;
				break;
			case 181:
				num2 = 116;
				break;
			case 183:
				num2 = (male ? 136 : 123);
				break;
			case 191:
				num2 = 131;
				break;
			case 93:
				num2 = 165;
				break;
			case 90:
				num2 = 166;
				break;
			case 88:
				num2 = 168;
				break;
			case 81:
				if (request.Legs == 0)
				{
					num2 = 169;
				}
				break;
			case 213:
				num2 = 187;
				break;
			case 215:
				num2 = 189;
				break;
			case 219:
				num2 = 196;
				break;
			case 221:
				num2 = 199;
				break;
			case 223:
				num2 = 204;
				break;
			case 231:
				num2 = 214;
				break;
			case 232:
				num2 = 215;
				break;
			case 233:
				num2 = 216;
				break;
			case 241:
				num2 = 229;
				break;
			}
			if (num2 != -1)
			{
				somethingSpecial = flag;
			}
		}
		if (armorSlotRequested == 2)
		{
			switch (num)
			{
			case 83:
				if (male)
				{
					num2 = 117;
				}
				break;
			case 84:
				if (male)
				{
					num2 = 120;
				}
				break;
			case 132:
				if (male)
				{
					num2 = 135;
				}
				break;
			case 57:
				if (male)
				{
					num2 = 137;
				}
				break;
			case 180:
				if (!male)
				{
					num2 = 179;
				}
				break;
			case 184:
				if (!male)
				{
					num2 = 183;
				}
				break;
			case 146:
				num2 = (male ? 146 : 147);
				break;
			case 154:
				num2 = (male ? 155 : 154);
				break;
			case 158:
				if (male)
				{
					num2 = 157;
				}
				break;
			case 191:
				if (!male)
				{
					num2 = 192;
				}
				break;
			case 193:
				if (!male)
				{
					num2 = 194;
				}
				break;
			case 197:
				if (!male)
				{
					num2 = 198;
				}
				break;
			case 203:
				if (!male)
				{
					num2 = 202;
				}
				break;
			case 208:
				if (!male)
				{
					num2 = 207;
				}
				break;
			case 219:
				if (!male)
				{
					num2 = 220;
				}
				break;
			case 232:
				if (!male)
				{
					num2 = 233;
				}
				break;
			}
		}
		ItemLoader.SetMatch(armorSlotRequested, num, male, ref num2, ref somethingSpecial);
		return num2;
	}

	public void Teleport(Vector2 newPos, int Style = 0, int extraInfo = 0)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			_funkytownAchievementCheckCooldown = 100;
			environmentBuffImmunityTimer = 4;
			if (Style != 10)
			{
				RemoveAllGrapplingHooks();
			}
			StopVanityActions();
			if (shimmering || shimmerWet)
			{
				shimmering = false;
				shimmerWet = false;
				wet = false;
				ClearBuff(353);
			}
			int extraInfo2 = 0;
			if (Style == 4)
			{
				extraInfo2 = lastPortalColorIndex;
			}
			if (Style == 9)
			{
				lastTeleportPylonStyleUsed = extraInfo;
				extraInfo2 = lastTeleportPylonStyleUsed;
			}
			float num = MathHelper.Clamp(1f - teleportTime * 0.99f, 0.01f, 1f);
			Vector2 otherPosition = position;
			Main.TeleportEffect(getRect(), Style, extraInfo2, num, TeleportationSide.Entry, newPos);
			float num2 = Vector2.Distance(position, newPos);
			PressurePlateHelper.UpdatePlayerPosition(this);
			position = newPos;
			if (Style == 8)
			{
				SoundEngine.PlaySound(in SoundID.Item6, otherPosition);
				SoundEngine.PlaySound(in SoundID.Item6, newPos);
			}
			fallStart = (int)(position.Y / 16f);
			if (whoAmI == Main.myPlayer)
			{
				bool flag = false;
				Vector2 val = new Vector2((float)Main.screenWidth, (float)Main.screenHeight);
				if (num2 < ((Vector2)(ref val)).Length() / 2f + 100f)
				{
					int time = 0;
					if (Style == 1)
					{
						time = 10;
					}
					Main.SetCameraLerp(0.1f, time);
					flag = true;
				}
				else
				{
					NPC.ResetNetOffsets();
					Main.BlackFadeIn = 255;
					Lighting.Clear();
					Main.screenLastPosition = Main.screenPosition;
					Main.screenPosition.X = position.X + (float)(width / 2) - (float)(Main.screenWidth / 2);
					Main.screenPosition.Y = position.Y + (float)(height / 2) - (float)(Main.screenHeight / 2);
					Main.instantBGTransitionCounter = 10;
					ForceUpdateBiomes();
				}
				if (num > 0.1f || !flag || Style != 0)
				{
					if (Main.mapTime < 5)
					{
						Main.mapTime = 5;
					}
					Main.maxQ = true;
					Main.renderNow = true;
				}
			}
			if (Style == 4)
			{
				lastPortalColorIndex = extraInfo;
				extraInfo2 = lastPortalColorIndex;
				portalPhysicsFlag = true;
				gravity = 0f;
			}
			PressurePlateHelper.UpdatePlayerPosition(this);
			ResetAdvancedShadows();
			for (int i = 0; i < 3; i++)
			{
				UpdateSocialShadow();
			}
			oldPosition = position + BlehOldPositionFixer;
			Main.TeleportEffect(getRect(), Style, extraInfo2, num, TeleportationSide.Exit, otherPosition);
			teleportTime = 1f;
			teleportStyle = Style;
		}
		catch
		{
		}
	}

	public void DoPotionOfReturnTeleportationAndSetTheComebackPoint()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		RemoveAllGrapplingHooks();
		PotionOfReturnOriginalUsePosition = base.Bottom;
		bool flag = immune;
		int num = immuneTime;
		StopVanityActions(multiplayerBroadcast: false);
		Spawn(PlayerSpawnContext.RecallFromItem);
		PotionOfReturnHomePosition = base.Bottom;
		NetMessage.SendData(13, -1, whoAmI, null, whoAmI);
		immune = flag;
		immuneTime = num;
	}

	public void DoPotionOfReturnReturnToOriginalUsePosition()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if (PotionOfReturnOriginalUsePosition.HasValue)
		{
			Vector2 newPos = PotionOfReturnOriginalUsePosition.Value + base.Size * new Vector2(-0.5f, -1f);
			int num = 8;
			Teleport(newPos, num);
			NetMessage.SendData(65, -1, -1, null, 0, whoAmI, newPos.X, newPos.Y, num);
			PotionOfReturnOriginalUsePosition = null;
			PotionOfReturnHomePosition = null;
		}
	}

	public void AutoFinchStaff()
	{
		int num = FindItem(4281);
		if (num != -1)
		{
			Item item = inventory[num];
			AddBuff(item.buffType, 3600, quiet: false);
		}
	}

	public void Spawn(PlayerSpawnContext context)
	{
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_033e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0340: Unknown result type (might be due to invalid IL or missing references)
		//IL_0356: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0397: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		Main.LocalPlayer.creativeInterface = false;
		_funkytownAchievementCheckCooldown = 100;
		bool flag = false;
		if (context == PlayerSpawnContext.SpawningIntoWorld)
		{
			if (Main.netMode == 0 && unlockedBiomeTorches)
			{
				NPC nPC = new NPC();
				nPC.SetDefaults(664);
				Main.BestiaryTracker.Kills.RegisterKill(nPC);
			}
			if (dead)
			{
				AdjustRespawnTimerForWorldJoining(this);
				if (dead)
				{
					flag = true;
				}
			}
		}
		StopVanityActions();
		if (whoAmI == Main.myPlayer)
		{
			Main.NotifyOfEvent(GameNotificationType.SpawnOrDeath);
		}
		if (whoAmI == Main.myPlayer)
		{
			if (Main.mapTime < 5)
			{
				Main.mapTime = 5;
			}
			Main.instantBGTransitionCounter = 10;
			FindSpawn();
			if (!CheckSpawn(SpawnX, SpawnY))
			{
				SpawnX = -1;
				SpawnY = -1;
			}
			Main.maxQ = true;
			NPC.ResetNetOffsets();
		}
		if (Main.netMode == 1 && whoAmI == Main.myPlayer)
		{
			NetMessage.SendData(12, -1, -1, null, Main.myPlayer, (int)(byte)context);
		}
		headPosition = Vector2.Zero;
		bodyPosition = Vector2.Zero;
		legPosition = Vector2.Zero;
		headRotation = 0f;
		bodyRotation = 0f;
		legRotation = 0f;
		rabbitOrderFrame.Reset();
		lavaTime = lavaMax;
		if (!flag)
		{
			if (statLife <= 0)
			{
				int num = statLifeMax2 / 2;
				statLife = 100;
				if (num > statLife)
				{
					statLife = num;
				}
				breath = breathMax;
				if (spawnMax)
				{
					statLife = statLifeMax2;
					statMana = statManaMax2;
				}
			}
			immune = true;
			if (dead)
			{
				PlayerLoader.OnRespawn(this);
			}
			dead = false;
			immuneTime = 0;
		}
		active = true;
		Vector2 value = position;
		if (SpawnX >= 0 && SpawnY >= 0)
		{
			_ = SpawnX;
			_ = SpawnY;
			Spawn_SetPosition(SpawnX, SpawnY);
		}
		else
		{
			Spawn_SetPositionAtWorldSpawn();
		}
		wet = false;
		wetCount = 0;
		lavaWet = false;
		fallStart = (int)(position.Y / 16f);
		fallStart2 = fallStart;
		velocity.X = 0f;
		velocity.Y = 0f;
		ResetAdvancedShadows();
		for (int i = 0; i < 3; i++)
		{
			UpdateSocialShadow();
		}
		oldPosition = position + BlehOldPositionFixer;
		SetTalkNPC(-1);
		if (whoAmI == Main.myPlayer)
		{
			Main.npcChatCornerItem = 0;
		}
		if (!flag)
		{
			if (pvpDeath)
			{
				pvpDeath = false;
				immuneTime = 300;
				statLife = statLifeMax;
			}
			else if (context == PlayerSpawnContext.ReviveFromDeath)
			{
				immuneTime = 180;
			}
			else
			{
				immuneTime = 60;
			}
			if (immuneTime > 0 && !hostile)
			{
				immuneNoBlink = true;
			}
		}
		if (whoAmI == Main.myPlayer)
		{
			float num2 = Vector2.Distance(value, position);
			Vector2 val = new Vector2((float)Main.screenWidth, (float)Main.screenHeight);
			bool flag2 = num2 < ((Vector2)(ref val)).Length() / 2f + 100f;
			if (flag2)
			{
				Main.SetCameraLerp(0.1f, 0);
				flag2 = true;
			}
			else
			{
				Main.BlackFadeIn = 255;
				Lighting.Clear();
				Main.screenLastPosition = Main.screenPosition;
				Main.instantBGTransitionCounter = 10;
			}
			if (!flag2)
			{
				Main.renderNow = true;
			}
			if (Main.netMode == 1)
			{
				Netplay.AddCurrentServerToRecentList();
			}
			if (!flag2)
			{
				Main.screenPosition.X = position.X + (float)(width / 2) - (float)(Main.screenWidth / 2);
				Main.screenPosition.Y = position.Y + (float)(height / 2) - (float)(Main.screenHeight / 2);
				ForceUpdateBiomes();
			}
		}
		if (flag)
		{
			immuneAlpha = 255;
		}
		UpdateGraveyard(now: true);
		if (whoAmI == Main.myPlayer && context == PlayerSpawnContext.ReviveFromDeath && difficulty == 3)
		{
			AutoFinchStaff();
		}
		if (whoAmI == Main.myPlayer && context == PlayerSpawnContext.SpawningIntoWorld)
		{
			Main.ReleaseHostAndPlayProcess();
			RefreshItems();
			SetPlayerDataToOutOfClassFields();
			Main.LocalGolfState.SetScoreTime();
			Main.ActivePlayerFileData.StartPlayTimer();
			Hooks.EnterWorld(whoAmI);
		}
	}

	public bool Spawn_GetPositionAtWorldSpawn(ref int floorX, ref int floorY)
	{
		int spawnTileX = Main.spawnTileX;
		int num = Main.spawnTileY;
		if (!Spawn_IsAreaAValidWorldSpawn(spawnTileX, num))
		{
			bool flag = false;
			if (!flag)
			{
				for (int i = 0; i < 30; i++)
				{
					if (Spawn_IsAreaAValidWorldSpawn(spawnTileX, num - i))
					{
						num -= i;
						flag = true;
						break;
					}
				}
			}
			if (!flag)
			{
				for (int j = 0; j < 30; j++)
				{
					if (Spawn_IsAreaAValidWorldSpawn(spawnTileX, num - j))
					{
						num -= j;
						flag = true;
						break;
					}
				}
			}
			if (flag)
			{
				floorX = spawnTileX;
				floorY = num;
				return true;
			}
			return false;
		}
		num = Spawn_DescendFromDefaultSpace(spawnTileX, num);
		floorX = spawnTileX;
		floorY = num;
		return false;
	}

	private void Spawn_SetPositionAtWorldSpawn()
	{
		int floorX = Main.spawnTileX;
		int floorY = Main.spawnTileY;
		bool num = Spawn_GetPositionAtWorldSpawn(ref floorX, ref floorY);
		Spawn_SetPosition(floorX, floorY);
		if (num && !Spawn_IsAreaAValidWorldSpawn(floorX, floorY))
		{
			Spawn_ForceClearArea(floorX, floorY);
		}
	}

	private static int Spawn_DescendFromDefaultSpace(int x, int y)
	{
		for (int i = 0; i < 50; i++)
		{
			bool flag = false;
			for (int j = -1; j <= 1; j++)
			{
				Tile tile = Main.tile[x + j, y + i];
				if (tile.nactive() && (Main.tileSolid[tile.type] || !Main.tileSolidTop[tile.type]))
				{
					flag = true;
					break;
				}
			}
			if (flag)
			{
				y += i;
				break;
			}
		}
		return y;
	}

	private static void Spawn_ForceClearArea(int floorX, int floorY)
	{
		for (int i = floorX - 1; i < floorX + 2; i++)
		{
			for (int j = floorY - 3; j < floorY; j++)
			{
				if (Main.tile[i, j] != null)
				{
					if (Main.tile[i, j].nactive() && Main.tileSolid[Main.tile[i, j].type] && !Main.tileSolidTop[Main.tile[i, j].type])
					{
						WorldGen.KillTile(i, j);
					}
					if (Main.tile[i, j].liquid > 0)
					{
						Main.tile[i, j].lava(lava: false);
						Main.tile[i, j].liquid = 0;
						WorldGen.SquareTileFrame(i, j);
					}
				}
			}
		}
	}

	private bool Spawn_IsAreaAValidWorldSpawn(int floorX, int floorY)
	{
		for (int i = floorX - 1; i < floorX + 2; i++)
		{
			for (int j = floorY - 3; j < floorY; j++)
			{
				if (Main.tile[i, j] != null)
				{
					if (Main.tile[i, j].nactive() && Main.tileSolid[Main.tile[i, j].type] && !Main.tileSolidTop[Main.tile[i, j].type])
					{
						return false;
					}
					if (Main.tile[i, j].liquid > 0)
					{
						return false;
					}
				}
			}
		}
		return true;
	}

	private void Spawn_SetPosition(int floorX, int floorY)
	{
		position.X = floorX * 16 + 8 - width / 2;
		position.Y = floorY * 16 - height;
	}

	public void SetImmuneTimeForAllTypes(int time)
	{
		immune = true;
		immuneTime = time;
		for (int i = 0; i < hurtCooldowns.Length; i++)
		{
			hurtCooldowns[i] = time;
		}
	}

	public void ShadowDodge()
	{
		SetImmuneTimeForAllTypes(longInvince ? 120 : 80);
		if (whoAmI != Main.myPlayer)
		{
			return;
		}
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffTime[i] > 0 && buffType[i] == 59)
			{
				DelBuff(i);
			}
		}
		PutHallowedArmorSetBonusOnCooldown();
		NetMessage.SendData(62, -1, -1, null, whoAmI, 2f);
	}

	private void PutHallowedArmorSetBonusOnCooldown()
	{
		shadowDodgeTimer = 1800;
	}

	public void BrainOfConfusionDodge()
	{
		SetImmuneTimeForAllTypes(longInvince ? 120 : 80);
		brainOfConfusionDodgeAnimationCounter = 300;
		if (whoAmI == Main.myPlayer)
		{
			AddBuff(321, 240, quiet: false);
			NetMessage.SendData(62, -1, -1, null, whoAmI, 4f);
		}
	}

	public void NinjaDodge()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_0313: Unknown result type (might be due to invalid IL or missing references)
		//IL_0318: Unknown result type (might be due to invalid IL or missing references)
		//IL_0353: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0436: Unknown result type (might be due to invalid IL or missing references)
		//IL_043d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0443: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04de: Unknown result type (might be due to invalid IL or missing references)
		//IL_0519: Unknown result type (might be due to invalid IL or missing references)
		//IL_0520: Unknown result type (might be due to invalid IL or missing references)
		//IL_0526: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_05bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c1: Unknown result type (might be due to invalid IL or missing references)
		SetImmuneTimeForAllTypes(longInvince ? 120 : 80);
		for (int i = 0; i < 100; i++)
		{
			int num = Dust.NewDust(new Vector2(position.X, position.Y), width, height, 31, 0f, 0f, 100, default(Color), 2f);
			Main.dust[num].position.X += Main.rand.Next(-20, 21);
			Main.dust[num].position.Y += Main.rand.Next(-20, 21);
			Dust obj = Main.dust[num];
			obj.velocity *= 0.4f;
			Main.dust[num].scale *= 1f + (float)Main.rand.Next(40) * 0.01f;
			Main.dust[num].shader = GameShaders.Armor.GetSecondaryShader(cWaist, this);
			if (Main.rand.Next(2) == 0)
			{
				Main.dust[num].scale *= 1f + (float)Main.rand.Next(40) * 0.01f;
				Main.dust[num].noGravity = true;
			}
		}
		int num2 = Gore.NewGore(new Vector2(position.X + (float)(width / 2) - 24f, position.Y + (float)(height / 2) - 24f), default(Vector2), Main.rand.Next(61, 64));
		Main.gore[num2].scale = 1.5f;
		Main.gore[num2].velocity.X = (float)Main.rand.Next(-50, 51) * 0.01f;
		Main.gore[num2].velocity.Y = (float)Main.rand.Next(-50, 51) * 0.01f;
		Gore obj2 = Main.gore[num2];
		obj2.velocity *= 0.4f;
		num2 = Gore.NewGore(new Vector2(position.X + (float)(width / 2) - 24f, position.Y + (float)(height / 2) - 24f), default(Vector2), Main.rand.Next(61, 64));
		Main.gore[num2].scale = 1.5f;
		Main.gore[num2].velocity.X = 1.5f + (float)Main.rand.Next(-50, 51) * 0.01f;
		Main.gore[num2].velocity.Y = 1.5f + (float)Main.rand.Next(-50, 51) * 0.01f;
		Gore obj3 = Main.gore[num2];
		obj3.velocity *= 0.4f;
		num2 = Gore.NewGore(new Vector2(position.X + (float)(width / 2) - 24f, position.Y + (float)(height / 2) - 24f), default(Vector2), Main.rand.Next(61, 64));
		Main.gore[num2].scale = 1.5f;
		Main.gore[num2].velocity.X = -1.5f - (float)Main.rand.Next(-50, 51) * 0.01f;
		Main.gore[num2].velocity.Y = 1.5f + (float)Main.rand.Next(-50, 51) * 0.01f;
		Gore obj4 = Main.gore[num2];
		obj4.velocity *= 0.4f;
		num2 = Gore.NewGore(new Vector2(position.X + (float)(width / 2) - 24f, position.Y + (float)(height / 2) - 24f), default(Vector2), Main.rand.Next(61, 64));
		Main.gore[num2].scale = 1.5f;
		Main.gore[num2].velocity.X = 1.5f + (float)Main.rand.Next(-50, 51) * 0.01f;
		Main.gore[num2].velocity.Y = -1.5f - (float)Main.rand.Next(-50, 51) * 0.01f;
		Gore obj5 = Main.gore[num2];
		obj5.velocity *= 0.4f;
		num2 = Gore.NewGore(new Vector2(position.X + (float)(width / 2) - 24f, position.Y + (float)(height / 2) - 24f), default(Vector2), Main.rand.Next(61, 64));
		Main.gore[num2].scale = 1.5f;
		Main.gore[num2].velocity.X = -1.5f - (float)Main.rand.Next(-50, 51) * 0.01f;
		Main.gore[num2].velocity.Y = -1.5f - (float)Main.rand.Next(-50, 51) * 0.01f;
		Gore obj6 = Main.gore[num2];
		obj6.velocity *= 0.4f;
		if (whoAmI == Main.myPlayer)
		{
			NetMessage.SendData(62, -1, -1, null, whoAmI, 1f);
		}
	}

	public void ApplyArmorSoundAndDustChanges()
	{
		int num = armor[0].headSlot;
		int num2 = armor[1].bodySlot;
		int num3 = armor[2].legSlot;
		if (armor[10].headSlot >= 0)
		{
			num = armor[10].headSlot;
		}
		if (armor[11].bodySlot >= 0)
		{
			num2 = armor[11].bodySlot;
		}
		if (armor[12].legSlot >= 0)
		{
			num3 = armor[12].legSlot;
		}
		if ((wereWolf || forceWerewolf) && !hideWolf)
		{
			num3 = 20;
			num2 = 21;
			num = 38;
		}
		if ((num == 75 || num == 7) && num2 == 7 && num3 == 7)
		{
			boneArmor = true;
		}
		if (num2 == 27 && num == 46 && num3 == 26)
		{
			frostArmor = true;
		}
	}

	private static float VanillaBaseDefenseEffectiveness()
	{
		if (Main.masterMode)
		{
			return 1f;
		}
		if (Main.expertMode)
		{
			return 0.75f;
		}
		return 0.5f;
	}

	internal double Hurt(PlayerDeathReason damageSource, int Damage, int hitDirection, bool pvp, bool quiet, bool Crit, int cooldownCounter, bool dodgeable = true, float armorPenetration = 0f)
	{
		return Hurt(damageSource, Damage, hitDirection, pvp, quiet, cooldownCounter, dodgeable, armorPenetration);
	}

	public double Hurt(PlayerDeathReason damageSource, int Damage, int hitDirection, bool pvp = false, bool quiet = false, int cooldownCounter = -1, bool dodgeable = true, float armorPenetration = 0f, float scalingArmorPenetration = 0f, float knockback = 4.5f)
	{
		HurtInfo info;
		return Hurt(damageSource, Damage, hitDirection, out info, pvp, quiet, cooldownCounter, dodgeable, armorPenetration, scalingArmorPenetration, knockback);
	}

	public double Hurt(PlayerDeathReason damageSource, int Damage, int hitDirection, out HurtInfo info, bool pvp = false, bool quiet = false, int cooldownCounter = -1, bool dodgeable = true, float armorPenetration = 0f, float scalingArmorPenetration = 0f, float knockback = 4.5f)
	{
		info = default(HurtInfo);
		if (shimmering && AllowShimmerDodge(damageSource, cooldownCounter, dodgeable))
		{
			return 0.0;
		}
		if (creativeGodMode)
		{
			return 0.0;
		}
		if (PlayerLoader.ImmuneTo(this, damageSource, cooldownCounter, dodgeable))
		{
			return 0.0;
		}
		bool flag = !immune;
		bool flag2 = false;
		switch (cooldownCounter)
		{
		case 0:
		case 1:
		case 3:
		case 4:
			flag = hurtCooldowns[cooldownCounter] <= 0;
			break;
		case 2:
			flag2 = true;
			cooldownCounter = -1;
			break;
		}
		if (flag)
		{
			HurtModifiers hurtModifiers = new HurtModifiers();
			hurtModifiers.DamageSource = damageSource;
			hurtModifiers.PvP = pvp;
			hurtModifiers.CooldownCounter = cooldownCounter;
			hurtModifiers.Dodgeable = dodgeable;
			hurtModifiers.HitDirection = hitDirection;
			HurtModifiers modifiers = hurtModifiers;
			PlayerLoader.ModifyHurt(this, ref modifiers);
			modifiers.ArmorPenetration += armorPenetration;
			modifiers.ScalingArmorPenetration += scalingArmorPenetration;
			if (flag2)
			{
				modifiers.Knockback.Base += 6f;
				modifiers.KnockbackImmunityEffectiveness *= 0.8f;
			}
			ApplyVanillaHurtEffectModifiers(ref modifiers);
			info = modifiers.ToHurtInfo(Damage, statDefense, pvp ? 0.5f : DefenseEffectiveness.Value, knockback, noKnockback);
			if (dodgeable)
			{
				if (whoAmI == Main.myPlayer && PlayerLoader.FreeDodge(this, in info))
				{
					return 0.0;
				}
				if (whoAmI == Main.myPlayer && blackBelt && Main.rand.Next(10) == 0)
				{
					NinjaDodge();
					return 0.0;
				}
				if (whoAmI == Main.myPlayer && brainOfConfusionItem != null && !brainOfConfusionItem.IsAir && Main.rand.Next(6) == 0 && FindBuffIndex(321) == -1)
				{
					BrainOfConfusionDodge();
					return 0.0;
				}
				if (whoAmI == Main.myPlayer && shadowDodge)
				{
					ShadowDodge();
					return 0.0;
				}
				if (whoAmI == Main.myPlayer && PlayerLoader.ConsumableDodge(this, in info))
				{
					return 0.0;
				}
			}
			Hurt(info, quiet);
			return info.Damage;
		}
		return 0.0;
	}

	private void OnHurt_Part1(HurtInfo info)
	{
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		int hitDirection = info.HitDirection;
		if (whoAmI == Main.myPlayer && panic)
		{
			AddBuff(63, 480);
		}
		if (whoAmI == Main.myPlayer && setSquireT2)
		{
			AddBuff(205, 300);
		}
		stealth = 1f;
		if (Main.netMode == 1)
		{
			NetMessage.SendData(84, -1, -1, null, whoAmI);
		}
		if (whoAmI == Main.myPlayer)
		{
			Main.NotifyOfEvent(GameNotificationType.Damage);
			if (hasFootball)
			{
				for (int i = 0; i < 59; i++)
				{
					if (inventory[i].stack > 0 && inventory[i].type == 4743)
					{
						Projectile.NewProjectile(GetProjectileSource_Misc(12), base.Center, new Vector2((float)(-hitDirection * 4), -6f), 861, 0, 0f, whoAmI, 0f, 1f);
						inventory[i].SetDefaults();
						if (i == 58)
						{
							Main.mouseItem = new Item();
						}
					}
				}
			}
		}
		if (inventory[selectedItem].type == 4790 || inventory[selectedItem].type == 4788 || inventory[selectedItem].type == 4789)
		{
			for (int j = 0; j < 1000; j++)
			{
				if (Main.projectile[j].active && Main.projectile[j].owner == whoAmI && (Main.projectile[j].type == 879 || Main.projectile[j].type == 877 || Main.projectile[j].type == 878))
				{
					Main.projectile[j].active = false;
				}
			}
		}
		if (channel && inventory[selectedItem].InterruptChannelOnHurt)
		{
			channel = false;
		}
		if (itemAnimation > 0 && inventory[selectedItem].StopAnimationOnHurt)
		{
			channel = false;
			itemAnimation = 0;
			itemAnimationMax = 0;
		}
		if (!invis)
		{
			return;
		}
		for (int k = 0; k < maxBuffs; k++)
		{
			if (buffType[k] == 10)
			{
				DelBuff(k);
			}
		}
	}

	private void ApplyVanillaHurtEffectModifiers(ref HurtModifiers modifiers)
	{
		modifiers.FinalDamage *= Math.Max(1f - endurance, 0f);
		if (setSolar && solarShields > 0)
		{
			modifiers.FinalDamage *= 0.8f;
		}
		if (beetleDefense && beetleOrbs > 0)
		{
			modifiers.FinalDamage *= 1f - 0.15f * (float)beetleOrbs;
		}
		if (defendedByPaladin && whoAmI == Main.myPlayer && TeammateHasPalidinShieldAndCanTakeDamage())
		{
			modifiers.FinalDamage *= 0.75f;
		}
	}

	private void OnHurt_Part2(HurtInfo info)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		PlayerDeathReason damageSource = info.DamageSource;
		if (ConsumeSolarFlare() && whoAmI == Main.myPlayer)
		{
			IEntitySource spawnSource = GetProjectileSource_SetBonus(1);
			Entity entity = null;
			if (damageSource.TryGetCausingEntity(out entity))
			{
				spawnSource = GetProjectileSource_OnHurt(entity, 1);
			}
			int num4 = Projectile.NewProjectile(spawnSource, base.Center.X, base.Center.Y, 0f, 0f, 608, (int)GetTotalDamage(DamageClass.Melee).ApplyTo(150f), 15f, Main.myPlayer);
			Main.projectile[num4].netUpdate = true;
			Main.projectile[num4].Kill();
		}
		if (beetleDefense && beetleOrbs > 0)
		{
			beetleOrbs--;
			for (int i = 0; i < maxBuffs; i++)
			{
				if (buffType[i] >= 95 && buffType[i] <= 97)
				{
					DelBuff(i);
				}
			}
			if (beetleOrbs > 0)
			{
				AddBuff(95 + beetleOrbs - 1, 5, quiet: false);
			}
			beetleCounter = 0f;
		}
		if (magicCuffs)
		{
			int num5 = info.SourceDamage;
			statMana += num5;
			if (statMana > statManaMax2)
			{
				statMana = statManaMax2;
			}
			ManaEffect(num5);
		}
		if (!defendedByPaladin || whoAmI == Main.myPlayer || !Main.player[Main.myPlayer].hasPaladinShield)
		{
			return;
		}
		Player player = Main.player[Main.myPlayer];
		if (player.team != team || team == 0)
		{
			return;
		}
		float num6 = player.Distance(base.Center);
		bool flag3 = num6 < 800f;
		if (flag3)
		{
			for (int j = 0; j < 255; j++)
			{
				if (j != Main.myPlayer && Main.player[j].active && !Main.player[j].dead && !Main.player[j].immune && Main.player[j].hasPaladinShield && Main.player[j].team == team && (float)Main.player[j].statLife > (float)Main.player[j].statLifeMax2 * 0.25f)
				{
					float num7 = Main.player[j].Distance(base.Center);
					if (num6 > num7 || (num6 == num7 && j < Main.myPlayer))
					{
						flag3 = false;
						break;
					}
				}
			}
		}
		if (flag3)
		{
			int damage = info.Damage / 3;
			player.Hurt(PlayerDeathReason.LegacyEmpty(), damage, 0);
		}
	}

	private bool TeammateHasPalidinShieldAndCanTakeDamage()
	{
		bool flag4 = false;
		for (int i = 0; i < 255; i++)
		{
			if (i != Main.myPlayer && Main.player[i].active && !Main.player[i].dead && !Main.player[i].immune && Main.player[i].hasPaladinShield && Main.player[i].team == team && (float)Main.player[i].statLife > (float)Main.player[i].statLifeMax2 * 0.25f)
			{
				flag4 = true;
				break;
			}
		}
		return flag4;
	}

	private void OnHurt_Part3(HurtInfo info)
	{
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		double num13 = info.Damage;
		if (brainOfConfusionItem == null || brainOfConfusionItem.IsAir || Main.myPlayer != whoAmI)
		{
			return;
		}
		for (int num14 = 0; num14 < 200; num14++)
		{
			if (!Main.npc[num14].active || Main.npc[num14].friendly)
			{
				continue;
			}
			int num10 = 300;
			num10 += (int)num13 * 2;
			if (Main.rand.Next(500) < num10)
			{
				Vector2 val = Main.npc[num14].Center - base.Center;
				float num15 = ((Vector2)(ref val)).Length();
				float num11 = Main.rand.Next(200 + (int)num13 / 2, 301 + (int)num13 * 2);
				if (num11 > 500f)
				{
					num11 = 500f + (num11 - 500f) * 0.75f;
				}
				if (num11 > 700f)
				{
					num11 = 700f + (num11 - 700f) * 0.5f;
				}
				if (num11 > 900f)
				{
					num11 = 900f + (num11 - 900f) * 0.25f;
				}
				if (num15 < num11)
				{
					float num12 = Main.rand.Next(90 + (int)num13 / 3, 300 + (int)num13 / 2);
					Main.npc[num14].AddBuff(31, (int)num12);
				}
			}
		}
		Projectile.NewProjectile(GetSource_Accessory_OnHurt(brainOfConfusionItem, info.DamageSource), base.Center.X + (float)Main.rand.Next(-40, 40), base.Center.Y - (float)Main.rand.Next(20, 60), velocity.X * 0.3f, velocity.Y * 0.3f, 565, 0, 0f, whoAmI);
	}

	public void Hurt(HurtInfo info, bool quiet = false)
	{
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0312: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0825: Unknown result type (might be due to invalid IL or missing references)
		//IL_082b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0846: Unknown result type (might be due to invalid IL or missing references)
		//IL_0877: Unknown result type (might be due to invalid IL or missing references)
		//IL_087d: Unknown result type (might be due to invalid IL or missing references)
		//IL_091a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0947: Unknown result type (might be due to invalid IL or missing references)
		//IL_094d: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_08eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_077e: Unknown result type (might be due to invalid IL or missing references)
		//IL_075d: Unknown result type (might be due to invalid IL or missing references)
		PlayerDeathReason damageSource = info.DamageSource;
		int hitDirection = info.HitDirection;
		int cooldownCounter = info.CooldownCounter;
		bool pvp = info.PvP;
		double num20 = info.Damage;
		bool Crit = false;
		bool flag2 = cooldownCounter == 2;
		if (Main.netMode == 1 && whoAmI == Main.myPlayer && !quiet)
		{
			if (info.Knockback != 0f && hitDirection != 0 && (!mount.Active || !mount.Cart))
			{
				NetMessage.SendData(13, -1, -1, null, whoAmI);
			}
			NetMessage.SendData(16, -1, -1, null, whoAmI);
			NetMessage.SendPlayerHurt(whoAmI, info);
		}
		PlayerLoader.OnHurt(this, info);
		OnHurt_Part1(info);
		OnHurt_Part2(info);
		OnHurt_Part3(info);
		Color color = (Crit ? CombatText.DamagedFriendlyCrit : CombatText.DamagedFriendly);
		CombatText.NewText(new Rectangle((int)position.X, (int)position.Y, width, height), color, (int)num20, Crit);
		statLife -= (int)num20;
		switch (cooldownCounter)
		{
		case -1:
		{
			immune = true;
			int num14 = 0;
			num14 = (pvp ? 8 : ((num20 == 1.0) ? (longInvince ? 40 : 20) : (longInvince ? 80 : 40)));
			immuneTime = num14;
			break;
		}
		case 0:
			if (num20 == 1.0)
			{
				hurtCooldowns[cooldownCounter] = (longInvince ? 40 : 20);
			}
			else
			{
				hurtCooldowns[cooldownCounter] = (longInvince ? 80 : 40);
			}
			break;
		case 1:
		case 3:
		case 4:
			if (num20 == 1.0)
			{
				hurtCooldowns[cooldownCounter] = (longInvince ? 40 : 20);
			}
			else
			{
				hurtCooldowns[cooldownCounter] = (longInvince ? 80 : 40);
			}
			break;
		}
		lifeRegenTime = 0f;
		int? sourceProjectileType = damageSource.SourceProjectileType;
		if (sourceProjectileType.HasValue && ProjectileID.Sets.DismountsPlayersOnHit.IndexInRange(sourceProjectileType.Value) && ProjectileID.Sets.DismountsPlayersOnHit[sourceProjectileType.Value])
		{
			mount.Dismount(this);
		}
		if (whoAmI == Main.myPlayer)
		{
			if (starCloakItem != null && !starCloakItem.IsAir && (cooldownCounter == -1 || cooldownCounter == 1))
			{
				Vector2 vector = default(Vector2);
				for (int num15 = 0; num15 < 3; num15++)
				{
					float x = position.X + (float)Main.rand.Next(-400, 400);
					float y = position.Y - (float)Main.rand.Next(500, 800);
					((Vector2)(ref vector))._002Ector(x, y);
					float num16 = position.X + (float)(width / 2) - vector.X;
					float num17 = position.Y + (float)(height / 2) - vector.Y;
					num16 += (float)Main.rand.Next(-100, 101);
					float num18 = (float)Math.Sqrt(num16 * num16 + num17 * num17);
					num18 = 23f / num18;
					num16 *= num18;
					num17 *= num18;
					int type = 726;
					Item item = starCloakItem;
					if (starCloakItem_starVeilOverrideItem != null)
					{
						item = starCloakItem_starVeilOverrideItem;
						type = 725;
					}
					if (starCloakItem_beeCloakOverrideItem != null)
					{
						item = starCloakItem_beeCloakOverrideItem;
						type = 724;
					}
					if (starCloakItem_manaCloakOverrideItem != null)
					{
						item = starCloakItem_manaCloakOverrideItem;
						type = 723;
					}
					int num19 = 75;
					if (Main.masterMode)
					{
						num19 *= 3;
					}
					else if (Main.expertMode)
					{
						num19 *= 2;
					}
					Projectile.NewProjectile(GetSource_Accessory_OnHurt(item, info.DamageSource), x, y, num16, num17, type, num19, 5f, whoAmI, 0f, position.Y);
				}
			}
			if (honeyCombItem != null && !honeyCombItem.IsAir)
			{
				int num21 = 1;
				if (Main.rand.Next(3) == 0)
				{
					num21++;
				}
				if (Main.rand.Next(3) == 0)
				{
					num21++;
				}
				if (strongBees && Main.rand.Next(3) == 0)
				{
					num21++;
				}
				float num22 = 13f;
				if (strongBees)
				{
					num22 = 18f;
				}
				if (Main.masterMode)
				{
					num22 *= 2f;
				}
				else if (Main.expertMode)
				{
					num22 *= 1.5f;
				}
				IEntitySource projectileSource_Accessory = GetSource_Accessory_OnHurt(honeyCombItem, info.DamageSource);
				for (int num23 = 0; num23 < num21; num23++)
				{
					float speedX = (float)Main.rand.Next(-35, 36) * 0.02f;
					float speedY = (float)Main.rand.Next(-35, 36) * 0.02f;
					Projectile.NewProjectile(projectileSource_Accessory, position.X, position.Y, speedX, speedY, beeType(), beeDamage((int)num22), beeKB(0f), Main.myPlayer);
				}
				AddBuff(48, 300);
			}
		}
		StopVanityActions();
		if (info.Knockback != 0f && hitDirection != 0 && (!mount.Active || !mount.Cart))
		{
			velocity.X = info.Knockback * (float)hitDirection;
			velocity.Y = info.Knockback * -7f / 9f;
			fallStart = (int)(position.Y / 16f);
		}
		if (!info.SoundDisabled)
		{
			if (stoned)
			{
				SoundEngine.PlaySound(0, (int)position.X, (int)position.Y);
			}
			else if (mount.Active && mount.Type == 52)
			{
				SoundEngine.PlaySound(3, (int)position.X, (int)position.Y, 6);
			}
			else if ((wereWolf || forceWerewolf) && !hideWolf)
			{
				SoundEngine.PlaySound(3, (int)position.X, (int)position.Y, 6);
			}
			else if (frostArmor)
			{
				SoundEngine.PlaySound(in SoundID.Item27, position);
			}
			else if (boneArmor)
			{
				SoundEngine.PlaySound(3, (int)position.X, (int)position.Y, 2);
			}
			else if (Main.dontStarveWorld && !Main.remixWorld)
			{
				SoundStyle style = (Male ? SoundID.DSTMaleHurt : SoundID.DSTFemaleHurt);
				SoundEngine.PlaySound(in style, position);
			}
			else
			{
				SoundEngine.PlaySound(Male ? 1 : 20, position);
			}
		}
		eyeHelper.BlinkBecausePlayerGotHurt();
		if (statLife > 0)
		{
			if (!info.DustDisabled)
			{
				double num24 = num20 / (double)statLifeMax2 * 100.0;
				float num25 = 2 * hitDirection;
				float num26 = 0f;
				if (flag2)
				{
					num24 *= 12.0;
					num26 = 6f;
				}
				for (int num27 = 0; (double)num27 < num24; num27++)
				{
					if (stoned)
					{
						Dust.NewDust(position, width, height, 1, num25 + (float)hitDirection * num26 * Main.rand.NextFloat(), -2f);
					}
					else if (frostArmor)
					{
						int num28 = Dust.NewDust(position, width, height, 135, num25 + (float)hitDirection * num26 * Main.rand.NextFloat(), -2f);
						Main.dust[num28].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
					}
					else if (boneArmor)
					{
						int num29 = Dust.NewDust(position, width, height, 26, num25 + (float)hitDirection * num26 * Main.rand.NextFloat(), -2f);
						Main.dust[num29].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
					}
					else
					{
						Dust.NewDust(position, width, height, 5, num25 + (float)hitDirection * num26 * Main.rand.NextFloat(), -2f);
					}
				}
			}
			PlayerLoader.PostHurt(this, info);
		}
		else
		{
			statLife = 0;
			if (whoAmI == Main.myPlayer)
			{
				KillMe(damageSource, num20, hitDirection, pvp);
			}
		}
	}

	private static bool AllowShimmerDodge(PlayerDeathReason damageSource, int cooldownCounter, bool dodgeable)
	{
		if (!dodgeable)
		{
			return false;
		}
		if (cooldownCounter == 1)
		{
			return false;
		}
		Entity entity = null;
		if (!damageSource.TryGetCausingEntity(out entity))
		{
			return true;
		}
		if (entity is NPC { active: not false } nPC && (nPC.boss || NPC.GetNPCInvasionGroup(nPC.type) != 0 || NPCID.Sets.CanHitPastShimmer[nPC.type]))
		{
			return false;
		}
		if (entity is Projectile { active: not false } projectile && ProjectileID.Sets.CanHitPastShimmer[projectile.type])
		{
			return false;
		}
		return true;
	}

	public void KillMeForGood()
	{
		PlayerFileData activePlayerFileData = Main.ActivePlayerFileData;
		if (!activePlayerFileData.ServerSideCharacter)
		{
			bool isCloudSave = activePlayerFileData.IsCloudSave;
			if (FileUtilities.Exists(Main.playerPathName, isCloudSave))
			{
				FileUtilities.Delete(Main.playerPathName, isCloudSave);
			}
			if (FileUtilities.Exists(Main.playerPathName + ".bak", isCloudSave))
			{
				FileUtilities.Delete(Main.playerPathName + ".bak", isCloudSave);
			}
			string moddedPlayerPathName = Path.ChangeExtension(Main.playerPathName, ".tplr");
			if (FileUtilities.Exists(moddedPlayerPathName, isCloudSave))
			{
				FileUtilities.Delete(moddedPlayerPathName, isCloudSave);
			}
			if (FileUtilities.Exists(moddedPlayerPathName + ".bak", isCloudSave))
			{
				FileUtilities.Delete(moddedPlayerPathName + ".bak", isCloudSave);
			}
			Main.ActivePlayerFileData = new PlayerFileData();
		}
	}

	public void KillMe(PlayerDeathReason damageSource, double dmg, int hitDirection, bool pvp = false)
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_07bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0568: Unknown result type (might be due to invalid IL or missing references)
		//IL_0577: Unknown result type (might be due to invalid IL or missing references)
		//IL_0998: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0806: Unknown result type (might be due to invalid IL or missing references)
		//IL_080c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0827: Unknown result type (might be due to invalid IL or missing references)
		//IL_0849: Unknown result type (might be due to invalid IL or missing references)
		//IL_084f: Unknown result type (might be due to invalid IL or missing references)
		//IL_08dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_08fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0901: Unknown result type (might be due to invalid IL or missing references)
		//IL_0889: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ae: Unknown result type (might be due to invalid IL or missing references)
		if (creativeGodMode || dead)
		{
			return;
		}
		StopVanityActions();
		bool playSound = true;
		bool genGore = true;
		if (!PlayerLoader.PreKill(this, dmg, hitDirection, pvp, ref playSound, ref genGore, ref damageSource))
		{
			return;
		}
		if (pvp)
		{
			pvpDeath = true;
		}
		if (trapDebuffSource)
		{
			AchievementsHelper.HandleSpecialEvent(this, 4);
		}
		if (Main.myPlayer == whoAmI && _framesLeftEligibleForDeadmansChestDeathAchievement > 0)
		{
			AchievementsHelper.HandleSpecialEvent(this, 23);
		}
		if (whoAmI == Main.myPlayer)
		{
			Main.NotifyOfEvent(GameNotificationType.SpawnOrDeath);
		}
		if (pvpDeath)
		{
			numberOfDeathsPVP++;
		}
		else
		{
			numberOfDeathsPVE++;
		}
		lastDeathPostion = base.Center;
		lastDeathTime = DateTime.Now;
		showLastDeath = true;
		bool overFlowing;
		long coinsOwned = Utils.CoinsCount(out overFlowing, inventory);
		if (Main.myPlayer == whoAmI)
		{
			lostCoins = coinsOwned;
			lostCoinString = Main.ValueToCoins(lostCoins);
		}
		if (Main.myPlayer == whoAmI)
		{
			EndOngoingTorchGodEvent();
		}
		if (Main.myPlayer == whoAmI)
		{
			Main.mapFullscreen = false;
		}
		if (Main.myPlayer == whoAmI)
		{
			trashItem.SetDefaults();
			if (difficulty == 0 || difficulty == 3)
			{
				for (int i = 0; i < 59; i++)
				{
					if (inventory[i].stack > 0 && ((inventory[i].type >= 1522 && inventory[i].type <= 1527) || inventory[i].type == 3643))
					{
						int num = Item.NewItem(GetItemSource_Death(), (int)position.X, (int)position.Y, width, height, inventory[i].type);
						Main.item[num].netDefaults(inventory[i].netID);
						Main.item[num].Prefix(inventory[i].prefix);
						Main.item[num].stack = inventory[i].stack;
						Main.item[num].velocity.Y = (float)Main.rand.Next(-20, 1) * 0.2f;
						Main.item[num].velocity.X = (float)Main.rand.Next(-20, 21) * 0.2f;
						Main.item[num].noGrabDelay = 100;
						Main.item[num].favorited = false;
						Main.item[num].newAndShiny = false;
						if (Main.netMode == 1)
						{
							NetMessage.SendData(21, -1, -1, null, num);
						}
						inventory[i].SetDefaults();
					}
				}
			}
			else if (difficulty == 1)
			{
				DropItems();
			}
			else if (difficulty == 2)
			{
				DropItems();
				KillMeForGood();
			}
		}
		if (playSound)
		{
			if (Main.dontStarveWorld || Main.tenthAnniversaryWorld)
			{
				SoundStyle style = (Male ? SoundID.DSTMaleHurt : SoundID.DSTFemaleHurt);
				SoundEngine.PlaySound(in style, position);
			}
			else
			{
				SoundEngine.PlaySound(5, (int)position.X, (int)position.Y);
			}
		}
		if (Main.tenthAnniversaryWorld)
		{
			for (int j = 0; j < 85; j++)
			{
				int type = Main.rand.Next(139, 143);
				int num2 = Dust.NewDust(new Vector2(position.X, position.Y), width, height, type, 0f, -10f, 0, default(Color), 1.2f);
				Main.dust[num2].velocity.X += (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.dust[num2].velocity.Y += (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.dust[num2].velocity.X *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.dust[num2].velocity.Y *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.dust[num2].velocity.X += (float)Main.rand.Next(-50, 51) * 0.05f;
				Main.dust[num2].velocity.Y += (float)Main.rand.Next(-50, 51) * 0.05f;
				Main.dust[num2].scale *= 1f + (float)Main.rand.Next(-30, 31) * 0.01f;
			}
			for (int k = 0; k < 40; k++)
			{
				int type2 = Main.rand.Next(276, 283);
				int num3 = Gore.NewGore(position, new Vector2(0f, -10f), type2);
				Main.gore[num3].velocity.X += (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.gore[num3].velocity.Y += (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.gore[num3].velocity.X *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.gore[num3].velocity.Y *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
				Main.gore[num3].scale *= 1f + (float)Main.rand.Next(-20, 21) * 0.01f;
				Main.gore[num3].velocity.X += (float)Main.rand.Next(-50, 51) * 0.05f;
				Main.gore[num3].velocity.Y += (float)Main.rand.Next(-50, 51) * 0.05f;
			}
		}
		headVelocity.Y = (float)Main.rand.Next(-40, -10) * 0.1f;
		bodyVelocity.Y = (float)Main.rand.Next(-40, -10) * 0.1f;
		legVelocity.Y = (float)Main.rand.Next(-40, -10) * 0.1f;
		headVelocity.X = (float)Main.rand.Next(-20, 21) * 0.1f + (float)(2 * hitDirection);
		bodyVelocity.X = (float)Main.rand.Next(-20, 21) * 0.1f + (float)(2 * hitDirection);
		legVelocity.X = (float)Main.rand.Next(-20, 21) * 0.1f + (float)(2 * hitDirection);
		if (stoned || !genGore)
		{
			headPosition = Vector2.Zero;
			bodyPosition = Vector2.Zero;
			legPosition = Vector2.Zero;
		}
		if (genGore)
		{
			for (int l = 0; l < 100; l++)
			{
				if (stoned)
				{
					Dust.NewDust(position, width, height, 1, 2 * hitDirection, -2f);
				}
				else if (frostArmor)
				{
					int num4 = Dust.NewDust(position, width, height, 135, 2 * hitDirection, -2f);
					Main.dust[num4].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
				}
				else if (boneArmor)
				{
					int num5 = Dust.NewDust(position, width, height, 26, 2 * hitDirection, -2f);
					Main.dust[num5].shader = GameShaders.Armor.GetSecondaryShader(ArmorSetDye(), this);
				}
				else
				{
					Dust.NewDust(position, width, height, 5, 2 * hitDirection, -2f);
				}
			}
		}
		mount.Dismount(this);
		dead = true;
		respawnTimer = GetRespawnTime(pvp);
		PlayerLoader.Kill(this, dmg, hitDirection, pvp, damageSource);
		immuneAlpha = 0;
		if (!ChildSafety.Disabled)
		{
			immuneAlpha = 255;
		}
		palladiumRegen = false;
		iceBarrier = false;
		crystalLeaf = false;
		NetworkText deathText = damageSource.GetDeathText(name);
		if (Main.netMode == 2)
		{
			ChatHelper.BroadcastChatMessage(deathText, new Color(225, 25, 25));
		}
		else if (Main.netMode == 0)
		{
			Main.NewText(deathText.ToString(), 225, 25, 25);
		}
		if (Main.netMode == 1 && whoAmI == Main.myPlayer)
		{
			NetMessage.SendPlayerDeath(whoAmI, damageSource, (int)dmg, hitDirection, pvp);
		}
		if (whoAmI == Main.myPlayer && (difficulty == 0 || difficulty == 3))
		{
			if (!pvp)
			{
				DropCoins();
			}
			else
			{
				lostCoins = 0L;
				lostCoinString = Main.ValueToCoins(lostCoins);
			}
		}
		DropTombstone(coinsOwned, deathText, hitDirection);
		if (whoAmI != Main.myPlayer)
		{
			return;
		}
		try
		{
			WorldGen.saveToonWhilePlaying();
		}
		catch
		{
		}
	}

	private int GetRespawnTime(bool pvp)
	{
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		int num = 600;
		bool flag = false;
		if (Main.netMode != 0 && !pvp)
		{
			for (int i = 0; i < 200; i++)
			{
				if (Main.npc[i].active && (Main.npc[i].boss || Main.npc[i].type == 13 || Main.npc[i].type == 14 || Main.npc[i].type == 15) && Math.Abs(base.Center.X - Main.npc[i].Center.X) + Math.Abs(base.Center.Y - Main.npc[i].Center.Y) < 4000f)
				{
					flag = true;
					break;
				}
			}
		}
		if (flag)
		{
			num += 600;
		}
		if (Main.expertMode)
		{
			num = (int)((double)num * 1.5);
		}
		if (flag && Main.getGoodWorld && Main.netMode != 0)
		{
			bool flag2 = false;
			for (int j = 0; j < 255; j++)
			{
				if (j != whoAmI && Main.player[j].active)
				{
					flag2 = true;
					break;
				}
			}
			if (flag2)
			{
				num *= 2;
			}
		}
		return num;
	}

	public void DropTombstone(long coinsOwned, NetworkText deathText, int hitDirection)
	{
		if (Main.netMode != 1)
		{
			float num;
			for (num = (float)Main.rand.Next(-35, 36) * 0.1f; num < 2f && num > -2f; num += (float)Main.rand.Next(-30, 31) * 0.1f)
			{
			}
			int num2 = Main.rand.Next(6);
			if (coinsOwned <= 100000)
			{
				num2 = ((num2 != 0) ? (200 + num2) : 43);
			}
			else
			{
				num2 = Main.rand.Next(5);
				num2 += 527;
			}
			IEntitySource projectileSource_Misc = GetProjectileSource_Misc(9);
			int damage = 0;
			int num3 = 0;
			if (Main.getGoodWorld)
			{
				damage = 70;
				num3 = 10;
			}
			int num4 = whoAmI;
			int num5 = ((!Main.getGoodWorld) ? Projectile.NewProjectile(projectileSource_Misc, position.X + (float)(width / 2), position.Y + (float)(height / 2), (float)Main.rand.Next(10, 30) * 0.1f * (float)hitDirection + num, (float)Main.rand.Next(-40, -20) * 0.1f, num2, damage, num3, Main.myPlayer, num4) : Projectile.NewProjectile(projectileSource_Misc, position.X + (float)(width / 2), position.Y + (float)(height / 2), ((float)Main.rand.Next(10, 30) * 0.1f * (float)hitDirection + num) * 1.5f, (float)Main.rand.Next(-40, -20) * 0.1f * 1.5f, num2, damage, num3, Main.myPlayer, num4));
			DateTime now = DateTime.Now;
			string text = now.ToString("D");
			if (GameCulture.FromCultureName(GameCulture.CultureName.English).IsActive)
			{
				text = now.ToString("MMMM d, yyy");
			}
			string miscText = deathText.ToString() + "\n" + text;
			Main.projectile[num5].miscText = miscText;
		}
	}

	public bool CanPullItem(Item item, ItemSpaceStatus status)
	{
		if (status.CanTakeItem)
		{
			return CanAcceptItemIntoInventory(item);
		}
		return false;
	}

	public ItemSpaceStatus ItemSpace(Item newItem)
	{
		if (ItemID.Sets.IsAPickup[newItem.type])
		{
			return new ItemSpaceStatus(CanTakeItem: true);
		}
		if (newItem.uniqueStack && HasItem(newItem.type))
		{
			return new ItemSpaceStatus(CanTakeItem: false);
		}
		if (ItemLoader.ItemSpace(newItem, this))
		{
			return new ItemSpaceStatus(CanTakeItem: true);
		}
		int num = 50;
		if (newItem.IsACoin)
		{
			num = 54;
		}
		for (int i = 0; i < num; i++)
		{
			if (CanItemSlotAccept(inventory[i], newItem))
			{
				return new ItemSpaceStatus(CanTakeItem: true);
			}
		}
		if (newItem.ammo > 0 && !newItem.notAmmo)
		{
			for (int j = 54; j < 58; j++)
			{
				if (CanGoIntoAmmoOnPickup(inventory[j], newItem))
				{
					return new ItemSpaceStatus(CanTakeItem: true);
				}
			}
		}
		for (int k = 54; k < 58; k++)
		{
			if (inventory[k].type > 0 && inventory[k].stack < inventory[k].maxStack && newItem.IsTheSameAs(inventory[k]))
			{
				return new ItemSpaceStatus(CanTakeItem: true);
			}
		}
		if (ItemSpaceForCofveve(newItem))
		{
			return new ItemSpaceStatus(CanTakeItem: true, ItemIsGoingToVoidVault: true);
		}
		return new ItemSpaceStatus(CanTakeItem: false);
	}

	public bool ItemSpaceForCofveve(Item newItem)
	{
		if (!IsVoidVaultEnabled)
		{
			return false;
		}
		if (!CanVoidVaultAccept(newItem))
		{
			return false;
		}
		Item[] item = bank4.item;
		for (int i = 0; i < item.Length; i++)
		{
			if (CanItemSlotAccept(item[i], newItem))
			{
				return true;
			}
		}
		return false;
	}

	public bool CanItemSlotAccept(Item theSlot, Item theItemToAccept)
	{
		if (theSlot.type == 0)
		{
			return true;
		}
		bool vanillaResult = false;
		if (theSlot.stack < theSlot.maxStack && theItemToAccept.IsTheSameAs(theSlot))
		{
			vanillaResult = true;
		}
		if (vanillaResult && ItemLoader.CanStack(theSlot, theItemToAccept))
		{
			return true;
		}
		return false;
	}

	public bool CanGoIntoAmmoOnPickup(Item theSlot, Item theItemToAccept)
	{
		if (!theItemToAccept.CanFillEmptyAmmoSlot() && theSlot.type == 0)
		{
			return false;
		}
		return CanItemSlotAccept(theSlot, theItemToAccept);
	}

	public void DoCoins(int i)
	{
		if (inventory[i].stack != 100 || (inventory[i].type != 71 && inventory[i].type != 72 && inventory[i].type != 73))
		{
			return;
		}
		inventory[i].SetDefaults(inventory[i].type + 1);
		for (int j = 0; j < 54; j++)
		{
			if (inventory[j].IsTheSameAs(inventory[i]) && j != i && inventory[j].type == inventory[i].type && inventory[j].stack < inventory[j].maxStack)
			{
				inventory[j].stack++;
				inventory[i].SetDefaults();
				inventory[i].active = false;
				inventory[i].TurnToAir();
				DoCoins(j);
			}
		}
	}

	public Item FillAmmo(int plr, Item newItem, GetItemSettings settings)
	{
		for (int i = 54; i < 58; i++)
		{
			if (inventory[i].type > 0 && inventory[i].stack < inventory[i].maxStack && newItem.IsTheSameAs(inventory[i]) && ItemLoader.TryStackItems(inventory[i], newItem, out var numTransfered))
			{
				SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
				if (!settings.NoText)
				{
					PopupText.NewText(PopupTextContext.RegularItemPickup, newItem, numTransfered);
				}
				DoCoins(i);
				if (plr == Main.myPlayer)
				{
					Recipe.FindRecipes();
				}
				settings.HandlePostAction(inventory[i]);
				if (newItem.stack <= 0)
				{
					return new Item();
				}
			}
		}
		if (newItem.CanFillEmptyAmmoSlot())
		{
			for (int j = 54; j < 58; j++)
			{
				if (inventory[j].type == 0)
				{
					newItem.shimmered = false;
					inventory[j] = newItem;
					if (!settings.NoText)
					{
						PopupText.NewText(PopupTextContext.RegularItemPickup, newItem, newItem.stack);
					}
					DoCoins(j);
					SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
					if (plr == Main.myPlayer)
					{
						Recipe.FindRecipes();
					}
					settings.HandlePostAction(inventory[j]);
					return new Item();
				}
			}
		}
		return newItem;
	}

	public Item GetItem(int plr, Item newItem, GetItemSettings settings)
	{
		bool isACoin = newItem.IsACoin;
		Item item = newItem;
		int num = 50;
		if (newItem.noGrabDelay > 0)
		{
			return item;
		}
		int num2 = 0;
		if (newItem.uniqueStack && HasItem(newItem.type))
		{
			return item;
		}
		if (isACoin)
		{
			num2 = -4;
			num = 54;
		}
		if (item.FitsAmmoSlot())
		{
			item = FillAmmo(plr, item, settings);
			if (item.type == 0 || item.stack == 0)
			{
				return new Item();
			}
		}
		for (int i = num2; i < 50; i++)
		{
			int num3 = i;
			if (num3 < 0)
			{
				num3 = 54 + i;
			}
			if (GetItem_FillIntoOccupiedSlot(plr, newItem, settings, item, num3))
			{
				return new Item();
			}
		}
		if (!isACoin && newItem.useStyle != 0)
		{
			for (int j = 0; j < 10; j++)
			{
				if (GetItem_FillEmptyInventorySlot(plr, newItem, settings, item, j))
				{
					return new Item();
				}
			}
		}
		if (newItem.favorited)
		{
			for (int k = 0; k < num; k++)
			{
				if (GetItem_FillEmptyInventorySlot(plr, newItem, settings, item, k))
				{
					return new Item();
				}
			}
		}
		else
		{
			for (int num4 = num - 1; num4 >= 0; num4--)
			{
				if (GetItem_FillEmptyInventorySlot(plr, newItem, settings, item, num4))
				{
					return new Item();
				}
			}
		}
		if (settings.CanGoIntoVoidVault && IsVoidVaultEnabled && CanVoidVaultAccept(newItem) && GetItem_VoidVault(plr, bank4.item, newItem, settings, item))
		{
			return new Item();
		}
		return item;
	}

	private bool GetItem_VoidVault(int plr, Item[] inventory, Item newItem, GetItemSettings settings, Item returnItem)
	{
		if (!CanVoidVaultAccept(newItem))
		{
			return false;
		}
		for (int i = 0; i < inventory.Length; i++)
		{
			if (GetItem_FillIntoOccupiedSlot_VoidBag(plr, inventory, newItem, settings, returnItem, i))
			{
				return true;
			}
		}
		for (int j = 0; j < inventory.Length; j++)
		{
			if (GetItem_FillEmptyInventorySlot_VoidBag(plr, inventory, newItem, settings, returnItem, j))
			{
				return true;
			}
		}
		return false;
	}

	private bool CanVoidVaultAccept(Item item)
	{
		if (item.questItem)
		{
			return false;
		}
		if (item.type == 3822)
		{
			return false;
		}
		return true;
	}

	private bool GetItem_FillIntoOccupiedSlot_VoidBag(int plr, Item[] inv, Item newItem, GetItemSettings settings, Item returnItem, int i)
	{
		if (inv[i].type > 0 && inv[i].stack < inv[i].maxStack && returnItem.IsTheSameAs(inv[i]))
		{
			if (!ItemLoader.TryStackItems(inv[i], returnItem, out var numTransfered))
			{
				return false;
			}
			if (newItem.IsACoin)
			{
				SoundEngine.PlaySound(38, (int)position.X, (int)position.Y);
			}
			else
			{
				SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
			}
			if (!settings.NoText)
			{
				PopupText.NewText(PopupTextContext.ItemPickupToVoidContainer, newItem, numTransfered, noStack: false, settings.LongText);
			}
			AchievementsHelper.NotifyItemPickup(this, returnItem);
			settings.HandlePostAction(inv[i]);
			if (returnItem.stack <= 0)
			{
				return true;
			}
		}
		return false;
	}

	private bool GetItem_FillIntoOccupiedSlot(int plr, Item newItem, GetItemSettings settings, Item returnItem, int i)
	{
		if (inventory[i].type > 0 && inventory[i].stack < inventory[i].maxStack && returnItem.IsTheSameAs(inventory[i]))
		{
			if (!ItemLoader.TryStackItems(inventory[i], returnItem, out var numTransfered))
			{
				return false;
			}
			if (newItem.IsACoin)
			{
				SoundEngine.PlaySound(38, (int)position.X, (int)position.Y);
			}
			else
			{
				SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
			}
			if (!settings.NoText)
			{
				PopupText.NewText(PopupTextContext.RegularItemPickup, newItem, numTransfered, noStack: false, settings.LongText);
			}
			DoCoins(i);
			if (plr == Main.myPlayer)
			{
				Recipe.FindRecipes();
			}
			AchievementsHelper.NotifyItemPickup(this, returnItem);
			settings.HandlePostAction(inventory[i]);
			if (returnItem.stack <= 0)
			{
				return true;
			}
		}
		return false;
	}

	private bool GetItem_FillEmptyInventorySlot_VoidBag(int plr, Item[] inv, Item newItem, GetItemSettings settings, Item returnItem, int i)
	{
		if (inv[i].type != 0)
		{
			return false;
		}
		if (newItem.IsACoin)
		{
			SoundEngine.PlaySound(38, (int)position.X, (int)position.Y);
		}
		else
		{
			SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
		}
		returnItem.shimmered = false;
		inv[i] = returnItem;
		if (!settings.NoText)
		{
			PopupText.NewText(PopupTextContext.ItemPickupToVoidContainer, newItem, newItem.stack, noStack: false, settings.LongText);
		}
		DoCoins(i);
		if (plr == Main.myPlayer)
		{
			Recipe.FindRecipes();
		}
		AchievementsHelper.NotifyItemPickup(this, returnItem);
		settings.HandlePostAction(inv[i]);
		return true;
	}

	private bool GetItem_FillEmptyInventorySlot(int plr, Item newItem, GetItemSettings settings, Item returnItem, int i)
	{
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		if (inventory[i].type != 0)
		{
			return false;
		}
		if (newItem.IsACoin)
		{
			SoundEngine.PlaySound(38, (int)position.X, (int)position.Y);
		}
		else
		{
			SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
		}
		returnItem.shimmered = false;
		inventory[i] = returnItem;
		if (!settings.NoText)
		{
			PopupText.NewText(PopupTextContext.RegularItemPickup, newItem, newItem.stack, noStack: false, settings.LongText);
		}
		DoCoins(i);
		if (plr == Main.myPlayer)
		{
			Recipe.FindRecipes();
		}
		AchievementsHelper.NotifyItemPickup(this, returnItem);
		if (plr == Main.myPlayer && newItem.type == 5095)
		{
			LucyAxeMessage.Create(LucyAxeMessage.MessageSource.PickedUp, base.Top, new Vector2(0f, -7f));
		}
		settings.HandlePostAction(inventory[i]);
		return true;
	}

	public void PlaceThing(ref ItemCheckContext context)
	{
		if (itemTime == 0)
		{
			dontConsumeWand = false;
		}
		PlaceThing_Paintbrush();
		PlaceThing_PaintRoller();
		PlaceThing_PaintScrapper();
		PlaceThing_CannonBall();
		PlaceThing_XMasTreeTops();
		PlaceThing_ItemInExtractinator(ref context);
		PlaceThing_LockChest();
		if (!noBuilding)
		{
			PlaceThing_Tiles();
			PlaceThing_Walls();
		}
	}

	private void PlaceThing_Walls()
	{
		if (inventory[selectedItem].createWall < 0 || !(position.X / 16f - (float)tileRangeX - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetX) || !((position.X + (float)width) / 16f + (float)tileRangeX + (float)inventory[selectedItem].tileBoost - 1f + (float)blockRange >= (float)tileTargetX) || !(position.Y / 16f - (float)tileRangeY - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetY) || !((position.Y + (float)height) / 16f + (float)tileRangeY + (float)inventory[selectedItem].tileBoost - 2f + (float)blockRange >= (float)tileTargetY))
		{
			return;
		}
		cursorItemIconEnabled = true;
		if (!ItemTimeIsZero || itemAnimation <= 0 || !controlUseItem || (!Main.tile[tileTargetX + 1, tileTargetY].active() && Main.tile[tileTargetX + 1, tileTargetY].wall <= 0 && !Main.tile[tileTargetX - 1, tileTargetY].active() && Main.tile[tileTargetX - 1, tileTargetY].wall <= 0 && !Main.tile[tileTargetX, tileTargetY + 1].active() && Main.tile[tileTargetX, tileTargetY + 1].wall <= 0 && !Main.tile[tileTargetX, tileTargetY - 1].active() && Main.tile[tileTargetX, tileTargetY - 1].wall <= 0) || Main.tile[tileTargetX, tileTargetY].wall == inventory[selectedItem].createWall)
		{
			return;
		}
		bool flag = true;
		flag &= WallLoader.CanPlace(tileTargetX, tileTargetY, inventory[selectedItem].createWall);
		if (TileReplacementEnabled)
		{
			flag = PlaceThing_TryReplacingWalls(flag);
		}
		if (!flag)
		{
			return;
		}
		WorldGen.PlaceWall(tileTargetX, tileTargetY, inventory[selectedItem].createWall);
		if (Main.tile[tileTargetX, tileTargetY].wall == inventory[selectedItem].createWall)
		{
			WallLoader.PlaceInWorld(tileTargetX, tileTargetY, inventory[selectedItem]);
			ApplyItemTime(inventory[selectedItem], wallSpeed);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 3, tileTargetX, tileTargetY, inventory[selectedItem].createWall);
			}
			PlaceThing_Walls_FillEmptySpace();
			if (autoPaint && builderAccStatus[3] == 0)
			{
				TryPainting(tileTargetX, tileTargetY, paintingAWall: true, applyItemAnimation: false);
			}
		}
	}

	private void PlaceThing_Walls_FillEmptySpace()
	{
		if (inventory[selectedItem].stack <= 1)
		{
			return;
		}
		int createWall = inventory[selectedItem].createWall;
		for (int i = 0; i < 4; i++)
		{
			int num = tileTargetX;
			int num2 = tileTargetY;
			if (i == 0)
			{
				num--;
			}
			if (i == 1)
			{
				num++;
			}
			if (i == 2)
			{
				num2--;
			}
			if (i == 3)
			{
				num2++;
			}
			if (Main.tile[num, num2].wall != 0)
			{
				continue;
			}
			int num3 = 0;
			for (int j = 0; j < 4; j++)
			{
				int num4 = num;
				int num5 = num2;
				if (j == 0)
				{
					num4--;
				}
				if (j == 1)
				{
					num4++;
				}
				if (j == 2)
				{
					num5--;
				}
				if (j == 3)
				{
					num5++;
				}
				if (Main.tile[num4, num5].wall == createWall)
				{
					num3++;
				}
			}
			if (num3 != 4)
			{
				continue;
			}
			WorldGen.PlaceWall(num, num2, createWall);
			if (Main.tile[num, num2].wall == createWall)
			{
				if (ItemLoader.ConsumeItem(inventory[selectedItem], this))
				{
					inventory[selectedItem].stack--;
				}
				if (inventory[selectedItem].stack == 0)
				{
					inventory[selectedItem].SetDefaults();
				}
				if (Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 3, num, num2, createWall);
				}
				if (autoPaint && builderAccStatus[3] == 0)
				{
					TryPainting(num, num2, paintingAWall: true, applyItemAnimation: false);
				}
			}
		}
	}

	private void PlaceThing_Tiles()
	{
		Item item = inventory[selectedItem];
		int tileToCreate = item.createTile;
		if (tileToCreate < 0 || !(position.X / 16f - (float)tileRangeX - (float)item.tileBoost - (float)blockRange <= (float)tileTargetX) || !((position.X + (float)width) / 16f + (float)tileRangeX + (float)item.tileBoost - 1f + (float)blockRange >= (float)tileTargetX) || !(position.Y / 16f - (float)tileRangeY - (float)item.tileBoost - (float)blockRange <= (float)tileTargetY) || !((position.Y + (float)height) / 16f + (float)tileRangeY + (float)item.tileBoost - 2f + (float)blockRange >= (float)tileTargetY))
		{
			return;
		}
		cursorItemIconEnabled = true;
		bool flag = PlaceThing_Tiles_CheckLavaBlocking();
		bool canUse = true;
		canUse = PlaceThing_Tiles_CheckGamepadTorchUsability(canUse);
		canUse = PlaceThing_Tiles_CheckWandUsability(canUse);
		canUse = PlaceThing_Tiles_CheckRopeUsability(canUse);
		canUse = PlaceThing_Tiles_CheckFlexibleWand(canUse);
		if (TileReplacementEnabled)
		{
			canUse = PlaceThing_TryReplacingTiles(canUse);
		}
		Tile tile = Main.tile[tileTargetX, tileTargetY];
		if (tile.active())
		{
			if (tileToCreate == 23 && tile.type == 59)
			{
				tileToCreate = 661;
			}
			if (tileToCreate == 199 && tile.type == 59)
			{
				tileToCreate = 662;
			}
		}
		if (canUse && ((!tile.active() && !flag) || (Main.tileCut[tile.type] && tile.type != 484) || (tile.type >= 373 && tile.type <= 375) || tile.type == 461 || tileToCreate == 199 || tileToCreate == 23 || tileToCreate == 662 || tileToCreate == 661 || tileToCreate == 2 || tileToCreate == 109 || tileToCreate == 60 || tileToCreate == 70 || tileToCreate == 633 || Main.tileMoss[tileToCreate] || TileID.Sets.BreakableWhenPlacing[tile.type]) && ItemTimeIsZero && itemAnimation > 0 && controlUseItem)
		{
			bool canPlace = false;
			bool newObjectType = false;
			bool? overrideCanPlace = null;
			int? forcedRandom = null;
			TileObject objectData = default(TileObject);
			FigureOutWhatToPlace(tile, item, out tileToCreate, out var previewPlaceStyle, out overrideCanPlace, out forcedRandom);
			PlantLoader.CheckAndInjectModSapling(tileTargetX, tileTargetY, ref tileToCreate, ref previewPlaceStyle);
			if (overrideCanPlace.HasValue)
			{
				canPlace = overrideCanPlace.Value;
			}
			else if (TileObjectData.CustomPlace(tileToCreate, previewPlaceStyle) && tileToCreate != 82 && tileToCreate != 227)
			{
				newObjectType = true;
				canPlace = TileObject.CanPlace(tileTargetX, tileTargetY, (ushort)tileToCreate, previewPlaceStyle, direction, out objectData, onlyCheck: false, forcedRandom);
				PlaceThing_Tiles_BlockPlacementIfOverPlayers(ref canPlace, ref objectData);
				PlaceThing_Tiles_BlockPlacementForRepeatedPigronatas(ref canPlace, ref objectData);
				PlaceThing_Tiles_BlockPlacementForRepeatedPumpkins(ref canPlace, ref objectData);
				PlaceThing_Tiles_BlockPlacementForRepeatedCoralAndBeachPiles(ref canPlace, ref objectData);
			}
			else
			{
				canPlace = PlaceThing_Tiles_BlockPlacementForAssortedThings(canPlace);
			}
			if (canPlace)
			{
				PlaceThing_Tiles_PlaceIt(newObjectType, objectData, tileToCreate);
			}
		}
	}

	private bool ModifyFlexibleWandPlacementInfo(ref int tileType, ref int tileStyle, ref int? forcedRandom)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		FlexibleTileWand flexibleTileWand = HeldItem.GetFlexibleTileWand();
		if (flexibleTileWand == null)
		{
			return true;
		}
		if (whoAmI == Main.myPlayer)
		{
			Point point = default(Point);
			((Point)(ref point))._002Ector(tileTargetX, tileTargetY);
			if (FlexibleWandLastPosition != point)
			{
				FlexibleWandLastPosition = point;
				FlexibleWandRandomSeed = Main.rand.Next();
			}
		}
		if (flexibleTileWand.TryGetPlacementOption(this, FlexibleWandRandomSeed, FlexibleWandCycleOffset, out var option, out var _))
		{
			tileType = option.TileIdToPlace;
			tileStyle = option.TileStyleToPlace;
			forcedRandom = FlexibleWandCycleOffset;
			return true;
		}
		return false;
	}

	private bool PlaceThing_TryReplacingWalls(bool canUse)
	{
		if (canUse && itemAnimation > 0 && ItemTimeIsZero && controlUseItem && PlaceThing_ValidWallForReplacement() && WorldGen.NearFriendlyWall(tileTargetX, tileTargetY) && WorldGen.ReplaceWall(tileTargetX, tileTargetY, (ushort)HeldItem.createWall))
		{
			canUse = false;
			ApplyItemTime(HeldItem, wallSpeed);
			NetMessage.SendData(17, -1, -1, null, 22, tileTargetX, tileTargetY, HeldItem.createWall);
			if (autoPaint && builderAccStatus[3] == 0)
			{
				TryPainting(tileTargetX, tileTargetY, paintingAWall: true, applyItemAnimation: false);
			}
		}
		return canUse;
	}

	private bool PlaceThing_ValidWallForReplacement()
	{
		_ = Main.tile[tileTargetX, tileTargetY];
		return Main.tile[tileTargetX, tileTargetY].wall > 0;
	}

	private bool PlaceThing_TryReplacingTiles(bool canUse)
	{
		bool flag = PlaceThing_ValidTileForReplacement();
		if (flag)
		{
			TileObject.objectPreview.Reset();
		}
		if (controlUseItem && canUse && Main.tile[tileTargetX, tileTargetY].active() && itemAnimation > 0 && ItemTimeIsZero && flag)
		{
			Item bestPickaxe = GetBestPickaxe();
			if (bestPickaxe == null)
			{
				return false;
			}
			Tile tile = Main.tile[tileTargetX, tileTargetY];
			_ = ref tile.type;
			int num = hitReplace.HitObject(tileTargetX, tileTargetY, 1);
			int pickaxeDamage = GetPickaxeDamage(tileTargetX, tileTargetY, bestPickaxe.pick, num, tile);
			if (pickaxeDamage == 0)
			{
				return false;
			}
			if (!WorldGen.IsTileReplacable(tileTargetX, tileTargetY))
			{
				return false;
			}
			if (!TileLoader.CanReplace(tileTargetX, tileTargetY, tile.type, HeldItem.createTile))
			{
				return false;
			}
			if (!TileLoader.CanPlace(tileTargetX, tileTargetY, HeldItem.createTile))
			{
				return false;
			}
			if (hitReplace.AddDamage(num, pickaxeDamage) < 100)
			{
				int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile, tileTargetX, tileTargetY);
				for (int i = 0; i < num2; i++)
				{
					WorldGen.KillTile_MakeTileDust(tileTargetX, tileTargetY, tile);
				}
				WorldGen.KillTile_PlaySounds(tileTargetX, tileTargetY, fail: true, tile);
				if (HeldItem.consumable)
				{
					HeldItem.stack++;
				}
				dontConsumeWand = true;
				ApplyItemTime(bestPickaxe, pickSpeed);
				SetItemAnimation((int)((float)bestPickaxe.useTime * pickSpeed));
				return false;
			}
			ClearMiningCacheAt(tileTargetX, tileTargetY, 1);
			int[,] typeCaches = PlaceThing_Tiles_GetAutoAccessoryCache();
			int num3 = HeldItem.createTile;
			int num4 = HeldItem.placeStyle;
			if (UsingBiomeTorches && num3 == 4)
			{
				BiomeTorchPlaceStyle(ref num3, ref num4);
			}
			if (UsingBiomeTorches && num3 == 215)
			{
				BiomeCampfirePlaceStyle(ref num3, ref num4);
			}
			if (WorldGen.ReplaceTile(tileTargetX, tileTargetY, (ushort)num3, num4))
			{
				canUse = false;
				NetMessage.SendData(17, -1, -1, null, 21, tileTargetX, tileTargetY, num3, num4);
				ApplyItemTime(HeldItem);
				SetItemAnimation(HeldItem.useAnimation);
				PlaceThing_Tiles_PlaceIt_AutoPaintAndActuate(typeCaches, num3);
			}
		}
		return canUse;
	}

	private bool PlaceThing_ValidTileForReplacement()
	{
		int createTile = HeldItem.createTile;
		int num = HeldItem.placeStyle;
		if (UsingBiomeTorches && createTile == 4)
		{
			BiomeTorchPlaceStyle(ref createTile, ref num);
		}
		if (UsingBiomeTorches && createTile == 215)
		{
			BiomeCampfirePlaceStyle(ref createTile, ref num);
		}
		Tile tile = Main.tile[tileTargetX, tileTargetY];
		if (WorldGen.WouldTileReplacementBeBlockedByLiquid(tileTargetX, tileTargetY, 1))
		{
			return false;
		}
		if (ItemID.Sets.SortingPriorityRopes[HeldItem.type] != -1)
		{
			return false;
		}
		if (Main.tileMoss[createTile])
		{
			return false;
		}
		if (TileID.Sets.DoesntPlaceWithTileReplacement[createTile])
		{
			return false;
		}
		if (TileID.Sets.DoesntGetReplacedWithTileReplacement[tile.type])
		{
			return false;
		}
		if (!PlaceThing_CheckSpecificValidtyCaseForBlockSwap(createTile, tile.type))
		{
			return false;
		}
		if (Main.tileCut[tile.type])
		{
			return false;
		}
		if (TileID.Sets.Platforms[tile.type] && tile.type == createTile)
		{
			return tile.frameY != num * 18;
		}
		if (TileID.Sets.Torch[tile.type] && TileID.Sets.Torch[createTile])
		{
			if (tile.type == createTile)
			{
				return tile.frameY != num * 22;
			}
			return true;
		}
		if (TileID.Sets.Campfire[tile.type] && TileID.Sets.Campfire[createTile])
		{
			if (tile.type == createTile)
			{
				return tile.frameX / 54 != num;
			}
			return true;
		}
		if (TileID.Sets.BasicChest[tile.type] && TileID.Sets.BasicChest[createTile])
		{
			if (tile.frameX / 36 == num)
			{
				return tile.type != createTile;
			}
			return true;
		}
		if (TileID.Sets.BasicDresser[tile.type] && TileID.Sets.BasicDresser[createTile])
		{
			if (tile.frameX / 54 == num)
			{
				return tile.type != createTile;
			}
			return true;
		}
		bool flag = false;
		if (Main.tileRope[tile.type])
		{
			if (createTile != 314 && !TileID.Sets.Platforms[createTile])
			{
				return false;
			}
			flag = true;
		}
		if (!flag && Main.tileFrameImportant[createTile] && !TileID.Sets.Platforms[createTile])
		{
			return false;
		}
		if (Main.tile[tileTargetX, tileTargetY].type == createTile)
		{
			return false;
		}
		if (Main.tile[tileTargetX, tileTargetY].type == 230 && Main.getGoodWorld)
		{
			return false;
		}
		if (!TileID.Sets.IgnoresTileReplacementDropCheckWhenBeingPlaced[createTile])
		{
			WorldGen.KillTile_GetItemDrops(tileTargetX, tileTargetY, tile, out var dropItem, out var _, out var _, out var _);
			if (dropItem == HeldItem.type)
			{
				return false;
			}
		}
		if (!WorldGen.WouldTileReplacementWork((ushort)createTile, tileTargetX, tileTargetY))
		{
			return false;
		}
		return true;
	}

	private bool PlaceThing_CheckSpecificValidtyCaseForBlockSwap(int tileTypeBeingPlaced, int tileTypeCurrentlyPlaced)
	{
		bool flag = TileID.Sets.Falling[tileTypeBeingPlaced];
		bool flag2 = TileID.Sets.Falling[tileTypeCurrentlyPlaced] && !flag;
		if (flag2)
		{
			Item bestPickaxe = GetBestPickaxe();
			if (bestPickaxe != null && bestPickaxe.pick >= 110)
			{
				flag2 = false;
			}
		}
		if (flag2 && tileTargetY > 0)
		{
			Tile tile = Main.tile[tileTargetX, tileTargetY - 1];
			bool flag3 = false;
			if (tile != null)
			{
				flag3 |= !tile.active();
				flag3 |= tile.active() && !TileID.Sets.Falling[tile.type];
			}
			if (flag3)
			{
				flag2 = false;
			}
		}
		if (flag2)
		{
			return false;
		}
		return true;
	}

	public Item GetBestPickaxe()
	{
		Item item = null;
		for (int i = 0; i < 50; i++)
		{
			if (inventory[i].stack > 0 && inventory[i].pick > 0 && (item == null || inventory[i].pick > item.pick))
			{
				item = inventory[i];
			}
		}
		return item;
	}

	private TileObject PlaceThing_Tiles_PlaceIt(bool newObjectType, TileObject data, int tileToCreate)
	{
		int num = inventory[selectedItem].placeStyle;
		if (!newObjectType)
		{
			num = PlaceThing_Tiles_PlaceIt_GetLegacyTileStyle(num);
		}
		int[,] typeCaches = PlaceThing_Tiles_GetAutoAccessoryCache();
		bool forced = false;
		bool flag;
		if (newObjectType)
		{
			flag = TileObject.Place(data);
			WorldGen.SquareTileFrame(tileTargetX, tileTargetY);
			if (Main.netMode != 1 || !TileID.Sets.IsAContainer[tileToCreate])
			{
				SoundEngine.PlaySound(0, tileTargetX * 16, tileTargetY * 16);
			}
		}
		else
		{
			if (UsingBiomeTorches && tileToCreate == 4 && num == 0)
			{
				BiomeTorchPlaceStyle(ref tileToCreate, ref num);
			}
			flag = WorldGen.PlaceTile(tileTargetX, tileTargetY, tileToCreate, mute: false, forced, whoAmI, num);
		}
		if (flag)
		{
			ApplyItemTime(inventory[selectedItem], tileSpeed);
			if (newObjectType)
			{
				TileObjectData.CallPostPlacementPlayerHook(tileTargetX, tileTargetY, tileToCreate, num, direction, data.alternate, data);
				if (Main.netMode == 1 && !Main.tileContainer[tileToCreate] && tileToCreate != 423)
				{
					NetMessage.SendObjectPlacement(-1, tileTargetX, tileTargetY, data.type, data.style, data.alternate, data.random, direction);
				}
			}
			else
			{
				NetMessage.SendData(17, -1, -1, null, 1, tileTargetX, tileTargetY, tileToCreate, num);
				PlaceThing_Tiles_PlaceIt_SpinChairs();
				PlaceThing_Tiles_PlaceIt_SpinBedsAndBaths();
			}
			PlaceThing_Tiles_PlaceIt_AdjustPlants();
			PlaceThing_Tiles_PlaceIt_SpinTraps();
			PlaceThing_Tiles_PlaceIt_TriggerLogicLamp();
			PlaceThing_Tiles_PlaceIt_SpinSmartPlatform();
			PlaceThing_Tiles_PlaceIt_ConsumeFlexibleWandMaterial();
			PlaceThing_Tiles_PlaceIt_UnslopeForSolids();
			PlaceThing_Tiles_PlaceIt_KillGrassForSolids();
			PlaceThing_Tiles_PlaceIt_AutoPaintAndActuate(typeCaches, tileToCreate);
			if (PlayerInput.UsingGamepad && ItemID.Sets.SingleUseInGamepad[inventory[selectedItem].type] && Main.myPlayer == whoAmI && !Main.SmartCursorIsUsed)
			{
				Main.blockMouse = true;
			}
			TileLoader.PlaceInWorld(tileTargetX, tileTargetY, inventory[selectedItem]);
		}
		return data;
	}

	public void PlaceThing_Tiles_PlaceIt_ConsumeFlexibleWandMaterial()
	{
		FlexibleTileWand flexibleTileWand = inventory[selectedItem].GetFlexibleTileWand();
		if (flexibleTileWand != null && flexibleTileWand.TryGetPlacementOption(this, FlexibleWandRandomSeed, FlexibleWandCycleOffset, out var _, out var itemToConsume))
		{
			itemToConsume.stack--;
			if (itemToConsume.stack <= 0)
			{
				itemToConsume.TurnToAir();
			}
		}
	}

	public int BiomeTorchPlaceStyle(ref int type, ref int style)
	{
		if (!UsingBiomeTorches || style != 0)
		{
			return style;
		}
		if (ZoneShimmer)
		{
			style = 23;
		}
		else if (ZoneLihzhardTemple)
		{
			style = 21;
		}
		else if (ZoneDungeon)
		{
			style = 13;
		}
		else if (position.Y > (float)(Main.UnderworldLayer * 16))
		{
			style = 7;
		}
		else if (ZoneHallow)
		{
			style = 20;
		}
		else if (ZoneCorrupt)
		{
			style = 18;
		}
		else if (ZoneCrimson)
		{
			style = 19;
		}
		else if (ZoneSnow)
		{
			style = 9;
		}
		else if (ZoneGlowshroom)
		{
			style = 22;
		}
		else if (ZoneJungle)
		{
			style = 21;
		}
		else if ((ZoneDesert && (double)position.Y < Main.worldSurface * 16.0) || ZoneUndergroundDesert)
		{
			style = 16;
		}
		else if (ZoneDesert && Main.remixWorld)
		{
			style = 16;
		}
		if (CurrentSceneEffect.biomeTorchItemType.value > -1)
		{
			Item item = ContentSamples.ItemsByType[CurrentSceneEffect.biomeTorchItemType.value];
			type = item.createTile;
			style = item.placeStyle;
		}
		return style;
	}

	public int BiomeTorchHoldStyle(int style)
	{
		if (!UsingBiomeTorches || style != 8)
		{
			return style;
		}
		if (ZoneShimmer)
		{
			style = 5353;
		}
		else if (ZoneLihzhardTemple)
		{
			style = 4388;
		}
		else if (ZoneDungeon)
		{
			style = 3004;
		}
		else if (position.Y > (float)(Main.UnderworldLayer * 16))
		{
			style = 433;
		}
		else if (ZoneHallow)
		{
			style = 4387;
		}
		else if (ZoneCorrupt)
		{
			style = 4385;
		}
		else if (ZoneCrimson)
		{
			style = 4386;
		}
		else if (ZoneSnow)
		{
			style = 974;
		}
		else if (ZoneGlowshroom)
		{
			style = 5293;
		}
		else if (ZoneJungle)
		{
			style = 4388;
		}
		else if ((ZoneDesert && (double)position.Y < Main.worldSurface * 16.0) || ZoneUndergroundDesert)
		{
			style = 4383;
		}
		else if (ZoneDesert && Main.remixWorld)
		{
			style = 4383;
		}
		if (CurrentSceneEffect.biomeTorchItemType.value > -1)
		{
			style = CurrentSceneEffect.biomeTorchItemType.value;
		}
		return style;
	}

	public int BiomeCampfirePlaceStyle(ref int type, ref int style)
	{
		if (!UsingBiomeTorches || style != 0)
		{
			return style;
		}
		if (ZoneShimmer)
		{
			style = 15;
		}
		else if (ZoneLihzhardTemple)
		{
			style = 13;
		}
		else if (ZoneDungeon)
		{
			style = 7;
		}
		else if (position.Y > (float)(Main.UnderworldLayer * 16))
		{
			style = 2;
		}
		else if (ZoneHallow)
		{
			style = 12;
		}
		else if (ZoneCorrupt)
		{
			style = 10;
		}
		else if (ZoneCrimson)
		{
			style = 11;
		}
		else if (ZoneSnow)
		{
			style = 3;
		}
		else if (ZoneGlowshroom)
		{
			style = 14;
		}
		else if (ZoneJungle)
		{
			style = 13;
		}
		else if ((ZoneDesert && (double)position.Y < Main.worldSurface * 16.0) || ZoneUndergroundDesert)
		{
			style = 8;
		}
		else if (ZoneDesert && Main.remixWorld)
		{
			style = 8;
		}
		if (CurrentSceneEffect.biomeCampfireItemType.value > -1)
		{
			Item item = ContentSamples.ItemsByType[CurrentSceneEffect.biomeCampfireItemType.value];
			type = item.createTile;
			style = item.placeStyle;
		}
		return style;
	}

	public int BiomeCampfireHoldStyle(int itemType)
	{
		if (!UsingBiomeTorches || itemType != 966)
		{
			return itemType;
		}
		if (ZoneShimmer)
		{
			itemType = 5357;
		}
		else if (ZoneLihzhardTemple)
		{
			itemType = 4694;
		}
		else if (ZoneDungeon)
		{
			itemType = 3724;
		}
		else if (position.Y > (float)(Main.UnderworldLayer * 16))
		{
			itemType = 3047;
		}
		else if (ZoneHallow)
		{
			itemType = 4693;
		}
		else if (ZoneCorrupt)
		{
			itemType = 4691;
		}
		else if (ZoneCrimson)
		{
			itemType = 4692;
		}
		else if (ZoneSnow)
		{
			itemType = 3048;
		}
		else if (ZoneJungle)
		{
			itemType = 4694;
		}
		else if (ZoneGlowshroom)
		{
			itemType = 5299;
		}
		else if ((ZoneDesert && (double)position.Y < Main.worldSurface * 16.0) || ZoneUndergroundDesert)
		{
			itemType = 4689;
		}
		else if (ZoneDesert && Main.remixWorld)
		{
			itemType = 4689;
		}
		if (CurrentSceneEffect.biomeCampfireItemType.value > -1)
		{
			itemType = CurrentSceneEffect.biomeCampfireItemType.value;
		}
		return itemType;
	}

	private int[,] PlaceThing_Tiles_GetAutoAccessoryCache()
	{
		int[,] array = null;
		if (autoPaint || autoActuator)
		{
			array = new int[11, 11];
			for (int i = 0; i < 11; i++)
			{
				for (int j = 0; j < 11; j++)
				{
					int num = tileTargetX - 5 + i;
					int num2 = tileTargetY - 5 + j;
					if (Main.tile[num, num2].active())
					{
						array[i, j] = Main.tile[num, num2].type;
					}
					else
					{
						array[i, j] = -1;
					}
				}
			}
		}
		return array;
	}

	private int PlaceThing_Tiles_PlaceIt_GetLegacyTileStyle(int style)
	{
		int createTile = inventory[selectedItem].createTile;
		if (createTile == 36)
		{
			style = Main.rand.Next(7);
		}
		if (createTile == 212 && direction > 0)
		{
			style = 1;
		}
		if (createTile == 141)
		{
			style = Main.rand.Next(2);
		}
		if (createTile == 128 || createTile == 269 || createTile == 334)
		{
			style = ((direction >= 0) ? 1 : (-1));
		}
		if (createTile == 241 && inventory[selectedItem].placeStyle == 0)
		{
			style = Main.rand.Next(0, 9);
		}
		if (createTile == 35 && inventory[selectedItem].placeStyle == 0)
		{
			style = Main.rand.Next(9);
		}
		if (createTile == 314 && style == 2 && direction == 1)
		{
			style++;
		}
		if (createTile == 129)
		{
			style = (short)Main.rand.Next(18);
		}
		return style;
	}

	private void PlaceThing_Tiles_PlaceIt_UnslopeForSolids()
	{
		if (!Main.tileSolid[inventory[selectedItem].createTile] || (inventory[selectedItem].createTile >= 0 && TileID.Sets.Platforms[inventory[selectedItem].createTile]))
		{
			return;
		}
		int num = tileTargetX;
		int num2 = tileTargetY + 1;
		if (Main.tile[num, num2] != null && !TileID.Sets.Platforms[Main.tile[num, num2].type] && (Main.tile[num, num2].topSlope() || Main.tile[num, num2].halfBrick()))
		{
			WorldGen.SlopeTile(num, num2);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 14, num, num2);
			}
		}
		num = tileTargetX;
		num2 = tileTargetY - 1;
		if (Main.tile[num, num2] != null && !TileID.Sets.Platforms[Main.tile[num, num2].type] && Main.tile[num, num2].bottomSlope())
		{
			WorldGen.SlopeTile(num, num2);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 14, num, num2);
			}
		}
	}

	private void PlaceThing_Tiles_PlaceIt_KillGrassForSolids()
	{
		if (!Main.tileSolid[inventory[selectedItem].createTile])
		{
			return;
		}
		for (int i = tileTargetX - 1; i <= tileTargetX + 1; i++)
		{
			for (int j = tileTargetY - 1; j <= tileTargetY + 1; j++)
			{
				Tile tile = Main.tile[i, j];
				if (!tile.active() || inventory[selectedItem].createTile == tile.type || (tile.type != 2 && tile.type != 23 && tile.type != 60 && tile.type != 70 && tile.type != 109 && tile.type != 199 && tile.type != 477 && tile.type != 492 && tile.type != 633))
				{
					continue;
				}
				bool flag = true;
				for (int k = i - 1; k <= i + 1; k++)
				{
					for (int l = j - 1; l <= j + 1; l++)
					{
						if (!WorldGen.SolidTile(k, l))
						{
							flag = false;
						}
					}
				}
				if (flag)
				{
					WorldGen.KillTile(i, j, fail: true);
					if (Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 0, i, j, 1f);
					}
				}
			}
		}
	}

	private void PlaceThing_Tiles_PlaceIt_AutoPaintAndActuate(int[,] typeCaches, int tileToCreate)
	{
		if (!autoPaint && !autoActuator)
		{
			return;
		}
		int num = 0;
		int num2 = 0;
		int num3 = 11;
		int num4 = 11;
		bool flag = TileID.Sets.Platforms[Main.tile[tileTargetX, tileTargetY].type];
		bool flag2 = TileID.Sets.Platforms[Main.tile[tileTargetX, tileTargetY].type] && TileID.Sets.Platforms[tileToCreate];
		if (!Main.tileFrameImportant[Main.tile[tileTargetX, tileTargetY].type] || flag)
		{
			num = (num2 = 5);
			num3 = (num4 = 6);
		}
		for (int i = num; i < num3; i++)
		{
			for (int j = num2; j < num4; j++)
			{
				int num5 = tileTargetX - 5 + i;
				int num6 = tileTargetY - 5 + j;
				if ((!Main.tile[num5, num6].active() && typeCaches[i, j] == -1) || (Main.tile[num5, num6].active() && !flag2 && (typeCaches[i, j] == Main.tile[num5, num6].type || Main.tile[num5, num6].type != tileToCreate)))
				{
					continue;
				}
				if (autoPaint && builderAccStatus[3] == 0)
				{
					TryPainting(num5, num6, paintingAWall: false, applyItemAnimation: false);
				}
				if (!autoActuator || builderAccStatus[2] != 0)
				{
					continue;
				}
				bool flag3 = Main.tileSolid[Main.tile[num5, num6].type] && !TileID.Sets.NotReallySolid[Main.tile[num5, num6].type];
				ushort type = Main.tile[num5, num6].type;
				if (type == 314 || (uint)(type - 386) <= 3u)
				{
					flag3 = false;
				}
				if (!flag3)
				{
					continue;
				}
				int num7 = FindItem(849);
				if (num7 > -1 && WorldGen.PlaceActuator(num5, num6))
				{
					NetMessage.SendData(17, -1, -1, null, 8, num5, num6);
					if (ItemLoader.ConsumeItem(inventory[num7], this))
					{
						inventory[num7].stack--;
					}
					if (inventory[num7].stack <= 0)
					{
						inventory[num7].SetDefaults();
					}
				}
			}
		}
	}

	private void PlaceThing_Tiles_PlaceIt_SpinSmartPlatform()
	{
		if (inventory[selectedItem].createTile < 0 || !TileID.Sets.Platforms[inventory[selectedItem].createTile] || !Main.SmartCursorIsUsed)
		{
			return;
		}
		int num = tileTargetX;
		int num4 = tileTargetY;
		int num5 = -1;
		int num6 = 0;
		int num7 = 0;
		bool flag = true;
		for (int i = -1; i < 2; i++)
		{
			for (int j = -1; j < 2; j++)
			{
				if ((i != 0 || j != 0) && TileID.Sets.Platforms[Main.tile[num + i, num4 + j].type])
				{
					flag = false;
				}
			}
		}
		if (flag)
		{
			return;
		}
		Tile tile = Main.tile[num - 1, num4 - 1];
		if (tile.active() && TileID.Sets.Platforms[tile.type] && tile.slope() != 2)
		{
			num6++;
		}
		tile = Main.tile[num - 1, num4 + 1];
		if (tile.active() && TileID.Sets.Platforms[tile.type] && tile.slope() != 1)
		{
			num7++;
		}
		tile = Main.tile[num + 1, num4 - 1];
		if (tile.active() && TileID.Sets.Platforms[tile.type] && tile.slope() != 1)
		{
			num7++;
		}
		tile = Main.tile[num + 1, num4 + 1];
		if (tile.active() && TileID.Sets.Platforms[tile.type] && tile.slope() != 2)
		{
			num6++;
		}
		tile = Main.tile[num - 1, num4];
		if (WorldGen.SolidTile(tile))
		{
			num6++;
			if (TileID.Sets.Platforms[tile.type] && tile.slope() == 0)
			{
				num6++;
			}
		}
		tile = Main.tile[num + 1, num4];
		if (WorldGen.SolidTile(tile))
		{
			num7++;
			if (TileID.Sets.Platforms[tile.type] && tile.slope() == 0)
			{
				num7++;
			}
		}
		if (num6 > num7)
		{
			num5 = 1;
		}
		else if (num7 > num6)
		{
			num5 = 2;
		}
		tile = Main.tile[num - 1, num4];
		if (tile.active() && TileID.Sets.Platforms[tile.type])
		{
			num5 = 0;
		}
		tile = Main.tile[num + 1, num4];
		if (tile.active() && TileID.Sets.Platforms[tile.type])
		{
			num5 = 0;
		}
		int num8 = 0;
		int num9 = 0;
		if (num5 != -1)
		{
			WorldGen.SlopeTile(num, num4, num5, noEffects: true);
			int num10 = Main.tile[num, num4].slope();
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 14, tileTargetX, tileTargetY, num10);
			}
			if (num5 == 1)
			{
				num8 = -1;
				num9 = -1;
			}
			else
			{
				num8 = 1;
				num9 = -1;
			}
			tile = Main.tile[num + num8, num4 + num9];
			if (tile.active() && TileID.Sets.Platforms[tile.type] && tile.slope() == 0 && (!Main.tile[num + num8 + num8, num4 + num9].active() || !TileID.Sets.Platforms[Main.tile[num + num8 + num8, num4 + num9].type] || !Main.tile[num + num8 + num8, num4 + num9].halfBrick()))
			{
				WorldGen.SlopeTile(num + num8, num4 + num9, num5);
				num10 = tile.slope();
				if (Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 14, num + num8, num4 + num9, num10);
				}
			}
			if (num5 == 1)
			{
				num8 = 1;
				num9 = 1;
			}
			else
			{
				num8 = -1;
				num9 = 1;
			}
			tile = Main.tile[num + num8, num4 + num9];
			if (tile.active() && TileID.Sets.Platforms[tile.type] && tile.slope() == 0 && WorldGen.PlatformProperSides(num + num8, num4 + num9, acceptNonOpposing: true) <= 0)
			{
				WorldGen.SlopeTile(num + num8, num4 + num9, num5);
				num10 = tile.slope();
				if (Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 14, num + num8, num4 + num9, num10);
				}
			}
			return;
		}
		num5 = 0;
		int num11 = 0;
		num8 = -1;
		tile = Main.tile[num + num8, num4];
		if (tile.active() && TileID.Sets.Platforms[tile.type] && tile.slope() != 0)
		{
			int num2 = (tile.slope() == 1).ToDirectionInt() * num8;
			num5 = ((num2 != -1) ? tile.slope() : 0);
			bool flag2 = true;
			if (Main.tile[num + num8 * 2, num4 + num2].active() && TileID.Sets.Platforms[Main.tile[num + num8 * 2, num4].type] && num5 == Main.tile[num + num8 * 2, num4 + num2].slope())
			{
				flag2 = false;
			}
			if (Main.tile[num, num4 - num2].active() && TileID.Sets.Platforms[Main.tile[num, num4 - num2].type] && tile.slope() == Main.tile[num, num4 - num2].slope())
			{
				flag2 = false;
			}
			if (flag2)
			{
				WorldGen.SlopeTile(num + num8, num4, num5);
				num11 = tile.slope();
				if (Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 14, num + num8, num4, num11);
				}
			}
		}
		num8 = 1;
		num9 = 0;
		tile = Main.tile[num + num8, num4 + num9];
		if (tile.active() && TileID.Sets.Platforms[tile.type] && tile.slope() != 0)
		{
			int num3 = (tile.slope() == 1).ToDirectionInt() * num8;
			num5 = ((num3 != -1) ? tile.slope() : 0);
			bool flag3 = true;
			if (Main.tile[num + num8 * 2, num4 + num3].active() && TileID.Sets.Platforms[Main.tile[num + num8 * 2, num4].type] && num5 == Main.tile[num + num8 * 2, num4 + num3].slope())
			{
				flag3 = false;
			}
			if (Main.tile[num, num4 - num3].active() && TileID.Sets.Platforms[Main.tile[num, num4 - num3].type] && tile.slope() == Main.tile[num, num4 - num3].slope())
			{
				flag3 = false;
			}
			if (flag3)
			{
				WorldGen.SlopeTile(num + num8, num4, num5);
				num11 = tile.slope();
				if (Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 14, num + num8, num4, num11);
				}
			}
		}
		if (num6 != num7 || WorldGen.PlatformProperSides(num, num4) != 0)
		{
			return;
		}
		tile = Main.tile[num, num4 + 1];
		if (tile.active() && !tile.halfBrick() && tile.slope() == 0 && Main.tileSolid[tile.type])
		{
			num5 = ((direction != 1) ? 1 : 2);
			WorldGen.SlopeTile(num, num4, num5);
			num11 = Main.tile[num, num4].slope();
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 14, tileTargetX, tileTargetY, num11);
			}
		}
	}

	private void PlaceThing_Tiles_PlaceIt_TriggerLogicLamp()
	{
		if (inventory[selectedItem].createTile == 419)
		{
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 18, tileTargetX, tileTargetY);
			}
			else
			{
				Wiring.PokeLogicGate(tileTargetX, tileTargetY);
			}
		}
	}

	private void PlaceThing_Tiles_PlaceIt_SpinBedsAndBaths()
	{
		if ((inventory[selectedItem].createTile == 79 || inventory[selectedItem].createTile == 90) && Main.netMode == 1)
		{
			NetMessage.SendTileSquare(-1, tileTargetX, tileTargetY, 5);
		}
	}

	private void PlaceThing_Tiles_PlaceIt_SpinChairs()
	{
		if (inventory[selectedItem].createTile == 15)
		{
			if (direction == 1)
			{
				Tile tile = Main.tile[tileTargetX, tileTargetY];
				tile.frameX += 18;
				tile = Main.tile[tileTargetX, tileTargetY - 1];
				tile.frameX += 18;
			}
			if (Main.netMode == 1)
			{
				NetMessage.SendTileSquare(-1, tileTargetX - 1, tileTargetY - 1, 3);
			}
		}
	}

	private void PlaceThing_Tiles_PlaceIt_SpinTraps()
	{
		if (inventory[selectedItem].createTile == 137)
		{
			if (direction == 1)
			{
				Main.tile[tileTargetX, tileTargetY].frameX += 18;
			}
			if (Main.netMode == 1)
			{
				NetMessage.SendTileSquare(-1, tileTargetX, tileTargetY);
			}
		}
	}

	private void PlaceThing_Tiles_PlaceIt_AdjustPlants()
	{
		if (inventory[selectedItem].createTile != 3)
		{
			return;
		}
		FlowerPacketInfo flowerPacketInfo = ItemID.Sets.flowerPacketInfo[inventory[selectedItem].type];
		if (flowerPacketInfo == null)
		{
			return;
		}
		List<int> stylesOnPurity = flowerPacketInfo.stylesOnPurity;
		if (stylesOnPurity.Count != 0)
		{
			int num = stylesOnPurity[Main.rand.Next(stylesOnPurity.Count)];
			Main.tile[tileTargetX, tileTargetY].frameX = (short)(num * 18);
			if (Main.netMode == 1)
			{
				NetMessage.SendTileSquare(-1, tileTargetX, tileTargetY);
			}
		}
	}

	private bool PlaceThing_Tiles_PlaceIt_StaffOfRegrowthCheck(bool placed)
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		bool flag = inventory[selectedItem].type == 213 || inventory[selectedItem].type == 5295;
		if (flag && !placed && Main.tile[tileTargetX, tileTargetY].type == 1 && Main.tile[tileTargetX, tileTargetY].active())
		{
			int num = 0;
			int num2 = 0;
			Point point = base.Center.ToTileCoordinates();
			Dictionary<ushort, int> dictionary = new Dictionary<ushort, int>();
			WorldUtils.Gen(new Point(point.X - 25, point.Y - 25), new Shapes.Rectangle(50, 50), new Actions.TileScanner(182, 515, 180, 513, 179, 512, 183, 516, 181, 514, 381, 517, 534, 535, 536, 537, 539, 540, 625, 626, 627, 628).Output(dictionary));
			foreach (KeyValuePair<ushort, int> item in dictionary)
			{
				if (item.Value > num2)
				{
					num2 = item.Value;
					num = item.Key;
				}
			}
			switch (num)
			{
			case 515:
				num = 182;
				break;
			case 513:
				num = 180;
				break;
			case 512:
				num = 179;
				break;
			case 516:
				num = 183;
				break;
			case 514:
				num = 181;
				break;
			case 517:
				num = 381;
				break;
			case 535:
				num = 534;
				break;
			case 537:
				num = 536;
				break;
			case 540:
				num = 539;
				break;
			case 626:
				num = 625;
				break;
			case 628:
				num = 627;
				break;
			}
			if (num2 == 0)
			{
				num = Utils.SelectRandom<int>(Main.rand, 182, 180, 179, 183, 181);
			}
			if (num != 0)
			{
				Main.tile[tileTargetX, tileTargetY].type = (ushort)num;
				WorldGen.SquareTileFrame(tileTargetX, tileTargetY);
				NetMessage.SendTileSquare(-1, tileTargetX, tileTargetY);
				placed = true;
			}
		}
		if (flag && !placed && Main.tile[tileTargetX, tileTargetY].type == 38 && Main.tile[tileTargetX, tileTargetY].active())
		{
			int num3 = 0;
			int num4 = 0;
			Point point2 = base.Center.ToTileCoordinates();
			Dictionary<ushort, int> dictionary2 = new Dictionary<ushort, int>();
			WorldUtils.Gen(new Point(point2.X - 25, point2.Y - 25), new Shapes.Rectangle(50, 50), new Actions.TileScanner(182, 515, 180, 513, 179, 512, 183, 516, 181, 514, 381, 517, 534, 535, 536, 537, 539, 540, 625, 626, 627, 628).Output(dictionary2));
			foreach (KeyValuePair<ushort, int> item2 in dictionary2)
			{
				if (item2.Value > num4)
				{
					num4 = item2.Value;
					num3 = item2.Key;
				}
			}
			switch (num3)
			{
			case 182:
				num3 = 515;
				break;
			case 180:
				num3 = 513;
				break;
			case 179:
				num3 = 512;
				break;
			case 183:
				num3 = 516;
				break;
			case 181:
				num3 = 514;
				break;
			case 381:
				num3 = 517;
				break;
			case 534:
				num3 = 535;
				break;
			case 536:
				num3 = 537;
				break;
			case 539:
				num3 = 540;
				break;
			case 625:
				num3 = 626;
				break;
			case 627:
				num3 = 628;
				break;
			}
			if (num4 == 0)
			{
				num3 = Utils.SelectRandom<int>(Main.rand, 515, 513, 512, 516, 514);
			}
			if (num3 != 0)
			{
				Main.tile[tileTargetX, tileTargetY].type = (ushort)num3;
				WorldGen.SquareTileFrame(tileTargetX, tileTargetY);
				NetMessage.SendTileSquare(-1, tileTargetX, tileTargetY);
				placed = true;
			}
		}
		return placed;
	}

	private bool PlaceThing_Tiles_BlockPlacementForAssortedThings(bool canPlace)
	{
		bool flag = inventory[selectedItem].type == 213 || inventory[selectedItem].type == 5295;
		if (flag)
		{
			if (Main.tile[tileTargetX, tileTargetY].type == 0 || Main.tile[tileTargetX, tileTargetY].type == 1 || Main.tile[tileTargetX, tileTargetY].type == 38)
			{
				canPlace = true;
			}
		}
		else if (inventory[selectedItem].createTile == 2 || inventory[selectedItem].createTile == 109)
		{
			if (Main.tile[tileTargetX, tileTargetY].nactive() && Main.tile[tileTargetX, tileTargetY].type == 0)
			{
				canPlace = true;
			}
		}
		else if (inventory[selectedItem].createTile == 23 || inventory[selectedItem].createTile == 199)
		{
			if (Main.tile[tileTargetX, tileTargetY].nactive())
			{
				if (Main.tile[tileTargetX, tileTargetY].type == 0)
				{
					canPlace = true;
				}
				else if (Main.tile[tileTargetX, tileTargetY].type == 59)
				{
					canPlace = true;
				}
			}
		}
		else if (inventory[selectedItem].createTile == 227)
		{
			canPlace = true;
		}
		else if (inventory[selectedItem].createTile >= 373 && inventory[selectedItem].createTile <= 375)
		{
			int num = tileTargetX;
			int num2 = tileTargetY - 1;
			if (Main.tile[num, num2].nactive() && Main.tileSolid[Main.tile[num, num2].type] && !Main.tileSolidTop[Main.tile[num, num2].type])
			{
				canPlace = true;
			}
		}
		else if (inventory[selectedItem].createTile == 461)
		{
			int num3 = tileTargetX;
			int num4 = tileTargetY - 1;
			if (Main.tile[num3, num4].nactive() && Main.tileSolid[Main.tile[num3, num4].type] && !Main.tileSolidTop[Main.tile[num3, num4].type])
			{
				canPlace = true;
			}
		}
		else if (inventory[selectedItem].createTile == 60 || inventory[selectedItem].createTile == 70 || inventory[selectedItem].createTile == 661 || inventory[selectedItem].createTile == 662)
		{
			if (Main.tile[tileTargetX, tileTargetY].nactive() && Main.tile[tileTargetX, tileTargetY].type == 59)
			{
				canPlace = true;
			}
		}
		else if (TileID.Sets.Torch[inventory[selectedItem].createTile] || inventory[selectedItem].createTile == 136)
		{
			if (Main.tile[tileTargetX, tileTargetY].wall > 0)
			{
				canPlace = true;
			}
			else
			{
				if (!WorldGen.SolidTileNoAttach(tileTargetX, tileTargetY + 1) && !WorldGen.SolidTileNoAttach(tileTargetX - 1, tileTargetY) && !WorldGen.SolidTileNoAttach(tileTargetX + 1, tileTargetY))
				{
					if (!WorldGen.SolidTileNoAttach(tileTargetX, tileTargetY + 1) && (Main.tile[tileTargetX, tileTargetY + 1].halfBrick() || Main.tile[tileTargetX, tileTargetY + 1].slope() != 0))
					{
						if (!TileID.Sets.Platforms[Main.tile[tileTargetX, tileTargetY + 1].type])
						{
							WorldGen.SlopeTile(tileTargetX, tileTargetY + 1);
							if (Main.netMode == 1)
							{
								NetMessage.SendData(17, -1, -1, null, 14, tileTargetX, tileTargetY + 1);
							}
						}
					}
					else if (!WorldGen.SolidTileNoAttach(tileTargetX, tileTargetY + 1) && !WorldGen.SolidTileNoAttach(tileTargetX - 1, tileTargetY) && (Main.tile[tileTargetX - 1, tileTargetY].halfBrick() || Main.tile[tileTargetX - 1, tileTargetY].slope() != 0))
					{
						if (!TileID.Sets.Platforms[Main.tile[tileTargetX - 1, tileTargetY].type])
						{
							WorldGen.SlopeTile(tileTargetX - 1, tileTargetY);
							if (Main.netMode == 1)
							{
								NetMessage.SendData(17, -1, -1, null, 14, tileTargetX - 1, tileTargetY);
							}
						}
					}
					else if (!WorldGen.SolidTileNoAttach(tileTargetX, tileTargetY + 1) && !WorldGen.SolidTileNoAttach(tileTargetX + 1, tileTargetY) && (Main.tile[tileTargetX + 1, tileTargetY].halfBrick() || Main.tile[tileTargetX + 1, tileTargetY].slope() != 0) && !TileID.Sets.Platforms[Main.tile[tileTargetX + 1, tileTargetY].type])
					{
						WorldGen.SlopeTile(tileTargetX + 1, tileTargetY);
						if (Main.netMode == 1)
						{
							NetMessage.SendData(17, -1, -1, null, 14, tileTargetX + 1, tileTargetY);
						}
					}
				}
				int num5 = Main.tile[tileTargetX, tileTargetY + 1].type;
				if (Main.tile[tileTargetX, tileTargetY].halfBrick())
				{
					num5 = -1;
				}
				int num6 = Main.tile[tileTargetX - 1, tileTargetY].type;
				int num7 = Main.tile[tileTargetX + 1, tileTargetY].type;
				int tree = Main.tile[tileTargetX - 1, tileTargetY - 1].type;
				int tree2 = Main.tile[tileTargetX + 1, tileTargetY - 1].type;
				int tree3 = Main.tile[tileTargetX - 1, tileTargetY - 1].type;
				int tree4 = Main.tile[tileTargetX + 1, tileTargetY + 1].type;
				if (!Main.tile[tileTargetX, tileTargetY + 1].nactive())
				{
					num5 = -1;
				}
				if (!Main.tile[tileTargetX - 1, tileTargetY].nactive())
				{
					num6 = -1;
				}
				if (!Main.tile[tileTargetX + 1, tileTargetY].nactive())
				{
					num7 = -1;
				}
				if (!Main.tile[tileTargetX - 1, tileTargetY - 1].nactive())
				{
					tree = -1;
				}
				if (!Main.tile[tileTargetX + 1, tileTargetY - 1].nactive())
				{
					tree2 = -1;
				}
				if (!Main.tile[tileTargetX - 1, tileTargetY + 1].nactive())
				{
					tree3 = -1;
				}
				if (!Main.tile[tileTargetX + 1, tileTargetY + 1].nactive())
				{
					tree4 = -1;
				}
				if (num5 >= 0 && Main.tileSolid[num5] && (!Main.tileNoAttach[num5] || (num5 >= 0 && TileID.Sets.Platforms[num5])))
				{
					canPlace = true;
				}
				else if ((num6 >= 0 && Main.tileSolid[num6] && !Main.tileNoAttach[num6]) || (WorldGen.IsTreeType(num6) && WorldGen.IsTreeType(tree) && WorldGen.IsTreeType(tree3)) || (num6 >= 0 && TileID.Sets.IsBeam[num6]))
				{
					canPlace = true;
				}
				else if ((num7 >= 0 && Main.tileSolid[num7] && !Main.tileNoAttach[num7]) || (WorldGen.IsTreeType(num7) && WorldGen.IsTreeType(tree2) && WorldGen.IsTreeType(tree4)) || (num7 >= 0 && TileID.Sets.IsBeam[num7]))
				{
					canPlace = true;
				}
			}
		}
		else if (inventory[selectedItem].createTile == 78 || inventory[selectedItem].createTile == 98 || inventory[selectedItem].createTile == 100 || inventory[selectedItem].createTile == 173 || inventory[selectedItem].createTile == 174 || inventory[selectedItem].createTile == 324)
		{
			if (Main.tile[tileTargetX, tileTargetY + 1].nactive() && (Main.tileSolid[Main.tile[tileTargetX, tileTargetY + 1].type] || Main.tileTable[Main.tile[tileTargetX, tileTargetY + 1].type]))
			{
				canPlace = true;
			}
		}
		else if (inventory[selectedItem].createTile == 419)
		{
			if (Main.tile[tileTargetX, tileTargetY + 1].active() && (Main.tile[tileTargetX, tileTargetY + 1].type == 419 || (inventory[selectedItem].placeStyle != 2 && Main.tile[tileTargetX, tileTargetY + 1].type == 420)))
			{
				canPlace = true;
			}
		}
		else if (inventory[selectedItem].createTile == 13 || inventory[selectedItem].createTile == 29 || inventory[selectedItem].createTile == 33 || inventory[selectedItem].createTile == 49 || inventory[selectedItem].createTile == 50 || inventory[selectedItem].createTile == 103)
		{
			if (Main.tile[tileTargetX, tileTargetY + 1].nactive() && Main.tileTable[Main.tile[tileTargetX, tileTargetY + 1].type])
			{
				canPlace = true;
			}
		}
		else if (inventory[selectedItem].createTile == 275 || inventory[selectedItem].createTile == 276 || inventory[selectedItem].createTile == 277)
		{
			canPlace = true;
		}
		else if (TileID.Sets.CanPlaceNextToNonSolidTile[inventory[selectedItem].createTile])
		{
			if (Main.tile[tileTargetX + 1, tileTargetY].active() || Main.tile[tileTargetX + 1, tileTargetY].wall > 0 || Main.tile[tileTargetX - 1, tileTargetY].active() || Main.tile[tileTargetX - 1, tileTargetY].wall > 0 || Main.tile[tileTargetX, tileTargetY + 1].active() || Main.tile[tileTargetX, tileTargetY + 1].wall > 0 || Main.tile[tileTargetX, tileTargetY - 1].active() || Main.tile[tileTargetX, tileTargetY - 1].wall > 0)
			{
				canPlace = true;
			}
		}
		else if (inventory[selectedItem].createTile == 314)
		{
			for (int i = tileTargetX - 1; i <= tileTargetX + 1; i++)
			{
				for (int j = tileTargetY - 1; j <= tileTargetY + 1; j++)
				{
					Tile tile = Main.tile[i, j];
					if (tile.active() || tile.wall > 0)
					{
						canPlace = true;
						break;
					}
				}
			}
		}
		else
		{
			Tile tile2 = Main.tile[tileTargetX - 1, tileTargetY];
			Tile tile3 = Main.tile[tileTargetX + 1, tileTargetY];
			Tile tile4 = Main.tile[tileTargetX, tileTargetY - 1];
			Tile tile5 = Main.tile[tileTargetX, tileTargetY + 1];
			if ((tile3.active() && (Main.tileSolid[tile3.type] || TileID.Sets.IsBeam[tile3.type] || Main.tileRope[tile3.type] || tile3.type == 314)) || tile3.wall > 0 || (tile2.active() && (Main.tileSolid[tile2.type] || TileID.Sets.IsBeam[tile2.type] || Main.tileRope[tile2.type] || tile2.type == 314)) || tile2.wall > 0 || (tile5.active() && (Main.tileSolid[tile5.type] || TileID.Sets.IsBeam[tile5.type] || Main.tileRope[tile5.type] || tile5.type == 314)) || tile5.wall > 0 || (tile4.active() && (Main.tileSolid[tile4.type] || TileID.Sets.IsBeam[tile4.type] || Main.tileRope[tile4.type] || tile4.type == 314)) || tile4.wall > 0)
			{
				canPlace = true;
			}
			else if (Main.tile[tileTargetX, tileTargetY].wall > 0)
			{
				canPlace = true;
			}
		}
		if (flag && Main.tile[tileTargetX, tileTargetY].active())
		{
			int num8 = tileTargetX;
			int num9 = tileTargetY;
			if (Main.tile[num8, num9].type == 3 || Main.tile[num8, num9].type == 73 || Main.tile[num8, num9].type == 84)
			{
				WorldGen.KillTile(tileTargetX, tileTargetY);
				if (!Main.tile[tileTargetX, tileTargetY].active() && Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 0, tileTargetX, tileTargetY);
				}
			}
			else if (Main.tile[num8, num9].type == 83)
			{
				bool flag2 = false;
				int num10 = Main.tile[num8, num9].frameX / 18;
				if (num10 == 0 && Main.dayTime)
				{
					flag2 = true;
				}
				if (num10 == 1 && !Main.dayTime)
				{
					flag2 = true;
				}
				if (num10 == 3 && !Main.dayTime && (Main.bloodMoon || Main.moonPhase == 0))
				{
					flag2 = true;
				}
				if (num10 == 4 && (Main.raining || Main.cloudAlpha > 0f))
				{
					flag2 = true;
				}
				if (num10 == 5 && !Main.raining && Main.dayTime && Main.time > 40500.0)
				{
					flag2 = true;
				}
				if (flag2)
				{
					WorldGen.KillTile(tileTargetX, tileTargetY);
					NetMessage.SendData(17, -1, -1, null, 0, tileTargetX, tileTargetY);
				}
			}
		}
		if (Main.tileAlch[inventory[selectedItem].createTile])
		{
			canPlace = true;
		}
		if (Main.tile[tileTargetX, tileTargetY].active() && (Main.tileCut[Main.tile[tileTargetX, tileTargetY].type] || TileID.Sets.BreakableWhenPlacing[Main.tile[tileTargetX, tileTargetY].type] || (Main.tile[tileTargetX, tileTargetY].type >= 373 && Main.tile[tileTargetX, tileTargetY].type <= 375) || Main.tile[tileTargetX, tileTargetY].type == 461))
		{
			if (Main.tile[tileTargetX, tileTargetY].type != inventory[selectedItem].createTile)
			{
				bool num11 = Main.tile[tileTargetX, tileTargetY + 1].type != 78 && Main.tile[tileTargetX, tileTargetY + 1].type != 380 && Main.tile[tileTargetX, tileTargetY + 1].type != 579;
				bool flag3 = Main.tile[tileTargetX, tileTargetY].type == 3 || Main.tile[tileTargetX, tileTargetY].type == 73;
				bool flag4 = Main.tileAlch[Main.tile[tileTargetX, tileTargetY].type] && WorldGen.IsHarvestableHerbWithSeed(Main.tile[tileTargetX, tileTargetY].type, Main.tile[tileTargetX, tileTargetY].frameX / 18);
				bool flag5 = Main.tileAlch[inventory[selectedItem].createTile];
				if (num11 || ((flag3 || flag4) && flag5))
				{
					WorldGen.KillTile(tileTargetX, tileTargetY);
					if (!Main.tile[tileTargetX, tileTargetY].active() && Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 0, tileTargetX, tileTargetY);
					}
				}
				else
				{
					canPlace = false;
				}
			}
			else
			{
				canPlace = false;
			}
		}
		if (!canPlace && inventory[selectedItem].createTile >= 0 && TileID.Sets.Platforms[inventory[selectedItem].createTile])
		{
			for (int k = tileTargetX - 1; k <= tileTargetX + 1; k++)
			{
				for (int l = tileTargetY - 1; l <= tileTargetY + 1; l++)
				{
					if (Main.tile[k, l].active())
					{
						canPlace = true;
						break;
					}
				}
			}
		}
		if (inventory[selectedItem].createTile == 3)
		{
			canPlace = WorldGen.IsFitToPlaceFlowerIn(tileTargetX, tileTargetY, 3);
			if (canPlace)
			{
				WorldGen.KillTile(tileTargetX, tileTargetY);
				if (Main.netMode == 1 && !Main.tile[tileTargetX, tileTargetY].active())
				{
					NetMessage.SendData(17, -1, -1, null, 0, tileTargetX, tileTargetY);
				}
			}
		}
		return canPlace;
	}

	private static void PlaceThing_Tiles_BlockPlacementForRepeatedPumpkins(ref bool canPlace, ref TileObject data)
	{
		if (data.type != 254)
		{
			return;
		}
		for (int i = -1; i < 1; i++)
		{
			for (int j = 0; j < 2; j++)
			{
				if (!WorldGen.CanCutTile(tileTargetX + j, tileTargetY + i, TileCuttingContext.TilePlacement))
				{
					canPlace = false;
				}
			}
		}
	}

	private static void PlaceThing_Tiles_BlockPlacementForRepeatedCoralAndBeachPiles(ref bool canPlace, ref TileObject data)
	{
		if (data.type == 81 || data.type == 324)
		{
			Tile tile = Main.tile[tileTargetX, tileTargetY];
			if (tile.active() && (Main.tileCut[tile.type] || TileID.Sets.BreakableWhenPlacing[tile.type] || (tile.type >= 373 && tile.type <= 375) || tile.type == 461))
			{
				canPlace = false;
			}
		}
	}

	private static void PlaceThing_Tiles_BlockPlacementForRepeatedPigronatas(ref bool canPlace, ref TileObject data)
	{
		if (data.type != 454)
		{
			return;
		}
		for (int i = -2; i < 2; i++)
		{
			Tile tile = Main.tile[tileTargetX + i, tileTargetY];
			if (tile.active() && tile.type == 454)
			{
				canPlace = false;
			}
		}
	}

	private static void PlaceThing_Tiles_BlockPlacementIfOverPlayers(ref bool canPlace, ref TileObject data)
	{
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		int num2 = 0;
		int x = 0;
		int y = 0;
		switch (data.type)
		{
		case 138:
		case 664:
			num = 32;
			num2 = 32;
			x = data.xCoord * 16;
			y = data.yCoord * 16;
			break;
		case 484:
			num = 32;
			num2 = 32;
			x = data.xCoord * 16;
			y = data.yCoord * 16;
			break;
		case 235:
			num = 48;
			num2 = 16;
			x = data.xCoord * 16;
			y = data.yCoord * 16;
			break;
		case 476:
			num = 16;
			num2 = 16;
			x = data.xCoord * 16;
			y = data.yCoord * 16;
			break;
		case 387:
			num = 32;
			num2 = 16;
			x = data.xCoord * 16;
			y = data.yCoord * 16;
			break;
		}
		if (num == 0 || num2 == 0)
		{
			return;
		}
		Rectangle value = default(Rectangle);
		((Rectangle)(ref value))._002Ector(x, y, num, num2);
		for (int i = 0; i < 255; i++)
		{
			Player player = Main.player[i];
			if (player.active && !player.dead && !player.ghost)
			{
				Rectangle hitbox = player.Hitbox;
				if (((Rectangle)(ref hitbox)).Intersects(value))
				{
					canPlace = false;
					break;
				}
			}
		}
	}

	private bool PlaceThing_Tiles_CheckLavaBlocking()
	{
		bool result = false;
		if (Main.tile[tileTargetX, tileTargetY].liquid > 0 && Main.tile[tileTargetX, tileTargetY].lava())
		{
			if (Main.tileSolid[inventory[selectedItem].createTile])
			{
				result = true;
			}
			else if (!TileObjectData.CheckLiquidPlacement(inventory[selectedItem].createTile, inventory[selectedItem].placeStyle, Main.tile[tileTargetX, tileTargetY]))
			{
				result = true;
			}
		}
		return result;
	}

	private bool PlaceThing_Tiles_CheckRopeUsability(bool canUse)
	{
		if (Main.tileRope[inventory[selectedItem].createTile] && canUse && Main.tile[tileTargetX, tileTargetY].active() && Main.tileRope[Main.tile[tileTargetX, tileTargetY].type])
		{
			int num = tileTargetY;
			int num2 = tileTargetX;
			bool flag = inventory[selectedItem].createTile == 214;
			while (Main.tile[num2, num].active() && (Main.tileRope[Main.tile[num2, num].type] || Main.tile[num2, num].type == 314 || TileID.Sets.Platforms[Main.tile[num2, num].type]) && num < Main.maxTilesY - 5 && Main.tile[num2, num + 2] != null && (flag || !Main.tile[num2, num + 1].lava()))
			{
				num++;
				if (Main.tile[num2, num] == null)
				{
					canUse = false;
					num = tileTargetY;
					break;
				}
			}
			if (!Main.tile[num2, num].active())
			{
				tileTargetY = num;
			}
		}
		return canUse;
	}

	private bool PlaceThing_Tiles_CheckFlexibleWand(bool canUse)
	{
		FlexibleTileWand.PlacementOption option;
		Item itemToConsume;
		return inventory[selectedItem].GetFlexibleTileWand()?.TryGetPlacementOption(this, FlexibleWandRandomSeed, FlexibleWandCycleOffset, out option, out itemToConsume) ?? canUse;
	}

	private bool PlaceThing_Tiles_CheckWandUsability(bool canUse)
	{
		if (inventory[selectedItem].tileWand > 0)
		{
			int tileWand = inventory[selectedItem].tileWand;
			canUse = false;
			for (int i = 0; i < 58; i++)
			{
				if (tileWand == inventory[i].type && inventory[i].stack > 0)
				{
					canUse = true;
					break;
				}
			}
		}
		return canUse;
	}

	private bool PlaceThing_Tiles_CheckGamepadTorchUsability(bool canUse)
	{
		if (PlayerInput.UsingGamepad && inventory[selectedItem].createTile == 4 && Main.SmartCursorIsUsed && !Main.SmartCursorShowing)
		{
			canUse = false;
		}
		return canUse;
	}

	private void PlaceThing_LockChest()
	{
		Tile tile = Main.tile[tileTargetX, tileTargetY];
		Item item = inventory[selectedItem];
		if (!tile.active() || item.type != 5328 || !TileID.Sets.IsAContainer[tile.type] || !(position.X / 16f - (float)tileRangeX - (float)item.tileBoost - (float)blockRange <= (float)tileTargetX) || !((position.X + (float)width) / 16f + (float)tileRangeX + (float)item.tileBoost - 1f + (float)blockRange >= (float)tileTargetX) || !(position.Y / 16f - (float)tileRangeY - (float)item.tileBoost - (float)blockRange <= (float)tileTargetY) || !((position.Y + (float)height) / 16f + (float)tileRangeY + (float)item.tileBoost - 2f + (float)blockRange >= (float)tileTargetY) || !ItemTimeIsZero || itemAnimation <= 0 || !controlUseItem)
		{
			return;
		}
		Tile tileSafely = Framing.GetTileSafely(tileTargetX, tileTargetY);
		int type = tileSafely.type;
		int num = tileSafely.frameX / 36;
		switch (type)
		{
		case 21:
			switch (num)
			{
			default:
				return;
			case 1:
			case 3:
			case 18:
			case 19:
			case 20:
			case 21:
			case 22:
			case 35:
			case 37:
			case 39:
				break;
			}
			break;
		case 467:
			if (num != 12)
			{
				return;
			}
			break;
		}
		if (inventory[selectedItem].stack <= 0)
		{
			return;
		}
		int num2;
		for (num2 = Main.tile[tileTargetX, tileTargetY].frameX / 18; num2 > 1; num2 -= 2)
		{
		}
		num2 = tileTargetX - num2;
		int num3 = tileTargetY - Main.tile[tileTargetX, tileTargetY].frameY / 18;
		if (Chest.Lock(num2, num3))
		{
			inventory[selectedItem].stack--;
			if (inventory[selectedItem].stack <= 0)
			{
				inventory[selectedItem] = new Item();
			}
			if (Main.netMode == 1)
			{
				NetMessage.SendData(52, -1, -1, null, whoAmI, 3f, num2, num3);
			}
		}
	}

	private void PlaceThing_ItemInExtractinator(ref ItemCheckContext context)
	{
		Tile tile = Main.tile[tileTargetX, tileTargetY];
		Item item = inventory[selectedItem];
		if (!tile.active() || !(position.X / 16f - (float)tileRangeX - (float)item.tileBoost - (float)blockRange <= (float)tileTargetX) || !((position.X + (float)width) / 16f + (float)tileRangeX + (float)item.tileBoost - 1f + (float)blockRange >= (float)tileTargetX) || !(position.Y / 16f - (float)tileRangeY - (float)item.tileBoost - (float)blockRange <= (float)tileTargetY) || !((position.Y + (float)height) / 16f + (float)tileRangeY + (float)item.tileBoost - 2f + (float)blockRange >= (float)tileTargetY) || !ItemTimeIsZero || itemAnimation <= 0 || !controlUseItem)
		{
			return;
		}
		float num = 1f;
		if (tile.type == 642)
		{
			num *= 0.33f;
		}
		ItemTrader itemTrader = TryGettingItemTraderFromBlock(tile);
		if (itemTrader != null && itemTrader.TryGetTradeOption(item, out var option))
		{
			SoundEngine.PlaySound(7);
			ApplyItemTime(item, num);
			context.SkipItemConsumption = true;
			item.stack -= option.TakingItemStack;
			if (item.stack <= 0)
			{
				item.TurnToAir();
			}
			DropItemFromExtractinator(option.GivingITemType, option.GivingItemStack);
		}
		else if (ItemID.Sets.ExtractinatorMode[item.type] >= 0 && (tile.type == 219 || tile.type == 642))
		{
			ApplyItemTime(item, num);
			SoundEngine.PlaySound(7);
			int extractType = ItemID.Sets.ExtractinatorMode[item.type];
			ExtractinatorUse(extractType, tile.type);
		}
	}

	private static ItemTrader TryGettingItemTraderFromBlock(Tile targetBlock)
	{
		ItemTrader result = null;
		if (targetBlock.type == 642)
		{
			result = ItemTrader.ChlorophyteExtractinator;
		}
		return result;
	}

	private void PlaceThing_XMasTreeTops()
	{
		if (inventory[selectedItem].type < 1874 || inventory[selectedItem].type > 1905 || !Main.tile[tileTargetX, tileTargetY].active() || Main.tile[tileTargetX, tileTargetY].type != 171 || !(position.X / 16f - (float)tileRangeX - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetX) || !((position.X + (float)width) / 16f + (float)tileRangeX + (float)inventory[selectedItem].tileBoost - 1f + (float)blockRange >= (float)tileTargetX) || !(position.Y / 16f - (float)tileRangeY - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetY) || !((position.Y + (float)height) / 16f + (float)tileRangeY + (float)inventory[selectedItem].tileBoost - 2f + (float)blockRange >= (float)tileTargetY) || !ItemTimeIsZero || itemAnimation <= 0 || !controlUseItem)
		{
			return;
		}
		int type = inventory[selectedItem].type;
		if (type >= 1874 && type <= 1877)
		{
			type -= 1873;
			if (WorldGen.checkXmasTreeDrop(tileTargetX, tileTargetY, 0) != type)
			{
				ApplyItemTime(inventory[selectedItem]);
				WorldGen.dropXmasTree(tileTargetX, tileTargetY, 0);
				WorldGen.setXmasTree(tileTargetX, tileTargetY, 0, type);
				int num = tileTargetX;
				int num2 = tileTargetY;
				if (Main.tile[tileTargetX, tileTargetY].frameX < 10)
				{
					num -= Main.tile[tileTargetX, tileTargetY].frameX;
					num2 -= Main.tile[tileTargetX, tileTargetY].frameY;
				}
				NetMessage.SendTileSquare(-1, num, num2);
			}
		}
		else if (type >= 1878 && type <= 1883)
		{
			type -= 1877;
			if (WorldGen.checkXmasTreeDrop(tileTargetX, tileTargetY, 1) != type)
			{
				ApplyItemTime(inventory[selectedItem]);
				WorldGen.dropXmasTree(tileTargetX, tileTargetY, 1);
				WorldGen.setXmasTree(tileTargetX, tileTargetY, 1, type);
				int num3 = tileTargetX;
				int num4 = tileTargetY;
				if (Main.tile[tileTargetX, tileTargetY].frameX < 10)
				{
					num3 -= Main.tile[tileTargetX, tileTargetY].frameX;
					num4 -= Main.tile[tileTargetX, tileTargetY].frameY;
				}
				NetMessage.SendTileSquare(-1, num3, num4);
			}
		}
		else if (type >= 1884 && type <= 1894)
		{
			type -= 1883;
			if (WorldGen.checkXmasTreeDrop(tileTargetX, tileTargetY, 2) != type)
			{
				ApplyItemTime(inventory[selectedItem]);
				WorldGen.dropXmasTree(tileTargetX, tileTargetY, 2);
				WorldGen.setXmasTree(tileTargetX, tileTargetY, 2, type);
				int num5 = tileTargetX;
				int num6 = tileTargetY;
				if (Main.tile[tileTargetX, tileTargetY].frameX < 10)
				{
					num5 -= Main.tile[tileTargetX, tileTargetY].frameX;
					num6 -= Main.tile[tileTargetX, tileTargetY].frameY;
				}
				NetMessage.SendTileSquare(-1, num5, num6);
			}
		}
		else
		{
			if (type < 1895 || type > 1905)
			{
				return;
			}
			type -= 1894;
			if (WorldGen.checkXmasTreeDrop(tileTargetX, tileTargetY, 3) != type)
			{
				ApplyItemTime(inventory[selectedItem]);
				WorldGen.dropXmasTree(tileTargetX, tileTargetY, 3);
				WorldGen.setXmasTree(tileTargetX, tileTargetY, 3, type);
				int num7 = tileTargetX;
				int num8 = tileTargetY;
				if (Main.tile[tileTargetX, tileTargetY].frameX < 10)
				{
					num7 -= Main.tile[tileTargetX, tileTargetY].frameX;
					num8 -= Main.tile[tileTargetX, tileTargetY].frameY;
				}
				NetMessage.SendTileSquare(-1, num7, num8);
			}
		}
	}

	private void PlaceThing_CannonBall()
	{
		if ((inventory[selectedItem].type == 929 || inventory[selectedItem].type == 1338 || inventory[selectedItem].type == 1345) && position.X / 16f - (float)tileRangeX - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetX && (position.X + (float)width) / 16f + (float)tileRangeX + (float)inventory[selectedItem].tileBoost - 1f + (float)blockRange >= (float)tileTargetX && position.Y / 16f - (float)tileRangeY - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetY && (position.Y + (float)height) / 16f + (float)tileRangeY + (float)inventory[selectedItem].tileBoost - 2f + (float)blockRange >= (float)tileTargetY)
		{
			int num = tileTargetX;
			int num2 = tileTargetY;
			if (Main.tile[num, num2].active() && Main.tile[num, num2].type == 209)
			{
				ShootFromCannon(num, num2);
			}
		}
	}

	private void PlaceThing_PaintScrapper()
	{
		if (ItemID.Sets.IsPaintScraper[inventory[selectedItem].type] && position.X / 16f - (float)tileRangeX - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetX && (position.X + (float)width) / 16f + (float)tileRangeX + (float)inventory[selectedItem].tileBoost - 1f + (float)blockRange >= (float)tileTargetX && position.Y / 16f - (float)tileRangeY - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetY && (position.Y + (float)height) / 16f + (float)tileRangeY + (float)inventory[selectedItem].tileBoost - 2f + (float)blockRange >= (float)tileTargetY)
		{
			int num = tileTargetX;
			int num2 = tileTargetY;
			if (Main.tile[num, num2] != null)
			{
				PlaceThing_PaintScrapper_TryScrapping(num, num2);
				PlaceThing_PaintScrapper_LongMoss(num, num2);
			}
		}
	}

	private void PlaceThing_PaintScrapper_LongMoss(int x, int y)
	{
		Tile tile = Main.tile[x, y];
		if (tile.type != 184)
		{
			return;
		}
		cursorItemIconEnabled = true;
		if (!ItemTimeIsZero || itemAnimation <= 0 || !controlUseItem)
		{
			return;
		}
		tile = Main.tile[x, y];
		_ = ref tile.type;
		tile = Main.tile[x, y];
		int frameX = tile.frameX;
		WorldGen.KillTile(x, y);
		tile = Main.tile[x, y];
		if (tile.active())
		{
			return;
		}
		ApplyItemTime(inventory[selectedItem]);
		if (Main.netMode == 1)
		{
			NetMessage.SendData(17, -1, -1, null, 0, x, y);
		}
		if (Main.rand.Next(9) == 0)
		{
			int type = 4349 + frameX / 22;
			switch (frameX / 22)
			{
			case 6:
				type = 4377;
				break;
			case 7:
				type = 4378;
				break;
			case 8:
				type = 4389;
				break;
			case 9:
				type = 5127;
				break;
			case 10:
				type = 5128;
				break;
			}
			int number = Item.NewItem(new EntitySource_ItemUse(this, HeldItem), x * 16, y * 16, 16, 16, type);
			NetMessage.SendData(21, -1, -1, null, number, 1f);
		}
	}

	private void PlaceThing_PaintScrapper_TryScrapping(int x, int y)
	{
		Tile tile = Main.tile[x, y];
		if ((0 | ((tile.wall > 0 && (tile.wallColor() > 0 || tile.invisibleWall() || tile.fullbrightWall())) ? 1 : 0) | ((tile.active() && (tile.color() > 0 || tile.invisibleBlock() || tile.fullbrightBlock())) ? 1 : 0)) == 0)
		{
			return;
		}
		cursorItemIconEnabled = true;
		if (ItemTimeIsZero && itemAnimation > 0 && controlUseItem)
		{
			if (WorldGen.paintTile(x, y, 0, broadCast: true) || WorldGen.paintCoatTile(x, y, 0, broadcast: true))
			{
				ApplyItemTime(inventory[selectedItem], tileSpeed);
			}
			else if (WorldGen.paintWall(x, y, 0, broadCast: true) || WorldGen.paintCoatWall(x, y, 0, broadcast: true))
			{
				ApplyItemTime(inventory[selectedItem], wallSpeed);
			}
		}
	}

	private void PlaceThing_PaintRoller()
	{
		if ((inventory[selectedItem].type != 1072 && inventory[selectedItem].type != 1544) || !(position.X / 16f - (float)tileRangeX - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetX) || !((position.X + (float)width) / 16f + (float)tileRangeX + (float)inventory[selectedItem].tileBoost - 1f + (float)blockRange >= (float)tileTargetX) || !(position.Y / 16f - (float)tileRangeY - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetY) || !((position.Y + (float)height) / 16f + (float)tileRangeY + (float)inventory[selectedItem].tileBoost - 2f + (float)blockRange >= (float)tileTargetY))
		{
			return;
		}
		int num = tileTargetX;
		int num2 = tileTargetY;
		if (Main.tile[num, num2] != null && Main.tile[num, num2].wall > 0)
		{
			cursorItemIconEnabled = true;
			if (ItemTimeIsZero && itemAnimation > 0 && controlUseItem)
			{
				TryPainting(num, num2, paintingAWall: true);
			}
		}
	}

	private void PlaceThing_Paintbrush()
	{
		if ((inventory[selectedItem].type != 1071 && inventory[selectedItem].type != 1543) || !(position.X / 16f - (float)tileRangeX - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetX) || !((position.X + (float)width) / 16f + (float)tileRangeX + (float)inventory[selectedItem].tileBoost - 1f + (float)blockRange >= (float)tileTargetX) || !(position.Y / 16f - (float)tileRangeY - (float)inventory[selectedItem].tileBoost - (float)blockRange <= (float)tileTargetY) || !((position.Y + (float)height) / 16f + (float)tileRangeY + (float)inventory[selectedItem].tileBoost - 2f + (float)blockRange >= (float)tileTargetY))
		{
			return;
		}
		int num = tileTargetX;
		int num2 = tileTargetY;
		if (Main.tile[num, num2] != null && Main.tile[num, num2].active())
		{
			cursorItemIconEnabled = true;
			if (ItemTimeIsZero && itemAnimation > 0 && controlUseItem)
			{
				TryPainting(num, num2);
			}
		}
	}

	public Item FindPaintOrCoating()
	{
		for (int i = 54; i < 58; i++)
		{
			if (inventory[i].stack > 0 && inventory[i].PaintOrCoating)
			{
				return inventory[i];
			}
		}
		for (int j = 0; j < 58; j++)
		{
			if (inventory[j].stack > 0 && inventory[j].PaintOrCoating)
			{
				return inventory[j];
			}
		}
		return null;
	}

	private void TryPainting(int x, int y, bool paintingAWall = false, bool applyItemAnimation = true)
	{
		Item item = FindPaintOrCoating();
		if (item != null)
		{
			if (item.paintCoating != 0)
			{
				ApplyCoating(x, y, paintingAWall, applyItemAnimation, item);
			}
			if (item.paint != 0)
			{
				ApplyPaint(x, y, paintingAWall, applyItemAnimation, item);
			}
		}
	}

	private void ApplyCoating(int x, int y, bool paintingAWall, bool applyItemAnimation, Item targetItem)
	{
		byte paintCoating = targetItem.paintCoating;
		if (paintingAWall)
		{
			if (WorldGen.paintCoatWall(x, y, paintCoating, broadcast: true))
			{
				targetItem.stack--;
				if (targetItem.stack <= 0)
				{
					targetItem.SetDefaults();
				}
				if (applyItemAnimation)
				{
					ApplyItemTime(inventory[selectedItem], wallSpeed);
				}
			}
		}
		else if (WorldGen.paintCoatTile(x, y, paintCoating, broadcast: true))
		{
			targetItem.stack--;
			if (targetItem.stack <= 0)
			{
				targetItem.SetDefaults();
			}
			if (applyItemAnimation)
			{
				ApplyItemTime(inventory[selectedItem], tileSpeed);
			}
		}
	}

	private void ApplyPaint(int x, int y, bool paintingAWall, bool applyItemAnimation, Item targetItem)
	{
		byte paint = targetItem.paint;
		if (paintingAWall)
		{
			if (Main.tile[x, y].wallColor() != paint && WorldGen.paintWall(x, y, paint, broadCast: true))
			{
				if (ItemLoader.ConsumeItem(targetItem, this))
				{
					targetItem.stack--;
				}
				if (targetItem.stack <= 0)
				{
					targetItem.SetDefaults();
				}
				if (applyItemAnimation)
				{
					ApplyItemTime(inventory[selectedItem], wallSpeed);
				}
			}
		}
		else if (Main.tile[x, y].color() != paint && WorldGen.paintTile(x, y, paint, broadCast: true))
		{
			if (ItemLoader.ConsumeItem(targetItem, this))
			{
				targetItem.stack--;
			}
			if (targetItem.stack <= 0)
			{
				targetItem.SetDefaults();
			}
			if (applyItemAnimation)
			{
				ApplyItemTime(inventory[selectedItem], tileSpeed);
			}
		}
	}

	private void ShootFromCannon(int x, int y)
	{
		int num = 0;
		int num2 = Main.tile[x, y].frameX / 72;
		int type = inventory[selectedItem].type;
		if (num2 == 0 && type == 929)
		{
			num = 1;
		}
		else if (num2 == 1 && type == 1338)
		{
			num = 2;
		}
		else if (num2 == 2 && type == 1345)
		{
			num = 3;
		}
		if (num <= 0 || (num == 2 && !WorldGen.BunnyCannonCanFire()))
		{
			return;
		}
		cursorItemIconEnabled = true;
		if (ItemTimeIsZero && itemAnimation > 0 && controlUseItem)
		{
			int num3 = Main.tile[x, y].frameX / 18;
			int num4 = 0;
			int num5 = 0;
			while (num3 >= 4)
			{
				num4++;
				num3 -= 4;
			}
			num3 = x - num3;
			int num6;
			for (num6 = Main.tile[x, y].frameY / 18; num6 >= 3; num6 -= 3)
			{
				num5++;
			}
			num6 = y - num6;
			ApplyItemTime(inventory[selectedItem]);
			WorldGen.ShootFromCannon(num3, num6, num5, num, inventory[selectedItem].damage, 8f, Main.myPlayer, fromWire: false);
		}
	}

	private void ExtractinatorUse(int extractType, int extractinatorBlockType)
	{
		int num = 5000;
		int num2 = 25;
		int num3 = 50;
		int num4 = -1;
		int num5 = -1;
		int num6 = -1;
		int num7 = 1;
		switch (extractType)
		{
		case 3347:
			num /= 3;
			num2 *= 2;
			num3 = 20;
			num4 = 10;
			break;
		case 2337:
			num = -1;
			num2 = -1;
			num3 = -1;
			num4 = -1;
			num5 = 1;
			num7 = -1;
			break;
		case 4354:
			num = -1;
			num2 = -1;
			num3 = -1;
			num4 = -1;
			num5 = -1;
			num7 = -1;
			num6 = 1;
			break;
		}
		int num8 = -1;
		int num9 = 1;
		if (num4 != -1 && Main.rand.Next(num4) == 0)
		{
			num8 = 3380;
			if (Main.rand.Next(5) == 0)
			{
				num9 += Main.rand.Next(2);
			}
			if (Main.rand.Next(10) == 0)
			{
				num9 += Main.rand.Next(3);
			}
			if (Main.rand.Next(15) == 0)
			{
				num9 += Main.rand.Next(4);
			}
		}
		else if (num7 != -1 && Main.rand.Next(2) == 0)
		{
			if (Main.rand.Next(12000) == 0)
			{
				num8 = 74;
				if (Main.rand.Next(14) == 0)
				{
					num9 += Main.rand.Next(0, 2);
				}
				if (Main.rand.Next(14) == 0)
				{
					num9 += Main.rand.Next(0, 2);
				}
				if (Main.rand.Next(14) == 0)
				{
					num9 += Main.rand.Next(0, 2);
				}
			}
			else if (Main.rand.Next(800) == 0)
			{
				num8 = 73;
				if (Main.rand.Next(6) == 0)
				{
					num9 += Main.rand.Next(1, 21);
				}
				if (Main.rand.Next(6) == 0)
				{
					num9 += Main.rand.Next(1, 21);
				}
				if (Main.rand.Next(6) == 0)
				{
					num9 += Main.rand.Next(1, 21);
				}
				if (Main.rand.Next(6) == 0)
				{
					num9 += Main.rand.Next(1, 21);
				}
				if (Main.rand.Next(6) == 0)
				{
					num9 += Main.rand.Next(1, 20);
				}
			}
			else if (Main.rand.Next(60) == 0)
			{
				num8 = 72;
				if (Main.rand.Next(4) == 0)
				{
					num9 += Main.rand.Next(5, 26);
				}
				if (Main.rand.Next(4) == 0)
				{
					num9 += Main.rand.Next(5, 26);
				}
				if (Main.rand.Next(4) == 0)
				{
					num9 += Main.rand.Next(5, 26);
				}
				if (Main.rand.Next(4) == 0)
				{
					num9 += Main.rand.Next(5, 25);
				}
			}
			else
			{
				num8 = 71;
				if (Main.rand.Next(3) == 0)
				{
					num9 += Main.rand.Next(10, 26);
				}
				if (Main.rand.Next(3) == 0)
				{
					num9 += Main.rand.Next(10, 26);
				}
				if (Main.rand.Next(3) == 0)
				{
					num9 += Main.rand.Next(10, 26);
				}
				if (Main.rand.Next(3) == 0)
				{
					num9 += Main.rand.Next(10, 25);
				}
			}
		}
		else if (num != -1 && Main.rand.Next(num) == 0)
		{
			num8 = 1242;
		}
		else if (num5 != -1)
		{
			num8 = ((Main.rand.Next(4) != 1) ? 2674 : ((Main.rand.Next(3) != 1) ? 2006 : ((Main.rand.Next(3) == 1) ? 2675 : 2002)));
		}
		else if (num6 != -1 && extractinatorBlockType == 642)
		{
			num8 = ((Main.rand.Next(10) == 1) ? (Main.rand.Next(5) switch
			{
				0 => 4354, 
				1 => 4389, 
				2 => 4377, 
				3 => 5127, 
				_ => 4378, 
			}) : (Main.rand.Next(5) switch
			{
				0 => 4349, 
				1 => 4350, 
				2 => 4351, 
				3 => 4352, 
				_ => 4353, 
			}));
		}
		else if (num6 != -1)
		{
			num8 = Main.rand.Next(5) switch
			{
				0 => 4349, 
				1 => 4350, 
				2 => 4351, 
				3 => 4352, 
				_ => 4353, 
			};
		}
		else if (num2 != -1 && Main.rand.Next(num2) == 0)
		{
			num8 = Main.rand.Next(6) switch
			{
				0 => 181, 
				1 => 180, 
				2 => 177, 
				3 => 179, 
				4 => 178, 
				_ => 182, 
			};
			if (Main.rand.Next(20) == 0)
			{
				num9 += Main.rand.Next(0, 2);
			}
			if (Main.rand.Next(30) == 0)
			{
				num9 += Main.rand.Next(0, 3);
			}
			if (Main.rand.Next(40) == 0)
			{
				num9 += Main.rand.Next(0, 4);
			}
			if (Main.rand.Next(50) == 0)
			{
				num9 += Main.rand.Next(0, 5);
			}
			if (Main.rand.Next(60) == 0)
			{
				num9 += Main.rand.Next(0, 6);
			}
		}
		else if (num3 != -1 && Main.rand.Next(num3) == 0)
		{
			num8 = 999;
			if (Main.rand.Next(20) == 0)
			{
				num9 += Main.rand.Next(0, 2);
			}
			if (Main.rand.Next(30) == 0)
			{
				num9 += Main.rand.Next(0, 3);
			}
			if (Main.rand.Next(40) == 0)
			{
				num9 += Main.rand.Next(0, 4);
			}
			if (Main.rand.Next(50) == 0)
			{
				num9 += Main.rand.Next(0, 5);
			}
			if (Main.rand.Next(60) == 0)
			{
				num9 += Main.rand.Next(0, 6);
			}
		}
		else if (Main.rand.Next(3) == 0)
		{
			if (Main.rand.Next(5000) == 0)
			{
				num8 = 74;
				if (Main.rand.Next(10) == 0)
				{
					num9 += Main.rand.Next(0, 3);
				}
				if (Main.rand.Next(10) == 0)
				{
					num9 += Main.rand.Next(0, 3);
				}
				if (Main.rand.Next(10) == 0)
				{
					num9 += Main.rand.Next(0, 3);
				}
				if (Main.rand.Next(10) == 0)
				{
					num9 += Main.rand.Next(0, 3);
				}
				if (Main.rand.Next(10) == 0)
				{
					num9 += Main.rand.Next(0, 3);
				}
			}
			else if (Main.rand.Next(400) == 0)
			{
				num8 = 73;
				if (Main.rand.Next(5) == 0)
				{
					num9 += Main.rand.Next(1, 21);
				}
				if (Main.rand.Next(5) == 0)
				{
					num9 += Main.rand.Next(1, 21);
				}
				if (Main.rand.Next(5) == 0)
				{
					num9 += Main.rand.Next(1, 21);
				}
				if (Main.rand.Next(5) == 0)
				{
					num9 += Main.rand.Next(1, 21);
				}
				if (Main.rand.Next(5) == 0)
				{
					num9 += Main.rand.Next(1, 20);
				}
			}
			else if (Main.rand.Next(30) == 0)
			{
				num8 = 72;
				if (Main.rand.Next(3) == 0)
				{
					num9 += Main.rand.Next(5, 26);
				}
				if (Main.rand.Next(3) == 0)
				{
					num9 += Main.rand.Next(5, 26);
				}
				if (Main.rand.Next(3) == 0)
				{
					num9 += Main.rand.Next(5, 26);
				}
				if (Main.rand.Next(3) == 0)
				{
					num9 += Main.rand.Next(5, 25);
				}
			}
			else
			{
				num8 = 71;
				if (Main.rand.Next(2) == 0)
				{
					num9 += Main.rand.Next(10, 26);
				}
				if (Main.rand.Next(2) == 0)
				{
					num9 += Main.rand.Next(10, 26);
				}
				if (Main.rand.Next(2) == 0)
				{
					num9 += Main.rand.Next(10, 26);
				}
				if (Main.rand.Next(2) == 0)
				{
					num9 += Main.rand.Next(10, 25);
				}
			}
		}
		else if (extractinatorBlockType == 642)
		{
			num8 = Main.rand.Next(14) switch
			{
				0 => 12, 
				1 => 11, 
				2 => 14, 
				3 => 13, 
				4 => 699, 
				5 => 700, 
				6 => 701, 
				7 => 702, 
				8 => 364, 
				9 => 1104, 
				10 => 365, 
				11 => 1105, 
				12 => 366, 
				_ => 1106, 
			};
			if (Main.rand.Next(20) == 0)
			{
				num9 += Main.rand.Next(0, 2);
			}
			if (Main.rand.Next(30) == 0)
			{
				num9 += Main.rand.Next(0, 3);
			}
			if (Main.rand.Next(40) == 0)
			{
				num9 += Main.rand.Next(0, 4);
			}
			if (Main.rand.Next(50) == 0)
			{
				num9 += Main.rand.Next(0, 5);
			}
			if (Main.rand.Next(60) == 0)
			{
				num9 += Main.rand.Next(0, 6);
			}
		}
		else
		{
			num8 = Main.rand.Next(8) switch
			{
				0 => 12, 
				1 => 11, 
				2 => 14, 
				3 => 13, 
				4 => 699, 
				5 => 700, 
				6 => 701, 
				_ => 702, 
			};
			if (Main.rand.Next(20) == 0)
			{
				num9 += Main.rand.Next(0, 2);
			}
			if (Main.rand.Next(30) == 0)
			{
				num9 += Main.rand.Next(0, 3);
			}
			if (Main.rand.Next(40) == 0)
			{
				num9 += Main.rand.Next(0, 4);
			}
			if (Main.rand.Next(50) == 0)
			{
				num9 += Main.rand.Next(0, 5);
			}
			if (Main.rand.Next(60) == 0)
			{
				num9 += Main.rand.Next(0, 6);
			}
		}
		ItemLoader.ExtractinatorUse(ref num8, ref num9, extractType, extractinatorBlockType);
		if (num8 > 0)
		{
			DropItemFromExtractinator(num8, num9);
		}
	}

	private void DropItemFromExtractinator(int itemType, int stack)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		Vector2 vector = Main.ReverseGravitySupport(Main.MouseScreen) + Main.screenPosition;
		if (Main.SmartCursorIsUsed || PlayerInput.UsingGamepad)
		{
			vector = base.Center;
		}
		int number = Item.NewItem(GetItemSource_TileInteraction(tileTargetX, tileTargetY), (int)vector.X, (int)vector.Y, 1, 1, itemType, stack, noBroadcast: false, -1);
		if (Main.netMode == 1)
		{
			NetMessage.SendData(21, -1, -1, null, number, 1f);
		}
	}

	public void ChangeDir(int dir)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if (!pulley || pulleyDir != 2)
		{
			direction = dir;
		}
		else
		{
			if (pulleyDir == 2 && dir == direction)
			{
				return;
			}
			int num = (int)(position.X + (float)(width / 2)) / 16 * 16 + 8 - width / 2;
			if (!Collision.SolidCollision(new Vector2((float)num, position.Y), width, height))
			{
				if (whoAmI == Main.myPlayer)
				{
					Main.cameraX = Main.cameraX + position.X - (float)num;
				}
				pulleyDir = 1;
				position.X = num;
				direction = dir;
			}
		}
	}

	public Rectangle getRect()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		return new Rectangle((int)position.X, (int)position.Y, width, height);
	}

	public void HorsemansBlade_SpawnPumpkin(int npcIndex, int dmg, float kb)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		Vector2 center = Main.npc[npcIndex].Center;
		int logicCheckScreenHeight = Main.LogicCheckScreenHeight;
		int logicCheckScreenWidth = Main.LogicCheckScreenWidth;
		int num = Main.rand.Next(100, 300);
		int num2 = Main.rand.Next(100, 300);
		num = ((Main.rand.Next(2) != 0) ? (num + (logicCheckScreenWidth / 2 - num)) : (num - (logicCheckScreenWidth / 2 + num)));
		num2 = ((Main.rand.Next(2) != 0) ? (num2 + (logicCheckScreenHeight / 2 - num2)) : (num2 - (logicCheckScreenHeight / 2 + num2)));
		num += (int)position.X;
		num2 += (int)position.Y;
		Vector2 vector = default(Vector2);
		((Vector2)(ref vector))._002Ector((float)num, (float)num2);
		float num3 = center.X - vector.X;
		float num4 = center.Y - vector.Y;
		float num5 = (float)Math.Sqrt(num3 * num3 + num4 * num4);
		num5 = 8f / num5;
		num3 *= num5;
		num4 *= num5;
		Projectile.NewProjectile(GetProjectileSource_Item(HeldItem), num, num2, num3, num4, 321, dmg, kb, whoAmI, npcIndex);
	}

	public void PutItemInInventoryFromItemUsage(int type, int theSelectedItem = -1)
	{
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < 58; i++)
		{
			Item item = inventory[i];
			if (item.stack > 0 && item.type == type && item.stack < item.maxStack)
			{
				item.stack++;
				return;
			}
		}
		if (theSelectedItem >= 0 && (inventory[theSelectedItem].type == 0 || inventory[theSelectedItem].stack <= 0))
		{
			inventory[theSelectedItem].SetDefaults(type);
			return;
		}
		Item item2 = new Item();
		item2.SetDefaults(type);
		if (GetItem(whoAmI, item2, GetItemSettings.ItemCreatedFromItemUsage).stack > 0)
		{
			Item item3 = item2;
			if (theSelectedItem != -1)
			{
				item3 = inventory[theSelectedItem];
			}
			int number = Item.NewItem(new EntitySource_ItemUse(this, item3), (int)position.X, (int)position.Y, width, height, type, 1, noBroadcast: false, 0, noGrabDelay: true);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(21, -1, -1, null, number, 1f);
			}
		}
		else
		{
			item2.position.X = base.Center.X - (float)(item2.width / 2);
			item2.position.Y = base.Center.Y - (float)(item2.height / 2);
			item2.active = true;
			PopupText.NewText(PopupTextContext.RegularItemPickup, item2, 0);
		}
	}

	public bool SummonItemCheck(Item item)
	{
		int type = item.type;
		for (int i = 0; i < 200; i++)
		{
			NPC nPC = Main.npc[i];
			if (nPC.active && ((type == 43 && nPC.type == 4) || (type == 70 && nPC.type == 13) || ((type == 560) & (nPC.type == 50)) || (type == 544 && nPC.type == 125) || (type == 544 && nPC.type == 126) || (type == 556 && nPC.type == 134) || (type == 557 && nPC.type == 127) || (type == 1133 && nPC.type == 222) || (type == 1331 && nPC.type == 266) || (type == 4988 && nPC.type == 657) || (type == 5120 && nPC.type == 668)))
			{
				return false;
			}
		}
		return true;
	}

	public PlayerFishingConditions GetFishingConditions()
	{
		PlayerFishingConditions result = default(PlayerFishingConditions);
		Fishing_GetBestFishingPole(out result.Pole);
		Fishing_GetBait(out result.Bait);
		if (result.BaitItemType == 2673)
		{
			return result;
		}
		if (result.BaitPower == 0 || result.PolePower == 0)
		{
			return result;
		}
		int num = 0;
		if (FindBuffIndex(25) != -1)
		{
			num += 5;
		}
		if (canFloatInWater && wet)
		{
			num += 5;
		}
		if (sitting.TryGetSittingBlock(this, out var tile) && ((tile.type == 15 && tile.frameY / 40 == 1) || tile.type == 497))
		{
			num += 5;
		}
		int num2 = result.BaitPower + result.PolePower + fishingSkill + num;
		result.LevelMultipliers = Fishing_GetPowerMultiplier(result.Pole, result.Bait);
		result.FinalFishingLevel = (int)((float)num2 * result.LevelMultipliers);
		return result;
	}

	private float Fishing_GetPowerMultiplier(Item pole, Item bait)
	{
		float num = 1f;
		if (Main.raining)
		{
			num *= 1.2f;
		}
		if (Main.cloudBGAlpha > 0f)
		{
			num *= 1.1f;
		}
		if (Main.dayTime && (Main.time < 5400.0 || Main.time > 48600.0))
		{
			num *= 1.3f;
		}
		if (Main.dayTime && Main.time > 16200.0 && Main.time < 37800.0)
		{
			num *= 0.8f;
		}
		if (!Main.dayTime && Main.time > 6480.0 && Main.time < 25920.0)
		{
			num *= 0.8f;
		}
		if (Main.moonPhase == 0)
		{
			num *= 1.1f;
		}
		if (Main.moonPhase == 1 || Main.moonPhase == 7)
		{
			num *= 1.05f;
		}
		if (Main.moonPhase == 3 || Main.moonPhase == 5)
		{
			num *= 0.95f;
		}
		if (Main.moonPhase == 4)
		{
			num *= 0.9f;
		}
		if (Main.bloodMoon)
		{
			num *= 1.1f;
		}
		PlayerLoader.GetFishingLevel(this, pole, bait, ref num);
		return num;
	}

	private void Fishing_GetBait(out Item bait)
	{
		bait = null;
		for (int i = 54; i < 58; i++)
		{
			if (inventory[i].stack > 0 && inventory[i].bait > 0)
			{
				bait = inventory[i];
				break;
			}
		}
		if (bait != null)
		{
			return;
		}
		for (int j = 0; j < 50; j++)
		{
			if (inventory[j].stack > 0 && inventory[j].bait > 0)
			{
				bait = inventory[j];
				break;
			}
		}
	}

	private void Fishing_GetBestFishingPole(out Item pole)
	{
		pole = inventory[selectedItem];
		if (pole.fishingPole != 0)
		{
			return;
		}
		for (int i = 0; i < 58; i++)
		{
			if (inventory[i].fishingPole > pole.fishingPole)
			{
				pole = inventory[i];
			}
		}
	}

	public bool HasUnityPotion()
	{
		for (int i = 0; i < 58; i++)
		{
			if (inventory[i].type == 2997 && inventory[i].stack > 0)
			{
				return true;
			}
		}
		if (useVoidBag())
		{
			for (int j = 0; j < 40; j++)
			{
				if (bank4.item[j].type == 2997 && bank4.item[j].stack > 0)
				{
					return true;
				}
			}
		}
		return false;
	}

	public void TakeUnityPotion()
	{
		for (int i = 0; i < 58; i++)
		{
			if (inventory[i].type == 2997 && inventory[i].stack > 0)
			{
				if (ItemLoader.ConsumeItem(inventory[i], this))
				{
					inventory[i].stack--;
				}
				if (inventory[i].stack <= 0)
				{
					inventory[i].SetDefaults();
				}
				return;
			}
		}
		if (!useVoidBag())
		{
			return;
		}
		for (int j = 0; j < 40; j++)
		{
			if (bank4.item[j].type == 2997 && bank4.item[j].stack > 0)
			{
				if (ItemLoader.ConsumeItem(bank4.item[j], this))
				{
					bank4.item[j].stack--;
				}
				if (bank4.item[j].stack <= 0)
				{
					bank4.item[j].SetDefaults();
				}
				break;
			}
		}
	}

	public void UnityTeleport(Vector2 telePos)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		int num = 3;
		if (Main.netMode == 0)
		{
			Teleport(telePos, num);
		}
		else
		{
			NetMessage.SendData(65, -1, -1, null, 2, whoAmI, telePos.X, telePos.Y, num);
		}
	}

	private void PayDD2CrystalsBeforeUse(Item item)
	{
		int requiredDD2CrystalsToUse = GetRequiredDD2CrystalsToUse(item);
		for (int i = 0; i < requiredDD2CrystalsToUse; i++)
		{
			ConsumeItem(3822, reverseOrder: true);
		}
	}

	private bool CheckDD2CrystalPaymentLock(Item item)
	{
		if (!DD2Event.Ongoing)
		{
			return true;
		}
		int requiredDD2CrystalsToUse = GetRequiredDD2CrystalsToUse(item);
		return CountItem(3822, requiredDD2CrystalsToUse) >= requiredDD2CrystalsToUse;
	}

	private int GetRequiredDD2CrystalsToUse(Item item)
	{
		switch (item.type)
		{
		case 3818:
		case 3819:
		case 3820:
			return 10;
		case 3824:
		case 3825:
		case 3826:
			return 10;
		case 3832:
		case 3833:
		case 3834:
			return 10;
		case 3829:
		case 3830:
		case 3831:
			return 10;
		default:
			return 0;
		}
	}

	public void SporeSac(Item sourceItem)
	{
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0335: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		int damage = 70;
		float knockBack = 1.5f;
		if (Main.rand.Next(15) != 0)
		{
			return;
		}
		int num = 0;
		for (int i = 0; i < 1000; i++)
		{
			if (Main.projectile[i].active && Main.projectile[i].owner == whoAmI && (Main.projectile[i].type == 567 || Main.projectile[i].type == 568))
			{
				num++;
			}
		}
		if (Main.rand.Next(15) < num || num >= 10)
		{
			return;
		}
		int num2 = 50;
		int num3 = 24;
		int num4 = 90;
		for (int j = 0; j < num2; j++)
		{
			int num5 = Main.rand.Next(200 - j * 2, 400 + j * 2);
			Vector2 center = base.Center;
			center.X += Main.rand.Next(-num5, num5 + 1);
			center.Y += Main.rand.Next(-num5, num5 + 1);
			if (Collision.SolidCollision(center, num3, num3) || Collision.WetCollision(center, num3, num3))
			{
				continue;
			}
			center.X += num3 / 2;
			center.Y += num3 / 2;
			if (!Collision.CanHit(new Vector2(base.Center.X, position.Y), 1, 1, center, 1, 1) && !Collision.CanHit(new Vector2(base.Center.X, position.Y - 50f), 1, 1, center, 1, 1))
			{
				continue;
			}
			int num6 = (int)center.X / 16;
			int num7 = (int)center.Y / 16;
			bool flag = false;
			if (Main.rand.Next(3) == 0 && Main.tile[num6, num7] != null && Main.tile[num6, num7].wall > 0)
			{
				flag = true;
			}
			else
			{
				center.X -= num4 / 2;
				center.Y -= num4 / 2;
				if (Collision.SolidCollision(center, num4, num4))
				{
					center.X += num4 / 2;
					center.Y += num4 / 2;
					flag = true;
				}
				else if (Main.tile[num6, num7] != null && Main.tile[num6, num7].active() && Main.tile[num6, num7].type == 19)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				continue;
			}
			for (int k = 0; k < 1000; k++)
			{
				if (Main.projectile[k].active && Main.projectile[k].owner == whoAmI && Main.projectile[k].aiStyle == 105)
				{
					Vector2 val = center - Main.projectile[k].Center;
					if (((Vector2)(ref val)).Length() < 48f)
					{
						flag = false;
						break;
					}
				}
			}
			if (flag && Main.myPlayer == whoAmI)
			{
				Projectile.NewProjectile(GetProjectileSource_Accessory(sourceItem), center.X, center.Y, 0f, 0f, 567 + Main.rand.Next(2), damage, knockBack, whoAmI);
				break;
			}
		}
	}

	public void VolatileGelatin(Item sourceItem)
	{
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		if (Main.myPlayer != whoAmI)
		{
			return;
		}
		volatileGelatinCounter++;
		if (volatileGelatinCounter <= 40)
		{
			return;
		}
		volatileGelatinCounter = 0;
		int damage = 65;
		float knockBack = 7f;
		float num = 640f;
		NPC nPC = null;
		for (int i = 0; i < 200; i++)
		{
			NPC nPC2 = Main.npc[i];
			if (nPC2 != null && nPC2.active && nPC2.CanBeChasedBy(this) && Collision.CanHit(this, nPC2))
			{
				float num2 = Vector2.Distance(nPC2.Center, base.Center);
				if (num2 < num)
				{
					num = num2;
					nPC = nPC2;
				}
			}
		}
		if (nPC != null)
		{
			Vector2 v = nPC.Center - base.Center;
			v = v.SafeNormalize(Vector2.Zero) * 12f;
			v.Y -= 1.3f;
			Projectile.NewProjectile(GetProjectileSource_Accessory(sourceItem), base.Center.X, base.Center.Y, v.X, v.Y, 937, damage, knockBack, whoAmI);
		}
	}

	public bool CanHit(Entity ent)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		if (!Collision.CanHit(position, width, height, ent.position, ent.width, ent.height) && !Collision.CanHitLine(base.Center + new Vector2((float)(direction * width / 2), gravDir * (float)(-height) / 3f), 0, 0, ent.Center + new Vector2(0f, (float)(-ent.height / 3)), 0, 0) && !Collision.CanHitLine(base.Center + new Vector2((float)(direction * width / 2), gravDir * (float)(-height) / 3f), 0, 0, ent.Center, 0, 0))
		{
			return Collision.CanHitLine(base.Center + new Vector2((float)(direction * width / 2), 0f), 0, 0, ent.Center + new Vector2(0f, (float)(ent.height / 3)), 0, 0);
		}
		return true;
	}

	public Rectangle GetItemDrawFrame(int type)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		if (Main.dedServ)
		{
			return Rectangle.Empty;
		}
		Main.instance.LoadItem(type);
		if (ItemID.Sets.IsFood[type])
		{
			return TextureAssets.Item[type].Frame(1, 3, 0, 1);
		}
		if (Main.itemAnimations[type] != null)
		{
			return Main.itemAnimations[type].GetFrame(TextureAssets.Item[type].Value);
		}
		return TextureAssets.Item[type].Frame();
	}

	/// <summary>
	/// Used to determine what the overall scale of an item should be.<br></br>
	/// <see cref="M:Terraria.ModLoader.CombinedHooks.ModifyItemScale(Terraria.Player,Terraria.Item,System.Single@)" /> is called here.
	/// </summary>
	/// <param name="item">The item to fetch the adjusted scale of.</param>
	/// <returns>
	/// The final scale of the item, after the Titan Glove effect and all modded calculations.
	/// </returns>
	public float GetAdjustedItemScale(Item item)
	{
		float scale = item.scale;
		if (item.melee)
		{
			ApplyMeleeScale(ref scale);
		}
		CombinedHooks.ModifyItemScale(this, item, ref scale);
		return scale;
	}

	public void ApplyMeleeScale(ref float scale)
	{
		if (meleeScaleGlove)
		{
			scale *= 1.1f;
		}
	}

	public Vector2 ApplyRangeCompensation(float rangeCompensation, Vector2 startPos, Vector2 targetPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		Vector2 v = targetPos - startPos;
		Vector2 vector = v.SafeNormalize(Vector2.Zero);
		vector.Y -= 1f;
		float num = ((Vector2)(ref v)).Length();
		num = (float)Math.Pow(num / 700f, 2.0) * 700f;
		targetPos.Y += vector.Y * num * rangeCompensation * 1f;
		targetPos.X += (0f - vector.X) * num * rangeCompensation * 1f;
		return targetPos;
	}

	public void ItemCheck()
	{
		if (PlayerLoader.PreItemCheck(this))
		{
			ItemCheck_Inner();
		}
		PlayerLoader.PostItemCheck(this);
	}

	private void ItemCheck_Inner()
	{
		//IL_0486: Unknown result type (might be due to invalid IL or missing references)
		//IL_048b: Unknown result type (might be due to invalid IL or missing references)
		//IL_05da: Unknown result type (might be due to invalid IL or missing references)
		//IL_05cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0614: Unknown result type (might be due to invalid IL or missing references)
		//IL_09b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_09d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_09de: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b01: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b1c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b22: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b24: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b33: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b38: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b3d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c93: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cb4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cb6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cc5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ccf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b58: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b5d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b5f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b76: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b7c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a27: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a63: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a69: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e32: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e37: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cf1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d05: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d0b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a95: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ab9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0abf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f9c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e64: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e69: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e6d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e72: Unknown result type (might be due to invalid IL or missing references)
		//IL_11b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_1041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e7a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e7f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e96: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e9c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0eb0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0eb2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0eb9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ec3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ec8: Unknown result type (might be due to invalid IL or missing references)
		//IL_125a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0fb8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ff2: Unknown result type (might be due to invalid IL or missing references)
		//IL_1003: Unknown result type (might be due to invalid IL or missing references)
		//IL_100d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1012: Unknown result type (might be due to invalid IL or missing references)
		//IL_11d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_120b: Unknown result type (might be due to invalid IL or missing references)
		//IL_121c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1226: Unknown result type (might be due to invalid IL or missing references)
		//IL_122b: Unknown result type (might be due to invalid IL or missing references)
		//IL_105c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1096: Unknown result type (might be due to invalid IL or missing references)
		//IL_10a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_10b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_10b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_14ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_150c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1512: Unknown result type (might be due to invalid IL or missing references)
		//IL_1514: Unknown result type (might be due to invalid IL or missing references)
		//IL_1519: Unknown result type (might be due to invalid IL or missing references)
		//IL_1275: Unknown result type (might be due to invalid IL or missing references)
		//IL_12af: Unknown result type (might be due to invalid IL or missing references)
		//IL_12c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_12ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_12cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_10ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_1121: Unknown result type (might be due to invalid IL or missing references)
		//IL_1132: Unknown result type (might be due to invalid IL or missing references)
		//IL_113c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1141: Unknown result type (might be due to invalid IL or missing references)
		//IL_155a: Unknown result type (might be due to invalid IL or missing references)
		//IL_157e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1581: Unknown result type (might be due to invalid IL or missing references)
		//IL_1586: Unknown result type (might be due to invalid IL or missing references)
		//IL_158b: Unknown result type (might be due to invalid IL or missing references)
		//IL_158d: Unknown result type (might be due to invalid IL or missing references)
		//IL_15a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_15a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_15bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_15bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_15da: Unknown result type (might be due to invalid IL or missing references)
		//IL_15df: Unknown result type (might be due to invalid IL or missing references)
		//IL_12fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_1320: Unknown result type (might be due to invalid IL or missing references)
		//IL_1331: Unknown result type (might be due to invalid IL or missing references)
		//IL_133b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1340: Unknown result type (might be due to invalid IL or missing references)
		if (CCed)
		{
			channel = false;
			itemAnimation = (itemAnimationMax = 0);
			return;
		}
		float heightOffsetHitboxCenter = HeightOffsetHitboxCenter;
		Item item = inventory[selectedItem];
		ItemCheckContext context = default(ItemCheckContext);
		bool flag = false;
		if (Main.myPlayer == whoAmI)
		{
			if (PlayerInput.ShouldFastUseItem)
			{
				controlUseItem = true;
				flag = true;
			}
			if (!cursorItemIconEnabled && item.stack > 0 && item.fishingPole > 0)
			{
				Fishing_GetBait(out var bait);
				if (bait != null)
				{
					cursorItemIconEnabled = true;
					cursorItemIconID = bait.type;
					cursorItemIconPush = 6;
				}
			}
			if (!cursorItemIconEnabled && item.stack > 0 && (item.type == 779 || item.type == 5134))
			{
				for (int i = 54; i < 58; i++)
				{
					if (inventory[i].ammo == item.useAmmo && inventory[i].stack > 0)
					{
						cursorItemIconEnabled = true;
						cursorItemIconID = inventory[i].type;
						cursorItemIconPush = 10;
						break;
					}
				}
				if (!cursorItemIconEnabled)
				{
					for (int j = 0; j < 54; j++)
					{
						if (inventory[j].ammo == item.useAmmo && inventory[j].stack > 0)
						{
							cursorItemIconEnabled = true;
							cursorItemIconID = inventory[j].type;
							cursorItemIconPush = 10;
							break;
						}
					}
				}
			}
		}
		if (itemAnimation > 0)
		{
			itemAnimation--;
			if (itemAnimation == 0 && whoAmI == Main.myPlayer)
			{
				PlayerInput.TryEndingFastUse();
			}
		}
		if (itemTime > 0)
		{
			itemTime--;
			if (ItemTimeIsZero && whoAmI == Main.myPlayer && !JustDroppedAnItem)
			{
				int type = item.type;
				if (type == 65 || type == 724 || type == 989 || type == 1226)
				{
					EmitMaxManaEffect();
				}
			}
		}
		if (itemAnimation == 0 && reuseDelay == 0 && (!controlUseItem || selectItemOnNextUse))
		{
			selectItemOnNextUse = false;
			int oldSelect = selectedItem;
			SmartSelectLookup();
			if (selectedItem != oldSelect)
			{
				item = inventory[selectedItem];
				releaseUseItem = true;
				itemTime = (itemTimeMax = 0);
			}
		}
		ItemCheck_HandleMount();
		int weaponDamage = GetWeaponDamage(item);
		ItemCheck_HandleMPItemAnimation(item);
		ItemCheck_HackHoldStyles(item);
		if (itemAnimation < 0)
		{
			itemAnimation = 0;
		}
		if (itemTime < 0)
		{
			itemTime = 0;
		}
		if (itemAnimation == 0 && reuseDelay > 0)
		{
			ApplyReuseDelay();
		}
		UpdatePlacementPreview(item);
		if (itemAnimation == 0 && altFunctionUse == 2)
		{
			altFunctionUse = 0;
		}
		bool flag2 = true;
		if (gravDir == -1f && GolfHelper.IsPlayerHoldingClub(this))
		{
			flag2 = false;
		}
		if (flag2 && controlUseItem && releaseUseItem && itemAnimation == 0 && item.useStyle != 0)
		{
			if (altFunctionUse == 1)
			{
				altFunctionUse = 2;
			}
			if (item.shoot == 0)
			{
				itemRotation = 0f;
			}
			bool flag3 = ItemCheck_CheckCanUse(item);
			if (item.potion && flag3)
			{
				ApplyPotionDelay(item);
			}
			if (item.mana > 0 && flag3 && whoAmI == Main.myPlayer && item.buffType != 0 && item.buffTime != 0)
			{
				AddBuff(item.buffType, item.buffTime);
			}
			if (item.shoot <= 0 || !ProjectileID.Sets.MinionTargettingFeature[item.shoot] || altFunctionUse != 2)
			{
				ItemCheck_ApplyPetBuffs(item);
			}
			if (whoAmI == Main.myPlayer && gravDir == 1f && item.mountType != -1 && mount.CanMount(item.mountType, this))
			{
				mount.SetMount(item.mountType, this);
			}
			if ((item.shoot <= 0 || !ProjectileID.Sets.MinionTargettingFeature[item.shoot] || altFunctionUse != 2) && flag3 && whoAmI == Main.myPlayer && item.shoot >= 0 && (ProjectileID.Sets.LightPet[item.shoot] || Main.projPet[item.shoot]))
			{
				FreeUpPetsAndMinions(item);
			}
			if (flag3)
			{
				ItemCheck_StartActualUse(item);
			}
		}
		bool flag4 = controlUseItem;
		if (mount.Active && mount.Type == 8)
		{
			flag4 = controlUseItem || controlUseTile;
		}
		if (!flag4)
		{
			channel = false;
		}
		Item item2 = ((itemAnimation > 0) ? lastVisualizedSelectedItem : item);
		Rectangle drawHitbox = Item.GetDrawHitbox(item2.type, this);
		compositeFrontArm.enabled = false;
		compositeBackArm.enabled = false;
		if (itemAnimation > 0)
		{
			if (item.mana > 0)
			{
				ItemCheck_ApplyManaRegenDelay(item);
			}
			if (Main.dedServ)
			{
				itemHeight = item.height;
				itemWidth = item.width;
			}
			else
			{
				itemHeight = drawHitbox.Height;
				itemWidth = drawHitbox.Width;
			}
		}
		releaseUseItem = !controlUseItem;
		ItemLoader.HoldItem(item, this);
		if (itemAnimation > 0)
		{
			ItemCheck_ApplyUseStyle(heightOffsetHitboxCenter, item2, drawHitbox);
		}
		else
		{
			ItemCheck_ApplyHoldStyle(heightOffsetHitboxCenter, item2, drawHitbox);
		}
		if (!JustDroppedAnItem)
		{
			ItemCheck_EmitHeldItemLight(item);
			ItemCheck_EmitFoodParticles(item);
			ItemCheck_EmitDrinkParticles(item);
			_ = whoAmI;
			_ = Main.myPlayer;
			ItemCheck_OwnerOnlyCode(ref context, item, weaponDamage, drawHitbox);
			if (ItemTimeIsZero && itemAnimation > 0)
			{
				if (ItemLoader.UseItem(item, this) == true)
				{
					ApplyItemTime(item, 1f, false);
				}
				if (item.hairDye >= 0)
				{
					ApplyItemTime(item);
					if (whoAmI == Main.myPlayer)
					{
						hairDye = item.hairDye;
						NetMessage.SendData(4, -1, -1, null, whoAmI);
					}
				}
				if (item.healLife > 0 || item.healMana > 0)
				{
					ApplyLifeAndOrMana(item);
					ApplyItemTime(item);
					if (Main.myPlayer == whoAmI && item.type == 126 && breath == 0)
					{
						AchievementsHelper.HandleSpecialEvent(this, 25);
					}
				}
				if (item.buffType > 0)
				{
					if (whoAmI == Main.myPlayer && item.buffType != 90 && item.buffType != 27)
					{
						AddBuff(item.buffType, item.buffTime);
					}
					ApplyItemTime(item);
				}
				if (item.type == 678)
				{
					if (Main.getGoodWorld)
					{
						ApplyItemTime(item);
						if (whoAmI == Main.myPlayer)
						{
							for (int k = 0; k < 3; k++)
							{
								int type2 = 0;
								int timeToAdd = 108000;
								switch (Main.rand.Next(18))
								{
								case 0:
									type2 = 16;
									break;
								case 1:
									type2 = 111;
									break;
								case 2:
									type2 = 114;
									break;
								case 3:
									type2 = 8;
									break;
								case 4:
									type2 = 105;
									break;
								case 5:
									type2 = 17;
									break;
								case 6:
									type2 = 116;
									break;
								case 7:
									type2 = 5;
									break;
								case 8:
									type2 = 113;
									break;
								case 9:
									type2 = 7;
									break;
								case 10:
									type2 = 6;
									break;
								case 11:
									type2 = 104;
									break;
								case 12:
									type2 = 115;
									break;
								case 13:
									type2 = 2;
									break;
								case 14:
									type2 = 9;
									break;
								case 15:
									type2 = 3;
									break;
								case 16:
									type2 = 117;
									break;
								case 17:
									type2 = 1;
									break;
								}
								AddBuff(type2, timeToAdd);
							}
						}
					}
					else
					{
						ApplyItemTime(item);
						if (whoAmI == Main.myPlayer)
						{
							AddBuff(20, 216000);
							AddBuff(22, 216000);
							AddBuff(23, 216000);
							AddBuff(24, 216000);
							AddBuff(30, 216000);
							AddBuff(31, 216000);
							AddBuff(32, 216000);
							AddBuff(33, 216000);
							AddBuff(35, 216000);
							AddBuff(36, 216000);
							AddBuff(68, 216000);
						}
					}
				}
			}
			if ((item.type == 50 || item.type == 3124 || item.type == 3199 || item.type == 5358) && itemAnimation > 0)
			{
				if (Main.rand.Next(2) == 0)
				{
					Dust.NewDust(position, width, height, 15, 0f, 0f, 150, default(Color), 1.1f);
				}
				if (ItemTimeIsZero)
				{
					ApplyItemTime(item);
				}
				else if (itemTime == itemTimeMax / 2)
				{
					for (int l = 0; l < 70; l++)
					{
						Dust.NewDust(position, width, height, 15, velocity.X * 0.5f, velocity.Y * 0.5f, 150, default(Color), 1.5f);
					}
					RemoveAllGrapplingHooks();
					Spawn(PlayerSpawnContext.RecallFromItem);
					for (int m = 0; m < 70; m++)
					{
						Dust.NewDust(position, width, height, 15, 0f, 0f, 150, default(Color), 1.5f);
					}
				}
			}
			if ((item.type == 4263 || item.type == 5360) && itemAnimation > 0)
			{
				Vector2 vector = Vector2.UnitY.RotatedBy((float)itemAnimation * ((float)Math.PI * 2f) / 30f) * new Vector2(15f, 0f);
				for (int n = 0; n < 2; n++)
				{
					if (Main.rand.Next(3) == 0)
					{
						Dust dust = Dust.NewDustPerfect(base.Bottom + vector, Dust.dustWater());
						dust.velocity.Y *= 0f;
						dust.velocity.Y -= 4.5f;
						dust.velocity.X *= 1.5f;
						dust.scale = 0.8f;
						dust.alpha = 130;
						dust.noGravity = true;
						dust.fadeIn = 1.1f;
					}
				}
				if (ItemTimeIsZero)
				{
					ApplyItemTime(item);
				}
				else if (itemTime == item.useTime / 2)
				{
					if (Main.netMode == 0)
					{
						MagicConch();
					}
					else if (Main.netMode == 1 && whoAmI == Main.myPlayer)
					{
						NetMessage.SendData(73, -1, -1, null, 1);
					}
				}
			}
			if ((item.type == 4819 || item.type == 5361) && itemAnimation > 0)
			{
				Vector2 vector2 = Vector2.UnitY.RotatedBy((float)itemAnimation * ((float)Math.PI * 2f) / 30f) * new Vector2(15f, 0f);
				for (int num = 0; num < 2; num++)
				{
					if (Main.rand.Next(3) == 0)
					{
						Dust dust2 = Dust.NewDustPerfect(base.Bottom + vector2, 35);
						dust2.velocity.Y *= 0f;
						dust2.velocity.Y -= 4.5f;
						dust2.velocity.X *= 1.5f;
						dust2.scale = 0.8f;
						dust2.alpha = 130;
						dust2.noGravity = true;
						dust2.fadeIn = 1.1f;
					}
				}
				if (ItemTimeIsZero)
				{
					ApplyItemTime(item);
				}
				else if (itemTime == item.useTime / 2)
				{
					if (Main.netMode == 0)
					{
						DemonConch();
					}
					else if (Main.netMode == 1 && whoAmI == Main.myPlayer)
					{
						NetMessage.SendData(73, -1, -1, null, 2);
					}
				}
			}
			if (item.type == 5359 && itemAnimation > 0)
			{
				if (Main.rand.Next(2) == 0)
				{
					int num8 = Main.rand.Next(4);
					Color color = Color.Green;
					switch (num8)
					{
					case 0:
					case 1:
						((Color)(ref color))._002Ector(100, 255, 100);
						break;
					case 2:
						color = Color.Yellow;
						break;
					case 3:
						color = Color.White;
						break;
					}
					Dust dust3 = Dust.NewDustPerfect(Main.rand.NextVector2FromRectangle(base.Hitbox), 267);
					dust3.noGravity = true;
					dust3.color = color;
					dust3.velocity *= 2f;
					dust3.scale = 0.8f + Main.rand.NextFloat() * 0.6f;
				}
				if (ItemTimeIsZero)
				{
					ApplyItemTime(item);
				}
				else if (itemTime == item.useTime / 2)
				{
					if (Main.netMode == 0)
					{
						Shellphone_Spawn();
					}
					else if (Main.netMode == 1 && whoAmI == Main.myPlayer)
					{
						NetMessage.SendData(73, -1, -1, null, 3);
					}
				}
			}
			if (item.type == 2350 && itemAnimation > 0)
			{
				if (ItemTimeIsZero)
				{
					ApplyItemTime(item);
					SoundEngine.PlaySound(in SoundID.Item3, position);
					for (int num9 = 0; num9 < 10; num9++)
					{
						Dust obj = Main.dust[Dust.NewDust(position, width, height, 15, velocity.X * 0.2f, velocity.Y * 0.2f, 150, Color.Cyan, 1.2f)];
						obj.velocity *= 0.5f;
					}
				}
				else if (itemTime == 20)
				{
					SoundEngine.PlaySound(HeldItem.UseSound, position);
					for (int num10 = 0; num10 < 70; num10++)
					{
						Dust obj2 = Main.dust[Dust.NewDust(position, width, height, 15, velocity.X * 0.2f, velocity.Y * 0.2f, 150, Color.Cyan, 1.2f)];
						obj2.velocity *= 0.5f;
					}
					RemoveAllGrapplingHooks();
					bool flag5 = immune;
					int num11 = immuneTime;
					Spawn(PlayerSpawnContext.RecallFromItem);
					immune = flag5;
					immuneTime = num11;
					for (int num12 = 0; num12 < 70; num12++)
					{
						Dust obj3 = Main.dust[Dust.NewDust(position, width, height, 15, 0f, 0f, 150, Color.Cyan, 1.2f)];
						obj3.velocity *= 0.5f;
					}
					if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
					{
						item.stack--;
					}
				}
			}
			if (item.type == 4870 && itemAnimation > 0)
			{
				if (ItemTimeIsZero)
				{
					ApplyItemTime(item);
					SoundEngine.PlaySound(in SoundID.Item3, position);
					for (int num13 = 0; num13 < 10; num13++)
					{
						Dust obj4 = Main.dust[Dust.NewDust(position, width, height, 15, velocity.X * 0.2f, velocity.Y * 0.2f, 150, Color.Cyan, 1.2f)];
						obj4.velocity *= 0.5f;
					}
				}
				else if (itemTime == 20)
				{
					SoundEngine.PlaySound(HeldItem.UseSound, position);
					for (int num14 = 0; num14 < 70; num14++)
					{
						Dust obj5 = Main.dust[Dust.NewDust(position, width, height, 15, velocity.X * 0.2f, velocity.Y * 0.2f, 150, Color.Cyan, 1.2f)];
						obj5.velocity *= 0.5f;
					}
					if (whoAmI == Main.myPlayer)
					{
						DoPotionOfReturnTeleportationAndSetTheComebackPoint();
					}
					for (int num15 = 0; num15 < 70; num15++)
					{
						Dust obj6 = Main.dust[Dust.NewDust(position, width, height, 15, 0f, 0f, 150, Color.Cyan, 1.2f)];
						obj6.velocity *= 0.5f;
					}
					if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
					{
						item.stack--;
					}
				}
			}
			if (item.type == 2351 && itemAnimation > 0)
			{
				if (ItemTimeIsZero)
				{
					ApplyItemTime(item);
				}
				else if (itemTime == 2)
				{
					if (Main.netMode == 0)
					{
						TeleportationPotion();
					}
					else if (Main.netMode == 1 && whoAmI == Main.myPlayer)
					{
						NetMessage.SendData(73);
					}
					if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
					{
						item.stack--;
					}
				}
			}
			if (item.type == 2756 && itemAnimation > 0)
			{
				if (ItemTimeIsZero)
				{
					ApplyItemTime(item);
				}
				else if (itemTime == 2)
				{
					if (whoAmI == Main.myPlayer)
					{
						Male = !Male;
						if (Main.netMode == 1)
						{
							NetMessage.SendData(4, -1, -1, null, whoAmI);
						}
					}
					if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
					{
						item.stack--;
					}
				}
				else
				{
					float num2 = itemTimeMax;
					num2 = (num2 - (float)itemTime) / num2;
					float num3 = 44f;
					float num4 = (float)Math.PI * 3f;
					Vector2 vector3 = Utils.RotatedBy(new Vector2(15f, 0f), num4 * num2);
					vector3.X *= direction;
					Vector2 vector4 = default(Vector2);
					for (int num5 = 0; num5 < 2; num5++)
					{
						int type3 = 221;
						if (num5 == 1)
						{
							vector3.X *= -1f;
							type3 = 219;
						}
						((Vector2)(ref vector4))._002Ector(vector3.X, num3 * (1f - num2) - num3 + (float)(height / 2));
						vector4 += base.Center;
						int num6 = Dust.NewDust(vector4, 0, 0, type3, 0f, 0f, 100);
						Main.dust[num6].position = vector4;
						Main.dust[num6].noGravity = true;
						Main.dust[num6].velocity = Vector2.Zero;
						Main.dust[num6].scale = 1.3f;
						Main.dust[num6].customData = this;
					}
				}
			}
			if (whoAmI == Main.myPlayer)
			{
				if ((itemTimeMax != 0 && itemTime == itemTimeMax) | (!item.IsAir && item.IsNotTheSameAs(lastVisualizedSelectedItem)))
				{
					lastVisualizedSelectedItem = item.Clone();
				}
			}
			else
			{
				lastVisualizedSelectedItem = item.Clone();
			}
			if (whoAmI == Main.myPlayer)
			{
				if (!dontConsumeWand && itemTimeMax != 0 && itemTime == itemTimeMax && item.tileWand > 0)
				{
					int tileWand = item.tileWand;
					for (int num7 = 0; num7 < 58; num7++)
					{
						if (tileWand == inventory[num7].type && inventory[num7].stack > 0)
						{
							if (ItemLoader.ConsumeItem(inventory[num7], this))
							{
								inventory[num7].stack--;
							}
							if (inventory[num7].stack <= 0)
							{
								inventory[num7] = new Item();
							}
							break;
						}
					}
				}
				if (itemTimeMax != 0 && itemTime == itemTimeMax && item.consumable && !context.SkipItemConsumption)
				{
					bool flag6 = true;
					if (item.ranged)
					{
						if (huntressAmmoCost90 && Main.rand.Next(10) == 0)
						{
							flag6 = false;
						}
						if (chloroAmmoCost80 && Main.rand.Next(5) == 0)
						{
							flag6 = false;
						}
						if (ammoCost80 && Main.rand.Next(5) == 0)
						{
							flag6 = false;
						}
						if (ammoCost75 && Main.rand.Next(4) == 0)
						{
							flag6 = false;
						}
					}
					if (item.CountsAsClass(DamageClass.Throwing))
					{
						if (ThrownCost50 && Main.rand.Next(100) < 50)
						{
							flag6 = false;
						}
						if (ThrownCost33 && Main.rand.Next(100) < 33)
						{
							flag6 = false;
						}
					}
					if (item.IsACoin)
					{
						flag6 = true;
					}
					bool? flag7 = ItemID.Sets.ForceConsumption[item.type];
					if (flag7.HasValue)
					{
						flag6 = flag7.Value;
					}
					if (flag6 && ItemLoader.ConsumeItem(item, this))
					{
						if (item.stack > 0)
						{
							item.stack--;
						}
						if (item.stack <= 0)
						{
							itemTime = itemAnimation;
							Main.blockMouse = true;
						}
					}
				}
				if (item.stack <= 0 && itemAnimation == 0)
				{
					inventory[selectedItem] = new Item();
				}
				if (selectedItem == 58 && itemAnimation != 0)
				{
					Main.mouseItem = item.Clone();
				}
			}
		}
		if (itemAnimation == 0)
		{
			JustDroppedAnItem = false;
		}
		if (whoAmI == Main.myPlayer && flag)
		{
			PlayerInput.TryEndingFastUse();
		}
	}

	private void UpdatePlacementPreview(Item sItem)
	{
		if (Main.myPlayer == whoAmI && itemAnimation == 0)
		{
			Tile targetTile = Main.tile[tileTargetX, tileTargetY];
			FigureOutWhatToPlace(targetTile, sItem, out var tileToCreate, out var previewPlaceStyle, out var overrideCanPlace, out var forcedRandom);
			PlantLoader.CheckAndInjectModSapling(tileTargetX, tileTargetY, ref tileToCreate, ref previewPlaceStyle);
			if ((!overrideCanPlace.HasValue || overrideCanPlace.Value) && TileObjectData.CustomPlace(tileToCreate, previewPlaceStyle))
			{
				TileObject.CanPlace(tileTargetX, tileTargetY, tileToCreate, previewPlaceStyle, direction, out var _, onlyCheck: true, forcedRandom);
			}
		}
	}

	private void FigureOutWhatToPlace(Tile targetTile, Item sItem, out int tileToCreate, out int previewPlaceStyle, out bool? overrideCanPlace, out int? forcedRandom)
	{
		tileToCreate = sItem.createTile;
		previewPlaceStyle = sItem.placeStyle;
		overrideCanPlace = null;
		forcedRandom = null;
		if (UsingBiomeTorches && tileToCreate == 215 && previewPlaceStyle == 0)
		{
			BiomeCampfirePlaceStyle(ref tileToCreate, ref previewPlaceStyle);
		}
		if (targetTile != null && targetTile.active())
		{
			ushort type = targetTile.type;
			if (tileToCreate == 23 && type == 59)
			{
				tileToCreate = 661;
			}
			if (tileToCreate == 199 && type == 59)
			{
				tileToCreate = 662;
			}
		}
		if (!ModifyFlexibleWandPlacementInfo(ref tileToCreate, ref previewPlaceStyle, ref forcedRandom))
		{
			overrideCanPlace = false;
		}
	}

	private void ItemCheck_OwnerOnlyCode(ref ItemCheckContext context, Item sItem, int weaponDamage, Rectangle heldItemFrame)
	{
		//IL_04a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_040a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0411: Unknown result type (might be due to invalid IL or missing references)
		//IL_0418: Unknown result type (might be due to invalid IL or missing references)
		//IL_041f: Unknown result type (might be due to invalid IL or missing references)
		//IL_050d: Unknown result type (might be due to invalid IL or missing references)
		//IL_04df: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_053f: Unknown result type (might be due to invalid IL or missing references)
		//IL_054a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0556: Unknown result type (might be due to invalid IL or missing references)
		//IL_0568: Unknown result type (might be due to invalid IL or missing references)
		bool flag = true;
		int type = sItem.type;
		if ((type == 65 || type == 676 || type == 723 || type == 724 || type == 757 || type == 674 || type == 675 || type == 989 || type == 1226 || type == 1227) && !ItemAnimationJustStarted)
		{
			flag = false;
		}
		if (type == 5097 && ItemAnimationJustStarted)
		{
			_batbatCanHeal = true;
		}
		if (type == 5094 && ItemAnimationJustStarted)
		{
			_spawnTentacleSpikes = true;
		}
		if (type == 795 && ItemAnimationJustStarted)
		{
			_spawnBloodButcherer = true;
		}
		if (type == 121 && ItemAnimationJustStarted)
		{
			_spawnVolcanoExplosion = true;
		}
		if (type == 155 && ItemAnimationJustStarted)
		{
			_spawnMuramasaCut = true;
		}
		if (type == 3852 && altFunctionUse == 2 && !ItemAnimationJustStarted)
		{
			flag = false;
		}
		if (type == 5451 && ownedProjectileCounts[1020] > 0)
		{
			flag = false;
		}
		if (sItem.useLimitPerAnimation.HasValue && ItemUsesThisAnimation >= sItem.useLimitPerAnimation.Value)
		{
			flag = false;
		}
		ItemCheck_TurretAltFeatureUse(sItem, flag);
		ItemCheck_MinionAltFeatureUse(sItem, flag);
		bool flag2 = itemAnimation > 0 && ItemTimeIsZero && flag;
		if (sItem.shootsEveryUse)
		{
			flag2 = ItemAnimationJustStarted;
		}
		if (sItem.shoot > 0 && flag2)
		{
			ItemCheck_Shoot(whoAmI, sItem, weaponDamage);
		}
		if (whoAmI != Main.myPlayer)
		{
			return;
		}
		ItemCheck_UseWiringTools(sItem);
		ItemCheck_UseLawnMower(sItem);
		ItemCheck_PlayInstruments(sItem);
		ItemCheck_UseBuckets(sItem);
		if (!channel)
		{
			toolTime = itemTime;
		}
		else
		{
			toolTime--;
			if (toolTime < 0)
			{
				toolTime = CombinedHooks.TotalUseTime(sItem.useTime, this, sItem);
			}
		}
		ItemCheck_TryDestroyingDrones(sItem);
		ItemCheck_UseMiningTools(sItem);
		ItemCheck_UseTeleportRod(sItem);
		ItemCheck_UseLifeCrystal(sItem);
		ItemCheck_UseLifeFruit(sItem);
		ItemCheck_UseManaCrystal(sItem);
		ItemCheck_UseDemonHeart(sItem);
		ItemCheck_UseMinecartPowerUp(sItem);
		ItemCheck_UseTorchGodsFavor(sItem);
		ItemCheck_UseArtisanLoaf(sItem);
		ItemCheck_UseEventItems(sItem);
		ItemCheck_UseBossSpawners(whoAmI, sItem);
		ItemCheck_UseCombatBook(sItem);
		ItemCheck_UsePeddlersSatchel(sItem);
		ItemCheck_UsePetLicenses(sItem);
		ItemCheck_UseShimmerPermanentItems(sItem);
		if (sItem.type == 4095 && itemAnimation == 2)
		{
			Main.LocalGolfState.ResetGolfBall();
		}
		PlaceThing(ref context);
		if (sItem.makeNPC > 0)
		{
			if (!Main.GamepadDisableCursorItemIcon && position.X / 16f - (float)tileRangeX - (float)sItem.tileBoost <= (float)tileTargetX && (position.X + (float)width) / 16f + (float)tileRangeX + (float)sItem.tileBoost - 1f >= (float)tileTargetX && position.Y / 16f - (float)tileRangeY - (float)sItem.tileBoost <= (float)tileTargetY && (position.Y + (float)height) / 16f + (float)tileRangeY + (float)sItem.tileBoost - 2f >= (float)tileTargetY)
			{
				cursorItemIconEnabled = true;
				Main.ItemIconCacheUpdate(sItem.type);
			}
			if (ItemTimeIsZero && itemAnimation > 0 && controlUseItem)
			{
				ItemCheck_ReleaseCritter(sItem);
			}
		}
		if (boneGloveItem != null && !boneGloveItem.IsAir && boneGloveTimer == 0 && itemAnimation > 0 && sItem.damage > 0)
		{
			boneGloveTimer = 60;
			Vector2 center = base.Center;
			Vector2 vector = DirectionTo(ApplyRangeCompensation(0.2f, center, Main.MouseWorld)) * 10f;
			Projectile.NewProjectile(GetProjectileSource_Accessory(boneGloveItem), center.X, center.Y, vector.X, vector.Y, 532, 25, 5f, whoAmI);
		}
		if (((sItem.damage < 0 || sItem.type <= 0 || sItem.noMelee) && sItem.type != 1450 && !ItemID.Sets.CatchingTool[sItem.type] && sItem.type != 3542 && sItem.type != 3779) || itemAnimation <= 0)
		{
			return;
		}
		ItemCheck_GetMeleeHitbox(sItem, heldItemFrame, out var dontAttack, out var itemRectangle);
		if (!dontAttack)
		{
			itemRectangle = ItemCheck_EmitUseVisuals(sItem, itemRectangle);
			if (Main.myPlayer == whoAmI && ItemID.Sets.CatchingTool[sItem.type])
			{
				itemRectangle = ItemCheck_CatchCritters(sItem, itemRectangle);
			}
			if (sItem.type == 3183 || sItem.type == 4821)
			{
				bool[] shouldIgnore = ItemCheck_GetTileCutIgnoreList(sItem);
				ItemCheck_CutTiles(sItem, itemRectangle, shouldIgnore);
			}
			if (sItem.damage > 0)
			{
				UpdateMeleeHitCooldowns();
				float knockBack = GetWeaponKnockback(sItem, sItem.knockBack);
				bool[] shouldIgnore2 = ItemCheck_GetTileCutIgnoreList(sItem);
				ItemCheck_CutTiles(sItem, itemRectangle, shouldIgnore2);
				ItemCheck_MeleeHitNPCs(sItem, itemRectangle, weaponDamage, knockBack);
				ItemCheck_MeleeHitPVP(sItem, itemRectangle, weaponDamage, knockBack);
				ItemCheck_EmitHammushProjectiles(whoAmI, sItem, itemRectangle, weaponDamage);
			}
		}
	}

	private void ItemCheck_EmitFoodParticles(Item sItem)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		if (itemAnimation < 1)
		{
			return;
		}
		Color[] array = ItemID.Sets.FoodParticleColors[sItem.type];
		if (array != null && array.Length != 0 && Main.rand.Next(2) != 0)
		{
			Vector2? mouthPosition = MouthPosition;
			if (mouthPosition.HasValue)
			{
				Vector2 val = mouthPosition.Value + Main.rand.NextVector2Square(-4f, 4f);
				Vector2 spinningpoint = default(Vector2);
				((Vector2)(ref spinningpoint))._002Ector((float)direction, (0f - gravDir) * 0.8f);
				Dust.NewDustPerfect(val, 284, 1.3f * spinningpoint.RotatedBy((float)Math.PI / 5f * Main.rand.NextFloatDirection()), 0, array[Main.rand.Next(array.Length)], 0.8f + 0.2f * Main.rand.NextFloat()).fadeIn = 0f;
			}
		}
	}

	private void ItemCheck_EmitDrinkParticles(Item sItem)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		if (itemAnimation < 1)
		{
			return;
		}
		Color[] array = ItemID.Sets.DrinkParticleColors[sItem.type];
		if (array != null && array.Length != 0)
		{
			Vector2? mouthPosition = MouthPosition;
			if (mouthPosition.HasValue)
			{
				Vector2 val = mouthPosition.Value + Main.rand.NextVector2Square(-4f, 4f);
				Vector2 spinningpoint = default(Vector2);
				((Vector2)(ref spinningpoint))._002Ector((float)direction * 0.1f, (0f - gravDir) * 0.1f);
				Dust.NewDustPerfect(val, 284, 1.3f * spinningpoint.RotatedBy(-(float)Math.PI / 5f * Main.rand.NextFloatDirection()), 0, array[Main.rand.Next(array.Length)] * 0.7f, 0.8f + 0.2f * Main.rand.NextFloat()).fadeIn = 0f;
			}
		}
	}

	private void ItemCheck_UseBossSpawners(int onWhichPlayer, Item sItem)
	{
		if (!ItemTimeIsZero || itemAnimation <= 0 || (sItem.type != 43 && sItem.type != 70 && sItem.type != 544 && sItem.type != 556 && sItem.type != 557 && sItem.type != 560 && sItem.type != 1133 && sItem.type != 1331 && sItem.type != 4988 && sItem.type != 5120 && sItem.type != 5334) || !SummonItemCheck(sItem))
		{
			return;
		}
		if (sItem.type == 560)
		{
			ApplyItemTime(sItem);
			SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
			if (Main.netMode != 1)
			{
				NPC.SpawnOnPlayer(onWhichPlayer, 50);
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, 50f);
			}
		}
		else if (sItem.type == 43)
		{
			if (!Main.IsItDay())
			{
				ApplyItemTime(sItem);
				SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
				if (Main.netMode != 1)
				{
					NPC.SpawnOnPlayer(onWhichPlayer, 4);
				}
				else
				{
					NetMessage.SendData(61, -1, -1, null, whoAmI, 4f);
				}
			}
		}
		else if (sItem.type == 70)
		{
			if (ZoneCorrupt)
			{
				ApplyItemTime(sItem);
				SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
				if (Main.netMode != 1)
				{
					NPC.SpawnOnPlayer(onWhichPlayer, 13);
				}
				else
				{
					NetMessage.SendData(61, -1, -1, null, whoAmI, 13f);
				}
			}
		}
		else if (sItem.type == 544)
		{
			if (!Main.IsItDay() && sItem.Variant != ItemVariants.DisabledBossSummonVariant)
			{
				ApplyItemTime(sItem);
				SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
				if (Main.netMode != 1)
				{
					NPC.SpawnOnPlayer(onWhichPlayer, 125);
					NPC.SpawnOnPlayer(onWhichPlayer, 126);
				}
				else
				{
					NetMessage.SendData(61, -1, -1, null, whoAmI, 125f);
					NetMessage.SendData(61, -1, -1, null, whoAmI, 126f);
				}
			}
		}
		else if (sItem.type == 556)
		{
			if (!Main.IsItDay() && sItem.Variant != ItemVariants.DisabledBossSummonVariant)
			{
				ApplyItemTime(sItem);
				SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
				if (Main.netMode != 1)
				{
					NPC.SpawnOnPlayer(onWhichPlayer, 134);
				}
				else
				{
					NetMessage.SendData(61, -1, -1, null, whoAmI, 134f);
				}
			}
		}
		else if (sItem.type == 557)
		{
			if (!Main.IsItDay() && sItem.Variant != ItemVariants.DisabledBossSummonVariant)
			{
				ApplyItemTime(sItem);
				SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
				if (Main.netMode != 1)
				{
					NPC.SpawnOnPlayer(onWhichPlayer, 127);
				}
				else
				{
					NetMessage.SendData(61, -1, -1, null, whoAmI, 127f);
				}
			}
		}
		else if (sItem.type == 5334)
		{
			if (NPC.SpawnMechQueen(whoAmI))
			{
				ApplyItemTime(sItem);
				SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
			}
		}
		else if (sItem.type == 1133)
		{
			ApplyItemTime(sItem);
			SoundEngine.PlaySound(SoundID.Item173, (int)position.X, (int)position.Y);
			if (Main.netMode != 1)
			{
				NPC.SpawnOnPlayer(onWhichPlayer, 222);
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, 222f);
			}
		}
		else if (sItem.type == 1331)
		{
			if (ZoneCrimson)
			{
				ApplyItemTime(sItem);
				SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
				if (Main.netMode != 1)
				{
					NPC.SpawnOnPlayer(onWhichPlayer, 266);
				}
				else
				{
					NetMessage.SendData(61, -1, -1, null, whoAmI, 266f);
				}
			}
		}
		else if (sItem.type == 4988)
		{
			if (ZoneHallow)
			{
				ApplyItemTime(sItem);
				SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
				if (Main.netMode != 1)
				{
					NPC.SpawnOnPlayer(onWhichPlayer, 657);
				}
				else
				{
					NetMessage.SendData(61, -1, -1, null, whoAmI, 657f);
				}
			}
		}
		else if (sItem.type == 5120 && ZoneSnow)
		{
			ApplyItemTime(sItem);
			SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
			if (Main.netMode != 1)
			{
				NPC.SpawnOnPlayer(onWhichPlayer, 668);
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, 668f);
			}
		}
	}

	private void ItemCheck_UseEventItems(Item sItem)
	{
		if (ItemTimeIsZero && itemAnimation > 0 && sItem.type == 361 && Main.CanStartInvasion(1, ignoreDelay: true))
		{
			ApplyItemTime(sItem);
			SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
			if (Main.netMode != 1)
			{
				if (Main.invasionType == 0)
				{
					Main.invasionDelay = 0;
					Main.StartInvasion();
				}
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, -1f);
			}
		}
		if (ItemTimeIsZero && itemAnimation > 0 && sItem.type == 602 && Main.CanStartInvasion(2, ignoreDelay: true))
		{
			ApplyItemTime(sItem);
			SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
			if (Main.netMode != 1)
			{
				if (Main.invasionType == 0)
				{
					Main.invasionDelay = 0;
					Main.StartInvasion(2);
				}
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, -2f);
			}
		}
		if (ItemTimeIsZero && itemAnimation > 0 && sItem.type == 1315 && Main.CanStartInvasion(3, ignoreDelay: true))
		{
			ApplyItemTime(sItem);
			SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
			if (Main.netMode != 1)
			{
				if (Main.invasionType == 0)
				{
					Main.invasionDelay = 0;
					Main.StartInvasion(3);
				}
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, -3f);
			}
		}
		if (ItemTimeIsZero && itemAnimation > 0 && sItem.type == 1844 && !Main.dayTime && !Main.pumpkinMoon && !Main.snowMoon && !DD2Event.Ongoing)
		{
			ApplyItemTime(sItem);
			SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
			if (Main.netMode != 1)
			{
				Main.NewText(Lang.misc[31].Value, 50, byte.MaxValue, 130);
				Main.startPumpkinMoon();
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, -4f);
			}
		}
		if (ItemTimeIsZero && itemAnimation > 0 && sItem.type == 2767 && Main.dayTime && !Main.eclipse)
		{
			SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
			ApplyItemTime(sItem);
			if (Main.netMode == 0)
			{
				Main.eclipse = true;
				if (Main.remixWorld)
				{
					Main.NewText(Lang.misc[106].Value, 50, byte.MaxValue, 130);
				}
				else
				{
					Main.NewText(Lang.misc[20].Value, 50, byte.MaxValue, 130);
				}
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, -6f);
			}
		}
		if (ItemTimeIsZero && itemAnimation > 0 && sItem.type == 4271 && !Main.dayTime && !Main.bloodMoon)
		{
			SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
			ApplyItemTime(sItem);
			if (Main.netMode == 0)
			{
				AchievementsHelper.NotifyProgressionEvent(4);
				Main.bloodMoon = true;
				if (Main.GetMoonPhase() == MoonPhase.Empty)
				{
					Main.moonPhase = 5;
				}
				Main.NewText(Lang.misc[8].Value, 50, byte.MaxValue, 130);
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, -10f);
			}
		}
		if (ItemTimeIsZero && itemAnimation > 0 && sItem.type == 3601 && NPC.downedGolemBoss && Main.hardMode && !NPC.AnyDanger() && !NPC.AnyoneNearCultists())
		{
			SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
			ApplyItemTime(sItem);
			if (Main.netMode == 0)
			{
				WorldGen.StartImpendingDoom(720);
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, -8f);
			}
		}
		if (ItemTimeIsZero && itemAnimation > 0 && sItem.type == 1958 && !Main.dayTime && !Main.pumpkinMoon && !Main.snowMoon && !DD2Event.Ongoing)
		{
			ApplyItemTime(sItem);
			SoundEngine.PlaySound(15, (int)position.X, (int)position.Y, 0);
			if (Main.netMode != 1)
			{
				Main.NewText(Lang.misc[34].Value, 50, byte.MaxValue, 130);
				Main.startSnowMoon();
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, -5f);
			}
		}
	}

	private void ItemCheck_ReleaseCritter(Item sItem)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (sItem.makeNPC == 614)
		{
			ApplyItemTime(sItem);
			NPC.ReleaseNPC((int)base.Center.X, (int)base.Bottom.Y, sItem.makeNPC, sItem.placeStyle, whoAmI);
		}
		else if (position.X / 16f - (float)tileRangeX - (float)sItem.tileBoost <= (float)tileTargetX && (position.X + (float)width) / 16f + (float)tileRangeX + (float)sItem.tileBoost - 1f >= (float)tileTargetX && position.Y / 16f - (float)tileRangeY - (float)sItem.tileBoost <= (float)tileTargetY && (position.Y + (float)height) / 16f + (float)tileRangeY + (float)sItem.tileBoost - 2f >= (float)tileTargetY)
		{
			int num = Main.mouseX + (int)Main.screenPosition.X;
			int num2 = Main.mouseY + (int)Main.screenPosition.Y;
			int i2 = num / 16;
			int i = num2 / 16;
			if (!WorldGen.SolidTile(i2, i))
			{
				ApplyItemTime(sItem);
				NPC.ReleaseNPC(num, num2, sItem.makeNPC, sItem.placeStyle, whoAmI);
			}
		}
	}

	private void ItemCheck_MeleeHitPVP(Item sItem, Rectangle itemRectangle, int damage, float knockBack)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0348: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0358: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		if (!hostile)
		{
			return;
		}
		Vector2 vector = default(Vector2);
		Vector2 vector2 = default(Vector2);
		for (int i = 0; i < 255; i++)
		{
			Player player = Main.player[i];
			if (i == whoAmI || !player.active || !player.hostile || player.immune || player.dead || (team != 0 && team == player.team) || !((Rectangle)(ref itemRectangle)).Intersects(player.Hitbox) || !CanHit(player) || !CombinedHooks.CanHitPvp(this, sItem, player))
			{
				continue;
			}
			bool flag = false;
			int num = Main.DamageVar(damage, luck);
			StatusToPlayerPvP(sItem.type, i);
			OnHit(player.Center.X, player.Center.Y, player);
			PlayerDeathReason playerDeathReason = PlayerDeathReason.ByPlayerItem(whoAmI, sItem);
			int num2 = (int)player.Hurt(playerDeathReason, num, direction, pvp: true, quiet: false, flag, -1);
			if (inventory[selectedItem].type == 3211)
			{
				((Vector2)(ref vector))._002Ector((float)(direction * 100 + Main.rand.Next(-25, 26)), (float)Main.rand.Next(-75, 76));
				((Vector2)(ref vector)).Normalize();
				vector *= (float)Main.rand.Next(30, 41) * 0.1f;
				((Vector2)(ref vector2))._002Ector((float)(itemRectangle.X + Main.rand.Next(itemRectangle.Width)), (float)(itemRectangle.Y + Main.rand.Next(itemRectangle.Height)));
				vector2 = (vector2 + player.Center * 2f) / 3f;
				Projectile.NewProjectile(GetProjectileSource_Item(HeldItem), vector2.X, vector2.Y, vector.X, vector.Y, 524, (int)((double)damage * 0.7), knockBack * 0.7f, whoAmI);
			}
			if (sItem.type == 5097)
			{
				BatBat_TryLifeLeeching(player);
			}
			if (beetleOffense)
			{
				beetleCounter += num2;
				beetleCountdown = 0;
			}
			if (meleeEnchant == 7)
			{
				Projectile.NewProjectile(GetProjectileSource_Misc(8), player.Center.X, player.Center.Y, player.velocity.X, player.velocity.Y, 289, 0, 0f, whoAmI);
			}
			if (sItem.type == 1123)
			{
				int num3 = Main.rand.Next(1, 4);
				if (strongBees && Main.rand.Next(3) == 0)
				{
					num3++;
				}
				for (int j = 0; j < num3; j++)
				{
					float num4 = (float)(direction * 2) + (float)Main.rand.Next(-35, 36) * 0.02f;
					float num5 = (float)Main.rand.Next(-35, 36) * 0.02f;
					num4 *= 0.2f;
					num5 *= 0.2f;
					int num6 = Projectile.NewProjectile(GetProjectileSource_Item(sItem), itemRectangle.X + itemRectangle.Width / 2, itemRectangle.Y + itemRectangle.Height / 2, num4, num5, beeType(), beeDamage(num / 3), beeKB(0f), whoAmI);
					Main.projectile[num6].melee = true;
				}
			}
			if (inventory[selectedItem].type == 3106)
			{
				stealth = 1f;
				if (Main.netMode == 1)
				{
					NetMessage.SendData(84, -1, -1, null, whoAmI);
				}
			}
			if (Main.netMode != 0)
			{
				NetMessage.SendPlayerHurt(i, playerDeathReason, num, direction, flag, pvp: true, -1);
			}
			ApplyAttackCooldown();
		}
	}

	private void Volcano_TrySpawningVolcano(NPC npc, Item sItem, float damage, float knockBack, Rectangle itemRectangle)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (_spawnVolcanoExplosion && Main.myPlayer == whoAmI && (npc == null || npc.HittableForOnHitRewards()))
		{
			Vector2 center = npc.Center;
			int num = 2;
			Projectile.NewProjectile(GetProjectileSource_Item(sItem), center.X, center.Y, 0f, -1f * gravDir, 978, (int)damage, knockBack, whoAmI, 0f, num);
			_spawnVolcanoExplosion = false;
		}
	}

	private void TentacleSpike_TrySpiking(NPC npc, Item sItem, float damage, float knockBack)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		if (_spawnTentacleSpikes && Main.myPlayer == whoAmI && (npc == null || npc.CanBeChasedBy(this)))
		{
			Vector2 v = npc.Center - MountedCenter;
			v = v.SafeNormalize(Vector2.Zero);
			Vector2 vector = npc.Hitbox.ClosestPointInRect(MountedCenter) + v;
			Vector2 vector2 = (npc.Center - vector) * 0.8f;
			int num = Projectile.NewProjectile(GetProjectileSource_Item(sItem), vector.X, vector.Y, vector2.X, vector2.Y, 971, (int)damage, knockBack, whoAmI, 1f, npc.whoAmI);
			Main.projectile[num].StatusNPC(npc.whoAmI);
			Projectile.KillOldestJavelin(num, 971, npc.whoAmI, _tentacleSpikesMax5);
			_spawnTentacleSpikes = false;
		}
	}

	private void BloodButcherer_TryButchering(NPC npc, Item sItem, float damage, float knockBack)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		if (_spawnBloodButcherer && Main.myPlayer == whoAmI && (npc == null || npc.CanBeChasedBy(this)))
		{
			Vector2 v = npc.Center - MountedCenter;
			v = v.SafeNormalize(Vector2.Zero);
			Vector2 vector = npc.Hitbox.ClosestPointInRect(MountedCenter) + v;
			Vector2 spinningpoint = (npc.Center - vector) * 0.8f;
			spinningpoint = spinningpoint.RotatedBy(Main.rand.NextFloatDirection() * (float)Math.PI * 0.25f);
			int num = Projectile.NewProjectile(GetProjectileSource_Item(sItem), vector.X, vector.Y, spinningpoint.X, spinningpoint.Y, 975, (int)damage, knockBack, whoAmI, 1f, npc.whoAmI);
			Main.projectile[num].StatusNPC(npc.whoAmI);
			Projectile.KillOldestJavelin(num, 975, npc.whoAmI, _bloodButchererMax5);
			_spawnBloodButcherer = false;
		}
	}

	private void BatBat_TryLifeLeeching(Entity entity)
	{
		if (_batbatCanHeal && statLife < statLifeMax2 && (!(entity is NPC nPC) || nPC.HittableForOnHitRewards()))
		{
			_batbatCanHeal = false;
			Heal(1);
		}
	}

	public bool HasNPCBannerBuff(int bannerType)
	{
		return Main.SceneMetrics.NPCBannerBuff[bannerType];
	}

	public void ResetMeleeHitCooldowns()
	{
		if (Main.myPlayer == whoAmI)
		{
			for (int i = 0; i < 200; i++)
			{
				meleeNPCHitCooldown[i] = 0;
			}
		}
	}

	public void UpdateMeleeHitCooldowns()
	{
		if (Main.myPlayer == whoAmI)
		{
			for (int i = 0; i < 200; i++)
			{
				meleeNPCHitCooldown[i]--;
			}
		}
	}

	public bool CanHitNPCWithMeleeHit(int npcIndex)
	{
		return meleeNPCHitCooldown[npcIndex] <= 0;
	}

	public void SetMeleeHitCooldown(int npcIndex, int timeInFrames)
	{
		meleeNPCHitCooldown[npcIndex] = timeInFrames;
	}

	private void ItemCheck_MeleeHitNPCs(Item sItem, Rectangle itemRectangle, int originalDamage, float knockBack)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < 200; i++)
		{
			NPC nPC = Main.npc[i];
			if (nPC.active && nPC.immune[whoAmI] == 0 && CanHitNPCWithMeleeHit(i) && attackCD <= 0)
			{
				nPC.position += nPC.netOffset;
				ProcessHitAgainstNPC(sItem, itemRectangle, originalDamage, knockBack, i);
				nPC.position -= nPC.netOffset;
			}
		}
	}

	public void TakeDamageFromJellyfish(int npcIndex)
	{
		NPC nPC = Main.npc[npcIndex];
		Hurt(PlayerDeathReason.ByNPC(npcIndex), (int)((double)nPC.damage * 1.3), -direction);
		SetMeleeHitCooldown(npcIndex, itemAnimation);
		ApplyAttackCooldown();
	}

	private void ProcessHitAgainstNPC(Item sItem, Rectangle itemRectangle, int originalDamage, float knockBack, int npcIndex)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0350: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0432: Unknown result type (might be due to invalid IL or missing references)
		//IL_0437: Unknown result type (might be due to invalid IL or missing references)
		//IL_046d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0472: Unknown result type (might be due to invalid IL or missing references)
		//IL_053e: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b4: Unknown result type (might be due to invalid IL or missing references)
		NPC nPC = Main.npc[npcIndex];
		if (nPC.dontTakeDamage || !CanNPCBeHitByPlayerOrPlayerProjectile(nPC))
		{
			if (NPCID.Sets.ZappingJellyfish[nPC.type] && ((Rectangle)(ref itemRectangle)).Intersects(nPC.Hitbox) && (nPC.noTileCollide || CanHit(nPC)))
			{
				TakeDamageFromJellyfish(npcIndex);
			}
			return;
		}
		bool? modCanHit = CombinedHooks.CanPlayerHitNPCWithItem(this, sItem, nPC);
		if (!(modCanHit ?? true) || (!(modCanHit ?? false) && nPC.friendly && (nPC.type != 22 || !killGuide) && (nPC.type != 54 || !killClothier) && (!nPC.isLikeATownNPC || sItem.type != 5129)))
		{
			return;
		}
		Rectangle rectangle = default(Rectangle);
		((Rectangle)(ref rectangle))._002Ector((int)nPC.position.X, (int)nPC.position.Y, nPC.width, nPC.height);
		bool flag = ((Rectangle)(ref itemRectangle)).Intersects(rectangle);
		if (sItem.type == 121)
		{
			GetPointOnSwungItemPath(70f, 70f, 0f, GetAdjustedItemScale(sItem), out var location, out var outwardDirection);
			GetPointOnSwungItemPath(70f, 70f, 0.9f, GetAdjustedItemScale(sItem), out var location2, out outwardDirection);
			bool flag2 = Utils.LineRectangleDistance(rectangle, location, location2) <= 16f;
			flag = ((!_spawnVolcanoExplosion) ? (flag || flag2) : flag2);
		}
		bool? modCanCollide = CombinedHooks.CanPlayerMeleeAttackCollideWithNPC(this, sItem, itemRectangle, nPC);
		if (modCanCollide == false)
		{
			return;
		}
		if (modCanCollide == true)
		{
			flag = true;
		}
		if (!flag || (!nPC.noTileCollide && !CanHit(nPC)))
		{
			return;
		}
		NPC.HitModifiers modifiers = nPC.GetIncomingStrikeModifiers(sItem.DamageType, direction);
		float num = 1000f;
		bool flag3 = false;
		if (sItem.DamageType.UseStandardCritCalcs)
		{
			int weaponCrit = GetWeaponCrit(sItem);
			if (Main.rand.Next(1, 101) <= weaponCrit)
			{
				flag3 = true;
			}
		}
		ApplyBannerOffenseBuff(nPC, ref modifiers);
		if (parryDamageBuff && sItem.melee)
		{
			modifiers.ScalingBonusDamage += 4f;
			parryDamageBuff = false;
			ClearBuff(198);
		}
		if (sItem.type == 426 && (float)nPC.life >= (float)nPC.lifeMax * 0.9f)
		{
			num = (int)(num * 2.5f);
		}
		if (sItem.type == 5096)
		{
			int num2 = 0;
			if (FindBuffIndex(26) != -1)
			{
				num2 = 1;
			}
			if (FindBuffIndex(206) != -1)
			{
				num2 = 2;
			}
			if (FindBuffIndex(207) != -1)
			{
				num2 = 3;
			}
			float num3 = 1f + 0.05f * (float)num2;
			num = (int)(num * num3);
		}
		if (sItem.type == 671)
		{
			float t = (float)nPC.life / (float)nPC.lifeMax;
			float lerpValue = Utils.GetLerpValue(1f, 0.1f, t, clamped: true);
			float num4 = 1f * lerpValue;
			num = (int)(num * (1f + num4));
			Vector2 point = ((Rectangle)(ref itemRectangle)).Center.ToVector2();
			Vector2 positionInWorld = nPC.Hitbox.ClosestPointInRect(point);
			ParticleOrchestrator.RequestParticleSpawn(clientOnly: false, ParticleOrchestraType.Keybrand, new ParticleOrchestraSettings
			{
				PositionInWorld = positionInWorld
			}, whoAmI);
		}
		modifiers.SourceDamage *= num / 1000f;
		float armorPenetrationPercent = 0f;
		if (sItem.type == 5129 && nPC.isLikeATownNPC)
		{
			armorPenetrationPercent = 1f;
			if (nPC.type == 18)
			{
				modifiers.TargetDamageMultiplier *= 2f;
			}
		}
		if (sItem.type == 3258)
		{
			ParticleOrchestraSettings particleOrchestraSettings3 = default(ParticleOrchestraSettings);
			particleOrchestraSettings3.PositionInWorld = nPC.Center;
			ParticleOrchestraSettings settings = particleOrchestraSettings3;
			ParticleOrchestrator.RequestParticleSpawn(clientOnly: false, ParticleOrchestraType.SlapHand, settings, whoAmI);
		}
		if (sItem.type == 5382)
		{
			ParticleOrchestraSettings particleOrchestraSettings2 = default(ParticleOrchestraSettings);
			particleOrchestraSettings2.PositionInWorld = nPC.Center;
			ParticleOrchestraSettings settings2 = particleOrchestraSettings2;
			ParticleOrchestrator.RequestParticleSpawn(clientOnly: false, ParticleOrchestraType.WaffleIron, settings2, whoAmI);
		}
		if (sItem.type == 5129)
		{
			ParticleOrchestraSettings particleOrchestraSettings = default(ParticleOrchestraSettings);
			particleOrchestraSettings.PositionInWorld = nPC.Center;
			ParticleOrchestraSettings settings3 = particleOrchestraSettings;
			ParticleOrchestrator.RequestParticleSpawn(clientOnly: false, ParticleOrchestraType.FlyMeal, settings3, whoAmI);
		}
		StatusToNPC(sItem.type, npcIndex);
		if (nPC.life > 5)
		{
			OnHit(nPC.Center.X, nPC.Center.Y, nPC);
		}
		modifiers.ArmorPenetration += (float)GetWeaponArmorPenetration(sItem);
		modifiers.ScalingArmorPenetration += armorPenetrationPercent;
		CombinedHooks.ModifyPlayerHitNPCWithItem(this, sItem, nPC, ref modifiers);
		NPC.HitInfo strike = modifiers.ToHitInfo(originalDamage, flag3, knockBack, damageVariation: true, luck);
		NPCKillAttempt attempt = new NPCKillAttempt(nPC);
		int dmgDone = nPC.StrikeNPC(strike);
		CombinedHooks.OnPlayerHitNPCWithItem(this, sItem, nPC, in strike, dmgDone);
		ApplyNPCOnHitEffects(sItem, itemRectangle, strike.SourceDamage, strike.Knockback, npcIndex, strike.SourceDamage, dmgDone);
		int num5 = Item.NPCtoBanner(nPC.BannerID());
		if (num5 >= 0)
		{
			lastCreatureHit = num5;
		}
		if (Main.netMode != 0)
		{
			NetMessage.SendStrikeNPC(nPC, in strike);
		}
		if (accDreamCatcher && !nPC.HideStrikeDamage)
		{
			addDPS(dmgDone);
		}
		SetMeleeHitCooldown(npcIndex, itemAnimation);
		if (attempt.DidNPCDie())
		{
			OnKillNPC(ref attempt, sItem);
		}
		ApplyAttackCooldown();
	}

	public void ApplyAttackCooldown()
	{
		attackCD = Math.Max(1, (int)((double)itemAnimationMax * 0.33));
	}

	public void ApplyAttackCooldown(int frames)
	{
		if (attackCD < frames)
		{
			attackCD = frames;
		}
	}

	private void ApplyNPCOnHitEffects(Item sItem, Rectangle itemRectangle, int damage, float knockBack, int npcIndex, int dmgRandomized, int dmgDone)
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_031d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0323: Unknown result type (might be due to invalid IL or missing references)
		//IL_032d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0333: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0402: Unknown result type (might be due to invalid IL or missing references)
		//IL_0404: Unknown result type (might be due to invalid IL or missing references)
		//IL_0409: Unknown result type (might be due to invalid IL or missing references)
		//IL_040d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0412: Unknown result type (might be due to invalid IL or missing references)
		//IL_0417: Unknown result type (might be due to invalid IL or missing references)
		//IL_0418: Unknown result type (might be due to invalid IL or missing references)
		//IL_041a: Unknown result type (might be due to invalid IL or missing references)
		//IL_042c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0431: Unknown result type (might be due to invalid IL or missing references)
		//IL_043b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0440: Unknown result type (might be due to invalid IL or missing references)
		//IL_0480: Unknown result type (might be due to invalid IL or missing references)
		//IL_048d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0493: Unknown result type (might be due to invalid IL or missing references)
		//IL_0495: Unknown result type (might be due to invalid IL or missing references)
		//IL_049a: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04db: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0504: Unknown result type (might be due to invalid IL or missing references)
		//IL_050d: Unknown result type (might be due to invalid IL or missing references)
		//IL_050f: Unknown result type (might be due to invalid IL or missing references)
		bool flag = !Main.npc[npcIndex].immortal;
		if (sItem.type == 3211)
		{
			Vector2 vector = default(Vector2);
			((Vector2)(ref vector))._002Ector((float)(direction * 100 + Main.rand.Next(-25, 26)), (float)Main.rand.Next(-75, 76));
			((Vector2)(ref vector)).Normalize();
			vector *= (float)Main.rand.Next(30, 41) * 0.1f;
			Vector2 vector2 = default(Vector2);
			((Vector2)(ref vector2))._002Ector((float)(itemRectangle.X + Main.rand.Next(itemRectangle.Width)), (float)(itemRectangle.Y + Main.rand.Next(itemRectangle.Height)));
			vector2 = (vector2 + Main.npc[npcIndex].Center * 2f) / 3f;
			Projectile.NewProjectile(GetProjectileSource_Item(sItem), vector2.X, vector2.Y, vector.X, vector.Y, 524, (int)((double)damage * 0.5), knockBack * 0.7f, whoAmI);
		}
		if (beetleOffense && flag)
		{
			beetleCounter += dmgDone;
			beetleCountdown = 0;
		}
		if (meleeEnchant == 7)
		{
			Projectile.NewProjectile(GetProjectileSource_Misc(8), Main.npc[npcIndex].Center.X, Main.npc[npcIndex].Center.Y, Main.npc[npcIndex].velocity.X, Main.npc[npcIndex].velocity.Y, 289, 0, 0f, whoAmI);
		}
		if (sItem.type == 3106)
		{
			stealth = 1f;
			if (Main.netMode == 1)
			{
				NetMessage.SendData(84, -1, -1, null, whoAmI);
			}
		}
		if (sItem.type == 5094)
		{
			TentacleSpike_TrySpiking(Main.npc[npcIndex], sItem, damage, knockBack);
		}
		if (sItem.type == 795)
		{
			BloodButcherer_TryButchering(Main.npc[npcIndex], sItem, damage, knockBack);
		}
		if (sItem.type == 121)
		{
			Volcano_TrySpawningVolcano(Main.npc[npcIndex], sItem, (int)((float)damage * 0.75f), knockBack, itemRectangle);
		}
		if (sItem.type == 5097)
		{
			BatBat_TryLifeLeeching(Main.npc[npcIndex]);
		}
		if (sItem.type == 1123 && flag)
		{
			int num = Main.rand.Next(1, 4);
			if (strongBees && Main.rand.Next(3) == 0)
			{
				num++;
			}
			for (int i = 0; i < num; i++)
			{
				float num4 = (float)(direction * 2) + (float)Main.rand.Next(-35, 36) * 0.02f;
				float num5 = (float)Main.rand.Next(-35, 36) * 0.02f;
				num4 *= 0.2f;
				num5 *= 0.2f;
				int num6 = Projectile.NewProjectile(GetProjectileSource_Item(sItem), itemRectangle.X + itemRectangle.Width / 2, itemRectangle.Y + itemRectangle.Height / 2, num4, num5, beeType(), beeDamage(dmgRandomized / 3), beeKB(0f), whoAmI);
				Main.projectile[num6].melee = true;
			}
		}
		if (sItem.type == 155 && flag && _spawnMuramasaCut)
		{
			_spawnMuramasaCut = false;
			int num7 = Main.rand.Next(1, 4);
			num7 = 1;
			for (int j = 0; j < num7; j++)
			{
				NPC nPC = Main.npc[npcIndex];
				Rectangle hitbox = nPC.Hitbox;
				((Rectangle)(ref hitbox)).Inflate(30, 16);
				hitbox.Y -= 8;
				Vector2 vector3 = Main.rand.NextVector2FromRectangle(hitbox);
				Vector2 val = ((Rectangle)(ref hitbox)).Center.ToVector2();
				Vector2 spinningpoint = (val - vector3).SafeNormalize(new Vector2((float)direction, gravDir)) * 8f;
				Main.rand.NextFloat();
				float num8 = (float)(Main.rand.Next(2) * 2 - 1) * ((float)Math.PI / 5f + (float)Math.PI * 4f / 5f * Main.rand.NextFloat());
				num8 *= 0.5f;
				spinningpoint = spinningpoint.RotatedBy(0.7853981852531433);
				int num9 = 3;
				int num10 = 10 * num9;
				int num11 = 5;
				int num2 = num11 * num9;
				vector3 = val;
				for (int k = 0; k < num2; k++)
				{
					vector3 -= spinningpoint;
					spinningpoint = spinningpoint.RotatedBy((0f - num8) / (float)num10);
				}
				vector3 += nPC.velocity * (float)num11;
				Projectile.NewProjectile(GetProjectileSource_Item(sItem), vector3, spinningpoint, 977, (int)((float)dmgRandomized * 0.5f), 0f, whoAmI, num8);
			}
		}
		if (Main.npc[npcIndex].value > 0f && hasLuckyCoin && Main.rand.Next(5) == 0)
		{
			int type = 71;
			if (Main.rand.Next(10) == 0)
			{
				type = 72;
			}
			if (Main.rand.Next(100) == 0)
			{
				type = 73;
			}
			int num3 = Item.NewItem(GetItemSource_OnHit(Main.npc[npcIndex], 2), (int)Main.npc[npcIndex].position.X, (int)Main.npc[npcIndex].position.Y, Main.npc[npcIndex].width, Main.npc[npcIndex].height, type);
			Main.item[num3].stack = Main.rand.Next(1, 11);
			Main.item[num3].velocity.Y = (float)Main.rand.Next(-20, 1) * 0.2f;
			Main.item[num3].velocity.X = (float)Main.rand.Next(10, 31) * 0.2f * (float)direction;
			Main.item[num3].timeLeftInWhichTheItemCannotBeTakenByEnemies = 60;
			if (Main.netMode == 1)
			{
				NetMessage.SendData(148, -1, -1, null, num3);
			}
		}
	}

	private void ItemCheck_EmitHammushProjectiles(int i, Item sItem, Rectangle itemRectangle, int damage)
	{
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		if (sItem.type != 787)
		{
			return;
		}
		int num = itemAnimationMax;
		if (itemAnimation != (int)((double)num * 0.1) && itemAnimation != (int)((double)num * 0.3) && itemAnimation != (int)((double)num * 0.5) && itemAnimation != (int)((double)num * 0.7) && itemAnimation != (int)((double)num * 0.9))
		{
			return;
		}
		float num2 = 0f;
		float num3 = 0f;
		float num4 = 0f;
		float num5 = 0f;
		if (itemAnimation == (int)((double)num * 0.9))
		{
			num2 = -7f;
		}
		if (itemAnimation == (int)((double)num * 0.7))
		{
			num2 = -6f;
			num3 = 2f;
		}
		if (itemAnimation == (int)((double)num * 0.5))
		{
			num2 = -4f;
			num3 = 4f;
		}
		if (itemAnimation == (int)((double)num * 0.3))
		{
			num2 = -2f;
			num3 = 6f;
		}
		if (itemAnimation == (int)((double)num * 0.1))
		{
			num3 = 7f;
		}
		if (itemAnimation == (int)((double)num * 0.7))
		{
			num5 = 26f;
		}
		if (itemAnimation == (int)((double)num * 0.3))
		{
			num5 -= 4f;
			num4 -= 20f;
		}
		if (itemAnimation == (int)((double)num * 0.1))
		{
			num4 += 6f;
		}
		if (direction == -1)
		{
			if (itemAnimation == (int)((double)num * 0.9))
			{
				num5 -= 8f;
			}
			if (itemAnimation == (int)((double)num * 0.7))
			{
				num5 -= 6f;
			}
		}
		num2 *= 1.5f;
		num3 *= 1.5f;
		num5 *= (float)direction;
		num4 *= gravDir;
		Projectile.NewProjectile(GetProjectileSource_Item(sItem), (float)(itemRectangle.X + itemRectangle.Width / 2) + num5, (float)(itemRectangle.Y + itemRectangle.Height / 2) + num4, (float)direction * num3, num2 * gravDir, 131, damage / 2, 0f, i);
	}

	private bool[] ItemCheck_GetTileCutIgnoreList(Item sItem)
	{
		bool allowRegrowth = false;
		int type = sItem.type;
		if (type == 213 || type == 5295)
		{
			allowRegrowth = true;
		}
		return GetTileCutIgnorance(allowRegrowth, fromTrap: false);
	}

	public bool[] GetTileCutIgnorance(bool allowRegrowth, bool fromTrap)
	{
		bool[] result = TileID.Sets.TileCutIgnore.None;
		if (allowRegrowth)
		{
			result = TileID.Sets.TileCutIgnore.Regrowth;
		}
		if (!fromTrap && dontHurtNature)
		{
			result = TileID.Sets.TileCutIgnore.IgnoreDontHurtNature;
		}
		return result;
	}

	private void ItemCheck_CutTiles(Item sItem, Rectangle itemRectangle, bool[] shouldIgnore)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		int minX = itemRectangle.X / 16;
		int maxX = (itemRectangle.X + itemRectangle.Width) / 16 + 1;
		int minY = itemRectangle.Y / 16;
		int maxY = (itemRectangle.Y + itemRectangle.Height) / 16 + 1;
		Utils.ClampWithinWorld(ref minX, ref minY, ref maxX, ref maxY);
		for (int i = minX; i < maxX; i++)
		{
			for (int j = minY; j < maxY; j++)
			{
				if (Main.tile[i, j] == null || !Main.tileCut[Main.tile[i, j].type] || shouldIgnore[Main.tile[i, j].type] || !WorldGen.CanCutTile(i, j, TileCuttingContext.AttackMelee))
				{
					continue;
				}
				if (sItem.type == 1786)
				{
					ushort type = Main.tile[i, j].type;
					WorldGen.KillTile(i, j);
					if (!Main.tile[i, j].active())
					{
						int num = 0;
						switch (type)
						{
						case 3:
						case 24:
						case 61:
						case 110:
						case 201:
						case 529:
						case 637:
							num = Main.rand.Next(1, 3);
							break;
						case 73:
						case 74:
						case 113:
							num = Main.rand.Next(2, 5);
							break;
						}
						if (num > 0)
						{
							int number = Item.NewItem(new EntitySource_ItemUse(this, sItem), i * 16, j * 16, 16, 16, 1727, num);
							if (Main.netMode == 1)
							{
								NetMessage.SendData(21, -1, -1, null, number, 1f);
							}
						}
					}
					if (Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 0, i, j);
					}
				}
				else
				{
					WorldGen.KillTile(i, j);
					if (Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 0, i, j);
					}
				}
			}
		}
	}

	private Rectangle ItemCheck_CatchCritters(Item sItem, Rectangle itemRectangle)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < 200; i++)
		{
			if (Main.npc[i].active && Main.npc[i].catchItem > 0)
			{
				NPC.CheckCatchNPC(Main.npc[i], itemRectangle, sItem, this, ItemID.Sets.LavaproofCatchingTool[sItem.type]);
			}
		}
		return itemRectangle;
	}

	private void GetPointOnSwungItemPath(float spriteWidth, float spriteHeight, float normalizedPointOnPath, float itemScale, out Vector2 location, out Vector2 outwardDirection)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		float num = (float)Math.Sqrt(spriteWidth * spriteWidth + spriteHeight * spriteHeight);
		float num2 = (float)(direction == 1).ToInt() * ((float)Math.PI / 2f);
		if (gravDir == -1f)
		{
			num2 += (float)Math.PI / 2f * (float)direction;
		}
		outwardDirection = itemRotation.ToRotationVector2().RotatedBy(3.926991f + num2);
		location = RotatedRelativePoint(itemLocation + outwardDirection * num * normalizedPointOnPath * itemScale);
	}

	private Rectangle ItemCheck_EmitUseVisuals(Item sItem, Rectangle itemRectangle)
	{
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_036d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0380: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		//IL_039f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0472: Unknown result type (might be due to invalid IL or missing references)
		//IL_0479: Unknown result type (might be due to invalid IL or missing references)
		//IL_0480: Unknown result type (might be due to invalid IL or missing references)
		//IL_0485: Unknown result type (might be due to invalid IL or missing references)
		//IL_048b: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_04aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03da: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_040c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0412: Unknown result type (might be due to invalid IL or missing references)
		//IL_056b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0572: Unknown result type (might be due to invalid IL or missing references)
		//IL_0579: Unknown result type (might be due to invalid IL or missing references)
		//IL_057e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0584: Unknown result type (might be due to invalid IL or missing references)
		//IL_05bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0502: Unknown result type (might be due to invalid IL or missing references)
		//IL_0508: Unknown result type (might be due to invalid IL or missing references)
		//IL_0521: Unknown result type (might be due to invalid IL or missing references)
		//IL_052b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0530: Unknown result type (might be due to invalid IL or missing references)
		//IL_053e: Unknown result type (might be due to invalid IL or missing references)
		//IL_054f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0554: Unknown result type (might be due to invalid IL or missing references)
		//IL_0559: Unknown result type (might be due to invalid IL or missing references)
		//IL_042c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0433: Unknown result type (might be due to invalid IL or missing references)
		//IL_043a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0441: Unknown result type (might be due to invalid IL or missing references)
		//IL_0447: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0602: Unknown result type (might be due to invalid IL or missing references)
		//IL_0609: Unknown result type (might be due to invalid IL or missing references)
		//IL_060e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0614: Unknown result type (might be due to invalid IL or missing references)
		//IL_064a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0650: Unknown result type (might be due to invalid IL or missing references)
		//IL_072d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0734: Unknown result type (might be due to invalid IL or missing references)
		//IL_073b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0740: Unknown result type (might be due to invalid IL or missing references)
		//IL_0746: Unknown result type (might be due to invalid IL or missing references)
		//IL_077d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0783: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_06dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0802: Unknown result type (might be due to invalid IL or missing references)
		//IL_0808: Unknown result type (might be due to invalid IL or missing references)
		//IL_082c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0836: Unknown result type (might be due to invalid IL or missing references)
		//IL_083b: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0900: Unknown result type (might be due to invalid IL or missing references)
		//IL_0905: Unknown result type (might be due to invalid IL or missing references)
		//IL_090b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0922: Unknown result type (might be due to invalid IL or missing references)
		//IL_0954: Unknown result type (might be due to invalid IL or missing references)
		//IL_0959: Unknown result type (might be due to invalid IL or missing references)
		//IL_0975: Unknown result type (might be due to invalid IL or missing references)
		//IL_097f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0984: Unknown result type (might be due to invalid IL or missing references)
		//IL_0860: Unknown result type (might be due to invalid IL or missing references)
		//IL_0867: Unknown result type (might be due to invalid IL or missing references)
		//IL_086e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0873: Unknown result type (might be due to invalid IL or missing references)
		//IL_0879: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_08db: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0996: Unknown result type (might be due to invalid IL or missing references)
		//IL_0997: Unknown result type (might be due to invalid IL or missing references)
		//IL_099c: Unknown result type (might be due to invalid IL or missing references)
		//IL_09a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_09d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_09ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_09f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_09fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a2d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a34: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a3b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a40: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a46: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a7e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a84: Unknown result type (might be due to invalid IL or missing references)
		//IL_0aa8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ab2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ab7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c91: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c98: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c9f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ca4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0caa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ce2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ce8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d65: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d6c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d73: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d78: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d7e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d97: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d9d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0db3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0dbd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0dc2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b15: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b2e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b34: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b36: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b3b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b3d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b40: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b47: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b55: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b5b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b89: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b90: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b97: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b9c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ba2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bdd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0be3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bf8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bfa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c28: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c32: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c37: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c45: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c4a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c51: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c56: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c5b: Unknown result type (might be due to invalid IL or missing references)
		//IL_19bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_19c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_1069: Unknown result type (might be due to invalid IL or missing references)
		//IL_1070: Unknown result type (might be due to invalid IL or missing references)
		//IL_1077: Unknown result type (might be due to invalid IL or missing references)
		//IL_107c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1082: Unknown result type (might be due to invalid IL or missing references)
		//IL_10bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_10c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_10e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_10f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_10f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1914: Unknown result type (might be due to invalid IL or missing references)
		//IL_191b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1922: Unknown result type (might be due to invalid IL or missing references)
		//IL_1927: Unknown result type (might be due to invalid IL or missing references)
		//IL_192d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1964: Unknown result type (might be due to invalid IL or missing references)
		//IL_196a: Unknown result type (might be due to invalid IL or missing references)
		//IL_115f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1166: Unknown result type (might be due to invalid IL or missing references)
		//IL_116d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1172: Unknown result type (might be due to invalid IL or missing references)
		//IL_1178: Unknown result type (might be due to invalid IL or missing references)
		//IL_1191: Unknown result type (might be due to invalid IL or missing references)
		//IL_1197: Unknown result type (might be due to invalid IL or missing references)
		//IL_11cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_11d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_11dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_1202: Unknown result type (might be due to invalid IL or missing references)
		//IL_1209: Unknown result type (might be due to invalid IL or missing references)
		//IL_1210: Unknown result type (might be due to invalid IL or missing references)
		//IL_1215: Unknown result type (might be due to invalid IL or missing references)
		//IL_121b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1253: Unknown result type (might be due to invalid IL or missing references)
		//IL_1259: Unknown result type (might be due to invalid IL or missing references)
		//IL_127d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1287: Unknown result type (might be due to invalid IL or missing references)
		//IL_128c: Unknown result type (might be due to invalid IL or missing references)
		//IL_12cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_12d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_12db: Unknown result type (might be due to invalid IL or missing references)
		//IL_12e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_12e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_131d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1323: Unknown result type (might be due to invalid IL or missing references)
		//IL_1347: Unknown result type (might be due to invalid IL or missing references)
		//IL_1351: Unknown result type (might be due to invalid IL or missing references)
		//IL_1356: Unknown result type (might be due to invalid IL or missing references)
		//IL_139a: Unknown result type (might be due to invalid IL or missing references)
		//IL_13a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_13a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_13ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_13b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_13eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_13f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1463: Unknown result type (might be due to invalid IL or missing references)
		//IL_146a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1471: Unknown result type (might be due to invalid IL or missing references)
		//IL_1476: Unknown result type (might be due to invalid IL or missing references)
		//IL_147c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1495: Unknown result type (might be due to invalid IL or missing references)
		//IL_149b: Unknown result type (might be due to invalid IL or missing references)
		//IL_150f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1516: Unknown result type (might be due to invalid IL or missing references)
		//IL_151d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1522: Unknown result type (might be due to invalid IL or missing references)
		//IL_1528: Unknown result type (might be due to invalid IL or missing references)
		//IL_1541: Unknown result type (might be due to invalid IL or missing references)
		//IL_1547: Unknown result type (might be due to invalid IL or missing references)
		//IL_15d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_15d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_15e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_15e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_15eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_160c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1612: Unknown result type (might be due to invalid IL or missing references)
		//IL_1859: Unknown result type (might be due to invalid IL or missing references)
		//IL_1860: Unknown result type (might be due to invalid IL or missing references)
		//IL_1867: Unknown result type (might be due to invalid IL or missing references)
		//IL_186c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1872: Unknown result type (might be due to invalid IL or missing references)
		//IL_1888: Unknown result type (might be due to invalid IL or missing references)
		//IL_188e: Unknown result type (might be due to invalid IL or missing references)
		//IL_18c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_18ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_18d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_172d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1734: Unknown result type (might be due to invalid IL or missing references)
		//IL_173b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1741: Unknown result type (might be due to invalid IL or missing references)
		if (sItem.type == 989 && Main.rand.Next(5) == 0)
		{
			int num30 = Main.rand.Next(3);
			int num = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, num30 switch
			{
				0 => 15, 
				1 => 57, 
				_ => 58, 
			}, direction * 2, 0f, 150, default(Color), 1.3f);
			Dust obj = Main.dust[num];
			obj.velocity *= 0.2f;
		}
		if (sItem.type == 2880 && Main.rand.Next(2) == 0)
		{
			int type2 = Utils.SelectRandom<int>(Main.rand, 226, 229);
			int num12 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, type2, direction * 2, 0f, 150);
			Dust obj2 = Main.dust[num12];
			obj2.velocity *= 0.2f;
			Main.dust[num12].noGravity = true;
		}
		if ((sItem.type == 44 || sItem.type == 45 || sItem.type == 103 || sItem.type == 104) && Main.rand.Next(15) == 0)
		{
			Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 14, direction * 2, 0f, 150, default(Color), 1.3f);
		}
		if (sItem.type == 46 && Main.rand.Next(15) == 0)
		{
			Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 14, direction * 2, 0f, 150, default(Color), 1.3f);
		}
		if (sItem.type == 273 || sItem.type == 675)
		{
			if (Main.rand.Next(5) == 0)
			{
				Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 14, direction * 2, 0f, 150, default(Color), 1.4f);
			}
			int num23 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 27, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 100, default(Color), 1.2f);
			Main.dust[num23].noGravity = true;
			Main.dust[num23].velocity.X /= 2f;
			Main.dust[num23].velocity.Y /= 2f;
		}
		if (sItem.type == 723 && Main.rand.Next(2) == 0)
		{
			int num24 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 64, 0f, 0f, 150, default(Color), 1.2f);
			Main.dust[num24].noGravity = true;
		}
		if (sItem.type == 65)
		{
			if (Main.rand.Next(5) == 0)
			{
				Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 58, 0f, 0f, 150, default(Color), 1.2f);
			}
			if (Main.rand.Next(10) == 0)
			{
				Gore.NewGore(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), default(Vector2), Main.rand.Next(16, 18));
			}
		}
		if (sItem.type == 3065)
		{
			int num25 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 58, 0f, 0f, 150, default(Color), 1.2f);
			Dust obj3 = Main.dust[num25];
			obj3.velocity *= 0.5f;
			if (Main.rand.Next(8) == 0)
			{
				int num26 = Gore.NewGore(new Vector2((float)((Rectangle)(ref itemRectangle)).Center.X, (float)((Rectangle)(ref itemRectangle)).Center.Y), default(Vector2), 16);
				Gore obj4 = Main.gore[num26];
				obj4.velocity *= 0.5f;
				Gore obj5 = Main.gore[num26];
				obj5.velocity += new Vector2((float)direction, 0f);
			}
		}
		if (sItem.type == 190)
		{
			int num27 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 40, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 0, default(Color), 1.2f);
			Main.dust[num27].noGravity = true;
		}
		else if (sItem.type == 213 || sItem.type == 5295)
		{
			int num28 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 3, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 0, default(Color), 1.2f);
			Main.dust[num28].noGravity = true;
		}
		if (sItem.type == 121)
		{
			for (int i = 0; i < 2; i++)
			{
				GetPointOnSwungItemPath(70f, 70f, 0.2f + 0.8f * Main.rand.NextFloat(), GetAdjustedItemScale(sItem), out var location, out var outwardDirection);
				Vector2 vector = outwardDirection.RotatedBy((float)Math.PI / 2f * (float)direction * gravDir);
				Dust.NewDustPerfect(location, 6, vector * 4f, 100, default(Color), 2.5f).noGravity = true;
			}
		}
		if (sItem.type == 122 || sItem.type == 217)
		{
			int num29 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 6, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 100, default(Color), 1.9f);
			Main.dust[num29].noGravity = true;
		}
		if (sItem.type == 155)
		{
			int num2 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 172, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 100, default(Color), 0.9f);
			Main.dust[num2].noGravity = true;
			Dust obj6 = Main.dust[num2];
			obj6.velocity *= 0.1f;
		}
		if (sItem.type == 676 && Main.rand.Next(3) == 0)
		{
			int num3 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 67, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 90, default(Color), 1.5f);
			Main.dust[num3].noGravity = true;
			Dust obj7 = Main.dust[num3];
			obj7.velocity *= 0.2f;
		}
		if (sItem.type == 3063)
		{
			int num4 = Dust.NewDust(itemRectangle.TopLeft(), itemRectangle.Width, itemRectangle.Height, 66, 0f, 0f, 150, Color.Transparent, 0.85f);
			Main.dust[num4].color = Main.hslToRgb(Main.rand.NextFloat(), 1f, 0.5f);
			Main.dust[num4].noGravity = true;
			Dust obj8 = Main.dust[num4];
			obj8.velocity /= 2f;
		}
		if (sItem.type == 3823)
		{
			Dust dust = Dust.NewDustDirect(itemRectangle.TopLeft(), itemRectangle.Width, itemRectangle.Height, 6, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 100, Color.Transparent, 0.7f);
			dust.noGravity = true;
			dust.velocity *= 2f;
			dust.fadeIn = 0.9f;
		}
		if (sItem.type == 724 && Main.rand.Next(5) == 0)
		{
			int num5 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 67, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 90, default(Color), 1.5f);
			Main.dust[num5].noGravity = true;
			Dust obj9 = Main.dust[num5];
			obj9.velocity *= 0.2f;
		}
		if (sItem.type >= 795 && sItem.type <= 802)
		{
			for (int j = 0; j < 2; j++)
			{
				GetPointOnSwungItemPath(60f, 60f, 0.2f + 0.8f * Main.rand.NextFloat(), GetAdjustedItemScale(sItem), out var location2, out var outwardDirection2);
				Vector2 vector2 = outwardDirection2.RotatedBy((float)Math.PI / 2f * (float)direction * gravDir);
				Dust.NewDustPerfect(location2, 5, vector2 * 2f, 100, default(Color), 0.7f + Main.rand.NextFloat() * 0.6f);
				if (Main.rand.Next(20) == 0)
				{
					int num6 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 115, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 140, default(Color), 0.7f);
					Main.dust[num6].position = location2;
					Main.dust[num6].fadeIn = 1.2f;
					Main.dust[num6].noGravity = true;
					Dust obj10 = Main.dust[num6];
					obj10.velocity *= 0.25f;
					Dust obj11 = Main.dust[num6];
					obj11.velocity += vector2 * 5f;
				}
			}
		}
		if (sItem.type == 367)
		{
			int num7 = 0;
			if (Main.rand.Next(3) == 0)
			{
				num7 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 57, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 100, default(Color), 1.1f);
				Main.dust[num7].noGravity = true;
				Main.dust[num7].velocity.X /= 2f;
				Main.dust[num7].velocity.Y /= 2f;
				Main.dust[num7].velocity.X += direction * 2;
			}
			if (Main.rand.Next(4) == 0)
			{
				num7 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 43, 0f, 0f, 254, default(Color), 0.3f);
				Dust obj12 = Main.dust[num7];
				obj12.velocity *= 0f;
			}
		}
		else if (sItem.type != 368)
		{
			_ = sItem.type;
		}
		if (sItem.type == 4258 || sItem.type == 4259 || (sItem.type >= 198 && sItem.type <= 203) || (sItem.type >= 3764 && sItem.type <= 3769))
		{
			float num8 = 0.5f;
			float num9 = 0.5f;
			float num10 = 0.5f;
			if (sItem.type == 198 || sItem.type == 3764)
			{
				num8 *= 0.1f;
				num9 *= 0.5f;
				num10 *= 1.2f;
			}
			else if (sItem.type == 199 || sItem.type == 3765)
			{
				num8 *= 1f;
				num9 *= 0.2f;
				num10 *= 0.1f;
			}
			else if (sItem.type == 200 || sItem.type == 3766)
			{
				num8 *= 0.1f;
				num9 *= 1f;
				num10 *= 0.2f;
			}
			else if (sItem.type == 201 || sItem.type == 3767)
			{
				num8 *= 0.8f;
				num9 *= 0.1f;
				num10 *= 1f;
			}
			else if (sItem.type == 202 || sItem.type == 3768)
			{
				num8 *= 0.8f;
				num9 *= 0.9f;
				num10 *= 1f;
			}
			else if (sItem.type == 203 || sItem.type == 3769)
			{
				num8 *= 0.8f;
				num9 *= 0.8f;
				num10 *= 0f;
			}
			else if (sItem.type == 4258 || sItem.type == 4259)
			{
				num8 *= 0.9f;
				num9 *= 0.5f;
				num10 *= 0f;
			}
			Lighting.AddLight((int)((itemLocation.X + 6f + velocity.X) / 16f), (int)((itemLocation.Y - 14f) / 16f), num8, num9, num10);
		}
		if (frostBurn && sItem.melee && !sItem.noMelee && !sItem.noUseGraphic && Main.rand.Next(2) == 0)
		{
			int num11 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 135, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 100, default(Color), 2.5f);
			Main.dust[num11].noGravity = true;
			Dust obj13 = Main.dust[num11];
			obj13.velocity *= 0.7f;
			Main.dust[num11].velocity.Y -= 0.5f;
		}
		if (sItem.melee && !sItem.noMelee && !sItem.noUseGraphic && meleeEnchant > 0)
		{
			if (meleeEnchant == 1)
			{
				if (Main.rand.Next(3) == 0)
				{
					int num13 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 171, 0f, 0f, 100);
					Main.dust[num13].noGravity = true;
					Main.dust[num13].fadeIn = 1.5f;
					Dust obj14 = Main.dust[num13];
					obj14.velocity *= 0.25f;
				}
			}
			else if (meleeEnchant == 2)
			{
				if (Main.rand.Next(2) == 0)
				{
					int num14 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 75, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 100, default(Color), 2.5f);
					Main.dust[num14].noGravity = true;
					Dust obj15 = Main.dust[num14];
					obj15.velocity *= 0.7f;
					Main.dust[num14].velocity.Y -= 0.5f;
				}
			}
			else if (meleeEnchant == 3)
			{
				if (Main.rand.Next(2) == 0)
				{
					int num15 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 6, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 100, default(Color), 2.5f);
					Main.dust[num15].noGravity = true;
					Dust obj16 = Main.dust[num15];
					obj16.velocity *= 0.7f;
					Main.dust[num15].velocity.Y -= 0.5f;
				}
			}
			else if (meleeEnchant == 4)
			{
				int num16 = 0;
				if (Main.rand.Next(2) == 0)
				{
					num16 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 57, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 100, default(Color), 1.1f);
					Main.dust[num16].noGravity = true;
					Main.dust[num16].velocity.X /= 2f;
					Main.dust[num16].velocity.Y /= 2f;
				}
			}
			else if (meleeEnchant == 5)
			{
				if (Main.rand.Next(2) == 0)
				{
					int num17 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 169, 0f, 0f, 100);
					Main.dust[num17].velocity.X += direction;
					Main.dust[num17].velocity.Y += 0.2f;
					Main.dust[num17].noGravity = true;
				}
			}
			else if (meleeEnchant == 6)
			{
				if (Main.rand.Next(2) == 0)
				{
					int num18 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 135, 0f, 0f, 100);
					Main.dust[num18].velocity.X += direction;
					Main.dust[num18].velocity.Y += 0.2f;
					Main.dust[num18].noGravity = true;
				}
			}
			else if (meleeEnchant == 7)
			{
				if (Main.rand.Next(20) == 0)
				{
					int type3 = Main.rand.Next(139, 143);
					int num19 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, type3, velocity.X, velocity.Y, 0, default(Color), 1.2f);
					Main.dust[num19].velocity.X *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
					Main.dust[num19].velocity.Y *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
					Main.dust[num19].velocity.X += (float)Main.rand.Next(-50, 51) * 0.05f;
					Main.dust[num19].velocity.Y += (float)Main.rand.Next(-50, 51) * 0.05f;
					Main.dust[num19].scale *= 1f + (float)Main.rand.Next(-30, 31) * 0.01f;
				}
				if (Main.rand.Next(40) == 0)
				{
					int type4 = Main.rand.Next(276, 283);
					int num20 = Gore.NewGore(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), velocity, type4);
					Main.gore[num20].velocity.X *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
					Main.gore[num20].velocity.Y *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
					Main.gore[num20].scale *= 1f + (float)Main.rand.Next(-20, 21) * 0.01f;
					Main.gore[num20].velocity.X += (float)Main.rand.Next(-50, 51) * 0.05f;
					Main.gore[num20].velocity.Y += (float)Main.rand.Next(-50, 51) * 0.05f;
				}
			}
			else if (meleeEnchant == 8 && Main.rand.Next(4) == 0)
			{
				int num21 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 46, 0f, 0f, 100);
				Main.dust[num21].noGravity = true;
				Main.dust[num21].fadeIn = 1.5f;
				Dust obj17 = Main.dust[num21];
				obj17.velocity *= 0.25f;
			}
		}
		if (magmaStone && sItem.melee && !sItem.noMelee && !sItem.noUseGraphic && Main.rand.Next(3) != 0)
		{
			int num22 = Dust.NewDust(new Vector2((float)itemRectangle.X, (float)itemRectangle.Y), itemRectangle.Width, itemRectangle.Height, 6, velocity.X * 0.2f + (float)(direction * 3), velocity.Y * 0.2f, 100, default(Color), 2.5f);
			Main.dust[num22].noGravity = true;
			Main.dust[num22].velocity.X *= 2f;
			Main.dust[num22].velocity.Y *= 2f;
		}
		CombinedHooks.MeleeEffects(this, sItem, itemRectangle);
		return itemRectangle;
	}

	private void ItemCheck_GetMeleeHitbox(Item sItem, Rectangle heldItemFrame, out bool dontAttack, out Rectangle itemRectangle)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0598: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_05bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0434: Unknown result type (might be due to invalid IL or missing references)
		//IL_043b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0441: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_05db: Unknown result type (might be due to invalid IL or missing references)
		//IL_05eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0605: Unknown result type (might be due to invalid IL or missing references)
		//IL_0607: Unknown result type (might be due to invalid IL or missing references)
		//IL_0611: Unknown result type (might be due to invalid IL or missing references)
		//IL_0616: Unknown result type (might be due to invalid IL or missing references)
		//IL_062e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0634: Unknown result type (might be due to invalid IL or missing references)
		//IL_0649: Unknown result type (might be due to invalid IL or missing references)
		//IL_064b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0668: Unknown result type (might be due to invalid IL or missing references)
		//IL_066d: Unknown result type (might be due to invalid IL or missing references)
		//IL_047b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0482: Unknown result type (might be due to invalid IL or missing references)
		//IL_0488: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0505: Unknown result type (might be due to invalid IL or missing references)
		//IL_050c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0512: Unknown result type (might be due to invalid IL or missing references)
		dontAttack = false;
		itemRectangle = new Rectangle((int)itemLocation.X, (int)itemLocation.Y, 32, 32);
		if (!Main.dedServ)
		{
			int num = heldItemFrame.Width;
			int num2 = heldItemFrame.Height;
			switch (sItem.type)
			{
			case 5094:
				num -= 10;
				num2 -= 10;
				break;
			case 5095:
				num -= 10;
				num2 -= 10;
				break;
			case 5096:
				num -= 12;
				num2 -= 12;
				break;
			case 5097:
				num -= 8;
				num2 -= 8;
				break;
			}
			itemRectangle = new Rectangle((int)itemLocation.X, (int)itemLocation.Y, num, num2);
		}
		float adjustedItemScale = GetAdjustedItemScale(sItem);
		itemRectangle.Width = (int)((float)itemRectangle.Width * adjustedItemScale);
		itemRectangle.Height = (int)((float)itemRectangle.Height * adjustedItemScale);
		if (direction == -1)
		{
			itemRectangle.X -= itemRectangle.Width;
		}
		if (gravDir == 1f)
		{
			itemRectangle.Y -= itemRectangle.Height;
		}
		if (sItem.useStyle == 1)
		{
			if ((double)itemAnimation < (double)itemAnimationMax * 0.333)
			{
				if (direction == -1)
				{
					itemRectangle.X -= (int)((double)itemRectangle.Width * 1.4 - (double)itemRectangle.Width);
				}
				itemRectangle.Width = (int)((double)itemRectangle.Width * 1.4);
				itemRectangle.Y += (int)((double)itemRectangle.Height * 0.5 * (double)gravDir);
				itemRectangle.Height = (int)((double)itemRectangle.Height * 1.1);
			}
			else if (!((double)itemAnimation < (double)itemAnimationMax * 0.666))
			{
				if (direction == 1)
				{
					itemRectangle.X -= (int)((double)itemRectangle.Width * 1.2);
				}
				itemRectangle.Width *= 2;
				itemRectangle.Y -= (int)(((double)itemRectangle.Height * 1.4 - (double)itemRectangle.Height) * (double)gravDir);
				itemRectangle.Height = (int)((double)itemRectangle.Height * 1.4);
			}
		}
		else if (sItem.useStyle == 3)
		{
			if ((double)itemAnimation > (double)itemAnimationMax * 0.666)
			{
				dontAttack = true;
			}
			else
			{
				if (direction == -1)
				{
					itemRectangle.X -= (int)((double)itemRectangle.Width * 1.4 - (double)itemRectangle.Width);
				}
				itemRectangle.Width = (int)((double)itemRectangle.Width * 1.4);
				itemRectangle.Y += (int)((double)itemRectangle.Height * 0.6);
				itemRectangle.Height = (int)((double)itemRectangle.Height * 0.6);
				if (sItem.type == 946 || sItem.type == 4707)
				{
					itemRectangle.Height += 14;
					itemRectangle.Width -= 10;
					if (direction == -1)
					{
						itemRectangle.X += 10;
					}
				}
			}
		}
		ItemLoader.UseItemHitbox(sItem, this, ref itemRectangle, ref dontAttack);
		if (sItem.type == 1450 && Main.rand.Next(3) == 0)
		{
			int num3 = -1;
			float x = itemRectangle.X + Main.rand.Next(itemRectangle.Width);
			float y = itemRectangle.Y + Main.rand.Next(itemRectangle.Height);
			if (Main.rand.Next(500) == 0)
			{
				num3 = Gore.NewGore(new Vector2(x, y), default(Vector2), 415, (float)Main.rand.Next(51, 101) * 0.01f);
			}
			else if (Main.rand.Next(250) == 0)
			{
				num3 = Gore.NewGore(new Vector2(x, y), default(Vector2), 414, (float)Main.rand.Next(51, 101) * 0.01f);
			}
			else if (Main.rand.Next(80) == 0)
			{
				num3 = Gore.NewGore(new Vector2(x, y), default(Vector2), 413, (float)Main.rand.Next(51, 101) * 0.01f);
			}
			else if (Main.rand.Next(10) == 0)
			{
				num3 = Gore.NewGore(new Vector2(x, y), default(Vector2), 412, (float)Main.rand.Next(51, 101) * 0.01f);
			}
			else if (Main.rand.Next(3) == 0)
			{
				num3 = Gore.NewGore(new Vector2(x, y), default(Vector2), 411, (float)Main.rand.Next(51, 101) * 0.01f);
			}
			if (num3 >= 0)
			{
				Main.gore[num3].velocity.X += direction * 2;
				Main.gore[num3].velocity.Y *= 0.3f;
			}
		}
		if (sItem.type == 3542)
		{
			dontAttack = true;
		}
		if (sItem.type == 3779)
		{
			dontAttack = true;
			Vector2 vector = itemLocation + new Vector2((float)(direction * 30), -8f);
			Vector2 vector2 = vector - position;
			for (float num4 = 0f; num4 < 1f; num4 += 0.2f)
			{
				Vector2 vector3 = Vector2.Lerp(oldPosition + vector2 + new Vector2(0f, gfxOffY), vector, num4);
				Dust obj = Main.dust[Dust.NewDust(vector - Vector2.One * 8f, 16, 16, 27, 0f, -2f)];
				obj.noGravity = true;
				obj.position = vector3;
				obj.velocity = new Vector2(0f, (0f - gravDir) * 2f);
				obj.scale = 1.2f;
				obj.alpha = 200;
			}
		}
	}

	private void ItemCheck_UseDemonHeart(Item sItem)
	{
		if (sItem.type == 3335 && itemAnimation > 0 && !extraAccessory && Main.expertMode && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			extraAccessory = true;
			NetMessage.SendData(4, -1, -1, null, whoAmI);
		}
	}

	private void ItemCheck_UseMinecartPowerUp(Item sItem)
	{
		if (sItem.type == 5289 && itemAnimation > 0 && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			if (!unlockedSuperCart)
			{
				unlockedSuperCart = true;
				NetMessage.SendData(4, -1, -1, null, whoAmI);
			}
			QuickSpawnItem(GetItemSource_OpenItem(5289), 3353);
		}
	}

	private void ItemCheck_UseArtisanLoaf(Item sItem)
	{
		if (sItem.type == 5326 && itemAnimation > 0 && !ateArtisanBread && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			ateArtisanBread = true;
			NetMessage.SendData(4, -1, -1, null, whoAmI);
		}
	}

	private void ItemCheck_UseTorchGodsFavor(Item sItem)
	{
		if (sItem.type == 5043 && itemAnimation > 0 && !unlockedBiomeTorches && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			unlockedBiomeTorches = true;
			UsingBiomeTorches = true;
			AchievementsHelper.HandleSpecialEvent(this, 24);
			if (Main.netMode == 0)
			{
				NPC nPC = new NPC();
				nPC.SetDefaults(664);
				Main.BestiaryTracker.Kills.RegisterKill(nPC);
			}
			NetMessage.SendData(4, -1, -1, null, whoAmI);
			NetMessage.SendData(51, -1, -1, null, whoAmI, 5f);
		}
	}

	private void ItemCheck_TryDestroyingDrones(Item sItem)
	{
		if (sItem.type != 5451 || ownedProjectileCounts[1020] <= 0 || !controlUseItem || !ItemTimeIsZero || mouseInterface)
		{
			return;
		}
		for (int i = 0; i < 1000; i++)
		{
			Projectile projectile = Main.projectile[i];
			if (projectile.owner == whoAmI && projectile.type == 1020)
			{
				projectile.Kill();
			}
		}
		releaseUseItem = false;
	}

	public void UseManaMaxIncreasingItem(int increase)
	{
		if (increase < 0)
		{
			increase = 0;
		}
		statManaMax += increase;
		statManaMax2 += increase;
		statMana += increase;
		if (Main.myPlayer == whoAmI)
		{
			ManaEffect(increase);
		}
	}

	private void ItemCheck_UseManaCrystal(Item sItem)
	{
		if (sItem.type == 109 && itemAnimation > 0 && ConsumedManaCrystals < 9 && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			UseManaMaxIncreasingItem(20);
			ConsumedManaCrystals++;
			AchievementsHelper.HandleSpecialEvent(this, 1);
		}
	}

	public void UseHealthMaxIncreasingItem(int increase)
	{
		if (increase < 0)
		{
			increase = 0;
		}
		statLifeMax += increase;
		statLifeMax2 += increase;
		statLife += increase;
		if (Main.myPlayer == whoAmI)
		{
			HealEffect(increase);
		}
	}

	private void ItemCheck_UseLifeFruit(Item sItem)
	{
		if (sItem.type == 1291 && itemAnimation > 0 && ConsumedLifeCrystals == 15 && ConsumedLifeFruit < 20 && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			UseHealthMaxIncreasingItem(5);
			ConsumedLifeFruit++;
			AchievementsHelper.HandleSpecialEvent(this, 2);
		}
	}

	private void ItemCheck_UseLifeCrystal(Item sItem)
	{
		if (sItem.type == 29 && itemAnimation > 0 && ConsumedLifeCrystals < 15 && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			UseHealthMaxIncreasingItem(20);
			ConsumedLifeCrystals++;
			AchievementsHelper.HandleSpecialEvent(this, 0);
		}
	}

	private void ItemCheck_UseCombatBook(Item sItem)
	{
		if (!NPC.combatBookWasUsed && sItem.type == 4382 && itemAnimation > 0 && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			if (Main.netMode == 0)
			{
				NPC.combatBookWasUsed = true;
				Main.NewText(Language.GetTextValue("Misc.CombatBookUsed"), 50, byte.MaxValue, 130);
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, -11f);
			}
		}
		if (!NPC.combatBookVolumeTwoWasUsed && sItem.type == 5336 && itemAnimation > 0 && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			if (Main.netMode == 0)
			{
				NPC.combatBookVolumeTwoWasUsed = true;
				Main.NewText(Language.GetTextValue("Misc.CombatBookVolumeTwoUsed"), 50, byte.MaxValue, 130);
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, -17f);
			}
		}
	}

	private void ItemCheck_UsePetLicenses(Item sItem)
	{
		if (sItem.type == 4829 && itemAnimation > 0)
		{
			LicenseOrExchangePet(sItem, ref NPC.boughtCat, 637, "Misc.LicenseCatUsed", -12);
		}
		if (sItem.type == 4830 && itemAnimation > 0)
		{
			LicenseOrExchangePet(sItem, ref NPC.boughtDog, 638, "Misc.LicenseDogUsed", -13);
		}
		if (sItem.type == 4910 && itemAnimation > 0)
		{
			LicenseOrExchangePet(sItem, ref NPC.boughtBunny, 656, "Misc.LicenseBunnyUsed", -14);
		}
	}

	private void ItemCheck_UsePeddlersSatchel(Item sItem)
	{
		if (!NPC.peddlersSatchelWasUsed && sItem.type == 5343 && itemAnimation > 0 && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			if (Main.netMode == 0)
			{
				NPC.peddlersSatchelWasUsed = true;
				Main.NewText(Language.GetTextValue("Misc.PeddlersSatchelUsed"), 50, byte.MaxValue, 130);
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, -18f);
			}
		}
	}

	private void ItemCheck_UseShimmerPermanentItems(Item sItem)
	{
		if (sItem.type == 5337 && itemAnimation > 0 && !usedAegisCrystal && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			usedAegisCrystal = true;
			NetMessage.SendData(4, -1, -1, null, whoAmI);
		}
		if (sItem.type == 5338 && itemAnimation > 0 && !usedAegisFruit && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			usedAegisFruit = true;
			NetMessage.SendData(4, -1, -1, null, whoAmI);
		}
		if (sItem.type == 5339 && itemAnimation > 0 && !usedArcaneCrystal && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			usedArcaneCrystal = true;
			NetMessage.SendData(4, -1, -1, null, whoAmI);
		}
		if (sItem.type == 5340 && itemAnimation > 0 && !usedGalaxyPearl && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			usedGalaxyPearl = true;
			NetMessage.SendData(4, -1, -1, null, whoAmI);
		}
		if (sItem.type == 5341 && itemAnimation > 0 && !usedGummyWorm && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			usedGummyWorm = true;
			NetMessage.SendData(4, -1, -1, null, whoAmI);
		}
		if (sItem.type == 5342 && itemAnimation > 0 && !usedAmbrosia && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			usedAmbrosia = true;
			NetMessage.SendData(4, -1, -1, null, whoAmI);
		}
	}

	private void LicenseOrExchangePet(Item sItem, ref bool petBoughtFlag, int npcType, string textKeyForLicense, int netMessageData)
	{
		if (ItemTimeIsZero && (!petBoughtFlag || NPC.AnyNPCs(npcType)))
		{
			ApplyItemTime(sItem);
			NPC.UnlockOrExchangePet(ref petBoughtFlag, npcType, textKeyForLicense, netMessageData);
		}
	}

	public void LimitPointToPlayerReachableArea(ref Vector2 pointPoisition)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		Vector2 center = base.Center;
		Vector2 val = pointPoisition - center;
		float num = Math.Abs(val.X);
		float num2 = Math.Abs(val.Y);
		float num3 = 1f;
		if (num > 960f)
		{
			float num4 = 960f / num;
			if (num3 > num4)
			{
				num3 = num4;
			}
		}
		if (num2 > 600f)
		{
			float num5 = 600f / num2;
			if (num3 > num5)
			{
				num3 = num5;
			}
		}
		Vector2 vector2 = val * num3;
		pointPoisition = center + vector2;
	}

	private void ItemCheck_UseTeleportRod(Item sItem)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		if (Main.myPlayer != whoAmI || (sItem.type != 1326 && sItem.type != 5335) || itemAnimation <= 0 || !ItemTimeIsZero)
		{
			return;
		}
		ApplyItemTime(sItem);
		Vector2 pointPoisition = default(Vector2);
		pointPoisition.X = (float)Main.mouseX + Main.screenPosition.X;
		if (gravDir == 1f)
		{
			pointPoisition.Y = (float)Main.mouseY + Main.screenPosition.Y - (float)height;
		}
		else
		{
			pointPoisition.Y = Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY;
		}
		pointPoisition.X -= width / 2;
		LimitPointToPlayerReachableArea(ref pointPoisition);
		if (!(pointPoisition.X > 50f) || !(pointPoisition.X < (float)(Main.maxTilesX * 16 - 50)) || !(pointPoisition.Y > 50f) || !(pointPoisition.Y < (float)(Main.maxTilesY * 16 - 50)))
		{
			return;
		}
		int num = (int)(pointPoisition.X / 16f);
		int num2 = (int)(pointPoisition.Y / 16f);
		if ((Main.tile[num, num2].wall == 87 && !NPC.downedPlantBoss && (Main.remixWorld || (double)num2 > Main.worldSurface)) || Collision.SolidCollision(pointPoisition, width, height))
		{
			return;
		}
		Teleport(pointPoisition, 1);
		NetMessage.SendData(65, -1, -1, null, 0, whoAmI, pointPoisition.X, pointPoisition.Y, 1);
		if (sItem.type != 1326)
		{
			return;
		}
		if (chaosState)
		{
			statLife -= statLifeMax2 / 7;
			PlayerDeathReason damageSource = PlayerDeathReason.ByOther(13);
			if (Main.rand.Next(2) == 0)
			{
				damageSource = PlayerDeathReason.ByOther(Male ? 14 : 15);
			}
			if (statLife <= 0)
			{
				KillMe(damageSource, 1.0, 0);
			}
			lifeRegenCount = 0;
			lifeRegenTime = 0f;
		}
		AddBuff(88, 360);
	}

	private bool IsTilePoundable(Tile targetTile)
	{
		if (!Main.tileHammer[targetTile.type] && !Main.tileSolid[targetTile.type] && targetTile.type != 314 && targetTile.type != 424 && targetTile.type != 442)
		{
			return targetTile.type != 351;
		}
		return false;
	}

	private void UseShovel(Player user, Item item, int sX, int sY)
	{
		for (int i = sX - 1; i <= sX + 1; i++)
		{
			for (int j = sY - 1; j <= sY + 1; j++)
			{
				DamageTileWithShovel(user, item, i, j);
			}
		}
		ApplyItemTime(item, pickSpeed);
	}

	private void DamageTileWithShovel(Player user, Item item, int x, int y)
	{
		Tile tileSafely = Framing.GetTileSafely(x, y);
		if (TileID.Sets.CanBeDugByShovel[tileSafely.type])
		{
			int pickPower = 30;
			if (tileSafely.active() && (TileID.Sets.Conversion.Grass[tileSafely.type] || TileID.Sets.Conversion.JungleGrass[tileSafely.type] || tileSafely.type == 70 || tileSafely.type == 633))
			{
				PickTile(x, y, 100);
			}
			PickTile(x, y, pickPower);
		}
	}

	private void ItemCheck_UseMiningTools(Item sItem)
	{
		SpecialToolUsageSettings specialToolUsageSettings = default(SpecialToolUsageSettings);
		if (sItem.type == 4711)
		{
			SpecialToolUsageSettings specialToolUsageSettings2 = default(SpecialToolUsageSettings);
			specialToolUsageSettings2.IsAValidTool = true;
			specialToolUsageSettings2.UsageAction = UseShovel;
			specialToolUsageSettings = specialToolUsageSettings2;
		}
		if (sItem.pick <= 0 && sItem.axe <= 0 && sItem.hammer <= 0 && !specialToolUsageSettings.IsAValidTool)
		{
			return;
		}
		bool flag = IsTargetTileInItemRange(sItem);
		if (noBuilding)
		{
			flag = false;
		}
		if (flag && specialToolUsageSettings.UsageCondition != null)
		{
			flag = specialToolUsageSettings.UsageCondition(this, sItem, tileTargetX, tileTargetY);
		}
		if (toolTime == 0 && itemAnimation > 0 && controlUseItem)
		{
			Tile tile = Main.tile[tileTargetX, tileTargetY];
			if (!tile.active() || (IsTilePoundable(tile) && !TileID.Sets.CanBeSloped[tile.type]))
			{
				poundRelease = false;
			}
		}
		if (!flag)
		{
			return;
		}
		if (!Main.GamepadDisableCursorItemIcon)
		{
			cursorItemIconEnabled = true;
			Main.ItemIconCacheUpdate(sItem.type);
		}
		bool canHitWalls = false;
		if (toolTime == 0 && itemAnimation > 0 && controlUseItem)
		{
			if (specialToolUsageSettings.UsageAction != null)
			{
				specialToolUsageSettings.UsageAction(this, sItem, tileTargetX, tileTargetY);
				return;
			}
			ItemCheck_UseMiningTools_ActuallyUseMiningTool(sItem, out canHitWalls, tileTargetX, tileTargetY);
		}
		if (releaseUseItem)
		{
			poundRelease = true;
		}
		if (toolTime == 0 && itemAnimation > 0 && controlUseItem && canHitWalls)
		{
			ItemCheck_UseMiningTools_TryFindingWallToHammer(out var wX, out var wY);
			ItemCheck_UseMiningTools_TryHittingWall(sItem, wX, wY);
		}
	}

	private void ItemCheck_UseMiningTools_ActuallyUseMiningTool(Item sItem, out bool canHitWalls, int x, int y)
	{
		//IL_038f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0368: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		int num = -1;
		int num2 = 0;
		canHitWalls = true;
		Tile tile = Main.tile[x, y];
		if (!tile.active())
		{
			return;
		}
		if ((sItem.pick > 0 && !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type]) || (sItem.axe > 0 && Main.tileAxe[tile.type]) || (sItem.hammer > 0 && Main.tileHammer[tile.type]))
		{
			canHitWalls = false;
		}
		num = hitTile.HitObject(x, y, 1);
		if (Main.tileNoFail[tile.type])
		{
			num2 = 100;
		}
		if (Main.tileHammer[tile.type])
		{
			canHitWalls = false;
			if (sItem.hammer > 0)
			{
				ModTile modTile = TileLoader.GetTile(tile.type);
				num2 = ((modTile == null) ? (num2 + sItem.hammer) : (num2 + (int)((float)sItem.hammer / modTile.MineResist)));
				if (!WorldGen.CanKillTile(x, y))
				{
					num2 = 0;
				}
				if (tile.type == 26 && (sItem.hammer < 80 || !Main.hardMode))
				{
					num2 = 0;
					Hurt(PlayerDeathReason.ByOther(4), statLife / 2, -direction);
				}
				AchievementsHelper.CurrentlyMining = true;
				if (hitTile.AddDamage(num, num2) >= 100)
				{
					ClearMiningCacheAt(x, y, 1);
					WorldGen.KillTile(x, y);
					if (Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 0, x, y);
					}
				}
				else
				{
					WorldGen.KillTile(x, y, fail: true);
					if (Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 0, x, y, 1f);
					}
				}
				if (num2 != 0)
				{
					hitTile.Prune();
				}
				ApplyItemTime(sItem);
				AchievementsHelper.CurrentlyMining = false;
			}
		}
		else if (Main.tileAxe[tile.type])
		{
			ModTile modTile2 = TileLoader.GetTile(tile.type);
			if (modTile2 != null)
			{
				num2 += (int)((float)sItem.axe / modTile2.MineResist);
			}
			else
			{
				num2 = ((tile.type != 80) ? (num2 + (int)((float)sItem.axe * 1.2f)) : (num2 + (int)((float)(sItem.axe * 3) * 1.2f)));
				if (Main.getGoodWorld)
				{
					num2 = (int)((double)num2 * 1.3);
				}
			}
			if (sItem.axe > 0)
			{
				AchievementsHelper.CurrentlyMining = true;
				if (!WorldGen.CanKillTile(x, y))
				{
					num2 = 0;
				}
				if (Main.dontStarveWorld && Main.myPlayer == whoAmI && num2 > 0 && tile.type == 80)
				{
					Hurt(PlayerDeathReason.ByOther(3), Main.DamageVar(6f, luck), 0, pvp: false, quiet: false, Crit: false, 0);
				}
				if (hitTile.AddDamage(num, num2) >= 100)
				{
					if (whoAmI == Main.myPlayer && sItem.type == 5095 && (TileID.Sets.IsATreeTrunk[tile.type] || tile.type == 323 || tile.type == 80))
					{
						LucyAxeMessage.MessageSource source = LucyAxeMessage.MessageSource.ChoppedTree;
						if (TileID.Sets.CountsAsGemTree[tile.type])
						{
							source = LucyAxeMessage.MessageSource.ChoppedGemTree;
						}
						if (tile.type == 80)
						{
							source = LucyAxeMessage.MessageSource.ChoppedCactus;
							LucyAxeMessage.TryCreatingMessageWithCooldown(source, base.Top, new Vector2((float)(direction * 7), -7f), 420);
						}
						else
						{
							LucyAxeMessage.Create(source, base.Top, new Vector2((float)(direction * 7), -7f));
						}
					}
					ClearMiningCacheAt(x, y, 1);
					bool flag = IsBottomOfTreeTrunkNoRoots(x, y);
					WorldGen.KillTile(x, y);
					if (Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 0, x, y);
					}
					if (sItem.type == 5295 && flag)
					{
						TryReplantingTree(x, y);
					}
				}
				else
				{
					WorldGen.KillTile(x, y, fail: true);
					if (Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 0, x, y, 1f);
					}
				}
				if (num2 != 0)
				{
					hitTile.Prune();
				}
				ApplyItemTime(sItem);
				AchievementsHelper.CurrentlyMining = false;
			}
		}
		else if (sItem.pick > 0)
		{
			PickTile(x, y, sItem.pick);
		}
		if (sItem.pick > 0)
		{
			ApplyItemTime(sItem, pickSpeed);
		}
		ItemCheck_UseMiningTools_TryPoundingTile(sItem, num, ref canHitWalls, x, y);
	}

	private bool IsBottomOfTreeTrunkNoRoots(int x, int y)
	{
		Tile tile = Main.tile[x, y];
		if (!tile.active())
		{
			return false;
		}
		if (!TileID.Sets.IsATreeTrunk[tile.type] && tile.type != 323)
		{
			return false;
		}
		short frameX = tile.frameX;
		short frameY = tile.frameY;
		if (tile.type != 323 && frameY >= 132 && frameY <= 176 && (frameX == 22 || frameX == 44))
		{
			return false;
		}
		return true;
	}

	private void TryReplantingTree(int x, int y)
	{
		int type = 20;
		int style = 0;
		PlantLoader.CheckAndInjectModSapling(x, y, ref type, ref style);
		if (!TileObject.CanPlace(tileTargetX, tileTargetY, type, style, direction, out var objectData))
		{
			return;
		}
		bool num = TileObject.Place(objectData);
		WorldGen.SquareTileFrame(tileTargetX, tileTargetY);
		if (num)
		{
			TileObjectData.CallPostPlacementPlayerHook(tileTargetX, tileTargetY, type, style, direction, objectData.alternate, objectData);
			if (Main.netMode == 1)
			{
				NetMessage.SendObjectPlacement(-1, tileTargetX, tileTargetY, objectData.type, objectData.style, objectData.alternate, objectData.random, direction);
			}
		}
	}

	private static void ItemCheck_UseMiningTools_TryFindingWallToHammer(out int wX, out int wY)
	{
		wX = tileTargetX;
		wY = tileTargetY;
		bool flag = true;
		if (Main.tile[wX, wY].wall > 0)
		{
			if (!Main.wallHouse[Main.tile[wX, wY].wall])
			{
				for (int i = wX - 1; i < wX + 2; i++)
				{
					for (int j = wY - 1; j < wY + 2; j++)
					{
						if (Main.tile[i, j].wall != Main.tile[wX, wY].wall)
						{
							flag = false;
							break;
						}
					}
				}
			}
			else
			{
				flag = false;
			}
		}
		if (!flag || Main.tile[wX, wY].active())
		{
			return;
		}
		int num = -1;
		if ((double)(((float)Main.mouseX + Main.screenPosition.X) / 16f) < Math.Round(((float)Main.mouseX + Main.screenPosition.X) / 16f))
		{
			num = 0;
		}
		int num2 = -1;
		if ((double)(((float)Main.mouseY + Main.screenPosition.Y) / 16f) < Math.Round(((float)Main.mouseY + Main.screenPosition.Y) / 16f))
		{
			num2 = 0;
		}
		for (int k = tileTargetX + num; k <= tileTargetX + num + 1; k++)
		{
			for (int l = tileTargetY + num2; l <= tileTargetY + num2 + 1; l++)
			{
				if (!flag)
				{
					continue;
				}
				wX = k;
				wY = l;
				if (Main.tile[wX, wY].wall <= 0)
				{
					continue;
				}
				if (!Main.wallHouse[Main.tile[wX, wY].wall])
				{
					for (int m = wX - 1; m < wX + 2; m++)
					{
						for (int n = wY - 1; n < wY + 2; n++)
						{
							if (Main.tile[m, n].wall != Main.tile[wX, wY].wall)
							{
								flag = false;
								break;
							}
						}
					}
				}
				else
				{
					flag = false;
				}
			}
		}
	}

	private void ItemCheck_UseMiningTools_TryHittingWall(Item sItem, int wX, int wY)
	{
		if (Main.tile[wX, wY].wall > 0 && (!Main.tile[wX, wY].active() || wX != tileTargetX || wY != tileTargetY || (!Main.tileHammer[Main.tile[wX, wY].type] && !poundRelease)) && toolTime == 0 && itemAnimation > 0 && controlUseItem && sItem.hammer > 0 && CanPlayerSmashWall(wX, wY))
		{
			int damage = (int)((float)sItem.hammer * 1.5f);
			PickWall(wX, wY, damage);
			itemTime = sItem.useTime / 2;
		}
	}

	public static bool CanPlayerSmashWall(int X, int Y)
	{
		bool result = true;
		if (!Main.wallHouse[Main.tile[X, Y].wall])
		{
			result = false;
			for (int i = X - 1; i < X + 2; i++)
			{
				for (int j = Y - 1; j < Y + 2; j++)
				{
					if (Main.tile[i, j].wall == 0 || Main.wallHouse[Main.tile[i, j].wall])
					{
						result = true;
						break;
					}
				}
			}
		}
		return result;
	}

	public void PickWall(int x, int y, int damage)
	{
		int tileId = hitTile.HitObject(x, y, 2);
		if (hitTile.AddDamage(tileId, damage) >= 100)
		{
			hitTile.Clear(tileId);
			ClearMiningCacheAt(x, y, 2);
			WorldGen.KillWall(x, y);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 2, x, y);
			}
		}
		else
		{
			WorldGen.KillWall(x, y, fail: true);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 2, x, y, 1f);
			}
		}
		if (damage != 0)
		{
			hitTile.Prune();
		}
	}

	private void ItemCheck_UseMiningTools_TryPoundingTile(Item sItem, int tileHitId, ref bool hitWall, int x, int y)
	{
		Tile tile = Main.tile[x, y];
		bool num16 = sItem.hammer > 0 && tile.active() && poundRelease;
		bool vanillaSloping = Main.tileSolid[tile.type] || tile.type == 314 || tile.type == 351 || tile.type == 424 || tile.type == 442;
		if (num16 && (vanillaSloping || TileID.Sets.CanBeSloped[tile.type]))
		{
			hitWall = false;
			ApplyItemTime(sItem);
			int damageAmount = 100;
			if (WorldGen.IsLockedDoor(x, y - 1) || WorldGen.IsLockedDoor(x, y + 1))
			{
				damageAmount = 0;
			}
			if (hitTile.AddDamage(tileHitId, damageAmount) >= 100)
			{
				ClearMiningCacheAt(x, y, 1);
				if (!poundRelease)
				{
					return;
				}
				if (!TileLoader.Slope(x, y, Main.tile[x, y].type))
				{
					if (TileID.Sets.Platforms[Main.tile[x, y].type])
					{
						if (tile.halfBrick())
						{
							WorldGen.PoundTile(x, y);
							if (Main.netMode == 1)
							{
								NetMessage.SendData(17, -1, -1, null, 7, x, y, 1f);
							}
						}
						else
						{
							int num = 1;
							int slope = 2;
							if (TileID.Sets.Platforms[Main.tile[x + 1, y - 1].type] || TileID.Sets.Platforms[Main.tile[x - 1, y + 1].type] || (WorldGen.SolidTile(x + 1, y) && !WorldGen.SolidTile(x - 1, y)))
							{
								num = 2;
								slope = 1;
							}
							if (Main.tile[x, y].slope() == 0)
							{
								WorldGen.SlopeTile(x, y, num);
								int num8 = Main.tile[x, y].slope();
								if (Main.netMode == 1)
								{
									NetMessage.SendData(17, -1, -1, null, 14, x, y, num8);
								}
							}
							else if (Main.tile[x, y].slope() == num)
							{
								WorldGen.SlopeTile(x, y, slope);
								int num9 = Main.tile[x, y].slope();
								if (Main.netMode == 1)
								{
									NetMessage.SendData(17, -1, -1, null, 14, x, y, num9);
								}
							}
							else
							{
								WorldGen.SlopeTile(x, y);
								int num10 = Main.tile[x, y].slope();
								if (Main.netMode == 1)
								{
									NetMessage.SendData(17, -1, -1, null, 14, x, y, num10);
								}
								WorldGen.PoundTile(x, y);
								if (Main.netMode == 1)
								{
									NetMessage.SendData(17, -1, -1, null, 7, x, y, 1f);
								}
							}
						}
					}
					else if (Main.tile[x, y].type == 314)
					{
						if (Minecart.FrameTrack(x, y, pound: true) && Main.netMode == 1)
						{
							NetMessage.SendData(17, -1, -1, null, 15, x, y, 1f);
						}
					}
					else if (Main.tile[x, y].type == 137)
					{
						int num11 = 0;
						switch (Main.tile[x, y].frameY / 18)
						{
						case 0:
						case 1:
						case 2:
						case 5:
							switch (Main.tile[x, y].frameX / 18)
							{
							case 0:
								num11 = 2;
								break;
							case 1:
								num11 = 3;
								break;
							case 2:
								num11 = 4;
								break;
							case 3:
								num11 = 5;
								break;
							case 4:
								num11 = 1;
								break;
							case 5:
								num11 = 0;
								break;
							}
							break;
						case 3:
						case 4:
							switch (Main.tile[x, y].frameX / 18)
							{
							case 0:
							case 1:
								num11 = 3;
								break;
							case 3:
								num11 = 2;
								break;
							case 2:
								num11 = 4;
								break;
							case 4:
								num11 = 0;
								break;
							}
							break;
						}
						Main.tile[x, y].frameX = (short)(num11 * 18);
						if (Main.netMode == 1)
						{
							NetMessage.SendTileSquare(-1, x, y);
						}
					}
					else if (Main.tile[x, y].type == 424)
					{
						if (Main.tile[x, y].frameX == 0)
						{
							Main.tile[x, y].frameX = 18;
						}
						else if (Main.tile[x, y].frameX == 18)
						{
							Main.tile[x, y].frameX = 36;
						}
						else
						{
							Main.tile[x, y].frameX = 0;
						}
						if (Main.netMode == 1)
						{
							NetMessage.SendTileSquare(-1, x, y);
						}
					}
					else if (Main.tile[x, y].type == 442)
					{
						Tile tile2 = Main.tile[x, y - 1];
						Tile tile3 = Main.tile[x, y + 1];
						Tile tile4 = Main.tile[x - 1, y];
						Tile tile5 = Main.tile[x + 1, y];
						Tile tile6 = Main.tile[x - 1, y + 1];
						Tile tile7 = Main.tile[x + 1, y + 1];
						Tile tile8 = Main.tile[x - 1, y - 1];
						Tile tile9 = Main.tile[x + 1, y - 1];
						int num12 = -1;
						int num13 = -1;
						int num14 = -1;
						int num15 = -1;
						int tree = -1;
						int tree2 = -1;
						int tree3 = -1;
						int tree4 = -1;
						if (tile2 != null && tile2.nactive() && !tile2.bottomSlope())
						{
							num13 = tile2.type;
						}
						if (tile3 != null && tile3.nactive() && !tile3.halfBrick() && !tile3.topSlope())
						{
							num12 = tile3.type;
						}
						if (tile4 != null && tile4.nactive() && (tile4.slope() == 0 || tile4.slope() % 2 != 1))
						{
							num14 = tile4.type;
						}
						if (tile5 != null && tile5.nactive() && (tile5.slope() == 0 || tile5.slope() % 2 != 0))
						{
							num15 = tile5.type;
						}
						if (tile6 != null && tile6.nactive())
						{
							tree = tile6.type;
						}
						if (tile7 != null && tile7.nactive())
						{
							tree2 = tile7.type;
						}
						if (tile8 != null && tile8.nactive())
						{
							tree3 = tile8.type;
						}
						if (tile9 != null && tile9.nactive())
						{
							tree4 = tile9.type;
						}
						bool flag = false;
						bool flag2 = false;
						bool flag3 = false;
						bool flag4 = false;
						if (num12 >= 0 && Main.tileSolid[num12] && (!Main.tileNoAttach[num12] || TileID.Sets.Platforms[num12]) && (tile3.bottomSlope() || tile3.slope() == 0) && !tile3.halfBrick())
						{
							flag4 = true;
						}
						if (num13 >= 0 && Main.tileSolid[num13] && (!Main.tileNoAttach[num13] || (TileID.Sets.Platforms[num13] && tile2.halfBrick())) && (tile2.topSlope() || tile2.slope() == 0 || tile2.halfBrick()))
						{
							flag = true;
						}
						if ((num14 >= 0 && Main.tileSolid[num14] && !Main.tileNoAttach[num14] && (tile4.leftSlope() || tile4.slope() == 0) && !tile4.halfBrick()) || (num14 >= 0 && TileID.Sets.IsBeam[num14]) || (WorldGen.IsTreeType(num14) && WorldGen.IsTreeType(tree3) && WorldGen.IsTreeType(tree)))
						{
							flag2 = true;
						}
						if ((num15 >= 0 && Main.tileSolid[num15] && !Main.tileNoAttach[num15] && (tile5.rightSlope() || tile5.slope() == 0) && !tile5.halfBrick()) || (num15 >= 0 && TileID.Sets.IsBeam[num15]) || (WorldGen.IsTreeType(num15) && WorldGen.IsTreeType(tree4) && WorldGen.IsTreeType(tree2)))
						{
							flag3 = true;
						}
						int num2 = Main.tile[x, y].frameX / 22;
						short num3 = -2;
						switch (num2)
						{
						case 0:
							num3 = (short)(flag2 ? 2 : (flag ? 1 : ((!flag3) ? (-1) : 3)));
							break;
						case 2:
							num3 = (short)(flag ? 1 : (flag3 ? 3 : ((!flag4) ? (-1) : 0)));
							break;
						case 1:
							num3 = (short)(flag3 ? 3 : ((!flag4) ? ((!flag2) ? (-1) : 2) : 0));
							break;
						case 3:
							num3 = (short)((!flag4) ? (flag2 ? 2 : (flag ? 1 : (-1))) : 0);
							break;
						}
						if (num3 != -1)
						{
							if (num3 == -2)
							{
								num3 = 0;
							}
							Main.tile[x, y].frameX = (short)(22 * num3);
							if (Main.netMode == 1)
							{
								NetMessage.SendTileSquare(-1, x, y);
							}
						}
					}
					else if ((Main.tile[x, y].halfBrick() || Main.tile[x, y].slope() != 0) && !Main.tileSolidTop[Main.tile[x, y].type])
					{
						int num4 = 1;
						int num5 = 1;
						int num6 = 2;
						if ((WorldGen.SolidTile(x + 1, y) || Main.tile[x + 1, y].slope() == 1 || Main.tile[x + 1, y].slope() == 3) && !WorldGen.SolidTile(x - 1, y))
						{
							num5 = 2;
							num6 = 1;
						}
						if (WorldGen.SolidTile(x, y - 1) && !WorldGen.SolidTile(x, y + 1))
						{
							num4 = -1;
						}
						if (num4 == 1)
						{
							if (Main.tile[x, y].slope() == 0)
							{
								WorldGen.SlopeTile(x, y, num5);
							}
							else if (Main.tile[x, y].slope() == num5)
							{
								WorldGen.SlopeTile(x, y, num6);
							}
							else if (Main.tile[x, y].slope() == num6)
							{
								WorldGen.SlopeTile(x, y, num5 + 2);
							}
							else if (Main.tile[x, y].slope() == num5 + 2)
							{
								WorldGen.SlopeTile(x, y, num6 + 2);
							}
							else
							{
								WorldGen.SlopeTile(x, y);
							}
						}
						else if (Main.tile[x, y].slope() == 0)
						{
							WorldGen.SlopeTile(x, y, num5 + 2);
						}
						else if (Main.tile[x, y].slope() == num5 + 2)
						{
							WorldGen.SlopeTile(x, y, num6 + 2);
						}
						else if (Main.tile[x, y].slope() == num6 + 2)
						{
							WorldGen.SlopeTile(x, y, num5);
						}
						else if (Main.tile[x, y].slope() == num5)
						{
							WorldGen.SlopeTile(x, y, num6);
						}
						else
						{
							WorldGen.SlopeTile(x, y);
						}
						int num7 = Main.tile[x, y].slope();
						if (Main.netMode == 1)
						{
							NetMessage.SendData(17, -1, -1, null, 14, x, y, num7);
						}
					}
					else
					{
						WorldGen.PoundTile(x, y);
						if (Main.netMode == 1)
						{
							NetMessage.SendData(17, -1, -1, null, 7, x, y, 1f);
						}
					}
				}
				poundRelease = false;
			}
			else
			{
				WorldGen.KillTile(x, y, fail: true, effectOnly: true);
				SoundEngine.PlaySound(0, x * 16, y * 16);
			}
		}
		else
		{
			poundRelease = false;
		}
	}

	public bool IsTargetTileInItemRange(Item sItem)
	{
		if (position.X / 16f - (float)tileRangeX - (float)sItem.tileBoost <= (float)tileTargetX && (position.X + (float)width) / 16f + (float)tileRangeX + (float)sItem.tileBoost - 1f >= (float)tileTargetX && position.Y / 16f - (float)tileRangeY - (float)sItem.tileBoost <= (float)tileTargetY)
		{
			return (position.Y + (float)height) / 16f + (float)tileRangeY + (float)sItem.tileBoost - 2f >= (float)tileTargetY;
		}
		return false;
	}

	private void ItemCheck_UseBuckets(Item sItem)
	{
		if (((sItem.type < 205 || sItem.type > 207) && sItem.type != 1128 && sItem.type != 3031 && sItem.type != 3032 && sItem.type != 4820 && sItem.type != 4872 && sItem.type != 5302 && sItem.type != 5303 && sItem.type != 5304 && sItem.type != 5364) || noBuilding || !(position.X / 16f - (float)tileRangeX - (float)sItem.tileBoost <= (float)tileTargetX) || !((position.X + (float)width) / 16f + (float)tileRangeX + (float)sItem.tileBoost - 1f >= (float)tileTargetX) || !(position.Y / 16f - (float)tileRangeY - (float)sItem.tileBoost <= (float)tileTargetY) || !((position.Y + (float)height) / 16f + (float)tileRangeY + (float)sItem.tileBoost - 2f >= (float)tileTargetY))
		{
			return;
		}
		if (!Main.GamepadDisableCursorItemIcon)
		{
			cursorItemIconEnabled = true;
			Main.ItemIconCacheUpdate(sItem.type);
		}
		if (!ItemTimeIsZero || itemAnimation <= 0 || !controlUseItem)
		{
			return;
		}
		Tile tile;
		if (sItem.type == 205)
		{
			tile = Main.tile[tileTargetX, tileTargetY];
			if (!tile.shimmer())
			{
				goto IL_027d;
			}
		}
		if (sItem.type == 3032)
		{
			tile = Main.tile[tileTargetX, tileTargetY];
			if (tile.liquidType() == 0)
			{
				goto IL_027d;
			}
		}
		if (sItem.type == 3032)
		{
			tile = Main.tile[tileTargetX, tileTargetY];
			if (tile.shimmer())
			{
				goto IL_027d;
			}
		}
		if (sItem.type == 4872)
		{
			tile = Main.tile[tileTargetX, tileTargetY];
			if (tile.lava())
			{
				goto IL_027d;
			}
		}
		if (sItem.type == 5303)
		{
			tile = Main.tile[tileTargetX, tileTargetY];
			if (tile.honey())
			{
				goto IL_027d;
			}
		}
		if (sItem.type != 5304)
		{
			tile = Main.tile[tileTargetX, tileTargetY];
			if (tile.liquid >= 200)
			{
				return;
			}
			tile = Main.tile[tileTargetX, tileTargetY];
			if (tile.nactive())
			{
				bool[] tileSolid = Main.tileSolid;
				tile = Main.tile[tileTargetX, tileTargetY];
				if (tileSolid[tile.type])
				{
					bool[] tileSolidTop = Main.tileSolidTop;
					tile = Main.tile[tileTargetX, tileTargetY];
					if (!tileSolidTop[tile.type])
					{
						tile = Main.tile[tileTargetX, tileTargetY];
						if (tile.type != 546)
						{
							return;
						}
					}
				}
			}
			if (sItem.type == 207 || sItem.type == 4820)
			{
				tile = Main.tile[tileTargetX, tileTargetY];
				if (tile.liquid != 0)
				{
					tile = Main.tile[tileTargetX, tileTargetY];
					if (tile.liquidType() != 1)
					{
						return;
					}
				}
				SoundEngine.PlaySound(19, (int)position.X, (int)position.Y);
				tile = Main.tile[tileTargetX, tileTargetY];
				tile.liquidType(1);
				tile = Main.tile[tileTargetX, tileTargetY];
				tile.liquid = byte.MaxValue;
				WorldGen.SquareTileFrame(tileTargetX, tileTargetY);
				if (sItem.type != 4820)
				{
					sItem.stack--;
					PutItemInInventoryFromItemUsage(205, selectedItem);
				}
				ApplyItemTime(sItem);
				if (Main.netMode == 1)
				{
					NetMessage.sendWater(tileTargetX, tileTargetY);
				}
			}
			else if (sItem.type == 206 || sItem.type == 3031)
			{
				tile = Main.tile[tileTargetX, tileTargetY];
				if (tile.liquid != 0)
				{
					tile = Main.tile[tileTargetX, tileTargetY];
					if (tile.liquidType() != 0)
					{
						return;
					}
				}
				SoundEngine.PlaySound(19, (int)position.X, (int)position.Y);
				tile = Main.tile[tileTargetX, tileTargetY];
				tile.liquidType(0);
				tile = Main.tile[tileTargetX, tileTargetY];
				tile.liquid = byte.MaxValue;
				WorldGen.SquareTileFrame(tileTargetX, tileTargetY);
				if (sItem.type != 3031)
				{
					sItem.stack--;
					PutItemInInventoryFromItemUsage(205, selectedItem);
				}
				ApplyItemTime(sItem);
				if (Main.netMode == 1)
				{
					NetMessage.sendWater(tileTargetX, tileTargetY);
				}
			}
			else if (sItem.type == 1128 || sItem.type == 5302)
			{
				tile = Main.tile[tileTargetX, tileTargetY];
				if (tile.liquid != 0)
				{
					tile = Main.tile[tileTargetX, tileTargetY];
					if (tile.liquidType() != 2)
					{
						return;
					}
				}
				SoundEngine.PlaySound(19, (int)position.X, (int)position.Y);
				tile = Main.tile[tileTargetX, tileTargetY];
				tile.liquidType(2);
				tile = Main.tile[tileTargetX, tileTargetY];
				tile.liquid = byte.MaxValue;
				WorldGen.SquareTileFrame(tileTargetX, tileTargetY);
				if (sItem.type != 5302)
				{
					sItem.stack--;
					PutItemInInventoryFromItemUsage(205, selectedItem);
				}
				ApplyItemTime(sItem);
				if (Main.netMode == 1)
				{
					NetMessage.sendWater(tileTargetX, tileTargetY);
				}
			}
			else
			{
				if (sItem.type != 5364)
				{
					return;
				}
				tile = Main.tile[tileTargetX, tileTargetY];
				if (tile.liquid != 0)
				{
					tile = Main.tile[tileTargetX, tileTargetY];
					if (tile.liquidType() != 3)
					{
						return;
					}
				}
				SoundEngine.PlaySound(19, (int)position.X, (int)position.Y);
				tile = Main.tile[tileTargetX, tileTargetY];
				tile.liquidType(3);
				tile = Main.tile[tileTargetX, tileTargetY];
				tile.liquid = byte.MaxValue;
				WorldGen.SquareTileFrame(tileTargetX, tileTargetY);
				ApplyItemTime(sItem);
				if (Main.netMode == 1)
				{
					NetMessage.sendWater(tileTargetX, tileTargetY);
				}
			}
			return;
		}
		goto IL_027d;
		IL_027d:
		tile = Main.tile[tileTargetX, tileTargetY];
		int num = tile.liquidType();
		int num2 = 0;
		for (int i = tileTargetX - 1; i <= tileTargetX + 1; i++)
		{
			for (int j = tileTargetY - 1; j <= tileTargetY + 1; j++)
			{
				tile = Main.tile[i, j];
				if (tile.liquidType() == num)
				{
					int num5 = num2;
					tile = Main.tile[i, j];
					num2 = num5 + tile.liquid;
				}
			}
		}
		tile = Main.tile[tileTargetX, tileTargetY];
		if (tile.liquid <= 0 || (num2 <= 100 && sItem.type != 3032 && sItem.type != 4872 && sItem.type != 5303 && sItem.type != 5304))
		{
			return;
		}
		tile = Main.tile[tileTargetX, tileTargetY];
		int liquidType = tile.liquidType();
		if (sItem.type != 3032 && sItem.type != 4872 && sItem.type != 5303 && sItem.type != 5304)
		{
			tile = Main.tile[tileTargetX, tileTargetY];
			if (tile.honey() && sItem.type == 205)
			{
				sItem.stack--;
				PutItemInInventoryFromItemUsage(1128, selectedItem);
			}
			else
			{
				tile = Main.tile[tileTargetX, tileTargetY];
				if (tile.lava() && sItem.type == 205)
				{
					sItem.stack--;
					PutItemInInventoryFromItemUsage(207, selectedItem);
				}
				else
				{
					tile = Main.tile[tileTargetX, tileTargetY];
					if (tile.shimmer() && sItem.type == 205)
					{
						return;
					}
					sItem.stack--;
					PutItemInInventoryFromItemUsage(206, selectedItem);
				}
			}
		}
		SoundEngine.PlaySound(19, (int)position.X, (int)position.Y);
		ApplyItemTime(sItem);
		tile = Main.tile[tileTargetX, tileTargetY];
		int num3 = tile.liquid;
		tile = Main.tile[tileTargetX, tileTargetY];
		tile.liquid = 0;
		tile = Main.tile[tileTargetX, tileTargetY];
		tile.lava(lava: false);
		tile = Main.tile[tileTargetX, tileTargetY];
		tile.honey(honey: false);
		WorldGen.SquareTileFrame(tileTargetX, tileTargetY, resetFrame: false);
		if (Main.netMode == 1)
		{
			NetMessage.sendWater(tileTargetX, tileTargetY);
		}
		else
		{
			Liquid.AddWater(tileTargetX, tileTargetY);
		}
		if (num3 >= 255)
		{
			return;
		}
		for (int k = tileTargetX - 1; k <= tileTargetX + 1; k++)
		{
			for (int l = tileTargetY - 1; l <= tileTargetY + 1; l++)
			{
				if (k == tileTargetX && l == tileTargetY)
				{
					continue;
				}
				tile = Main.tile[k, l];
				if (tile.liquid <= 0)
				{
					continue;
				}
				tile = Main.tile[k, l];
				if (tile.liquidType() == num)
				{
					tile = Main.tile[k, l];
					int num4 = tile.liquid;
					if (num4 + num3 > 255)
					{
						num4 = 255 - num3;
					}
					num3 += num4;
					tile = Main.tile[k, l];
					tile.liquid -= (byte)num4;
					tile = Main.tile[k, l];
					tile.liquidType(liquidType);
					tile = Main.tile[k, l];
					if (tile.liquid == 0)
					{
						tile = Main.tile[k, l];
						tile.lava(lava: false);
						tile = Main.tile[k, l];
						tile.honey(honey: false);
					}
					WorldGen.SquareTileFrame(k, l, resetFrame: false);
					if (Main.netMode == 1)
					{
						NetMessage.sendWater(k, l);
					}
					else
					{
						Liquid.AddWater(k, l);
					}
				}
			}
		}
	}

	private void ItemCheck_PlayInstruments(Item sItem)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_05df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_030b: Unknown result type (might be due to invalid IL or missing references)
		//IL_042a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0443: Unknown result type (might be due to invalid IL or missing references)
		//IL_0469: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_052f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0548: Unknown result type (might be due to invalid IL or missing references)
		//IL_056e: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06be: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e4: Unknown result type (might be due to invalid IL or missing references)
		Vector2 vector = default(Vector2);
		((Vector2)(ref vector))._002Ector(position.X + (float)width * 0.5f, position.Y + (float)height * 0.5f);
		float num30 = (float)Main.mouseX + Main.screenPosition.X - vector.X;
		float num18 = (float)Main.mouseY + Main.screenPosition.Y - vector.Y;
		float num25 = (float)Math.Sqrt(num30 * num30 + num18 * num18);
		float num26 = (float)Main.screenHeight / Main.GameViewMatrix.Zoom.Y;
		num25 /= num26 / 2f;
		if (num25 > 1f)
		{
			num25 = 1f;
		}
		musicDist = num25;
		if (itemAnimation > 0 && ItemTimeIsZero && (sItem.type == 508 || sItem.type == 507))
		{
			ApplyItemTime(sItem);
			Vector2 vector2 = default(Vector2);
			((Vector2)(ref vector2))._002Ector(position.X + (float)width * 0.5f, position.Y + (float)height * 0.5f);
			float num31 = (float)Main.mouseX + Main.screenPosition.X - vector2.X;
			float num27 = (float)Main.mouseY + Main.screenPosition.Y - vector2.Y;
			float num28 = (float)Math.Sqrt(num31 * num31 + num27 * num27);
			float num29 = (float)Main.screenHeight / Main.GameViewMatrix.Zoom.Y;
			num28 /= num29 / 2f;
			if (num28 > 1f)
			{
				num28 = 1f;
			}
			num28 = num28 * 2f - 1f;
			if (num28 < -1f)
			{
				num28 = -1f;
			}
			if (num28 > 1f)
			{
				num28 = 1f;
			}
			num28 = (float)Math.Round(num28 * (float)musicNotes);
			num28 = (Main.musicPitch = num28 / (float)musicNotes);
			SoundStyle type = SoundID.Item26;
			if (sItem.type == 507)
			{
				type = SoundID.Item35;
			}
			SoundEngine.PlaySound(in type, position);
			NetMessage.SendData(58, -1, -1, null, whoAmI, num28);
		}
		if (itemAnimation <= 0 || mouseInterface)
		{
			return;
		}
		if (Main.mouseLeft && Main.mouseLeftRelease)
		{
			if (sItem.type == 1305)
			{
				Vector2 vector3 = default(Vector2);
				((Vector2)(ref vector3))._002Ector(position.X + (float)width * 0.5f, position.Y + (float)height * 0.5f);
				float num32 = (float)Main.mouseX + Main.screenPosition.X - vector3.X;
				float num10 = (float)Main.mouseY + Main.screenPosition.Y - vector3.Y;
				float num11 = (float)Math.Sqrt(num32 * num32 + num10 * num10);
				float num12 = (float)Main.screenHeight / Main.GameViewMatrix.Zoom.Y;
				num11 /= num12 / 2f;
				if (num11 > 1f)
				{
					num11 = 1f;
				}
				num11 = num11 * 2f - 1f;
				if (num11 < -1f)
				{
					num11 = -1f;
				}
				if (num11 > 1f)
				{
					num11 = 1f;
				}
				num11 = (float)Math.Round(num11 * (float)musicNotes);
				num11 = (Main.musicPitch = num11 / (float)musicNotes);
				SoundEngine.PlaySound(in SoundID.Item47, position);
				NetMessage.SendData(58, -1, -1, null, whoAmI, num11);
			}
			else if (sItem.type == 4057 || sItem.type == 4372)
			{
				Vector2 vector4 = default(Vector2);
				((Vector2)(ref vector4))._002Ector(position.X + (float)width * 0.5f, position.Y + (float)height * 0.5f);
				float num33 = (float)Main.mouseX + Main.screenPosition.X - vector4.X;
				float num13 = (float)Main.mouseY + Main.screenPosition.Y - vector4.Y;
				float num14 = (float)Math.Sqrt(num33 * num33 + num13 * num13);
				float num15 = (float)Main.screenHeight / Main.GameViewMatrix.Zoom.Y;
				num14 /= num15 / 2f;
				if (num14 > 1f)
				{
					num14 = 1f;
				}
				PlayGuitarChord(num14);
				NetMessage.SendData(58, -1, -1, null, whoAmI, num14);
			}
		}
		if (sItem.type == 4715 && ((Main.mouseLeft && Main.mouseLeftRelease) | ItemAnimationJustStarted))
		{
			Vector2 vector5 = default(Vector2);
			((Vector2)(ref vector5))._002Ector(position.X + (float)width * 0.5f, position.Y + (float)height * 0.5f);
			float num34 = (float)Main.mouseX + Main.screenPosition.X - vector5.X;
			float num16 = (float)Main.mouseY + Main.screenPosition.Y - vector5.Y;
			float num17 = (float)Math.Sqrt(num34 * num34 + num16 * num16);
			float num19 = (float)Main.screenHeight / Main.GameViewMatrix.Zoom.Y;
			num17 /= num19 / 2f;
			if (num17 > 1f)
			{
				num17 = 1f;
			}
			PlayGuitarChord(num17);
			NetMessage.SendData(58, -1, -1, null, whoAmI, num17);
		}
		if (sItem.type != 4673)
		{
			return;
		}
		int num20 = (int)base.Center.X / 16;
		int num21 = (int)base.Center.Y / 16;
		if (WorldGen.InWorld(num20, num21) && Main.tile[num20, num21] != null && Main.tile[num20, num21].type == 486 && ((Main.mouseLeft && Main.mouseLeftRelease) || (Main.mouseRight && Main.mouseRightRelease)))
		{
			Vector2 vector6 = default(Vector2);
			((Vector2)(ref vector6))._002Ector(position.X + (float)width * 0.5f, position.Y + (float)height * 0.5f);
			float num35 = (float)Main.mouseX + Main.screenPosition.X - vector6.X;
			float num22 = (float)Main.mouseY + Main.screenPosition.Y - vector6.Y;
			float num23 = (float)Math.Sqrt(num35 * num35 + num22 * num22);
			float num24 = (float)Main.screenHeight / Main.GameViewMatrix.Zoom.Y;
			num23 /= num24 / 2f;
			if (num23 > 1f)
			{
				num23 = 1f;
			}
			PlayDrums(num23);
			NetMessage.SendData(58, -1, -1, null, whoAmI, num23);
		}
	}

	private bool GetSparkleGuitarTarget(out List<NPC> validTargets)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		validTargets = new List<NPC>();
		Rectangle value = Utils.CenteredRectangle(base.Center, new Vector2(1000f, 800f));
		for (int i = 0; i < 200; i++)
		{
			NPC nPC = Main.npc[i];
			if (nPC.CanBeChasedBy(this))
			{
				Rectangle hitbox = nPC.Hitbox;
				if (((Rectangle)(ref hitbox)).Intersects(value))
				{
					validTargets.Add(nPC);
				}
			}
		}
		if (validTargets.Count == 0)
		{
			return false;
		}
		return true;
	}

	private bool GetZenithTarget(Vector2 searchCenter, float maxDistance, out int npcTargetIndex)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		npcTargetIndex = 0;
		int? num = null;
		float num2 = maxDistance;
		for (int i = 0; i < 200; i++)
		{
			NPC nPC = Main.npc[i];
			if (nPC.CanBeChasedBy(this))
			{
				float num3 = searchCenter.Distance(nPC.Center);
				if (!(num2 <= num3))
				{
					num = i;
					num2 = num3;
				}
			}
		}
		if (!num.HasValue)
		{
			return false;
		}
		npcTargetIndex = num.Value;
		return true;
	}

	public void PlayGuitarChord(float range)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		int num = 6;
		float num2 = 1f / (float)num;
		if (range > num2 * 5f)
		{
			SoundEngine.PlaySound(49, base.Center);
		}
		else if (range > num2 * 4f)
		{
			SoundEngine.PlaySound(48, base.Center);
		}
		else if (range > num2 * 3f)
		{
			SoundEngine.PlaySound(47, base.Center);
		}
		else if (range > num2 * 2f)
		{
			SoundEngine.PlaySound(51, base.Center);
		}
		else if (range > num2 * 1f)
		{
			SoundEngine.PlaySound(52, base.Center);
		}
		else
		{
			SoundEngine.PlaySound(50, base.Center);
		}
	}

	public void PlayDrums(float range)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		int num = 10;
		float num2 = 1f / (float)num;
		if (range > num2 * 9f)
		{
			SoundEngine.PlaySound(59, base.Center);
		}
		else if (range > num2 * 8f)
		{
			SoundEngine.PlaySound(58, base.Center);
		}
		else if (range > num2 * 7f)
		{
			SoundEngine.PlaySound(53, base.Center);
		}
		else if (range > num2 * 6f)
		{
			SoundEngine.PlaySound(57, base.Center);
		}
		else if (range > num2 * 5f)
		{
			SoundEngine.PlaySound(62, base.Center);
		}
		else if (range > num2 * 4f)
		{
			SoundEngine.PlaySound(61, base.Center);
		}
		else if (range > num2 * 3f)
		{
			SoundEngine.PlaySound(54, base.Center);
		}
		else if (range > num2 * 2f)
		{
			SoundEngine.PlaySound(56, base.Center);
		}
		else if (range > num2 * 1f)
		{
			SoundEngine.PlaySound(55, base.Center);
		}
		else
		{
			SoundEngine.PlaySound(60, base.Center);
		}
	}

	private void ItemCheck_UseWiringTools(Item sItem)
	{
		//IL_082e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0830: Unknown result type (might be due to invalid IL or missing references)
		//IL_0801: Unknown result type (might be due to invalid IL or missing references)
		//IL_0808: Unknown result type (might be due to invalid IL or missing references)
		//IL_0810: Unknown result type (might be due to invalid IL or missing references)
		//IL_0818: Unknown result type (might be due to invalid IL or missing references)
		if ((sItem.type != 509 && sItem.type != 510 && sItem.type != 849 && sItem.type != 850 && sItem.type != 851 && sItem.type != 3612 && sItem.type != 3620 && sItem.type != 3625) || !(position.X / 16f - (float)tileRangeX - (float)sItem.tileBoost - (float)blockRange <= (float)tileTargetX) || !((position.X + (float)width) / 16f + (float)tileRangeX + (float)sItem.tileBoost - 1f + (float)blockRange >= (float)tileTargetX) || !(position.Y / 16f - (float)tileRangeY - (float)sItem.tileBoost - (float)blockRange <= (float)tileTargetY) || !((position.Y + (float)height) / 16f + (float)tileRangeY + (float)sItem.tileBoost - 2f + (float)blockRange >= (float)tileTargetY))
		{
			return;
		}
		if (!Main.GamepadDisableCursorItemIcon)
		{
			cursorItemIconEnabled = true;
			Main.ItemIconCacheUpdate(sItem.type);
		}
		if (!CanDoWireStuffHere(tileTargetX, tileTargetY) || itemAnimation <= 0 || !ItemTimeIsZero || !controlUseItem)
		{
			return;
		}
		int num = tileTargetX;
		int num2 = tileTargetY;
		if (sItem.type == 509)
		{
			int num3 = -1;
			for (int i = 0; i < 58; i++)
			{
				if (inventory[i].stack > 0 && inventory[i].type == 530)
				{
					num3 = i;
					break;
				}
			}
			if (num3 >= 0 && WorldGen.PlaceWire(num, num2))
			{
				if (ItemLoader.ConsumeItem(inventory[num3], this))
				{
					inventory[num3].stack--;
				}
				if (inventory[num3].stack <= 0)
				{
					inventory[num3].SetDefaults();
				}
				ApplyItemTime(sItem);
				NetMessage.SendData(17, -1, -1, null, 5, tileTargetX, tileTargetY);
			}
		}
		else if (sItem.type == 850)
		{
			int num4 = -1;
			for (int j = 0; j < 58; j++)
			{
				if (inventory[j].stack > 0 && inventory[j].type == 530)
				{
					num4 = j;
					break;
				}
			}
			if (num4 >= 0 && WorldGen.PlaceWire2(num, num2))
			{
				if (ItemLoader.ConsumeItem(inventory[num4], this))
				{
					inventory[num4].stack--;
				}
				if (inventory[num4].stack <= 0)
				{
					inventory[num4].SetDefaults();
				}
				ApplyItemTime(sItem);
				NetMessage.SendData(17, -1, -1, null, 10, tileTargetX, tileTargetY);
			}
		}
		if (sItem.type == 851)
		{
			int num5 = -1;
			for (int k = 0; k < 58; k++)
			{
				if (inventory[k].stack > 0 && inventory[k].type == 530)
				{
					num5 = k;
					break;
				}
			}
			if (num5 >= 0 && WorldGen.PlaceWire3(num, num2))
			{
				if (ItemLoader.ConsumeItem(inventory[num5], this))
				{
					inventory[num5].stack--;
				}
				if (inventory[num5].stack <= 0)
				{
					inventory[num5].SetDefaults();
				}
				ApplyItemTime(sItem);
				NetMessage.SendData(17, -1, -1, null, 12, tileTargetX, tileTargetY);
			}
		}
		if (sItem.type == 3612)
		{
			int num6 = -1;
			for (int l = 0; l < 58; l++)
			{
				if (inventory[l].stack > 0 && inventory[l].type == 530)
				{
					num6 = l;
					break;
				}
			}
			if (num6 >= 0 && WorldGen.PlaceWire4(num, num2))
			{
				if (ItemLoader.ConsumeItem(inventory[num6], this))
				{
					inventory[num6].stack--;
				}
				if (inventory[num6].stack <= 0)
				{
					inventory[num6].SetDefaults();
				}
				ApplyItemTime(sItem);
				NetMessage.SendData(17, -1, -1, null, 16, tileTargetX, tileTargetY);
			}
		}
		else if (sItem.type == 510)
		{
			if (WorldGen.KillActuator(num, num2))
			{
				ApplyItemTime(sItem);
				NetMessage.SendData(17, -1, -1, null, 9, tileTargetX, tileTargetY);
			}
			else if (WorldGen.KillWire4(num, num2))
			{
				ApplyItemTime(sItem);
				NetMessage.SendData(17, -1, -1, null, 17, tileTargetX, tileTargetY);
			}
			else if (WorldGen.KillWire3(num, num2))
			{
				ApplyItemTime(sItem);
				NetMessage.SendData(17, -1, -1, null, 13, tileTargetX, tileTargetY);
			}
			else if (WorldGen.KillWire2(num, num2))
			{
				ApplyItemTime(sItem);
				NetMessage.SendData(17, -1, -1, null, 11, tileTargetX, tileTargetY);
			}
			else if (WorldGen.KillWire(num, num2))
			{
				ApplyItemTime(sItem);
				NetMessage.SendData(17, -1, -1, null, 6, tileTargetX, tileTargetY);
			}
		}
		else if (sItem.type == 849 && sItem.stack > 0 && WorldGen.PlaceActuator(num, num2))
		{
			ApplyItemTime(sItem);
			NetMessage.SendData(17, -1, -1, null, 8, tileTargetX, tileTargetY);
			if (ItemLoader.ConsumeItem(sItem, this))
			{
				sItem.stack--;
			}
			if (sItem.stack <= 0)
			{
				sItem.SetDefaults();
			}
		}
		if (sItem.type == 3620)
		{
			Tile tile = Main.tile[num, num2];
			if (tile != null && tile.actuator())
			{
				bool flag = tile.inActive();
				if ((!ActuationRodLock || ActuationRodLockSetting == tile.inActive()) && Wiring.Actuate(num, num2) && flag != tile.inActive())
				{
					ActuationRodLock = true;
					ActuationRodLockSetting = !tile.inActive();
					ApplyItemTime(sItem);
					NetMessage.SendData(17, -1, -1, null, 19, tileTargetX, tileTargetY);
				}
			}
		}
		if (sItem.type == 3625)
		{
			Point point = default(Point);
			((Point)(ref point))._002Ector(tileTargetX, tileTargetY);
			ApplyItemTime(sItem);
			WiresUI.Settings.MultiToolMode toolMode = WiresUI.Settings.ToolMode;
			WiresUI.Settings.ToolMode &= ~WiresUI.Settings.MultiToolMode.Actuator;
			if (Main.netMode == 1)
			{
				NetMessage.SendData(109, -1, -1, null, point.X, point.Y, point.X, point.Y, (int)WiresUI.Settings.ToolMode);
			}
			else
			{
				Wiring.MassWireOperation(point, point, this);
			}
			WiresUI.Settings.ToolMode = toolMode;
		}
	}

	public bool CanDoWireStuffHere(int x, int y)
	{
		if (!WorldGen.InWorld(x, y))
		{
			return false;
		}
		if (!NPC.downedGolemBoss && Main.tile[x, y].wall == 87)
		{
			return false;
		}
		return true;
	}

	private void ItemCheck_UseLawnMower(Item sItem)
	{
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		if (sItem.type == 4049 && position.X / 16f - (float)tileRangeX - (float)sItem.tileBoost - (float)blockRange <= (float)tileTargetX && (position.X + (float)width) / 16f + (float)tileRangeX + (float)sItem.tileBoost - 1f + (float)blockRange >= (float)tileTargetX && position.Y / 16f - (float)tileRangeY - (float)sItem.tileBoost - (float)blockRange <= (float)tileTargetY && (position.Y + (float)height) / 16f + (float)tileRangeY + (float)sItem.tileBoost - 2f + (float)blockRange >= (float)tileTargetY && itemAnimation > 0 && ItemTimeIsZero && controlUseItem)
		{
			MowGrassTile(Utils.ToWorldCoordinates(new Point(tileTargetX, tileTargetY), 8f, 8f));
			ApplyItemTime(sItem);
		}
	}

	private void DestroyOldestProximityMinesOverMinesCap(int minesCap)
	{
		_oldestProjCheckList.Clear();
		for (int i = 0; i < 1000; i++)
		{
			Projectile projectile = Main.projectile[i];
			if (projectile.active && projectile.owner == whoAmI)
			{
				switch (projectile.type)
				{
				case 135:
				case 138:
				case 141:
				case 144:
				case 778:
				case 782:
				case 786:
				case 789:
				case 792:
				case 795:
				case 798:
				case 801:
					_oldestProjCheckList.Add(projectile);
					break;
				}
			}
		}
		while (_oldestProjCheckList.Count > minesCap)
		{
			Projectile projectile2 = _oldestProjCheckList[0];
			for (int j = 1; j < _oldestProjCheckList.Count; j++)
			{
				if (_oldestProjCheckList[j].timeLeft < projectile2.timeLeft)
				{
					projectile2 = _oldestProjCheckList[j];
				}
			}
			projectile2.Kill();
			_oldestProjCheckList.Remove(projectile2);
		}
		_oldestProjCheckList.Clear();
	}

	private void ItemCheck_Shoot(int i, Item sItem, int weaponDamage)
	{
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_0328: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0311: Unknown result type (might be due to invalid IL or missing references)
		//IL_031f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0324: Unknown result type (might be due to invalid IL or missing references)
		//IL_0425: Unknown result type (might be due to invalid IL or missing references)
		//IL_0427: Unknown result type (might be due to invalid IL or missing references)
		//IL_0429: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0456: Unknown result type (might be due to invalid IL or missing references)
		//IL_0458: Unknown result type (might be due to invalid IL or missing references)
		//IL_045a: Unknown result type (might be due to invalid IL or missing references)
		//IL_045f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0474: Unknown result type (might be due to invalid IL or missing references)
		//IL_047a: Unknown result type (might be due to invalid IL or missing references)
		//IL_047c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0486: Unknown result type (might be due to invalid IL or missing references)
		//IL_048b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0490: Unknown result type (might be due to invalid IL or missing references)
		//IL_043e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0440: Unknown result type (might be due to invalid IL or missing references)
		//IL_0442: Unknown result type (might be due to invalid IL or missing references)
		//IL_0447: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0610: Unknown result type (might be due to invalid IL or missing references)
		//IL_05da: Unknown result type (might be due to invalid IL or missing references)
		//IL_05dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_074e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0755: Unknown result type (might be due to invalid IL or missing references)
		//IL_075b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0765: Unknown result type (might be due to invalid IL or missing references)
		//IL_076a: Unknown result type (might be due to invalid IL or missing references)
		//IL_079d: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_07aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0778: Unknown result type (might be due to invalid IL or missing references)
		//IL_077e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0788: Unknown result type (might be due to invalid IL or missing references)
		//IL_078d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0792: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0808: Unknown result type (might be due to invalid IL or missing references)
		//IL_0813: Unknown result type (might be due to invalid IL or missing references)
		//IL_0818: Unknown result type (might be due to invalid IL or missing references)
		//IL_0822: Unknown result type (might be due to invalid IL or missing references)
		//IL_0828: Unknown result type (might be due to invalid IL or missing references)
		//IL_082a: Unknown result type (might be due to invalid IL or missing references)
		//IL_082f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0834: Unknown result type (might be due to invalid IL or missing references)
		//IL_0836: Unknown result type (might be due to invalid IL or missing references)
		//IL_083a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0840: Unknown result type (might be due to invalid IL or missing references)
		//IL_084a: Unknown result type (might be due to invalid IL or missing references)
		//IL_084f: Unknown result type (might be due to invalid IL or missing references)
		//IL_07cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07da: Unknown result type (might be due to invalid IL or missing references)
		//IL_07dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_089e: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_085d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0863: Unknown result type (might be due to invalid IL or missing references)
		//IL_086d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0872: Unknown result type (might be due to invalid IL or missing references)
		//IL_0877: Unknown result type (might be due to invalid IL or missing references)
		//IL_091a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0923: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c2f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c31: Unknown result type (might be due to invalid IL or missing references)
		//IL_0966: Unknown result type (might be due to invalid IL or missing references)
		//IL_0986: Unknown result type (might be due to invalid IL or missing references)
		//IL_099a: Unknown result type (might be due to invalid IL or missing references)
		//IL_09aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a3c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a5c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a70: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a80: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cd2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d4c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d53: Unknown result type (might be due to invalid IL or missing references)
		//IL_12bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_12c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1330: Unknown result type (might be due to invalid IL or missing references)
		//IL_1337: Unknown result type (might be due to invalid IL or missing references)
		//IL_10d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_10ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_10fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_114c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0eb3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0eca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ed8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f23: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f3e: Unknown result type (might be due to invalid IL or missing references)
		//IL_13a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_13a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1404: Unknown result type (might be due to invalid IL or missing references)
		//IL_1407: Unknown result type (might be due to invalid IL or missing references)
		//IL_140c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1411: Unknown result type (might be due to invalid IL or missing references)
		//IL_1226: Unknown result type (might be due to invalid IL or missing references)
		//IL_122d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1000: Unknown result type (might be due to invalid IL or missing references)
		//IL_1007: Unknown result type (might be due to invalid IL or missing references)
		//IL_1425: Unknown result type (might be due to invalid IL or missing references)
		//IL_16a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_16a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_16ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_1739: Unknown result type (might be due to invalid IL or missing references)
		//IL_173d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1742: Unknown result type (might be due to invalid IL or missing references)
		//IL_1744: Unknown result type (might be due to invalid IL or missing references)
		//IL_174d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1758: Unknown result type (might be due to invalid IL or missing references)
		//IL_175f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1770: Unknown result type (might be due to invalid IL or missing references)
		//IL_1777: Unknown result type (might be due to invalid IL or missing references)
		//IL_14f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_14fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_1500: Unknown result type (might be due to invalid IL or missing references)
		//IL_179e: Unknown result type (might be due to invalid IL or missing references)
		//IL_17a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_17ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_17b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_17bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_17bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_17c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_17c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_17c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1544: Unknown result type (might be due to invalid IL or missing references)
		//IL_154c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1551: Unknown result type (might be due to invalid IL or missing references)
		//IL_1532: Unknown result type (might be due to invalid IL or missing references)
		//IL_1534: Unknown result type (might be due to invalid IL or missing references)
		//IL_1536: Unknown result type (might be due to invalid IL or missing references)
		//IL_153b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1458: Unknown result type (might be due to invalid IL or missing references)
		//IL_145f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1444: Unknown result type (might be due to invalid IL or missing references)
		//IL_144b: Unknown result type (might be due to invalid IL or missing references)
		//IL_17e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_17d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_17d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_17d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_17de: Unknown result type (might be due to invalid IL or missing references)
		//IL_1488: Unknown result type (might be due to invalid IL or missing references)
		//IL_148f: Unknown result type (might be due to invalid IL or missing references)
		//IL_19fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a05: Unknown result type (might be due to invalid IL or missing references)
		//IL_1971: Unknown result type (might be due to invalid IL or missing references)
		//IL_1978: Unknown result type (might be due to invalid IL or missing references)
		//IL_15bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_15c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_15cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_15d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_183d: Unknown result type (might be due to invalid IL or missing references)
		//IL_185c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1862: Unknown result type (might be due to invalid IL or missing references)
		//IL_1864: Unknown result type (might be due to invalid IL or missing references)
		//IL_186b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1870: Unknown result type (might be due to invalid IL or missing references)
		//IL_1874: Unknown result type (might be due to invalid IL or missing references)
		//IL_187b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1882: Unknown result type (might be due to invalid IL or missing references)
		//IL_1889: Unknown result type (might be due to invalid IL or missing references)
		//IL_1aba: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ad3: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b9d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bb4: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bbc: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c0a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c25: Unknown result type (might be due to invalid IL or missing references)
		//IL_20fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_2100: Unknown result type (might be due to invalid IL or missing references)
		//IL_2105: Unknown result type (might be due to invalid IL or missing references)
		//IL_2107: Unknown result type (might be due to invalid IL or missing references)
		//IL_210c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2110: Unknown result type (might be due to invalid IL or missing references)
		//IL_2112: Unknown result type (might be due to invalid IL or missing references)
		//IL_1d91: Unknown result type (might be due to invalid IL or missing references)
		//IL_1da8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1db0: Unknown result type (might be due to invalid IL or missing references)
		//IL_1dfe: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e2f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c54: Unknown result type (might be due to invalid IL or missing references)
		//IL_2140: Unknown result type (might be due to invalid IL or missing references)
		//IL_2151: Unknown result type (might be due to invalid IL or missing references)
		//IL_2156: Unknown result type (might be due to invalid IL or missing references)
		//IL_215b: Unknown result type (might be due to invalid IL or missing references)
		//IL_215d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2169: Unknown result type (might be due to invalid IL or missing references)
		//IL_1fa8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1fbf: Unknown result type (might be due to invalid IL or missing references)
		//IL_1fc7: Unknown result type (might be due to invalid IL or missing references)
		//IL_2015: Unknown result type (might be due to invalid IL or missing references)
		//IL_2030: Unknown result type (might be due to invalid IL or missing references)
		//IL_203c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e5e: Unknown result type (might be due to invalid IL or missing references)
		//IL_22c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_22c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_22ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_22d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_22d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_22d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_22d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_217c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1cdf: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ce6: Unknown result type (might be due to invalid IL or missing references)
		//IL_23cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_23d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_2095: Unknown result type (might be due to invalid IL or missing references)
		//IL_209f: Unknown result type (might be due to invalid IL or missing references)
		//IL_20a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_20a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_20af: Unknown result type (might be due to invalid IL or missing references)
		//IL_20b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_20bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ed3: Unknown result type (might be due to invalid IL or missing references)
		//IL_1eda: Unknown result type (might be due to invalid IL or missing references)
		//IL_243d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2444: Unknown result type (might be due to invalid IL or missing references)
		//IL_2303: Unknown result type (might be due to invalid IL or missing references)
		//IL_230d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2313: Unknown result type (might be due to invalid IL or missing references)
		//IL_2315: Unknown result type (might be due to invalid IL or missing references)
		//IL_231a: Unknown result type (might be due to invalid IL or missing references)
		//IL_2197: Unknown result type (might be due to invalid IL or missing references)
		//IL_21ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_21bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_21c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_21d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_21d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_21db: Unknown result type (might be due to invalid IL or missing references)
		//IL_21e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_21e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_24b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_24bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_232d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2334: Unknown result type (might be due to invalid IL or missing references)
		//IL_233c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2343: Unknown result type (might be due to invalid IL or missing references)
		//IL_2320: Unknown result type (might be due to invalid IL or missing references)
		//IL_2322: Unknown result type (might be due to invalid IL or missing references)
		//IL_2324: Unknown result type (might be due to invalid IL or missing references)
		//IL_2329: Unknown result type (might be due to invalid IL or missing references)
		//IL_2200: Unknown result type (might be due to invalid IL or missing references)
		//IL_252f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2536: Unknown result type (might be due to invalid IL or missing references)
		//IL_2221: Unknown result type (might be due to invalid IL or missing references)
		//IL_2224: Unknown result type (might be due to invalid IL or missing references)
		//IL_2229: Unknown result type (might be due to invalid IL or missing references)
		//IL_222b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2234: Unknown result type (might be due to invalid IL or missing references)
		//IL_225d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2264: Unknown result type (might be due to invalid IL or missing references)
		//IL_2575: Unknown result type (might be due to invalid IL or missing references)
		//IL_257c: Unknown result type (might be due to invalid IL or missing references)
		//IL_27c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_27db: Unknown result type (might be due to invalid IL or missing references)
		//IL_27e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_27e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_27e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_2922: Unknown result type (might be due to invalid IL or missing references)
		//IL_2929: Unknown result type (might be due to invalid IL or missing references)
		//IL_292e: Unknown result type (might be due to invalid IL or missing references)
		//IL_2930: Unknown result type (might be due to invalid IL or missing references)
		//IL_2934: Unknown result type (might be due to invalid IL or missing references)
		//IL_2936: Unknown result type (might be due to invalid IL or missing references)
		//IL_2938: Unknown result type (might be due to invalid IL or missing references)
		//IL_2824: Unknown result type (might be due to invalid IL or missing references)
		//IL_283f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2844: Unknown result type (might be due to invalid IL or missing references)
		//IL_2849: Unknown result type (might be due to invalid IL or missing references)
		//IL_284b: Unknown result type (might be due to invalid IL or missing references)
		//IL_284d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2852: Unknown result type (might be due to invalid IL or missing references)
		//IL_2859: Unknown result type (might be due to invalid IL or missing references)
		//IL_2860: Unknown result type (might be due to invalid IL or missing references)
		//IL_25db: Unknown result type (might be due to invalid IL or missing references)
		//IL_25e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_25e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_297d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2987: Unknown result type (might be due to invalid IL or missing references)
		//IL_298d: Unknown result type (might be due to invalid IL or missing references)
		//IL_298f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2994: Unknown result type (might be due to invalid IL or missing references)
		//IL_28bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_28c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_28c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_28d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ba6: Unknown result type (might be due to invalid IL or missing references)
		//IL_2bad: Unknown result type (might be due to invalid IL or missing references)
		//IL_29a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_29a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_29aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_29ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_29ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_29b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_29b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_29b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_29b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_29be: Unknown result type (might be due to invalid IL or missing references)
		//IL_29c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_29c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_29cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_29d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_29d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_29df: Unknown result type (might be due to invalid IL or missing references)
		//IL_29e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_29e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_29ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_29f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_29f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_29fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a09: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a0c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2998: Unknown result type (might be due to invalid IL or missing references)
		//IL_299a: Unknown result type (might be due to invalid IL or missing references)
		//IL_299c: Unknown result type (might be due to invalid IL or missing references)
		//IL_29a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_25f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_25fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_2614: Unknown result type (might be due to invalid IL or missing references)
		//IL_2619: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ce3: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ce8: Unknown result type (might be due to invalid IL or missing references)
		//IL_2cf2: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d03: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d08: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d0d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d10: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d12: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d31: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d36: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d38: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d3a: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d3c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d41: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d46: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d4b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d55: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d5a: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d5e: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d65: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d6c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2d73: Unknown result type (might be due to invalid IL or missing references)
		//IL_2b53: Unknown result type (might be due to invalid IL or missing references)
		//IL_2b5a: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a51: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a54: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a59: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a27: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a29: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a2d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a36: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a3b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a40: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a45: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a4a: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a4f: Unknown result type (might be due to invalid IL or missing references)
		//IL_262a: Unknown result type (might be due to invalid IL or missing references)
		//IL_263b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2642: Unknown result type (might be due to invalid IL or missing references)
		//IL_2db7: Unknown result type (might be due to invalid IL or missing references)
		//IL_2dbc: Unknown result type (might be due to invalid IL or missing references)
		//IL_2bef: Unknown result type (might be due to invalid IL or missing references)
		//IL_2bf1: Unknown result type (might be due to invalid IL or missing references)
		//IL_2bf3: Unknown result type (might be due to invalid IL or missing references)
		//IL_2bf8: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c0d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c13: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c15: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c24: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c2e: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c33: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c38: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c3a: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c3c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c41: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c48: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c4d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c4f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c58: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c97: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c9e: Unknown result type (might be due to invalid IL or missing references)
		//IL_266d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f2f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f34: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e02: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e05: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e0a: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e0f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2de5: Unknown result type (might be due to invalid IL or missing references)
		//IL_2dec: Unknown result type (might be due to invalid IL or missing references)
		//IL_2df6: Unknown result type (might be due to invalid IL or missing references)
		//IL_2dfb: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e00: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ac3: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ac5: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a88: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a8a: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a8f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2a9b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2aa0: Unknown result type (might be due to invalid IL or missing references)
		//IL_2aa4: Unknown result type (might be due to invalid IL or missing references)
		//IL_2aa6: Unknown result type (might be due to invalid IL or missing references)
		//IL_28b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_28b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_26b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_316c: Unknown result type (might be due to invalid IL or missing references)
		//IL_3172: Unknown result type (might be due to invalid IL or missing references)
		//IL_3176: Unknown result type (might be due to invalid IL or missing references)
		//IL_317c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f7d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f80: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f85: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f8a: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f9b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2fa0: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f60: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f67: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f71: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f76: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f7b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e72: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e77: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e79: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e13: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e24: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e29: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e2e: Unknown result type (might be due to invalid IL or missing references)
		//IL_2683: Unknown result type (might be due to invalid IL or missing references)
		//IL_319c: Unknown result type (might be due to invalid IL or missing references)
		//IL_31a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_31a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_31ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e95: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e87: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e8e: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e93: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e3e: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e4d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e52: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e55: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e5a: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e5c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2e61: Unknown result type (might be due to invalid IL or missing references)
		//IL_31cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_31d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_31d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_31dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ecb: Unknown result type (might be due to invalid IL or missing references)
		//IL_2eda: Unknown result type (might be due to invalid IL or missing references)
		//IL_2edf: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ee3: Unknown result type (might be due to invalid IL or missing references)
		//IL_2eea: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ef1: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ef8: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f05: Unknown result type (might be due to invalid IL or missing references)
		//IL_2f0c: Unknown result type (might be due to invalid IL or missing references)
		//IL_26a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_30a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_30ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_30b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_30c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_30c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_2fbb: Unknown result type (might be due to invalid IL or missing references)
		//IL_2fcc: Unknown result type (might be due to invalid IL or missing references)
		//IL_2fd1: Unknown result type (might be due to invalid IL or missing references)
		//IL_2fd6: Unknown result type (might be due to invalid IL or missing references)
		//IL_2748: Unknown result type (might be due to invalid IL or missing references)
		//IL_2755: Unknown result type (might be due to invalid IL or missing references)
		//IL_2778: Unknown result type (might be due to invalid IL or missing references)
		//IL_302a: Unknown result type (might be due to invalid IL or missing references)
		//IL_3034: Unknown result type (might be due to invalid IL or missing references)
		//IL_3039: Unknown result type (might be due to invalid IL or missing references)
		//IL_303b: Unknown result type (might be due to invalid IL or missing references)
		//IL_303d: Unknown result type (might be due to invalid IL or missing references)
		//IL_3041: Unknown result type (might be due to invalid IL or missing references)
		//IL_3046: Unknown result type (might be due to invalid IL or missing references)
		//IL_304b: Unknown result type (might be due to invalid IL or missing references)
		//IL_304d: Unknown result type (might be due to invalid IL or missing references)
		//IL_304f: Unknown result type (might be due to invalid IL or missing references)
		//IL_3054: Unknown result type (might be due to invalid IL or missing references)
		//IL_3059: Unknown result type (might be due to invalid IL or missing references)
		//IL_2fe6: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ff5: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ffa: Unknown result type (might be due to invalid IL or missing references)
		//IL_2ffd: Unknown result type (might be due to invalid IL or missing references)
		//IL_3002: Unknown result type (might be due to invalid IL or missing references)
		//IL_3004: Unknown result type (might be due to invalid IL or missing references)
		//IL_3009: Unknown result type (might be due to invalid IL or missing references)
		//IL_3455: Unknown result type (might be due to invalid IL or missing references)
		//IL_345c: Unknown result type (might be due to invalid IL or missing references)
		//IL_30cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_30cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_30d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_30d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_30d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_30df: Unknown result type (might be due to invalid IL or missing references)
		//IL_30e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_30e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_30ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_30fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_30fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_3102: Unknown result type (might be due to invalid IL or missing references)
		//IL_3104: Unknown result type (might be due to invalid IL or missing references)
		//IL_3106: Unknown result type (might be due to invalid IL or missing references)
		//IL_3108: Unknown result type (might be due to invalid IL or missing references)
		//IL_310d: Unknown result type (might be due to invalid IL or missing references)
		//IL_312c: Unknown result type (might be due to invalid IL or missing references)
		//IL_312e: Unknown result type (might be due to invalid IL or missing references)
		//IL_3380: Unknown result type (might be due to invalid IL or missing references)
		//IL_3389: Unknown result type (might be due to invalid IL or missing references)
		//IL_34e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_34eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_32a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_32ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_3814: Unknown result type (might be due to invalid IL or missing references)
		//IL_381b: Unknown result type (might be due to invalid IL or missing references)
		//IL_35ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_35f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_3b15: Unknown result type (might be due to invalid IL or missing references)
		//IL_3b1c: Unknown result type (might be due to invalid IL or missing references)
		//IL_3bb0: Unknown result type (might be due to invalid IL or missing references)
		//IL_3bb7: Unknown result type (might be due to invalid IL or missing references)
		//IL_3c3a: Unknown result type (might be due to invalid IL or missing references)
		//IL_3c41: Unknown result type (might be due to invalid IL or missing references)
		//IL_3a57: Unknown result type (might be due to invalid IL or missing references)
		//IL_3a5e: Unknown result type (might be due to invalid IL or missing references)
		//IL_3966: Unknown result type (might be due to invalid IL or missing references)
		//IL_396d: Unknown result type (might be due to invalid IL or missing references)
		//IL_3cc3: Unknown result type (might be due to invalid IL or missing references)
		//IL_3cca: Unknown result type (might be due to invalid IL or missing references)
		//IL_3e70: Unknown result type (might be due to invalid IL or missing references)
		//IL_3e87: Unknown result type (might be due to invalid IL or missing references)
		//IL_3e8c: Unknown result type (might be due to invalid IL or missing references)
		//IL_3ed0: Unknown result type (might be due to invalid IL or missing references)
		//IL_3ed7: Unknown result type (might be due to invalid IL or missing references)
		//IL_3ede: Unknown result type (might be due to invalid IL or missing references)
		//IL_3ee5: Unknown result type (might be due to invalid IL or missing references)
		//IL_3d4c: Unknown result type (might be due to invalid IL or missing references)
		//IL_3d53: Unknown result type (might be due to invalid IL or missing references)
		//IL_3dd5: Unknown result type (might be due to invalid IL or missing references)
		//IL_3ddc: Unknown result type (might be due to invalid IL or missing references)
		//IL_4029: Unknown result type (might be due to invalid IL or missing references)
		//IL_402f: Unknown result type (might be due to invalid IL or missing references)
		//IL_4033: Unknown result type (might be due to invalid IL or missing references)
		//IL_4039: Unknown result type (might be due to invalid IL or missing references)
		//IL_406e: Unknown result type (might be due to invalid IL or missing references)
		//IL_4074: Unknown result type (might be due to invalid IL or missing references)
		//IL_4078: Unknown result type (might be due to invalid IL or missing references)
		//IL_407e: Unknown result type (might be due to invalid IL or missing references)
		//IL_3fcf: Unknown result type (might be due to invalid IL or missing references)
		//IL_3fd6: Unknown result type (might be due to invalid IL or missing references)
		//IL_40ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_40b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_40b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_40bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_40ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_40f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_40fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_40ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_4104: Unknown result type (might be due to invalid IL or missing references)
		//IL_410e: Unknown result type (might be due to invalid IL or missing references)
		//IL_4110: Unknown result type (might be due to invalid IL or missing references)
		//IL_4118: Unknown result type (might be due to invalid IL or missing references)
		//IL_4125: Unknown result type (might be due to invalid IL or missing references)
		//IL_412b: Unknown result type (might be due to invalid IL or missing references)
		//IL_412d: Unknown result type (might be due to invalid IL or missing references)
		//IL_4132: Unknown result type (might be due to invalid IL or missing references)
		//IL_413e: Unknown result type (might be due to invalid IL or missing references)
		//IL_4140: Unknown result type (might be due to invalid IL or missing references)
		//IL_4167: Unknown result type (might be due to invalid IL or missing references)
		//IL_416d: Unknown result type (might be due to invalid IL or missing references)
		//IL_4171: Unknown result type (might be due to invalid IL or missing references)
		//IL_4177: Unknown result type (might be due to invalid IL or missing references)
		//IL_41bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_41c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_41c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_41cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_41ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_41f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_41f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_41ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_4253: Unknown result type (might be due to invalid IL or missing references)
		//IL_4259: Unknown result type (might be due to invalid IL or missing references)
		//IL_425d: Unknown result type (might be due to invalid IL or missing references)
		//IL_4263: Unknown result type (might be due to invalid IL or missing references)
		//IL_46e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_46e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_46ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_46f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_43a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_43ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_43da: Unknown result type (might be due to invalid IL or missing references)
		//IL_43e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_4412: Unknown result type (might be due to invalid IL or missing references)
		//IL_4419: Unknown result type (might be due to invalid IL or missing references)
		//IL_444a: Unknown result type (might be due to invalid IL or missing references)
		//IL_4451: Unknown result type (might be due to invalid IL or missing references)
		//IL_4531: Unknown result type (might be due to invalid IL or missing references)
		//IL_4538: Unknown result type (might be due to invalid IL or missing references)
		//IL_4569: Unknown result type (might be due to invalid IL or missing references)
		//IL_4570: Unknown result type (might be due to invalid IL or missing references)
		//IL_4891: Unknown result type (might be due to invalid IL or missing references)
		//IL_4897: Unknown result type (might be due to invalid IL or missing references)
		//IL_489c: Unknown result type (might be due to invalid IL or missing references)
		//IL_48a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_48a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_48ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_48f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_490b: Unknown result type (might be due to invalid IL or missing references)
		//IL_497a: Unknown result type (might be due to invalid IL or missing references)
		//IL_498b: Unknown result type (might be due to invalid IL or missing references)
		//IL_4c21: Unknown result type (might be due to invalid IL or missing references)
		//IL_4c28: Unknown result type (might be due to invalid IL or missing references)
		//IL_4c2f: Unknown result type (might be due to invalid IL or missing references)
		//IL_4c3a: Unknown result type (might be due to invalid IL or missing references)
		//IL_4942: Unknown result type (might be due to invalid IL or missing references)
		//IL_4944: Unknown result type (might be due to invalid IL or missing references)
		//IL_494a: Unknown result type (might be due to invalid IL or missing references)
		//IL_494f: Unknown result type (might be due to invalid IL or missing references)
		//IL_499d: Unknown result type (might be due to invalid IL or missing references)
		//IL_49ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_4853: Unknown result type (might be due to invalid IL or missing references)
		//IL_485a: Unknown result type (might be due to invalid IL or missing references)
		//IL_4bb7: Unknown result type (might be due to invalid IL or missing references)
		//IL_4bbe: Unknown result type (might be due to invalid IL or missing references)
		//IL_496f: Unknown result type (might be due to invalid IL or missing references)
		//IL_4975: Unknown result type (might be due to invalid IL or missing references)
		//IL_4e25: Unknown result type (might be due to invalid IL or missing references)
		//IL_4e27: Unknown result type (might be due to invalid IL or missing references)
		//IL_4cb9: Unknown result type (might be due to invalid IL or missing references)
		//IL_4cbe: Unknown result type (might be due to invalid IL or missing references)
		//IL_4cd0: Unknown result type (might be due to invalid IL or missing references)
		//IL_4cd7: Unknown result type (might be due to invalid IL or missing references)
		//IL_4cdc: Unknown result type (might be due to invalid IL or missing references)
		//IL_4ce1: Unknown result type (might be due to invalid IL or missing references)
		//IL_4cfd: Unknown result type (might be due to invalid IL or missing references)
		//IL_4f36: Unknown result type (might be due to invalid IL or missing references)
		//IL_4f41: Unknown result type (might be due to invalid IL or missing references)
		//IL_4f46: Unknown result type (might be due to invalid IL or missing references)
		//IL_4f4c: Unknown result type (might be due to invalid IL or missing references)
		//IL_4f52: Unknown result type (might be due to invalid IL or missing references)
		//IL_4f57: Unknown result type (might be due to invalid IL or missing references)
		//IL_4f5c: Unknown result type (might be due to invalid IL or missing references)
		//IL_4f61: Unknown result type (might be due to invalid IL or missing references)
		//IL_4eed: Unknown result type (might be due to invalid IL or missing references)
		//IL_4eef: Unknown result type (might be due to invalid IL or missing references)
		//IL_4e70: Unknown result type (might be due to invalid IL or missing references)
		//IL_4e7b: Unknown result type (might be due to invalid IL or missing references)
		//IL_4e80: Unknown result type (might be due to invalid IL or missing references)
		//IL_4eb4: Unknown result type (might be due to invalid IL or missing references)
		//IL_4eb6: Unknown result type (might be due to invalid IL or missing references)
		//IL_4d2d: Unknown result type (might be due to invalid IL or missing references)
		//IL_4d33: Unknown result type (might be due to invalid IL or missing references)
		//IL_4d38: Unknown result type (might be due to invalid IL or missing references)
		//IL_4d3d: Unknown result type (might be due to invalid IL or missing references)
		//IL_4d97: Unknown result type (might be due to invalid IL or missing references)
		//IL_4da2: Unknown result type (might be due to invalid IL or missing references)
		//IL_4da7: Unknown result type (might be due to invalid IL or missing references)
		//IL_4dc4: Unknown result type (might be due to invalid IL or missing references)
		//IL_4dc6: Unknown result type (might be due to invalid IL or missing references)
		//IL_5021: Unknown result type (might be due to invalid IL or missing references)
		//IL_5026: Unknown result type (might be due to invalid IL or missing references)
		//IL_5030: Unknown result type (might be due to invalid IL or missing references)
		//IL_503b: Unknown result type (might be due to invalid IL or missing references)
		//IL_5040: Unknown result type (might be due to invalid IL or missing references)
		//IL_5046: Unknown result type (might be due to invalid IL or missing references)
		//IL_504a: Unknown result type (might be due to invalid IL or missing references)
		//IL_504c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5052: Unknown result type (might be due to invalid IL or missing references)
		//IL_507e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5089: Unknown result type (might be due to invalid IL or missing references)
		//IL_508e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5094: Unknown result type (might be due to invalid IL or missing references)
		//IL_509a: Unknown result type (might be due to invalid IL or missing references)
		//IL_509f: Unknown result type (might be due to invalid IL or missing references)
		//IL_50a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_50a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_5060: Unknown result type (might be due to invalid IL or missing references)
		//IL_5062: Unknown result type (might be due to invalid IL or missing references)
		//IL_5068: Unknown result type (might be due to invalid IL or missing references)
		//IL_506d: Unknown result type (might be due to invalid IL or missing references)
		//IL_4f8a: Unknown result type (might be due to invalid IL or missing references)
		//IL_4f8c: Unknown result type (might be due to invalid IL or missing references)
		//IL_4f92: Unknown result type (might be due to invalid IL or missing references)
		//IL_4f9e: Unknown result type (might be due to invalid IL or missing references)
		//IL_4fa8: Unknown result type (might be due to invalid IL or missing references)
		//IL_4fad: Unknown result type (might be due to invalid IL or missing references)
		//IL_4fc2: Unknown result type (might be due to invalid IL or missing references)
		//IL_4fc8: Unknown result type (might be due to invalid IL or missing references)
		//IL_4fca: Unknown result type (might be due to invalid IL or missing references)
		//IL_4d72: Unknown result type (might be due to invalid IL or missing references)
		//IL_4d87: Unknown result type (might be due to invalid IL or missing references)
		//IL_4d8c: Unknown result type (might be due to invalid IL or missing references)
		//IL_4d91: Unknown result type (might be due to invalid IL or missing references)
		//IL_4b3b: Unknown result type (might be due to invalid IL or missing references)
		//IL_4b5f: Unknown result type (might be due to invalid IL or missing references)
		//IL_4b66: Unknown result type (might be due to invalid IL or missing references)
		//IL_53cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_53d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_53f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_53f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_53fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_5183: Unknown result type (might be due to invalid IL or missing references)
		//IL_5187: Unknown result type (might be due to invalid IL or missing references)
		//IL_518d: Unknown result type (might be due to invalid IL or missing references)
		//IL_519b: Unknown result type (might be due to invalid IL or missing references)
		//IL_51a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_51a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_51ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_51b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_51fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_520c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5212: Unknown result type (might be due to invalid IL or missing references)
		//IL_5214: Unknown result type (might be due to invalid IL or missing references)
		//IL_522f: Unknown result type (might be due to invalid IL or missing references)
		//IL_5234: Unknown result type (might be due to invalid IL or missing references)
		//IL_523c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5243: Unknown result type (might be due to invalid IL or missing references)
		//IL_524a: Unknown result type (might be due to invalid IL or missing references)
		//IL_5255: Unknown result type (might be due to invalid IL or missing references)
		//IL_50ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_50d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_50d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_50e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_50ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_50f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_5108: Unknown result type (might be due to invalid IL or missing references)
		//IL_510e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5110: Unknown result type (might be due to invalid IL or missing references)
		//IL_52ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_52af: Unknown result type (might be due to invalid IL or missing references)
		//IL_52b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_52c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_52c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_52cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_52d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_52da: Unknown result type (might be due to invalid IL or missing references)
		//IL_531a: Unknown result type (might be due to invalid IL or missing references)
		//IL_5328: Unknown result type (might be due to invalid IL or missing references)
		//IL_532e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5330: Unknown result type (might be due to invalid IL or missing references)
		//IL_534b: Unknown result type (might be due to invalid IL or missing references)
		//IL_5350: Unknown result type (might be due to invalid IL or missing references)
		//IL_5358: Unknown result type (might be due to invalid IL or missing references)
		//IL_535a: Unknown result type (might be due to invalid IL or missing references)
		//IL_5365: Unknown result type (might be due to invalid IL or missing references)
		//IL_536a: Unknown result type (might be due to invalid IL or missing references)
		//IL_536f: Unknown result type (might be due to invalid IL or missing references)
		//IL_570a: Unknown result type (might be due to invalid IL or missing references)
		//IL_5710: Unknown result type (might be due to invalid IL or missing references)
		//IL_5410: Unknown result type (might be due to invalid IL or missing references)
		//IL_5418: Unknown result type (might be due to invalid IL or missing references)
		//IL_5438: Unknown result type (might be due to invalid IL or missing references)
		//IL_543d: Unknown result type (might be due to invalid IL or missing references)
		//IL_5442: Unknown result type (might be due to invalid IL or missing references)
		//IL_5448: Unknown result type (might be due to invalid IL or missing references)
		//IL_544c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5452: Unknown result type (might be due to invalid IL or missing references)
		//IL_5458: Unknown result type (might be due to invalid IL or missing references)
		//IL_545a: Unknown result type (might be due to invalid IL or missing references)
		//IL_545f: Unknown result type (might be due to invalid IL or missing references)
		//IL_5464: Unknown result type (might be due to invalid IL or missing references)
		//IL_546e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5473: Unknown result type (might be due to invalid IL or missing references)
		//IL_54b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_54b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_54bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_54c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_54cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_54d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_54d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_54dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_54e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_54e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_54ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_54f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_54f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_54fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_5504: Unknown result type (might be due to invalid IL or missing references)
		//IL_550a: Unknown result type (might be due to invalid IL or missing references)
		//IL_5515: Unknown result type (might be due to invalid IL or missing references)
		//IL_551a: Unknown result type (might be due to invalid IL or missing references)
		//IL_5522: Unknown result type (might be due to invalid IL or missing references)
		//IL_5528: Unknown result type (might be due to invalid IL or missing references)
		//IL_5582: Unknown result type (might be due to invalid IL or missing references)
		//IL_5584: Unknown result type (might be due to invalid IL or missing references)
		//IL_558a: Unknown result type (might be due to invalid IL or missing references)
		//IL_5590: Unknown result type (might be due to invalid IL or missing references)
		//IL_5595: Unknown result type (might be due to invalid IL or missing references)
		//IL_55ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_55c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_55c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_55d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_55db: Unknown result type (might be due to invalid IL or missing references)
		//IL_55e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_5602: Unknown result type (might be due to invalid IL or missing references)
		//IL_5604: Unknown result type (might be due to invalid IL or missing references)
		//IL_560a: Unknown result type (might be due to invalid IL or missing references)
		//IL_5610: Unknown result type (might be due to invalid IL or missing references)
		//IL_5615: Unknown result type (might be due to invalid IL or missing references)
		//IL_5640: Unknown result type (might be due to invalid IL or missing references)
		//IL_5646: Unknown result type (might be due to invalid IL or missing references)
		//IL_5648: Unknown result type (might be due to invalid IL or missing references)
		//IL_5657: Unknown result type (might be due to invalid IL or missing references)
		//IL_5661: Unknown result type (might be due to invalid IL or missing references)
		//IL_5666: Unknown result type (might be due to invalid IL or missing references)
		//IL_56a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_56a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_56aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_56b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_56bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_56c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_5751: Unknown result type (might be due to invalid IL or missing references)
		//IL_5756: Unknown result type (might be due to invalid IL or missing references)
		//IL_575b: Unknown result type (might be due to invalid IL or missing references)
		//IL_5779: Unknown result type (might be due to invalid IL or missing references)
		//IL_577f: Unknown result type (might be due to invalid IL or missing references)
		//IL_5781: Unknown result type (might be due to invalid IL or missing references)
		//IL_5786: Unknown result type (might be due to invalid IL or missing references)
		//IL_578d: Unknown result type (might be due to invalid IL or missing references)
		//IL_579c: Unknown result type (might be due to invalid IL or missing references)
		//IL_57a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_57a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_57ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_57b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_57bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_57c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_57c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_57cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_590f: Unknown result type (might be due to invalid IL or missing references)
		//IL_5920: Unknown result type (might be due to invalid IL or missing references)
		//IL_594f: Unknown result type (might be due to invalid IL or missing references)
		//IL_5958: Unknown result type (might be due to invalid IL or missing references)
		//IL_5835: Unknown result type (might be due to invalid IL or missing references)
		//IL_584a: Unknown result type (might be due to invalid IL or missing references)
		//IL_584f: Unknown result type (might be due to invalid IL or missing references)
		//IL_5854: Unknown result type (might be due to invalid IL or missing references)
		//IL_57fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_5823: Unknown result type (might be due to invalid IL or missing references)
		//IL_5828: Unknown result type (might be due to invalid IL or missing references)
		//IL_582d: Unknown result type (might be due to invalid IL or missing references)
		//IL_59c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_59d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_5a45: Unknown result type (might be due to invalid IL or missing references)
		//IL_5a56: Unknown result type (might be due to invalid IL or missing references)
		//IL_588e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5894: Unknown result type (might be due to invalid IL or missing references)
		//IL_589f: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ac5: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ad6: Unknown result type (might be due to invalid IL or missing references)
		//IL_5b09: Unknown result type (might be due to invalid IL or missing references)
		//IL_5b12: Unknown result type (might be due to invalid IL or missing references)
		//IL_5b81: Unknown result type (might be due to invalid IL or missing references)
		//IL_5b92: Unknown result type (might be due to invalid IL or missing references)
		//IL_5bc1: Unknown result type (might be due to invalid IL or missing references)
		//IL_5bd2: Unknown result type (might be due to invalid IL or missing references)
		//IL_5c44: Unknown result type (might be due to invalid IL or missing references)
		//IL_5c55: Unknown result type (might be due to invalid IL or missing references)
		//IL_5c88: Unknown result type (might be due to invalid IL or missing references)
		//IL_5c91: Unknown result type (might be due to invalid IL or missing references)
		//IL_5c9b: Unknown result type (might be due to invalid IL or missing references)
		//IL_5cf9: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d08: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d0e: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d13: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d18: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d1d: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d24: Unknown result type (might be due to invalid IL or missing references)
		//IL_6060: Unknown result type (might be due to invalid IL or missing references)
		//IL_6067: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d77: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d8c: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d91: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d96: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d65: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d6a: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d6f: Unknown result type (might be due to invalid IL or missing references)
		//IL_60ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_60b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_5d9d: Unknown result type (might be due to invalid IL or missing references)
		//IL_5dc3: Unknown result type (might be due to invalid IL or missing references)
		//IL_5dc9: Unknown result type (might be due to invalid IL or missing references)
		//IL_5dce: Unknown result type (might be due to invalid IL or missing references)
		//IL_5dd3: Unknown result type (might be due to invalid IL or missing references)
		//IL_5dd8: Unknown result type (might be due to invalid IL or missing references)
		//IL_5dde: Unknown result type (might be due to invalid IL or missing references)
		//IL_5de4: Unknown result type (might be due to invalid IL or missing references)
		//IL_5dea: Unknown result type (might be due to invalid IL or missing references)
		//IL_5def: Unknown result type (might be due to invalid IL or missing references)
		//IL_60f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_60ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_5e85: Unknown result type (might be due to invalid IL or missing references)
		//IL_5e90: Unknown result type (might be due to invalid IL or missing references)
		//IL_5e95: Unknown result type (might be due to invalid IL or missing references)
		//IL_5e9b: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ea1: Unknown result type (might be due to invalid IL or missing references)
		//IL_61db: Unknown result type (might be due to invalid IL or missing references)
		//IL_61e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f18: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f29: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f2f: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f34: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f4f: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f55: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f57: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f62: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f67: Unknown result type (might be due to invalid IL or missing references)
		//IL_619e: Unknown result type (might be due to invalid IL or missing references)
		//IL_61a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f87: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f92: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f97: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ebe: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ec4: Unknown result type (might be due to invalid IL or missing references)
		//IL_5eca: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ecf: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ed5: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ee4: Unknown result type (might be due to invalid IL or missing references)
		//IL_5eea: Unknown result type (might be due to invalid IL or missing references)
		//IL_5eec: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ef1: Unknown result type (might be due to invalid IL or missing references)
		//IL_6392: Unknown result type (might be due to invalid IL or missing references)
		//IL_6399: Unknown result type (might be due to invalid IL or missing references)
		//IL_63a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_63b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_63b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ff8: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ffe: Unknown result type (might be due to invalid IL or missing references)
		//IL_5fc0: Unknown result type (might be due to invalid IL or missing references)
		//IL_5fe3: Unknown result type (might be due to invalid IL or missing references)
		//IL_5fe9: Unknown result type (might be due to invalid IL or missing references)
		//IL_5feb: Unknown result type (might be due to invalid IL or missing references)
		//IL_5ff0: Unknown result type (might be due to invalid IL or missing references)
		//IL_63e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_63e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_63c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_63d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_63d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_63dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_627d: Unknown result type (might be due to invalid IL or missing references)
		//IL_628b: Unknown result type (might be due to invalid IL or missing references)
		//IL_62a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_62a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_62a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_62ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_62b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_62bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_62c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_62c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_62d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_649c: Unknown result type (might be due to invalid IL or missing references)
		//IL_64a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_644c: Unknown result type (might be due to invalid IL or missing references)
		//IL_6454: Unknown result type (might be due to invalid IL or missing references)
		//IL_66f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_66fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_6701: Unknown result type (might be due to invalid IL or missing references)
		//IL_6707: Unknown result type (might be due to invalid IL or missing references)
		//IL_670d: Unknown result type (might be due to invalid IL or missing references)
		//IL_6713: Unknown result type (might be due to invalid IL or missing references)
		//IL_6715: Unknown result type (might be due to invalid IL or missing references)
		//IL_671b: Unknown result type (might be due to invalid IL or missing references)
		//IL_672a: Unknown result type (might be due to invalid IL or missing references)
		//IL_672f: Unknown result type (might be due to invalid IL or missing references)
		//IL_6734: Unknown result type (might be due to invalid IL or missing references)
		//IL_67cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_67d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_675d: Unknown result type (might be due to invalid IL or missing references)
		//IL_6768: Unknown result type (might be due to invalid IL or missing references)
		//IL_6809: Unknown result type (might be due to invalid IL or missing references)
		//IL_6810: Unknown result type (might be due to invalid IL or missing references)
		//IL_6785: Unknown result type (might be due to invalid IL or missing references)
		//IL_6787: Unknown result type (might be due to invalid IL or missing references)
		//IL_6798: Unknown result type (might be due to invalid IL or missing references)
		//IL_6771: Unknown result type (might be due to invalid IL or missing references)
		//IL_6777: Unknown result type (might be due to invalid IL or missing references)
		//IL_6876: Unknown result type (might be due to invalid IL or missing references)
		//IL_687d: Unknown result type (might be due to invalid IL or missing references)
		//IL_6846: Unknown result type (might be due to invalid IL or missing references)
		//IL_684d: Unknown result type (might be due to invalid IL or missing references)
		//IL_673c: Unknown result type (might be due to invalid IL or missing references)
		//IL_6742: Unknown result type (might be due to invalid IL or missing references)
		//IL_674d: Unknown result type (might be due to invalid IL or missing references)
		//IL_6752: Unknown result type (might be due to invalid IL or missing references)
		//IL_6757: Unknown result type (might be due to invalid IL or missing references)
		if (!CombinedHooks.CanShoot(this, sItem))
		{
			return;
		}
		int projToShoot = sItem.shoot;
		float speed = sItem.shootSpeed;
		int damage = sItem.damage;
		if (sItem.melee && !ProjectileID.Sets.NoMeleeSpeedVelocityScaling[projToShoot])
		{
			speed /= inverseMeleeSpeed;
		}
		if (sItem.CountsAsClass(DamageClass.Throwing) && speed < 16f)
		{
			speed *= ThrownVelocity;
			if (speed > 16f)
			{
				speed = 16f;
			}
		}
		bool canShoot = false;
		int Damage = weaponDamage;
		float KnockBack = sItem.knockBack;
		int usedAmmoItemId = 0;
		if (sItem.useAmmo > 0)
		{
			PickAmmo(sItem, ref projToShoot, ref speed, ref canShoot, ref Damage, ref KnockBack, out usedAmmoItemId, ItemID.Sets.gunProj[sItem.type]);
		}
		else
		{
			canShoot = true;
		}
		if (ItemID.Sets.gunProj[sItem.type])
		{
			KnockBack = sItem.knockBack;
			Damage = weaponDamage;
			speed = sItem.shootSpeed;
		}
		if (sItem.IsACoin)
		{
			canShoot = false;
		}
		if (sItem.type == 1254 && projToShoot == 14)
		{
			projToShoot = 242;
		}
		if (sItem.type == 1255 && projToShoot == 14)
		{
			projToShoot = 242;
		}
		if (sItem.type == 1265 && projToShoot == 14)
		{
			projToShoot = 242;
		}
		if (sItem.type == 3542)
		{
			if (Main.rand.Next(100) < 20)
			{
				projToShoot++;
				Damage *= 3;
			}
			else
			{
				speed -= 1f;
			}
		}
		if (sItem.type == 1928)
		{
			Damage = (int)((float)Damage * 1f);
		}
		if (sItem.type == 3063)
		{
			Damage = (int)((float)Damage * 1.25f);
		}
		if (sItem.type == 1306)
		{
			Damage = (int)((double)Damage * 0.67);
		}
		if (sItem.type == 1227)
		{
			Damage = (int)((double)Damage * 0.7);
		}
		if (!canShoot)
		{
			return;
		}
		if (whoAmI != Main.myPlayer)
		{
			ApplyItemTime(sItem);
			return;
		}
		KnockBack = GetWeaponKnockback(sItem, KnockBack);
		IEntitySource projectileSource_Item_WithPotentialAmmo = GetProjectileSource_Item_WithPotentialAmmo(sItem, usedAmmoItemId);
		if (projToShoot == 228)
		{
			KnockBack = 0f;
		}
		if (projToShoot == 1 && sItem.type == 120)
		{
			projToShoot = 2;
		}
		if (sItem.type == 682)
		{
			projToShoot = 117;
		}
		if (sItem.type == 725)
		{
			projToShoot = 120;
		}
		if (sItem.type == 2796)
		{
			projToShoot = 442;
		}
		if (sItem.type == 2223)
		{
			projToShoot = 357;
		}
		if (sItem.type == 5117)
		{
			projToShoot = 968;
		}
		if (sItem.fishingPole > 0 && overrideFishingBobber > -1)
		{
			projToShoot = overrideFishingBobber;
		}
		ApplyItemTime(sItem);
		Vector2 pointPoisition = RotatedRelativePoint(MountedCenter);
		bool flag = true;
		_ = sItem.type;
		if (!sItem.ChangePlayerDirectionOnShoot)
		{
			flag = false;
		}
		Vector2 unitX = Vector2.UnitX;
		double radians = fullRotation;
		Vector2 val = default(Vector2);
		Vector2 val2 = unitX.RotatedBy(radians, val);
		Vector2 vector = Main.MouseWorld - pointPoisition;
		Vector2 v = itemRotation.ToRotationVector2() * (float)direction;
		if (sItem.type == 3852 && !ItemAnimationJustStarted)
		{
			vector = (v.ToRotation() + fullRotation).ToRotationVector2();
		}
		if (vector != Vector2.Zero)
		{
			((Vector2)(ref vector)).Normalize();
		}
		float num = Vector2.Dot(val2, vector);
		if (flag)
		{
			if (num > 0f)
			{
				ChangeDir(1);
			}
			else
			{
				ChangeDir(-1);
			}
		}
		if (sItem.type == 3094 || sItem.type == 3378 || sItem.type == 3543)
		{
			pointPoisition.Y = base.position.Y + (float)(height / 3);
		}
		if (sItem.type == 5117)
		{
			pointPoisition.Y = base.position.Y + (float)(height / 3);
		}
		if (sItem.type == 517)
		{
			pointPoisition.X += (float)Main.rand.Next(-3, 4) * 3.5f;
			pointPoisition.Y += (float)Main.rand.Next(-3, 4) * 3.5f;
		}
		if (sItem.type == 2611)
		{
			Vector2 vector12 = vector;
			if (vector12 != Vector2.Zero)
			{
				((Vector2)(ref vector12)).Normalize();
			}
			pointPoisition += vector12;
		}
		if (sItem.type == 3827)
		{
			Vector2 val3 = pointPoisition;
			Vector2 spinningpoint3 = vector.SafeNormalize(Vector2.Zero);
			double radians2 = (float)direction * (-(float)Math.PI / 2f);
			val = default(Vector2);
			pointPoisition = val3 + spinningpoint3.RotatedBy(radians2, val) * 24f;
		}
		if (projToShoot == 9)
		{
			((Vector2)(ref pointPoisition))._002Ector(base.position.X + (float)width * 0.5f + (float)(Main.rand.Next(201) * -direction) + ((float)Main.mouseX + Main.screenPosition.X - base.position.X), MountedCenter.Y - 600f);
			KnockBack = 0f;
			Damage = (int)((float)Damage * 1.5f);
		}
		if (sItem.type == 986 || sItem.type == 281)
		{
			pointPoisition.X += 6 * direction;
			pointPoisition.Y -= 6f * gravDir;
		}
		if (sItem.type == 3007)
		{
			pointPoisition.X -= 4 * direction;
			pointPoisition.Y -= 2f * gravDir;
		}
		float num102 = (float)Main.mouseX + Main.screenPosition.X - pointPoisition.X;
		float num113 = (float)Main.mouseY + Main.screenPosition.Y - pointPoisition.Y;
		if (sItem.type == 3852 && !ItemAnimationJustStarted)
		{
			Vector2 val4 = vector;
			num102 = val4.X;
			num113 = val4.Y;
		}
		if (gravDir == -1f)
		{
			num113 = Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY - pointPoisition.Y;
		}
		float num124 = (float)Math.Sqrt(num102 * num102 + num113 * num113);
		float num135 = num124;
		if ((float.IsNaN(num102) && float.IsNaN(num113)) || (num102 == 0f && num113 == 0f))
		{
			num102 = direction;
			num113 = 0f;
			num124 = speed;
		}
		else
		{
			num124 = speed / num124;
		}
		if (sItem.type == 1929 || sItem.type == 2270)
		{
			num102 += (float)Main.rand.Next(-50, 51) * 0.03f / num124;
			num113 += (float)Main.rand.Next(-50, 51) * 0.03f / num124;
		}
		num102 *= num124;
		num113 *= num124;
		if (projToShoot == 250)
		{
			for (int j = 0; j < 1000; j++)
			{
				if (Main.projectile[j].active && Main.projectile[j].owner == whoAmI && (Main.projectile[j].type == 250 || Main.projectile[j].type == 251))
				{
					Main.projectile[j].Kill();
				}
			}
		}
		if (projToShoot == 12 && Collision.CanHitLine(base.Center, 0, 0, pointPoisition + new Vector2(num102, num113) * 4f, 0, 0))
		{
			pointPoisition += new Vector2(num102, num113) * 3f;
		}
		if (projToShoot == 728 && !Collision.CanHitLine(base.Center, 0, 0, pointPoisition + new Vector2(num102, num113) * 2f, 0, 0))
		{
			Vector2 vector33 = new Vector2(num102, num113) * 0.25f;
			pointPoisition = base.Center - vector33;
		}
		if (projToShoot == 85)
		{
			Vector2 val5 = pointPoisition;
			Vector2 spinningpoint4 = new Vector2(0f, -6f * (float)direction * Directions.Y);
			double radians3 = vector.ToRotation();
			val = default(Vector2);
			pointPoisition = val5 + Utils.RotatedBy(spinningpoint4, radians3, val);
			if (Collision.CanHitLine(pointPoisition, 0, 0, pointPoisition + new Vector2(num102, num113) * 5f, 0, 0))
			{
				pointPoisition += new Vector2(num102, num113) * 4f;
			}
		}
		if (projToShoot == 802 || projToShoot == 842)
		{
			Vector2 v2 = default(Vector2);
			((Vector2)(ref v2))._002Ector(num102, num113);
			float num146 = (float)Math.PI / 4f;
			Vector2 spinningpoint5 = v2.SafeNormalize(Vector2.Zero);
			double radians4 = num146 * (Main.rand.NextFloat() - 0.5f);
			val = default(Vector2);
			Vector2 val6 = spinningpoint5.RotatedBy(radians4, val) * (((Vector2)(ref v2)).Length() - Main.rand.NextFloatDirection() * 0.7f);
			num102 = val6.X;
			num113 = val6.Y;
		}
		if (projToShoot == 17)
		{
			pointPoisition.X = (float)Main.mouseX + Main.screenPosition.X;
			pointPoisition.Y = (float)Main.mouseY + Main.screenPosition.Y;
			if (gravDir == -1f)
			{
				pointPoisition.Y = Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY;
			}
			LimitPointToPlayerReachableArea(ref pointPoisition);
		}
		Vector2 velocity = default(Vector2);
		((Vector2)(ref velocity))._002Ector(num102, num113);
		CombinedHooks.ModifyShootStats(this, sItem, ref pointPoisition, ref velocity, ref projToShoot, ref Damage, ref KnockBack);
		num102 = velocity.X;
		num113 = velocity.Y;
		if (sItem.useStyle == 5)
		{
			if (sItem.type == 3029)
			{
				Vector2 vector54 = default(Vector2);
				((Vector2)(ref vector54))._002Ector(num102, num113);
				vector54.X = (float)Main.mouseX + Main.screenPosition.X - pointPoisition.X;
				vector54.Y = (float)Main.mouseY + Main.screenPosition.Y - pointPoisition.Y - 1000f;
				itemRotation = (float)Math.Atan2(vector54.Y * (float)direction, vector54.X * (float)direction);
				NetMessage.SendData(13, -1, -1, null, whoAmI);
				NetMessage.SendData(41, -1, -1, null, whoAmI);
			}
			else if (sItem.type == 4381)
			{
				Vector2 vector56 = default(Vector2);
				((Vector2)(ref vector56))._002Ector(num102, num113);
				vector56.X = (float)Main.mouseX + Main.screenPosition.X - pointPoisition.X;
				vector56.Y = (float)Main.mouseY + Main.screenPosition.Y - pointPoisition.Y - 1000f;
				itemRotation = (float)Math.Atan2(vector56.Y * (float)direction, vector56.X * (float)direction);
				NetMessage.SendData(13, -1, -1, null, whoAmI);
				NetMessage.SendData(41, -1, -1, null, whoAmI);
			}
			else if (sItem.type == 3779)
			{
				itemRotation = 0f;
				NetMessage.SendData(13, -1, -1, null, whoAmI);
				NetMessage.SendData(41, -1, -1, null, whoAmI);
			}
			else
			{
				itemRotation = (float)Math.Atan2(num113 * (float)direction, num102 * (float)direction) - fullRotation;
				NetMessage.SendData(13, -1, -1, null, whoAmI);
				NetMessage.SendData(41, -1, -1, null, whoAmI);
			}
		}
		if (sItem.useStyle == 13)
		{
			itemRotation = (float)Math.Atan2(num113 * (float)direction, num102 * (float)direction) - fullRotation;
			NetMessage.SendData(13, -1, -1, null, whoAmI);
			NetMessage.SendData(41, -1, -1, null, whoAmI);
		}
		if (!CombinedHooks.Shoot(this, sItem, (EntitySource_ItemUse_WithAmmo)projectileSource_Item_WithPotentialAmmo, pointPoisition, velocity, projToShoot, Damage, KnockBack))
		{
			return;
		}
		if (projToShoot == 76)
		{
			projToShoot += Main.rand.Next(3);
			float num156 = (float)Main.screenHeight / Main.GameViewMatrix.Zoom.Y;
			num135 /= num156 / 2f;
			if (num135 > 1f)
			{
				num135 = 1f;
			}
			float num167 = num102 + (float)Main.rand.Next(-40, 41) * 0.01f;
			float num178 = num113 + (float)Main.rand.Next(-40, 41) * 0.01f;
			num167 *= num135 + 0.25f;
			num178 *= num135 + 0.25f;
			int num2 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num167, num178, projToShoot, Damage, KnockBack, i);
			Main.projectile[num2].ai[1] = 1f;
			num135 = num135 * 2f - 1f;
			if (num135 < -1f)
			{
				num135 = -1f;
			}
			if (num135 > 1f)
			{
				num135 = 1f;
			}
			num135 = (float)Math.Round(num135 * (float)musicNotes);
			num135 /= (float)musicNotes;
			Main.projectile[num2].ai[0] = num135;
			NetMessage.SendData(27, -1, -1, null, num2);
		}
		else if (sItem.type == 3029)
		{
			int num12 = 3;
			if (projToShoot == 91 || projToShoot == 4 || projToShoot == 5 || projToShoot == 41)
			{
				if (Main.rand.Next(3) == 0)
				{
					num12--;
				}
			}
			else if (Main.rand.Next(3) == 0)
			{
				num12++;
			}
			for (int k = 0; k < num12; k++)
			{
				((Vector2)(ref pointPoisition))._002Ector(base.position.X + (float)width * 0.5f + (float)(Main.rand.Next(201) * -direction) + ((float)Main.mouseX + Main.screenPosition.X - base.position.X), MountedCenter.Y - 600f);
				pointPoisition.X = (pointPoisition.X * 10f + base.Center.X) / 11f + (float)Main.rand.Next(-100, 101);
				pointPoisition.Y -= 150 * k;
				num102 = (float)Main.mouseX + Main.screenPosition.X - pointPoisition.X;
				num113 = (float)Main.mouseY + Main.screenPosition.Y - pointPoisition.Y;
				if (num113 < 0f)
				{
					num113 *= -1f;
				}
				if (num113 < 20f)
				{
					num113 = 20f;
				}
				num124 = (float)Math.Sqrt(num102 * num102 + num113 * num113);
				num124 = speed / num124;
				num102 *= num124;
				num113 *= num124;
				float num23 = num102 + (float)Main.rand.Next(-40, 41) * 0.03f;
				float speedY = num113 + (float)Main.rand.Next(-40, 41) * 0.03f;
				num23 *= (float)Main.rand.Next(75, 150) * 0.01f;
				pointPoisition.X += Main.rand.Next(-50, 51);
				int num34 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num23, speedY, projToShoot, Damage, KnockBack, i);
				Main.projectile[num34].noDropItem = true;
			}
		}
		else if (sItem.type == 4381)
		{
			int num45 = Main.rand.Next(1, 3);
			if (Main.rand.Next(3) == 0)
			{
				num45++;
			}
			for (int l = 0; l < num45; l++)
			{
				((Vector2)(ref pointPoisition))._002Ector(base.position.X + (float)width * 0.5f + (float)(Main.rand.Next(61) * -direction) + ((float)Main.mouseX + Main.screenPosition.X - base.position.X), MountedCenter.Y - 600f);
				pointPoisition.X = (pointPoisition.X * 10f + base.Center.X) / 11f + (float)Main.rand.Next(-30, 31);
				pointPoisition.Y -= 150f * Main.rand.NextFloat();
				num102 = (float)Main.mouseX + Main.screenPosition.X - pointPoisition.X;
				num113 = (float)Main.mouseY + Main.screenPosition.Y - pointPoisition.Y;
				if (num113 < 0f)
				{
					num113 *= -1f;
				}
				if (num113 < 20f)
				{
					num113 = 20f;
				}
				num124 = (float)Math.Sqrt(num102 * num102 + num113 * num113);
				num124 = speed / num124;
				num102 *= num124;
				num113 *= num124;
				float num56 = num102 + (float)Main.rand.Next(-20, 21) * 0.03f;
				float speedY3 = num113 + (float)Main.rand.Next(-40, 41) * 0.03f;
				num56 *= (float)Main.rand.Next(55, 80) * 0.01f;
				pointPoisition.X += Main.rand.Next(-50, 51);
				int num67 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num56, speedY3, projToShoot, Damage, KnockBack, i);
				Main.projectile[num67].noDropItem = true;
			}
		}
		else if (sItem.type == 98 || sItem.type == 533)
		{
			float speedX = num102 + (float)Main.rand.Next(-40, 41) * 0.01f;
			float speedY4 = num113 + (float)Main.rand.Next(-40, 41) * 0.01f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, speedX, speedY4, projToShoot, Damage, KnockBack, i);
		}
		else if (sItem.type == 1319)
		{
			float speedX2 = num102 + (float)Main.rand.Next(-40, 41) * 0.02f;
			float speedY5 = num113 + (float)Main.rand.Next(-40, 41) * 0.02f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, speedX2, speedY5, projToShoot, Damage, KnockBack, i);
		}
		else if (sItem.type == 3107)
		{
			float speedX3 = num102 + (float)Main.rand.Next(-40, 41) * 0.02f;
			float speedY6 = num113 + (float)Main.rand.Next(-40, 41) * 0.02f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, speedX3, speedY6, projToShoot, Damage, KnockBack, i);
		}
		else if (ProjectileID.Sets.IsAGolfBall[projToShoot])
		{
			Vector2 vector57 = default(Vector2);
			((Vector2)(ref vector57))._002Ector((float)Main.mouseX + Main.screenPosition.X, (float)Main.mouseY + Main.screenPosition.Y);
			Vector2 vector58 = vector57 - base.Center;
			bool flag2 = false;
			if (((Vector2)(ref vector58)).Length() < 100f)
			{
				flag2 = TryPlacingAGolfBallNearANearbyTee(vector57);
			}
			if (!flag2)
			{
				if (((Vector2)(ref vector58)).Length() > 100f || !Collision.CanHit(base.Center, 1, 1, vector57, 1, 1))
				{
					Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num102, num113, projToShoot, Damage, KnockBack, i);
				}
				else
				{
					Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, vector57.X, vector57.Y, 0f, 0f, projToShoot, Damage, KnockBack, i);
				}
			}
		}
		else if (sItem.type == 3053)
		{
			bool flag3 = false;
			if (itemAnimation <= sItem.useTime + 1)
			{
				flag3 = true;
			}
			Vector2 vector2 = default(Vector2);
			((Vector2)(ref vector2))._002Ector(num102, num113);
			((Vector2)(ref vector2)).Normalize();
			vector2 *= 4f;
			if (!flag3)
			{
				Vector2 vector3 = default(Vector2);
				((Vector2)(ref vector3))._002Ector((float)Main.rand.Next(-100, 101), (float)Main.rand.Next(-100, 101));
				((Vector2)(ref vector3)).Normalize();
				vector2 += vector3;
			}
			((Vector2)(ref vector2)).Normalize();
			vector2 *= sItem.shootSpeed;
			float num77 = (float)Main.rand.Next(10, 80) * 0.001f;
			if (Main.rand.Next(2) == 0)
			{
				num77 *= -1f;
			}
			float num87 = (float)Main.rand.Next(10, 80) * 0.001f;
			if (Main.rand.Next(2) == 0)
			{
				num87 *= -1f;
			}
			if (flag3)
			{
				num87 = (num77 = 0f);
			}
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, vector2.X, vector2.Y, projToShoot, Damage, KnockBack, i, num87, num77);
		}
		else if (sItem.type == 3019)
		{
			Vector2 vector4 = default(Vector2);
			((Vector2)(ref vector4))._002Ector(num102, num113);
			float num98 = ((Vector2)(ref vector4)).Length();
			vector4.X += (float)Main.rand.Next(-100, 101) * 0.01f * num98 * 0.15f;
			vector4.Y += (float)Main.rand.Next(-100, 101) * 0.01f * num98 * 0.15f;
			float num103 = num102 + (float)Main.rand.Next(-40, 41) * 0.03f;
			float num104 = num113 + (float)Main.rand.Next(-40, 41) * 0.03f;
			((Vector2)(ref vector4)).Normalize();
			vector4 *= num98;
			num103 *= (float)Main.rand.Next(50, 150) * 0.01f;
			num104 *= (float)Main.rand.Next(50, 150) * 0.01f;
			Vector2 vector5 = default(Vector2);
			((Vector2)(ref vector5))._002Ector(num103, num104);
			vector5.X += (float)Main.rand.Next(-100, 101) * 0.025f;
			vector5.Y += (float)Main.rand.Next(-100, 101) * 0.025f;
			((Vector2)(ref vector5)).Normalize();
			vector5 *= num98;
			num103 = vector5.X;
			num104 = vector5.Y;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num103, num104, projToShoot, Damage, KnockBack, i, vector4.X, vector4.Y);
		}
		else if (sItem.type == 2797)
		{
			Vector2 vector6 = Vector2.Normalize(new Vector2(num102, num113)) * 40f * sItem.scale;
			if (Collision.CanHit(pointPoisition, 0, 0, pointPoisition + vector6, 0, 0))
			{
				pointPoisition += vector6;
			}
			float ai = Utils.ToRotation(new Vector2(num102, num113));
			float num105 = (float)Math.PI * 2f / 3f;
			int num106 = Main.rand.Next(4, 5);
			if (Main.rand.Next(4) == 0)
			{
				num106++;
			}
			for (int m = 0; m < num106; m++)
			{
				float num107 = (float)Main.rand.NextDouble() * 0.2f + 0.05f;
				Vector2 spinningpoint6 = new Vector2(num102, num113);
				double radians5 = num105 * (float)Main.rand.NextDouble() - num105 / 2f;
				val = default(Vector2);
				Vector2 vector7 = Utils.RotatedBy(spinningpoint6, radians5, val) * num107;
				int num108 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, vector7.X, vector7.Y, 444, Damage, KnockBack, i, ai);
				Main.projectile[num108].localAI[0] = projToShoot;
				Main.projectile[num108].localAI[1] = speed;
			}
		}
		else if (sItem.type == 2270)
		{
			float num109 = num102 + (float)Main.rand.Next(-40, 41) * 0.05f;
			float num110 = num113 + (float)Main.rand.Next(-40, 41) * 0.05f;
			if (Main.rand.Next(3) == 0)
			{
				num109 *= 1f + (float)Main.rand.Next(-30, 31) * 0.02f;
				num110 *= 1f + (float)Main.rand.Next(-30, 31) * 0.02f;
			}
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num109, num110, projToShoot, Damage, KnockBack, i);
		}
		else if (sItem.type == 5117)
		{
			float speedX4 = num102 + (float)Main.rand.Next(-15, 16) * 0.075f;
			float speedY7 = num113 + (float)Main.rand.Next(-15, 16) * 0.075f;
			int num111 = Main.rand.Next(Main.projFrames[sItem.shoot]);
			int damage2 = Damage;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, speedX4, speedY7, projToShoot, damage2, KnockBack, i, 0f, num111);
		}
		else if (sItem.type == 1930)
		{
			int num112 = 2 + Main.rand.Next(3);
			for (int n = 0; n < num112; n++)
			{
				float num114 = num102;
				float num115 = num113;
				float num116 = 0.025f * (float)n;
				num114 += (float)Main.rand.Next(-35, 36) * num116;
				num115 += (float)Main.rand.Next(-35, 36) * num116;
				num124 = (float)Math.Sqrt(num114 * num114 + num115 * num115);
				num124 = speed / num124;
				num114 *= num124;
				num115 *= num124;
				float x = pointPoisition.X + num102 * (float)(num112 - n) * 1.75f;
				float y = pointPoisition.Y + num113 * (float)(num112 - n) * 1.75f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, x, y, num114, num115, projToShoot, Damage, KnockBack, i, Main.rand.Next(0, 10 * (n + 1)));
			}
		}
		else if (sItem.type == 1931)
		{
			int num117 = 2;
			for (int num118 = 0; num118 < num117; num118++)
			{
				((Vector2)(ref pointPoisition))._002Ector(base.position.X + (float)width * 0.5f + (float)(Main.rand.Next(201) * -direction) + ((float)Main.mouseX + Main.screenPosition.X - base.position.X), MountedCenter.Y - 600f);
				pointPoisition.X = (pointPoisition.X + base.Center.X) / 2f + (float)Main.rand.Next(-200, 201);
				pointPoisition.Y -= 100 * num118;
				num102 = (float)Main.mouseX + Main.screenPosition.X - pointPoisition.X;
				num113 = (float)Main.mouseY + Main.screenPosition.Y - pointPoisition.Y;
				if (gravDir == -1f)
				{
					num113 = Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY - pointPoisition.Y;
				}
				if (num113 < 0f)
				{
					num113 *= -1f;
				}
				if (num113 < 20f)
				{
					num113 = 20f;
				}
				num124 = (float)Math.Sqrt(num102 * num102 + num113 * num113);
				num124 = speed / num124;
				num102 *= num124;
				num113 *= num124;
				float speedX5 = num102 + (float)Main.rand.Next(-40, 41) * 0.02f;
				float speedY8 = num113 + (float)Main.rand.Next(-40, 41) * 0.02f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, speedX5, speedY8, projToShoot, Damage, KnockBack, i, 0f, Main.rand.Next(5));
			}
		}
		else if (sItem.type == 2750)
		{
			int num119 = 1;
			for (int num120 = 0; num120 < num119; num120++)
			{
				((Vector2)(ref pointPoisition))._002Ector(base.position.X + (float)width * 0.5f + (float)(Main.rand.Next(201) * -direction) + ((float)Main.mouseX + Main.screenPosition.X - base.position.X), MountedCenter.Y - 600f);
				pointPoisition.X = (pointPoisition.X + base.Center.X) / 2f + (float)Main.rand.Next(-200, 201);
				pointPoisition.Y -= 100 * num120;
				num102 = (float)Main.mouseX + Main.screenPosition.X - pointPoisition.X + (float)Main.rand.Next(-40, 41) * 0.03f;
				num113 = (float)Main.mouseY + Main.screenPosition.Y - pointPoisition.Y;
				if (gravDir == -1f)
				{
					num113 = Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY - pointPoisition.Y;
				}
				if (num113 < 0f)
				{
					num113 *= -1f;
				}
				if (num113 < 20f)
				{
					num113 = 20f;
				}
				num124 = (float)Math.Sqrt(num102 * num102 + num113 * num113);
				num124 = speed / num124;
				num102 *= num124;
				num113 *= num124;
				float num121 = num102;
				float num122 = num113 + (float)Main.rand.Next(-40, 41) * 0.02f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num121 * 0.75f, num122 * 0.75f, projToShoot + Main.rand.Next(3), Damage, KnockBack, i, 0f, 0.5f + (float)Main.rand.NextDouble() * 0.3f);
			}
		}
		else if (sItem.type == 3570)
		{
			int num123 = 3;
			for (int num125 = 0; num125 < num123; num125++)
			{
				((Vector2)(ref pointPoisition))._002Ector(base.position.X + (float)width * 0.5f + (float)(Main.rand.Next(201) * -direction) + ((float)Main.mouseX + Main.screenPosition.X - base.position.X), MountedCenter.Y - 600f);
				pointPoisition.X = (pointPoisition.X + base.Center.X) / 2f + (float)Main.rand.Next(-200, 201);
				pointPoisition.Y -= 100 * num125;
				num102 = (float)Main.mouseX + Main.screenPosition.X - pointPoisition.X;
				num113 = (float)Main.mouseY + Main.screenPosition.Y - pointPoisition.Y;
				float ai2 = num113 + pointPoisition.Y;
				if (num113 < 0f)
				{
					num113 *= -1f;
				}
				if (num113 < 20f)
				{
					num113 = 20f;
				}
				num124 = (float)Math.Sqrt(num102 * num102 + num113 * num113);
				num124 = speed / num124;
				num102 *= num124;
				num113 *= num124;
				Vector2 vector8 = new Vector2(num102, num113) / 2f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, vector8.X, vector8.Y, projToShoot, Damage, KnockBack, i, 0f, ai2);
			}
		}
		else if (sItem.type == 5065)
		{
			Vector2 farthestSpawnPositionOnLine = GetFarthestSpawnPositionOnLine(pointPoisition, num102, num113);
			Vector2 zero = Vector2.Zero;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, farthestSpawnPositionOnLine, zero, projToShoot, Damage, KnockBack, i);
		}
		else if (sItem.type == 3065)
		{
			Vector2 vector9 = Main.screenPosition + new Vector2((float)Main.mouseX, (float)Main.mouseY);
			float num126 = vector9.Y;
			if (num126 > base.Center.Y - 200f)
			{
				num126 = base.Center.Y - 200f;
			}
			for (int num127 = 0; num127 < 3; num127++)
			{
				pointPoisition = base.Center + new Vector2((float)(-Main.rand.Next(0, 401) * direction), -600f);
				pointPoisition.Y -= 100 * num127;
				Vector2 vector10 = vector9 - pointPoisition;
				if (vector10.Y < 0f)
				{
					vector10.Y *= -1f;
				}
				if (vector10.Y < 20f)
				{
					vector10.Y = 20f;
				}
				((Vector2)(ref vector10)).Normalize();
				vector10 *= speed;
				num102 = vector10.X;
				num113 = vector10.Y;
				float speedX6 = num102;
				float speedY9 = num113 + (float)Main.rand.Next(-40, 41) * 0.02f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, speedX6, speedY9, projToShoot, Damage, KnockBack, i, 0f, num126);
			}
		}
		else if (sItem.type == 2624)
		{
			float num128 = (float)Math.PI / 10f;
			int num129 = 5;
			Vector2 vector11 = default(Vector2);
			((Vector2)(ref vector11))._002Ector(num102, num113);
			((Vector2)(ref vector11)).Normalize();
			vector11 *= 40f;
			bool flag4 = Collision.CanHit(pointPoisition, 0, 0, pointPoisition + vector11, 0, 0);
			for (int num130 = 0; num130 < num129; num130++)
			{
				float num131 = (float)num130 - ((float)num129 - 1f) / 2f;
				Vector2 spinningpoint7 = vector11;
				double radians6 = num128 * num131;
				val = default(Vector2);
				Vector2 vector13 = spinningpoint7.RotatedBy(radians6, val);
				if (!flag4)
				{
					vector13 -= vector11;
				}
				int num132 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X + vector13.X, pointPoisition.Y + vector13.Y, num102, num113, projToShoot, Damage, KnockBack, i);
				Main.projectile[num132].noDropItem = true;
			}
		}
		else if (sItem.type == 1929)
		{
			float speedX7 = num102 + (float)Main.rand.Next(-40, 41) * 0.03f;
			float speedY10 = num113 + (float)Main.rand.Next(-40, 41) * 0.03f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, speedX7, speedY10, projToShoot, Damage, KnockBack, i);
		}
		else if (sItem.type == 1553)
		{
			float speedX8 = num102 + (float)Main.rand.Next(-40, 41) * 0.005f;
			float speedY2 = num113 + (float)Main.rand.Next(-40, 41) * 0.005f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, speedX8, speedY2, projToShoot, Damage, KnockBack, i);
		}
		else if (sItem.type == 518)
		{
			float num133 = num102;
			float num134 = num113;
			num133 += (float)Main.rand.Next(-40, 41) * 0.04f;
			num134 += (float)Main.rand.Next(-40, 41) * 0.04f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num133, num134, projToShoot, Damage, KnockBack, i);
		}
		else if (sItem.type == 1265)
		{
			float num136 = num102;
			float num137 = num113;
			num136 += (float)Main.rand.Next(-30, 31) * 0.03f;
			num137 += (float)Main.rand.Next(-30, 31) * 0.03f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num136, num137, projToShoot, Damage, KnockBack, i);
		}
		else if (sItem.type == 4262)
		{
			float num138 = 2.6666667f;
			_ = base.Bottom;
			_ = (int)base.Bottom.X / 16;
			int num139 = 4;
			float num140 = Math.Abs((float)Main.mouseX + Main.screenPosition.X - base.position.X) / 16f;
			if (direction < 0)
			{
				num140 += 1f;
			}
			num139 = (int)num140;
			if (num139 > 15)
			{
				num139 = 15;
			}
			Point point = base.Center.ToTileCoordinates();
			int maxDistance = 31;
			for (int num141 = num139; num141 >= 0; num141--)
			{
				if (Collision.CanHitLine(base.Center, 1, 1, base.Center + new Vector2((float)(16 * num141 * direction), 0f), 1, 1) && WorldUtils.Find(new Point(point.X + direction * num141, point.Y), Searches.Chain(new Searches.Down(maxDistance), new Terraria.WorldBuilding.Conditions.MysticSnake()), out var result))
				{
					int num142 = result.Y;
					while (Main.tile[result.X, num142 - 1].active())
					{
						num142--;
						if (Main.tile[result.X, num142 - 1] == null || num142 < 10 || result.Y - num142 > 7)
						{
							num142 = -1;
							break;
						}
					}
					if (num142 >= 10)
					{
						result.Y = num142;
						for (int num143 = 0; num143 < 1000; num143++)
						{
							Projectile projectile = Main.projectile[num143];
							if (projectile.active && projectile.owner == whoAmI && projectile.type == projToShoot)
							{
								if (projectile.ai[1] == 2f)
								{
									projectile.timeLeft = 4;
								}
								else
								{
									projectile.Kill();
								}
							}
						}
						Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, result.X * 16 + 8, result.Y * 16 + 8 - 16, 0f, 0f - num138, projToShoot, Damage, KnockBack, i, result.Y * 16 + 8 - 16);
						break;
					}
				}
			}
		}
		else if (sItem.type == 4952)
		{
			Vector2 vector14 = Main.rand.NextVector2Circular(1f, 1f) + Main.rand.NextVector2CircularEdge(3f, 3f);
			if (vector14.Y > 0f)
			{
				vector14.Y *= -1f;
			}
			float num144 = (float)itemAnimation / (float)itemAnimationMax * 0.66f + miscCounterNormalized;
			pointPoisition = MountedCenter + new Vector2((float)(direction * 15), gravDir * 3f);
			Point point2 = pointPoisition.ToTileCoordinates();
			Tile tile = Main.tile[point2.X, point2.Y];
			if (tile != null && tile.nactive() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type] && !TileID.Sets.Platforms[tile.type])
			{
				pointPoisition = MountedCenter;
			}
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, vector14.X, vector14.Y, projToShoot, Damage, KnockBack, i, -1f, num144 % 1f);
		}
		else if (sItem.type == 4953)
		{
			float num145 = (float)Math.PI / 10f;
			int num147 = 5;
			Vector2 vector15 = default(Vector2);
			((Vector2)(ref vector15))._002Ector(num102, num113);
			((Vector2)(ref vector15)).Normalize();
			vector15 *= 40f;
			bool num189 = Collision.CanHit(pointPoisition, 0, 0, pointPoisition + vector15, 0, 0);
			int num148 = (itemAnimationMax - itemAnimation) / 2;
			int num149 = num148;
			if (direction == 1)
			{
				num149 = 4 - num148;
			}
			float num150 = (float)num149 - ((float)num147 - 1f) / 2f;
			Vector2 spinningpoint8 = vector15;
			double radians7 = num145 * num150;
			val = default(Vector2);
			Vector2 vector16 = spinningpoint8.RotatedBy(radians7, val);
			if (!num189)
			{
				vector16 -= vector15;
			}
			Vector2 mouseWorld = Main.MouseWorld;
			Vector2 origin = pointPoisition + vector16;
			Vector2 vector17 = origin.DirectionTo(mouseWorld).SafeNormalize(-Vector2.UnitY);
			Vector2 value2 = base.Center.DirectionTo(base.Center + new Vector2(num102, num113)).SafeNormalize(-Vector2.UnitY);
			float lerpValue = Utils.GetLerpValue(100f, 40f, mouseWorld.Distance(base.Center), clamped: true);
			if (lerpValue > 0f)
			{
				vector17 = Vector2.Lerp(vector17, value2, lerpValue).SafeNormalize(Utils.SafeNormalize(new Vector2(num102, num113), -Vector2.UnitY));
			}
			Vector2 v3 = vector17 * speed;
			if (num148 == 2)
			{
				projToShoot = 932;
				Damage *= 2;
			}
			if (projToShoot == 932)
			{
				float ai3 = miscCounterNormalized * 12f % 1f;
				v3 = v3.SafeNormalize(Vector2.Zero) * (speed * 2f);
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, origin, v3, projToShoot, Damage, KnockBack, i, 0f, ai3);
			}
			else
			{
				int num151 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, origin, v3, projToShoot, Damage, KnockBack, i);
				Main.projectile[num151].noDropItem = true;
			}
		}
		else if (sItem.type == 534)
		{
			int num152 = Main.rand.Next(4, 6);
			for (int num153 = 0; num153 < num152; num153++)
			{
				float num154 = num102;
				float num155 = num113;
				num154 += (float)Main.rand.Next(-40, 41) * 0.05f;
				num155 += (float)Main.rand.Next(-40, 41) * 0.05f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num154, num155, projToShoot, Damage, KnockBack, i);
			}
		}
		else if (sItem.type == 4703)
		{
			float num157 = (float)Math.PI / 2f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num102, num113, projToShoot, Damage, KnockBack, i);
			Vector2 v4 = default(Vector2);
			for (int num158 = 0; num158 < 7; num158++)
			{
				((Vector2)(ref v4))._002Ector(num102, num113);
				float num159 = ((Vector2)(ref v4)).Length();
				Vector2 val7 = v4;
				Vector2 spinningpoint9 = v4.SafeNormalize(Vector2.Zero);
				double radians8 = num157 * Main.rand.NextFloat();
				val = default(Vector2);
				v4 = val7 + spinningpoint9.RotatedBy(radians8, val) * Main.rand.NextFloatDirection() * 5f;
				v4 = v4.SafeNormalize(Vector2.Zero) * num159;
				float x2 = v4.X;
				float y2 = v4.Y;
				x2 += (float)Main.rand.Next(-40, 41) * 0.05f;
				y2 += (float)Main.rand.Next(-40, 41) * 0.05f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, x2, y2, projToShoot, Damage, KnockBack, i);
			}
		}
		else if (sItem.type == 4270)
		{
			Vector2 pointPoisition2 = Main.MouseWorld;
			LimitPointToPlayerReachableArea(ref pointPoisition2);
			Vector2 vector18 = pointPoisition2 + Main.rand.NextVector2Circular(8f, 8f);
			Vector2 vector19 = FindSharpTearsSpot(vector18).ToWorldCoordinates(Main.rand.Next(17), Main.rand.Next(17));
			Vector2 vector20 = (vector18 - vector19).SafeNormalize(-Vector2.UnitY) * 16f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, vector19.X, vector19.Y, vector20.X, vector20.Y, projToShoot, Damage, KnockBack, i, 0f, Main.rand.NextFloat() * 0.5f + 0.6f);
		}
		else if (sItem.type == 4715)
		{
			Vector2 vector21 = Main.MouseWorld;
			List<NPC> validTargets;
			bool sparkleGuitarTarget3 = GetSparkleGuitarTarget(out validTargets);
			if (sparkleGuitarTarget3)
			{
				NPC nPC = validTargets[Main.rand.Next(validTargets.Count)];
				vector21 = nPC.Center + nPC.velocity * 20f;
			}
			Vector2 vector22 = vector21 - base.Center;
			if (!sparkleGuitarTarget3)
			{
				vector21 += Main.rand.NextVector2Circular(24f, 24f);
				if (((Vector2)(ref vector22)).Length() > 700f)
				{
					vector22 *= 700f / ((Vector2)(ref vector22)).Length();
					vector21 = base.Center + vector22;
				}
			}
			Vector2 vector23 = Main.rand.NextVector2CircularEdge(1f, 1f);
			if (vector23.Y > 0f)
			{
				vector23 *= -1f;
			}
			if (Math.Abs(vector23.Y) < 0.5f)
			{
				vector23.Y = (0f - Main.rand.NextFloat()) * 0.5f - 0.5f;
			}
			vector23 *= ((Vector2)(ref vector22)).Length() * 2f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, vector23.X, vector23.Y, projToShoot, Damage, KnockBack, i, vector21.X, vector21.Y);
		}
		else if (sItem.type == 4722)
		{
			Vector2 vector24 = Main.MouseWorld;
			List<NPC> validTargets2;
			bool sparkleGuitarTarget2 = GetSparkleGuitarTarget(out validTargets2);
			if (sparkleGuitarTarget2)
			{
				NPC nPC2 = validTargets2[Main.rand.Next(validTargets2.Count)];
				vector24 = nPC2.Center + nPC2.velocity * 20f;
			}
			Vector2 vector25 = vector24 - base.Center;
			Vector2 vector26 = Main.rand.NextVector2CircularEdge(1f, 1f);
			float num160 = 1f;
			int num161 = 1;
			Vector2 vector28 = default(Vector2);
			for (int num162 = 0; num162 < num161; num162++)
			{
				if (!sparkleGuitarTarget2)
				{
					vector24 += Main.rand.NextVector2Circular(24f, 24f);
					if (((Vector2)(ref vector25)).Length() > 700f)
					{
						vector25 *= 700f / ((Vector2)(ref vector25)).Length();
						vector24 = base.Center + vector25;
					}
					float num163 = Utils.GetLerpValue(0f, 6f, ((Vector2)(ref velocity)).Length(), clamped: true) * 0.8f;
					vector26 *= 1f - num163;
					vector26 += velocity * num163;
					vector26 = vector26.SafeNormalize(Vector2.UnitX);
				}
				float num164 = 60f;
				float num165 = Main.rand.NextFloatDirection() * (float)Math.PI * (1f / num164) * 0.5f * num160;
				float num166 = num164 / 2f;
				float num168 = 12f + Main.rand.NextFloat() * 2f;
				Vector2 vector27 = vector26 * num168;
				((Vector2)(ref vector28))._002Ector(0f, 0f);
				Vector2 vector29 = vector27;
				for (int num169 = 0; (float)num169 < num166; num169++)
				{
					vector28 += vector29;
					Vector2 spinningpoint10 = vector29;
					double radians9 = num165;
					val = default(Vector2);
					vector29 = spinningpoint10.RotatedBy(radians9, val);
				}
				Vector2 vector30 = -vector28;
				Vector2 vector31 = vector24 + vector30;
				float lerpValue2 = Utils.GetLerpValue(itemAnimationMax, 0f, itemAnimation, clamped: true);
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, vector31, vector27, projToShoot, Damage, KnockBack, i, num165, lerpValue2);
			}
		}
		else if (sItem.type == 4607)
		{
			int minionProjectileId = projToShoot;
			float knockBack = KnockBack;
			val = default(Vector2);
			Vector2 offsetFromCursor = val;
			val = default(Vector2);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, minionProjectileId, damage, knockBack, offsetFromCursor, val);
		}
		else if (sItem.type == 5069)
		{
			int minionProjectileId2 = projToShoot;
			float knockBack2 = KnockBack;
			val = default(Vector2);
			Vector2 offsetFromCursor2 = val;
			val = default(Vector2);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, minionProjectileId2, damage, knockBack2, offsetFromCursor2, val);
		}
		else if (sItem.type == 5114)
		{
			int minionProjectileId3 = projToShoot;
			float knockBack3 = KnockBack;
			val = default(Vector2);
			Vector2 offsetFromCursor3 = val;
			val = default(Vector2);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, minionProjectileId3, damage, knockBack3, offsetFromCursor3, val);
		}
		else if (sItem.type == 2188)
		{
			int num170 = 4;
			if (Main.rand.Next(3) == 0)
			{
				num170++;
			}
			if (Main.rand.Next(4) == 0)
			{
				num170++;
			}
			if (Main.rand.Next(5) == 0)
			{
				num170++;
			}
			for (int num171 = 0; num171 < num170; num171++)
			{
				float num172 = num102;
				float num173 = num113;
				float num174 = 0.05f * (float)num171;
				num172 += (float)Main.rand.Next(-35, 36) * num174;
				num173 += (float)Main.rand.Next(-35, 36) * num174;
				num124 = (float)Math.Sqrt(num172 * num172 + num173 * num173);
				num124 = speed / num124;
				num172 *= num124;
				num173 *= num124;
				float x3 = pointPoisition.X;
				float y3 = pointPoisition.Y;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, x3, y3, num172, num173, projToShoot, Damage, KnockBack, i);
			}
		}
		else if (sItem.type == 1308)
		{
			int num175 = 3;
			if (Main.rand.Next(3) == 0)
			{
				num175++;
			}
			for (int num176 = 0; num176 < num175; num176++)
			{
				float num177 = num102;
				float num179 = num113;
				float num180 = 0.05f * (float)num176;
				num177 += (float)Main.rand.Next(-35, 36) * num180;
				num179 += (float)Main.rand.Next(-35, 36) * num180;
				num124 = (float)Math.Sqrt(num177 * num177 + num179 * num179);
				num124 = speed / num124;
				num177 *= num124;
				num179 *= num124;
				float x4 = pointPoisition.X;
				float y4 = pointPoisition.Y;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, x4, y4, num177, num179, projToShoot, Damage, KnockBack, i);
			}
		}
		else if (sItem.type == 1258)
		{
			float num181 = num102;
			float num182 = num113;
			num181 += (float)Main.rand.Next(-40, 41) * 0.01f;
			num182 += (float)Main.rand.Next(-40, 41) * 0.01f;
			pointPoisition.X += (float)Main.rand.Next(-40, 41) * 0.05f;
			pointPoisition.Y += (float)Main.rand.Next(-45, 36) * 0.05f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num181, num182, projToShoot, Damage, KnockBack, i);
		}
		else if (sItem.type == 964)
		{
			int num183 = Main.rand.Next(3, 5);
			for (int num184 = 0; num184 < num183; num184++)
			{
				float num185 = num102;
				float num186 = num113;
				num185 += (float)Main.rand.Next(-35, 36) * 0.04f;
				num186 += (float)Main.rand.Next(-35, 36) * 0.04f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num185, num186, projToShoot, Damage, KnockBack, i);
			}
		}
		else if (sItem.type == 1569)
		{
			int num187 = 4;
			if (Main.rand.Next(2) == 0)
			{
				num187++;
			}
			if (Main.rand.Next(4) == 0)
			{
				num187++;
			}
			if (Main.rand.Next(8) == 0)
			{
				num187++;
			}
			if (Main.rand.Next(16) == 0)
			{
				num187++;
			}
			for (int num188 = 0; num188 < num187; num188++)
			{
				float num3 = num102;
				float num4 = num113;
				float num5 = 0.05f * (float)num188;
				num3 += (float)Main.rand.Next(-35, 36) * num5;
				num4 += (float)Main.rand.Next(-35, 36) * num5;
				num124 = (float)Math.Sqrt(num3 * num3 + num4 * num4);
				num124 = speed / num124;
				num3 *= num124;
				num4 *= num124;
				float x5 = pointPoisition.X;
				float y5 = pointPoisition.Y;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, x5, y5, num3, num4, projToShoot, Damage, KnockBack, i);
			}
		}
		else if (sItem.type == 1572 || sItem.type == 2366 || sItem.type == 3571 || sItem.type == 3569 || sItem.type == 5119)
		{
			bool num190 = sItem.type == 3571 || sItem.type == 3569;
			int num6 = (int)((float)Main.mouseX + Main.screenPosition.X) / 16;
			int num7 = (int)((float)Main.mouseY + Main.screenPosition.Y) / 16;
			if (gravDir == -1f)
			{
				num7 = (int)(Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY) / 16;
			}
			if (!num190)
			{
				for (; num7 < Main.maxTilesY - 10 && Main.tile[num6, num7] != null && !WorldGen.SolidTile2(num6, num7) && Main.tile[num6 - 1, num7] != null && !WorldGen.SolidTile2(num6 - 1, num7) && Main.tile[num6 + 1, num7] != null && !WorldGen.SolidTile2(num6 + 1, num7); num7++)
				{
				}
				num7--;
			}
			int num8 = 0;
			switch (sItem.type)
			{
			case 1572:
				num8 = 60;
				break;
			case 5119:
				num8 = 90;
				break;
			}
			int num9 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, (float)Main.mouseX + Main.screenPosition.X, num7 * 16 - 24, 0f, 15f, projToShoot, Damage, KnockBack, i, num8);
			Main.projectile[num9].originalDamage = damage;
			UpdateMaxTurrets();
		}
		else if (sItem.type == 1244 || sItem.type == 1256)
		{
			int num10 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num102, num113, projToShoot, Damage, KnockBack, i);
			Main.projectile[num10].ai[0] = (float)Main.mouseX + Main.screenPosition.X;
			Main.projectile[num10].ai[1] = (float)Main.mouseY + Main.screenPosition.Y;
		}
		else if (sItem.type == 1229)
		{
			int num11 = 2;
			if (Main.rand.Next(3) == 0)
			{
				num11++;
			}
			for (int num13 = 0; num13 < num11; num13++)
			{
				float num14 = num102;
				float num15 = num113;
				if (num13 > 0)
				{
					num14 += (float)Main.rand.Next(-35, 36) * 0.04f;
					num15 += (float)Main.rand.Next(-35, 36) * 0.04f;
				}
				if (num13 > 1)
				{
					num14 += (float)Main.rand.Next(-35, 36) * 0.04f;
					num15 += (float)Main.rand.Next(-35, 36) * 0.04f;
				}
				if (num13 > 2)
				{
					num14 += (float)Main.rand.Next(-35, 36) * 0.04f;
					num15 += (float)Main.rand.Next(-35, 36) * 0.04f;
				}
				int num16 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num14, num15, projToShoot, Damage, KnockBack, i);
				Main.projectile[num16].noDropItem = true;
			}
		}
		else if (sItem.type == 1121)
		{
			int num17 = Main.rand.Next(1, 4);
			if (Main.rand.Next(6) == 0)
			{
				num17++;
			}
			if (Main.rand.Next(6) == 0)
			{
				num17++;
			}
			if (strongBees && Main.rand.Next(3) == 0)
			{
				num17++;
			}
			for (int num18 = 0; num18 < num17; num18++)
			{
				float num19 = num102;
				float num20 = num113;
				num19 += (float)Main.rand.Next(-35, 36) * 0.02f;
				num20 += (float)Main.rand.Next(-35, 36) * 0.02f;
				int num21 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num19, num20, beeType(), beeDamage(Damage), beeKB(KnockBack), i);
				Main.projectile[num21].magic = true;
			}
		}
		else if (sItem.type == 1155)
		{
			int num22 = Main.rand.Next(2, 5);
			for (int num24 = 0; num24 < num22; num24++)
			{
				float num25 = num102;
				float num26 = num113;
				num25 += (float)Main.rand.Next(-35, 36) * 0.02f;
				num26 += (float)Main.rand.Next(-35, 36) * 0.02f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num25, num26, projToShoot, Damage, KnockBack, i);
			}
		}
		else if (sItem.type == 1801)
		{
			int num27 = Main.rand.Next(2, 4);
			for (int num28 = 0; num28 < num27; num28++)
			{
				float num29 = num102;
				float num30 = num113;
				num29 += (float)Main.rand.Next(-35, 36) * 0.05f;
				num30 += (float)Main.rand.Next(-35, 36) * 0.05f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num29, num30, projToShoot, Damage, KnockBack, i);
			}
		}
		else if (sItem.type == 679)
		{
			for (int num31 = 0; num31 < 6; num31++)
			{
				float num32 = num102;
				float num33 = num113;
				num32 += (float)Main.rand.Next(-40, 41) * 0.05f;
				num33 += (float)Main.rand.Next(-40, 41) * 0.05f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num32, num33, projToShoot, Damage, KnockBack, i);
			}
		}
		else if (sItem.type == 1156)
		{
			for (int num35 = 0; num35 < 3; num35++)
			{
				float num36 = num102;
				float num37 = num113;
				num36 += (float)Main.rand.Next(-40, 41) * 0.05f;
				num37 += (float)Main.rand.Next(-40, 41) * 0.05f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num36, num37, projToShoot, Damage, KnockBack, i);
			}
		}
		else if (sItem.type == 4682)
		{
			for (int num38 = 0; num38 < 3; num38++)
			{
				float num39 = num102;
				float num40 = num113;
				num39 += (float)Main.rand.Next(-20, 21) * 0.1f;
				num40 += (float)Main.rand.Next(-20, 21) * 0.1f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num39, num40, projToShoot, Damage, KnockBack, i);
			}
		}
		else if (sItem.type == 2623)
		{
			for (int num41 = 0; num41 < 3; num41++)
			{
				float num42 = num102;
				float num43 = num113;
				num42 += (float)Main.rand.Next(-40, 41) * 0.1f;
				num43 += (float)Main.rand.Next(-40, 41) * 0.1f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num42, num43, projToShoot, Damage, KnockBack, i);
			}
		}
		else if (sItem.type == 3210)
		{
			Vector2 vector32 = default(Vector2);
			((Vector2)(ref vector32))._002Ector(num102, num113);
			vector32.X += (float)Main.rand.Next(-30, 31) * 0.04f;
			vector32.Y += (float)Main.rand.Next(-30, 31) * 0.03f;
			((Vector2)(ref vector32)).Normalize();
			vector32 *= (float)Main.rand.Next(70, 91) * 0.1f;
			vector32.X += (float)Main.rand.Next(-30, 31) * 0.04f;
			vector32.Y += (float)Main.rand.Next(-30, 31) * 0.03f;
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, vector32.X, vector32.Y, projToShoot, Damage, KnockBack, i, Main.rand.Next(20));
		}
		else if (sItem.type == 434)
		{
			float num44 = num102;
			float num46 = num113;
			if (itemAnimation < 5)
			{
				num44 += (float)Main.rand.Next(-40, 41) * 0.01f;
				num46 += (float)Main.rand.Next(-40, 41) * 0.01f;
				num44 *= 1.1f;
				num46 *= 1.1f;
			}
			else if (itemAnimation < 10)
			{
				num44 += (float)Main.rand.Next(-20, 21) * 0.01f;
				num46 += (float)Main.rand.Next(-20, 21) * 0.01f;
				num44 *= 1.05f;
				num46 *= 1.05f;
			}
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num44, num46, projToShoot, Damage, KnockBack, i);
		}
		else if (sItem.type == 1157)
		{
			projToShoot = Main.rand.Next(191, 195);
			int minionProjectileId4 = projToShoot;
			float knockBack4 = KnockBack;
			val = default(Vector2);
			Vector2 offsetFromCursor4 = val;
			val = default(Vector2);
			int num47 = SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, minionProjectileId4, damage, knockBack4, offsetFromCursor4, val);
			Main.projectile[num47].localAI[0] = 30f;
		}
		else if (sItem.type == 1802)
		{
			int minionProjectileId5 = projToShoot;
			float knockBack5 = KnockBack;
			val = default(Vector2);
			Vector2 offsetFromCursor5 = val;
			val = default(Vector2);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, minionProjectileId5, damage, knockBack5, offsetFromCursor5, val);
		}
		else if (sItem.type == 2364 || sItem.type == 2365)
		{
			int minionProjectileId6 = projToShoot;
			float knockBack6 = KnockBack;
			val = default(Vector2);
			Vector2 offsetFromCursor6 = val;
			val = default(Vector2);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, minionProjectileId6, damage, knockBack6, offsetFromCursor6, val);
		}
		else if (sItem.type == 2535)
		{
			num102 = 0f;
			num113 = 0f;
			Vector2 spinningpoint = default(Vector2);
			((Vector2)(ref spinningpoint))._002Ector(num102, num113);
			Vector2 spinningpoint11 = spinningpoint;
			val = default(Vector2);
			spinningpoint = spinningpoint11.RotatedBy(1.5707963705062866, val);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, projToShoot, damage, KnockBack, spinningpoint, spinningpoint);
			Vector2 spinningpoint12 = spinningpoint;
			val = default(Vector2);
			spinningpoint = spinningpoint12.RotatedBy(-3.1415927410125732, val);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, projToShoot + 1, damage, KnockBack, spinningpoint, spinningpoint);
		}
		else if (sItem.type == 2551)
		{
			int minionProjectileId7 = projToShoot + nextCycledSpiderMinionType;
			float knockBack7 = KnockBack;
			val = default(Vector2);
			Vector2 offsetFromCursor7 = val;
			val = default(Vector2);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, minionProjectileId7, damage, knockBack7, offsetFromCursor7, val);
			nextCycledSpiderMinionType++;
			nextCycledSpiderMinionType %= 3;
		}
		else if (sItem.type == 2584)
		{
			int minionProjectileId8 = projToShoot + Main.rand.Next(3);
			float knockBack8 = KnockBack;
			val = default(Vector2);
			Vector2 offsetFromCursor8 = val;
			val = default(Vector2);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, minionProjectileId8, damage, knockBack8, offsetFromCursor8, val);
		}
		else if (sItem.type == 2621)
		{
			int minionProjectileId9 = projToShoot;
			float knockBack9 = KnockBack;
			val = default(Vector2);
			Vector2 offsetFromCursor9 = val;
			val = default(Vector2);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, minionProjectileId9, damage, knockBack9, offsetFromCursor9, val);
		}
		else if (sItem.type == 2749 || sItem.type == 3249 || sItem.type == 3474 || sItem.type == 4273 || sItem.type == 4281)
		{
			int minionProjectileId10 = projToShoot;
			float knockBack10 = KnockBack;
			val = default(Vector2);
			Vector2 offsetFromCursor10 = val;
			val = default(Vector2);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, minionProjectileId10, damage, knockBack10, offsetFromCursor10, val);
		}
		else if (sItem.type == 3531)
		{
			int num48 = -1;
			int num49 = -1;
			for (int num50 = 0; num50 < 1000; num50++)
			{
				if (Main.projectile[num50].active && Main.projectile[num50].owner == Main.myPlayer)
				{
					if (num48 == -1 && Main.projectile[num50].type == 625)
					{
						num48 = num50;
					}
					if (num49 == -1 && Main.projectile[num50].type == 628)
					{
						num49 = num50;
					}
					if (num48 != -1 && num49 != -1)
					{
						break;
					}
				}
			}
			if (num48 == -1 && num49 == -1)
			{
				num102 = 0f;
				num113 = 0f;
				pointPoisition.X = (float)Main.mouseX + Main.screenPosition.X;
				pointPoisition.Y = (float)Main.mouseY + Main.screenPosition.Y;
				int num51 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num102, num113, projToShoot, Damage, KnockBack, i);
				int num52 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num102, num113, projToShoot + 1, Damage, KnockBack, i, num51);
				int num53 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num102, num113, projToShoot + 2, Damage, KnockBack, i, num52);
				int num54 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num102, num113, projToShoot + 3, Damage, KnockBack, i, num53);
				Main.projectile[num52].localAI[1] = num53;
				Main.projectile[num53].localAI[1] = num54;
				Main.projectile[num51].originalDamage = damage;
				Main.projectile[num52].originalDamage = damage;
				Main.projectile[num53].originalDamage = damage;
				Main.projectile[num54].originalDamage = damage;
			}
			else if (num48 != -1 && num49 != -1)
			{
				int num55 = (int)Main.projectile[num49].ai[0];
				int num57 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num102, num113, projToShoot + 1, Damage, KnockBack, i, num55);
				int num58 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num102, num113, projToShoot + 2, Damage, KnockBack, i, num57);
				Main.projectile[num57].localAI[1] = num58;
				Main.projectile[num57].netUpdate = true;
				Main.projectile[num57].ai[1] = 1f;
				Main.projectile[num58].localAI[1] = num49;
				Main.projectile[num58].netUpdate = true;
				Main.projectile[num58].ai[1] = 1f;
				Main.projectile[num49].ai[0] = num58;
				Main.projectile[num49].netUpdate = true;
				Main.projectile[num49].ai[1] = 1f;
				Main.projectile[num57].originalDamage = damage;
				Main.projectile[num58].originalDamage = damage;
				Main.projectile[num49].originalDamage = damage;
			}
		}
		else if (sItem.type == 1309 || sItem.type == 4758 || sItem.type == 4269 || sItem.type == 5005)
		{
			int minionProjectileId11 = projToShoot;
			float knockBack11 = KnockBack;
			val = default(Vector2);
			Vector2 offsetFromCursor11 = val;
			val = default(Vector2);
			SpawnMinionOnCursor(projectileSource_Item_WithPotentialAmmo, i, minionProjectileId11, damage, knockBack11, offsetFromCursor11, val);
		}
		else if (sItem.shoot > 0 && (Main.projPet[sItem.shoot] || sItem.shoot == 72 || sItem.shoot == 18 || sItem.shoot == 500 || sItem.shoot == 650) && !sItem.summon)
		{
			for (int num59 = 0; num59 < 1000; num59++)
			{
				Projectile projectile2 = Main.projectile[num59];
				if (projectile2.active && projectile2.owner == whoAmI)
				{
					if (sItem.shoot == 72 && (projectile2.type == 72 || projectile2.type == 86 || projectile2.type == 87))
					{
						projectile2.Kill();
					}
					else if (sItem.type == 5131 && (projectile2.type == 881 || projectile2.type == 934))
					{
						projectile2.Kill();
					}
					else if (sItem.shoot == projectile2.type)
					{
						projectile2.Kill();
					}
				}
			}
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num102, num113, projToShoot, 0, 0f, i);
		}
		else if (sItem.type == 3006)
		{
			pointPoisition = GetFarthestSpawnPositionOnLine(pointPoisition, num102, num113);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, 0f, 0f, projToShoot, Damage, KnockBack, i);
		}
		else if (sItem.type == 3014)
		{
			Vector2 pointPoisition3 = default(Vector2);
			pointPoisition3.X = Main.MouseWorld.X;
			pointPoisition3.Y = Main.MouseWorld.Y;
			LimitPointToPlayerReachableArea(ref pointPoisition3);
			while (Collision.CanHitLine(base.position, width, height, pointPoisition, 1, 1))
			{
				pointPoisition.X += num102;
				pointPoisition.Y += num113;
				val = pointPoisition - pointPoisition3;
				if (((Vector2)(ref val)).Length() < 20f + Math.Abs(num102) + Math.Abs(num113))
				{
					pointPoisition = pointPoisition3;
					break;
				}
			}
			bool flag5 = false;
			int num60 = (int)pointPoisition.Y / 16;
			int num61 = (int)pointPoisition.X / 16;
			int num62;
			for (num62 = num60; num60 < Main.maxTilesY - 10 && num60 - num62 < 30 && !WorldGen.SolidTile(num61, num60) && !TileID.Sets.Platforms[Main.tile[num61, num60].type]; num60++)
			{
			}
			if (!WorldGen.SolidTile(num61, num60) && !TileID.Sets.Platforms[Main.tile[num61, num60].type])
			{
				flag5 = true;
			}
			float num63 = num60 * 16;
			num60 = num62;
			while (num60 > 10 && num62 - num60 < 30 && !WorldGen.SolidTile(num61, num60))
			{
				num60--;
			}
			float num64 = num60 * 16 + 16;
			float num65 = num63 - num64;
			int num66 = 15;
			if (num65 > (float)(16 * num66))
			{
				num65 = 16 * num66;
			}
			num64 = num63 - num65;
			pointPoisition.X = (int)(pointPoisition.X / 16f) * 16;
			if (!flag5)
			{
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, 0f, 0f, projToShoot, Damage, KnockBack, i, num64, num65);
			}
		}
		else if (sItem.type == 3384)
		{
			int num68 = ((altFunctionUse == 2) ? 1 : 0);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num102, num113, projToShoot, Damage, KnockBack, i, 0f, num68);
		}
		else if (sItem.type == 3473)
		{
			float ai4 = (Main.rand.NextFloat() - 0.5f) * ((float)Math.PI / 4f);
			Vector2 vector34 = default(Vector2);
			((Vector2)(ref vector34))._002Ector(num102, num113);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, vector34.X, vector34.Y, projToShoot, Damage, KnockBack, i, 0f, ai4);
		}
		else if (sItem.type == 4956)
		{
			int num69 = (itemAnimationMax - itemAnimation) / itemTime;
			Vector2 vector35 = default(Vector2);
			((Vector2)(ref vector35))._002Ector(num102, num113);
			int num70 = FinalFractalHelper.GetRandomProfileIndex();
			if (num69 == 0)
			{
				num70 = 4956;
			}
			Vector2 pointPoisition4 = Main.MouseWorld;
			LimitPointToPlayerReachableArea(ref pointPoisition4);
			Vector2 vector36 = pointPoisition4 - MountedCenter;
			if (num69 == 1 || num69 == 2)
			{
				int npcTargetIndex;
				bool zenithTarget = GetZenithTarget(pointPoisition4, 400f, out npcTargetIndex);
				if (zenithTarget)
				{
					vector36 = Main.npc[npcTargetIndex].Center - MountedCenter;
				}
				bool flag6 = num69 == 2;
				if (num69 == 1 && !zenithTarget)
				{
					flag6 = true;
				}
				if (flag6)
				{
					vector36 += Main.rand.NextVector2Circular(150f, 150f);
				}
			}
			vector35 = vector36 / 2f;
			float ai5 = Main.rand.Next(-100, 101);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition, vector35, projToShoot, Damage, KnockBack, i, ai5, num70);
		}
		else if (sItem.type == 3836)
		{
			float ai6 = Main.rand.NextFloat() * speed * 0.75f * (float)direction;
			((Vector2)(ref val))._002Ector(num102, num113);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition, val, projToShoot, Damage, KnockBack, i, ai6);
		}
		else if (sItem.type == 3858)
		{
			bool num191 = altFunctionUse == 2;
			Vector2 vector37 = default(Vector2);
			((Vector2)(ref vector37))._002Ector(num102, num113);
			if (num191)
			{
				vector37 *= 1.5f;
				float ai7 = (0.3f + 0.7f * Main.rand.NextFloat()) * speed * 1.75f * (float)direction;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition, vector37, 708, (int)((float)Damage * 0.5f), KnockBack + 4f, i, ai7);
			}
			else
			{
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition, vector37, projToShoot, Damage, KnockBack, i);
			}
		}
		else if (sItem.type == 3859)
		{
			Vector2 vector38 = default(Vector2);
			((Vector2)(ref vector38))._002Ector(num102, num113);
			projToShoot = 710;
			vector38 *= 0.8f;
			Vector2 vector39 = vector38.SafeNormalize(-Vector2.UnitY);
			float num71 = (float)Math.PI / 180f * (float)(-direction);
			for (float num72 = -2.5f; num72 < 3f; num72 += 1f)
			{
				Vector2 val8 = pointPoisition;
				Vector2 spinningpoint13 = vector38 + vector39 * num72 * 0.5f;
				double radians10 = num72 * num71;
				val = default(Vector2);
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, val8, spinningpoint13.RotatedBy(radians10, val), projToShoot, Damage, KnockBack, i);
			}
		}
		else if (sItem.type == 3870)
		{
			Vector2 vector40 = Vector2.Normalize(new Vector2(num102, num113)) * 40f * sItem.scale;
			if (Collision.CanHit(pointPoisition, 0, 0, pointPoisition + vector40, 0, 0))
			{
				pointPoisition += vector40;
			}
			Vector2 vector41 = default(Vector2);
			((Vector2)(ref vector41))._002Ector(num102, num113);
			vector41 *= 0.8f;
			Vector2 vector42 = vector41.SafeNormalize(-Vector2.UnitY);
			float num73 = (float)Math.PI / 180f * (float)(-direction);
			for (int num74 = 0; num74 <= 2; num74++)
			{
				Vector2 val9 = pointPoisition;
				Vector2 spinningpoint14 = vector41 + vector42 * (float)num74 * 1f;
				double radians11 = (float)num74 * num73;
				val = default(Vector2);
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, val9, spinningpoint14.RotatedBy(radians11, val), projToShoot, Damage, KnockBack, i);
			}
		}
		else if (sItem.type == 3542)
		{
			float num75 = (Main.rand.NextFloat() - 0.5f) * ((float)Math.PI / 4f) * 0.7f;
			for (int num76 = 0; num76 < 10; num76++)
			{
				Vector2 position = pointPoisition;
				Vector2 val10 = pointPoisition;
				Vector2 spinningpoint15 = new Vector2(num102, num113);
				double radians12 = num75;
				val = default(Vector2);
				if (Collision.CanHit(position, 0, 0, val10 + Utils.RotatedBy(spinningpoint15, radians12, val) * 100f, 0, 0))
				{
					break;
				}
				num75 = (Main.rand.NextFloat() - 0.5f) * ((float)Math.PI / 4f) * 0.7f;
			}
			Vector2 spinningpoint16 = new Vector2(num102, num113);
			double radians13 = num75;
			val = default(Vector2);
			Vector2 vector43 = Utils.RotatedBy(spinningpoint16, radians13, val) * (0.95f + Main.rand.NextFloat() * 0.3f);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, vector43.X, vector43.Y, projToShoot, Damage, KnockBack, i);
		}
		else if (sItem.type == 3779)
		{
			float num78 = Main.rand.NextFloat() * ((float)Math.PI * 2f);
			for (int num79 = 0; num79 < 10; num79++)
			{
				Vector2 position2 = pointPoisition;
				Vector2 val11 = pointPoisition;
				Vector2 spinningpoint17 = new Vector2(num102, num113);
				double radians14 = num78;
				val = default(Vector2);
				if (Collision.CanHit(position2, 0, 0, val11 + Utils.RotatedBy(spinningpoint17, radians14, val) * 100f, 0, 0))
				{
					break;
				}
				num78 = Main.rand.NextFloat() * ((float)Math.PI * 2f);
			}
			Vector2 spinningpoint18 = new Vector2(num102, num113);
			double radians15 = num78;
			val = default(Vector2);
			Vector2 vector44 = Utils.RotatedBy(spinningpoint18, radians15, val) * (0.95f + Main.rand.NextFloat() * 0.3f);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition + vector44 * 30f, Vector2.Zero, projToShoot, Damage, KnockBack, i, -2f);
		}
		else if (sItem.type == 3787)
		{
			float f = Main.rand.NextFloat() * ((float)Math.PI * 2f);
			float value3 = 20f;
			float value4 = 60f;
			Vector2 vector45 = pointPoisition + f.ToRotationVector2() * MathHelper.Lerp(value3, value4, Main.rand.NextFloat());
			for (int num80 = 0; num80 < 50; num80++)
			{
				vector45 = pointPoisition + f.ToRotationVector2() * MathHelper.Lerp(value3, value4, Main.rand.NextFloat());
				if (Collision.CanHit(pointPoisition, 0, 0, vector45 + (vector45 - pointPoisition).SafeNormalize(Vector2.UnitX) * 8f, 0, 0))
				{
					break;
				}
				f = Main.rand.NextFloat() * ((float)Math.PI * 2f);
			}
			Vector2 v5 = Main.MouseWorld - vector45;
			Vector2 vector46 = Utils.SafeNormalize(new Vector2(num102, num113), Vector2.UnitY) * speed;
			v5 = v5.SafeNormalize(vector46) * speed;
			v5 = Vector2.Lerp(v5, vector46, 0.25f);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, vector45, v5, projToShoot, Damage, KnockBack, i);
		}
		else if (sItem.type == 3788)
		{
			Vector2 vector47 = default(Vector2);
			((Vector2)(ref vector47))._002Ector(num102, num113);
			float num81 = (float)Math.PI / 4f;
			for (int num82 = 0; num82 < 2; num82++)
			{
				Vector2 val12 = pointPoisition;
				Vector2 val13 = vector47;
				Vector2 spinningpoint19 = vector47.SafeNormalize(Vector2.Zero);
				double radians16 = num81 * (Main.rand.NextFloat() * 0.5f + 0.5f);
				val = default(Vector2);
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, val12, val13 + spinningpoint19.RotatedBy(radians16, val) * Main.rand.NextFloatDirection() * 2f, projToShoot, Damage, KnockBack, i);
				Vector2 val14 = pointPoisition;
				Vector2 val15 = vector47;
				Vector2 spinningpoint20 = vector47.SafeNormalize(Vector2.Zero);
				double radians17 = (0f - num81) * (Main.rand.NextFloat() * 0.5f + 0.5f);
				val = default(Vector2);
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, val14, val15 + spinningpoint20.RotatedBy(radians17, val) * Main.rand.NextFloatDirection() * 2f, projToShoot, Damage, KnockBack, i);
			}
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition, vector47.SafeNormalize(Vector2.UnitX * (float)direction) * (speed * 1.3f), 661, Damage * 2, KnockBack, i);
		}
		else if (sItem.type == 4463 || sItem.type == 486)
		{
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition, new Vector2(num102, num113), projToShoot, Damage, KnockBack, i);
		}
		else if (sItem.type == 46)
		{
			Vector2 spinningpoint21 = Utils.SafeNormalize(new Vector2((float)direction, gravDir * 4f), Vector2.UnitY);
			double radians18 = (float)Math.PI * 2f * Main.rand.NextFloatDirection() * 0.05f;
			val = default(Vector2);
			Vector2 vector48 = spinningpoint21.RotatedBy(radians18, val);
			Vector2 searchCenter = MountedCenter + new Vector2(70f, -40f) * Directions + vector48 * -10f;
			if (GetZenithTarget(searchCenter, 50f, out var npcTargetIndex2))
			{
				NPC nPC3 = Main.npc[npcTargetIndex2];
				searchCenter = nPC3.Center + Main.rand.NextVector2Circular(nPC3.width / 2, nPC3.height / 2);
			}
			else
			{
				searchCenter += Main.rand.NextVector2Circular(20f, 20f);
			}
			float ai8 = 1f;
			if ((float)Main.rand.Next(100) < meleeCrit)
			{
				ai8 = 2f;
				Damage *= 2;
			}
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, searchCenter, vector48 * 0.001f, projToShoot, (int)((double)Damage * 0.5), KnockBack, i, ai8);
			NetMessage.SendData(13, -1, -1, null, whoAmI);
		}
		else if (sItem.type == 273)
		{
			float adjustedItemScale = GetAdjustedItemScale(sItem);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, MountedCenter, new Vector2((float)direction, 0f), projToShoot, Damage, KnockBack, i, (float)direction * gravDir, itemAnimationMax, adjustedItemScale);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, MountedCenter, new Vector2(num102, num113), projToShoot, Damage, KnockBack, i, (float)direction * gravDir * 0.1f, 30f, adjustedItemScale);
			NetMessage.SendData(13, -1, -1, null, whoAmI);
		}
		else if (sItem.type == 368)
		{
			float adjustedItemScale2 = GetAdjustedItemScale(sItem);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, MountedCenter, new Vector2((float)direction, 0f), projToShoot, Damage, KnockBack, i, (float)direction * gravDir, itemAnimationMax, adjustedItemScale2);
			NetMessage.SendData(13, -1, -1, null, whoAmI);
		}
		else if (sItem.type == 1826)
		{
			float adjustedItemScale3 = GetAdjustedItemScale(sItem);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, MountedCenter, new Vector2((float)direction, 0f), projToShoot, Damage, KnockBack, i, (float)direction * gravDir, itemAnimationMax, adjustedItemScale3);
			NetMessage.SendData(13, -1, -1, null, whoAmI);
		}
		else if (sItem.type == 675)
		{
			float adjustedItemScale4 = GetAdjustedItemScale(sItem);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, MountedCenter, new Vector2((float)direction, 0f), 972, Damage, KnockBack, i, (float)direction * gravDir, itemAnimationMax, adjustedItemScale4);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, MountedCenter, new Vector2(num102, num113), projToShoot, Damage / 2, KnockBack, i, (float)direction * gravDir, 32f, adjustedItemScale4);
			NetMessage.SendData(13, -1, -1, null, whoAmI);
		}
		else if (sItem.type == 674)
		{
			float adjustedItemScale5 = GetAdjustedItemScale(sItem);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, MountedCenter, new Vector2((float)direction, 0f), projToShoot, Damage, KnockBack, i, (float)direction * gravDir, itemAnimationMax, adjustedItemScale5);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, MountedCenter, new Vector2((float)direction, 0f), 982, 0, KnockBack, i, (float)direction * gravDir, itemAnimationMax, adjustedItemScale5);
			NetMessage.SendData(13, -1, -1, null, whoAmI);
		}
		else if (sItem.type == 757)
		{
			float adjustedItemScale6 = GetAdjustedItemScale(sItem);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, MountedCenter, new Vector2((float)direction, 0f), 984, Damage, KnockBack, i, (float)direction * gravDir, itemAnimationMax, adjustedItemScale6);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, MountedCenter, new Vector2(num102, num113) * 5f, projToShoot, Damage, KnockBack, i, (float)direction * gravDir, 18f, adjustedItemScale6);
			NetMessage.SendData(13, -1, -1, null, whoAmI);
		}
		else if (sItem.type == 190)
		{
			Vector2 vector49 = MountedCenter + new Vector2(70f, -40f) * Directions;
			int npcTargetIndex3;
			bool zenithTarget2 = GetZenithTarget(vector49, 150f, out npcTargetIndex3);
			if (zenithTarget2)
			{
				NPC nPC4 = Main.npc[npcTargetIndex3];
				vector49 = Main.rand.NextVector2FromRectangle(nPC4.Hitbox);
			}
			else
			{
				vector49 += Main.rand.NextVector2Circular(20f, 20f);
			}
			Vector2 vector50 = base.Center + new Vector2(Main.rand.NextFloatDirection() * (float)width / 2f, (float)(height / 2)) * Directions;
			Vector2 v6 = vector49 - vector50;
			float num192 = ((float)Math.PI + (float)Math.PI * 2f * Main.rand.NextFloat() * 1.5f) * ((float)(-direction) * gravDir);
			int num83 = 60;
			float num84 = num192 / (float)num83;
			float num85 = 16f;
			float num86 = ((Vector2)(ref v6)).Length();
			if (Math.Abs(num84) >= 0.17f)
			{
				num84 *= 0.7f;
			}
			_ = direction;
			_ = gravDir;
			Vector2 vector51 = Vector2.UnitX * num85;
			Vector2 v7 = vector51;
			int num88 = 0;
			while (((Vector2)(ref v7)).Length() < num86 && num88 < num83)
			{
				num88++;
				v7 += vector51;
				Vector2 spinningpoint22 = vector51;
				double radians19 = num84;
				val = default(Vector2);
				vector51 = spinningpoint22.RotatedBy(radians19, val);
			}
			float num89 = v7.ToRotation();
			Vector2 spinningpoint23 = v6.SafeNormalize(Vector2.UnitY);
			double radians20 = 0f - num89 - num84;
			val = default(Vector2);
			Vector2 spinningpoint2 = spinningpoint23.RotatedBy(radians20, val) * num85;
			if (num88 == num83)
			{
				spinningpoint2 = new Vector2((float)direction, 0f) * num85;
			}
			if (!zenithTarget2)
			{
				vector50.Y -= gravDir * 24f;
				Vector2 spinningpoint24 = spinningpoint2;
				double radians21 = (float)direction * gravDir * ((float)Math.PI * 2f) * 0.14f;
				val = default(Vector2);
				spinningpoint2 = spinningpoint24.RotatedBy(radians21, val);
			}
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, vector50, spinningpoint2, projToShoot, (int)((double)Damage * 0.25), KnockBack, i, num84, num88);
			NetMessage.SendData(13, -1, -1, null, whoAmI);
		}
		else if (sItem.type == 3475)
		{
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num102, num113, 615, Damage, KnockBack, i, 5 * Main.rand.Next(0, 20));
		}
		else if (sItem.type == 3930)
		{
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num102, num113, 714, Damage, KnockBack, i, 5 * Main.rand.Next(0, 20));
		}
		else if (sItem.type == 3540)
		{
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num102, num113, 630, Damage, KnockBack, i);
		}
		else if (sItem.type == 5451)
		{
			for (int num90 = 0; num90 < 1000; num90++)
			{
				Projectile projectile3 = Main.projectile[num90];
				if (projectile3.type == projToShoot && projectile3.owner == whoAmI)
				{
					projectile3.Kill();
				}
			}
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num102, num113, projToShoot, Damage, KnockBack, i);
		}
		else if (sItem.type == 3854)
		{
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num102, num113, 705, Damage, KnockBack, i);
		}
		else if (sItem.type == 3546)
		{
			for (int num91 = 0; num91 < 2; num91++)
			{
				float num92 = num102;
				float num93 = num113;
				num92 += (float)Main.rand.Next(-40, 41) * 0.05f;
				num93 += (float)Main.rand.Next(-40, 41) * 0.05f;
				Vector2 val16 = pointPoisition;
				Vector2 spinningpoint25 = new Vector2(num92, num93);
				double radians22 = -(float)Math.PI / 2f * (float)direction;
				val = default(Vector2);
				Vector2 vector52 = val16 + Vector2.Normalize(Utils.RotatedBy(spinningpoint25, radians22, val)) * 6f;
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, vector52.X, vector52.Y, num92, num93, 167 + Main.rand.Next(4), Damage, KnockBack, i, 0f, 1f);
			}
		}
		else if (sItem.type == 3350)
		{
			float num94 = num102;
			float num95 = num113;
			num94 += (float)Main.rand.Next(-1, 2) * 0.5f;
			num95 += (float)Main.rand.Next(-1, 2) * 0.5f;
			if (Collision.CanHitLine(base.Center, 0, 0, pointPoisition + new Vector2(num94, num95) * 2f, 0, 0))
			{
				pointPoisition += new Vector2(num94, num95);
			}
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y - gravDir * 4f, num94, num95, projToShoot, Damage, KnockBack, i, 0f, (float)Main.rand.Next(12) / 6f);
		}
		else if (sItem.type == 3852)
		{
			if (altFunctionUse == 2)
			{
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, base.Bottom.Y - 100f, (float)direction * speed, 0f, 704, (int)((float)Damage * 1.75f), KnockBack, i);
			}
			else
			{
				Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num102, num113, projToShoot, Damage, KnockBack, i);
			}
		}
		else if (sItem.type == 3818 || sItem.type == 3819 || sItem.type == 3820 || sItem.type == 3824 || sItem.type == 3825 || sItem.type == 3826 || sItem.type == 3829 || sItem.type == 3830 || sItem.type == 3831 || sItem.type == 3832 || sItem.type == 3833 || sItem.type == 3834)
		{
			PayDD2CrystalsBeforeUse(sItem);
			FindSentryRestingSpot(sItem.shoot, out var worldX, out var worldY, out var pushYUp);
			int num96 = 0;
			int num97 = 0;
			int num99 = 0;
			switch (sItem.type)
			{
			case 3824:
			case 3825:
			case 3826:
				num96 = 1;
				num97 = Projectile.GetBallistraShotDelay(this);
				break;
			case 3832:
			case 3833:
			case 3834:
				num99 = Projectile.GetExplosiveTrapCooldown(this);
				break;
			case 3818:
				num96 = 1;
				num97 = 80;
				break;
			case 3819:
				num96 = 1;
				num97 = 70;
				break;
			case 3820:
				num96 = 1;
				num97 = 60;
				break;
			}
			int num100 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, worldX, worldY - pushYUp, 0f, 0f, projToShoot, Damage, KnockBack, i, num96, num97);
			Main.projectile[num100].originalDamage = damage;
			Main.projectile[num100].localAI[0] = num99;
			UpdateMaxTurrets();
		}
		else if (sItem.type == 65)
		{
			Vector2 vector53 = default(Vector2);
			((Vector2)(ref vector53))._002Ector(num102, num113);
			new Vector2(100f, 0f);
			Vector2 mouseWorld2 = Main.MouseWorld;
			Vector2 vec = mouseWorld2;
			Vector2 vector55 = (pointPoisition - mouseWorld2).SafeNormalize(new Vector2(0f, -1f));
			while (vec.Y > pointPoisition.Y && WorldGen.SolidTile(vec.ToTileCoordinates()))
			{
				vec += vector55 * 16f;
			}
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition, vector53, projToShoot, Damage, KnockBack, i, 0f, vec.Y);
		}
		else if (sItem.type == 4923)
		{
			float adjustedItemScale7 = GetAdjustedItemScale(sItem);
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num102, num113, projToShoot, Damage, KnockBack, i, 0f, adjustedItemScale7);
		}
		else if (sItem.type == 1910)
		{
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num102, num113, projToShoot, Damage, KnockBack, i, 1f);
		}
		else if (sItem.type == 5134)
		{
			Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num102, num113, projToShoot, Damage, KnockBack, i, 0f, 1f);
		}
		else
		{
			int num101 = Projectile.NewProjectile(projectileSource_Item_WithPotentialAmmo, pointPoisition.X, pointPoisition.Y, num102, num113, projToShoot, Damage, KnockBack, i);
			if (sItem.type == 726)
			{
				Main.projectile[num101].magic = true;
			}
			if (sItem.type == 724 || sItem.type == 676)
			{
				Main.projectile[num101].melee = true;
			}
			if (projToShoot == 80)
			{
				Main.projectile[num101].ai[0] = tileTargetX;
				Main.projectile[num101].ai[1] = tileTargetY;
			}
			if (sItem.type == 760)
			{
				DestroyOldestProximityMinesOverMinesCap(20);
			}
			if (projToShoot == 442)
			{
				Main.projectile[num101].ai[0] = tileTargetX;
				Main.projectile[num101].ai[1] = tileTargetY;
			}
			if (projToShoot == 826)
			{
				Main.projectile[num101].ai[1] = Main.rand.Next(3);
			}
			if (sItem.type == 949)
			{
				Main.projectile[num101].ai[1] = 1f;
			}
			if (Main.projectile[num101].aiStyle == 99)
			{
				AchievementsHelper.HandleSpecialEvent(this, 7);
			}
			if (Main.projectile[num101].aiStyle == 160 && Main.IsItAHappyWindyDay)
			{
				AchievementsHelper.HandleSpecialEvent(this, 17);
			}
			NetMessage.SendData(13, -1, -1, null, whoAmI);
		}
	}

	public Vector2 GetFarthestSpawnPositionOnLine(Vector2 startPos, float speedX, float speedY)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		Vector2 pointPoisition = Main.ReverseGravitySupport(Main.MouseScreen) + Main.screenPosition;
		LimitPointToPlayerReachableArea(ref pointPoisition);
		int num = 0;
		Vector2 val = new Vector2(speedX, speedY);
		float num2 = ((Vector2)(ref val)).Length();
		val = pointPoisition - startPos;
		float num3 = ((Vector2)(ref val)).Length();
		Vector2 center = base.Center;
		center.X += direction * 16;
		while (Collision.CanHitLine(center, 0, 0, startPos, 0, 0))
		{
			num++;
			startPos.X += speedX;
			startPos.Y += speedY;
			val = startPos - pointPoisition;
			if (((Vector2)(ref val)).Length() < 20f + Math.Abs(speedX) + Math.Abs(speedY))
			{
				startPos = pointPoisition;
				break;
			}
			if (num2 * (float)num >= num3)
			{
				startPos = pointPoisition;
				break;
			}
		}
		return startPos;
	}

	public int SpawnMinionOnCursor(IEntitySource projectileSource, int ownerIndex, int minionProjectileId, int originalDamageNotScaledByMinionDamage, float KnockBack, Vector2 offsetFromCursor = default(Vector2), Vector2 velocityOnSpawn = default(Vector2))
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		Vector2 pointPoisition = Main.MouseWorld;
		pointPoisition += offsetFromCursor;
		LimitPointToPlayerReachableArea(ref pointPoisition);
		float ai = 0f;
		if (projectileSource is EntitySource_ItemUse entitySource_ItemUse)
		{
			switch (entitySource_ItemUse.Item.type)
			{
			case 1157:
				ai = 60f;
				break;
			case 2364:
			case 2365:
			case 2535:
			case 2621:
			case 2749:
			case 3474:
				ai = 1f;
				break;
			}
		}
		int num = Projectile.NewProjectile(projectileSource, pointPoisition, velocityOnSpawn, minionProjectileId, originalDamageNotScaledByMinionDamage, KnockBack, ownerIndex, 0f, ai);
		Main.projectile[num].originalDamage = originalDamageNotScaledByMinionDamage;
		return num;
	}

	private Point FindSharpTearsSpot(Vector2 targetSpot)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		Point point = targetSpot.ToTileCoordinates();
		Vector2 center = base.Center;
		Vector2 endPoint = targetSpot;
		int samplesToTake = 3;
		float samplingWidth = 4f;
		Collision.AimingLaserScan(center, endPoint, samplingWidth, samplesToTake, out var vectorTowardsTarget, out var samples);
		float num = float.PositiveInfinity;
		for (int i = 0; i < samples.Length; i++)
		{
			if (samples[i] < num)
			{
				num = samples[i];
			}
		}
		targetSpot = center + vectorTowardsTarget.SafeNormalize(Vector2.Zero) * num;
		point = targetSpot.ToTileCoordinates();
		Rectangle value = default(Rectangle);
		((Rectangle)(ref value))._002Ector(point.X, point.Y, 1, 1);
		((Rectangle)(ref value)).Inflate(6, 16);
		Rectangle value2 = default(Rectangle);
		((Rectangle)(ref value2))._002Ector(0, 0, Main.maxTilesX, Main.maxTilesY);
		((Rectangle)(ref value2)).Inflate(-40, -40);
		value = Rectangle.Intersect(value, value2);
		List<Point> list = new List<Point>();
		List<Point> list2 = new List<Point>();
		Vector2 value3 = default(Vector2);
		for (int j = ((Rectangle)(ref value)).Left; j <= ((Rectangle)(ref value)).Right; j++)
		{
			for (int k = ((Rectangle)(ref value)).Top; k <= ((Rectangle)(ref value)).Bottom; k++)
			{
				if (!WorldGen.SolidTile2(j, k))
				{
					continue;
				}
				((Vector2)(ref value3))._002Ector((float)(j * 16 + 8), (float)(k * 16 + 8));
				if (!(Vector2.Distance(targetSpot, value3) > 200f))
				{
					if (FindSharpTearsOpening(j, k, j > point.X, j < point.X, k > point.Y, k < point.Y))
					{
						list.Add(new Point(j, k));
					}
					else
					{
						list2.Add(new Point(j, k));
					}
				}
			}
		}
		if (list.Count == 0 && list2.Count == 0)
		{
			list.Add((base.Center.ToTileCoordinates().ToVector2() + Main.rand.NextVector2Square(-2f, 2f)).ToPoint());
		}
		List<Point> list3 = list;
		if (list3.Count == 0)
		{
			list3 = list2;
		}
		int index = Main.rand.Next(list3.Count);
		return list3[index];
	}

	private bool FindSharpTearsOpening(int x, int y, bool acceptLeft, bool acceptRight, bool acceptUp, bool acceptDown)
	{
		if (acceptLeft && !WorldGen.SolidTile(x - 1, y))
		{
			return true;
		}
		if (acceptRight && !WorldGen.SolidTile(x + 1, y))
		{
			return true;
		}
		if (acceptUp && !WorldGen.SolidTile(x, y - 1))
		{
			return true;
		}
		if (acceptDown && !WorldGen.SolidTile(x, y + 1))
		{
			return true;
		}
		return false;
	}

	public bool TryPlacingAGolfBallNearANearbyTee(Vector2 placePosition)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		int value = (int)(placePosition.X / 16f) - tileRangeX - num + 1;
		int value2 = (int)(placePosition.X / 16f) + tileRangeX + num - 1;
		int value3 = (int)(placePosition.Y / 16f) - tileRangeY - num + 1;
		int value4 = (int)(placePosition.Y / 16f) + tileRangeY + num - 2;
		value = Utils.Clamp(value, 10, Main.maxTilesX - 10);
		value2 = Utils.Clamp(value2, 10, Main.maxTilesX - 10);
		value3 = Utils.Clamp(value3, 10, Main.maxTilesY - 10);
		value4 = Utils.Clamp(value4, 10, Main.maxTilesY - 10);
		Vector2 value5 = Main.screenPosition + new Vector2((float)Main.mouseX, (float)Main.mouseY);
		if (gravDir == -1f)
		{
			value5.Y = Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY;
		}
		Point point = placePosition.ToTileCoordinates();
		List<Tuple<int, int>> list = new List<Tuple<int, int>>();
		for (int i = -2; i <= 2; i++)
		{
			for (int j = -2; j <= 2; j++)
			{
				int num2 = point.X + i;
				int num3 = point.Y + j;
				if (WorldGen.InWorld(num2, num3, 1))
				{
					Tile tileSafely = Framing.GetTileSafely(num2, num3);
					if (tileSafely.active() && tileSafely.type == 494)
					{
						list.Add(new Tuple<int, int>(num2, num3));
						break;
					}
				}
			}
		}
		bool result = false;
		if (list.Count > 0)
		{
			float num4 = -1f;
			Tuple<int, int> tuple = list[0];
			for (int k = 0; k < list.Count; k++)
			{
				float num5 = Vector2.Distance(new Vector2((float)list[k].Item1, (float)list[k].Item2) * 16f + Vector2.One * 8f, value5);
				if (num4 == -1f || num5 < num4)
				{
					num4 = num5;
					tuple = list[k];
				}
			}
			if (Collision.InTileBounds(tuple.Item1, tuple.Item2, value, value3, value2, value4))
			{
				result = true;
				for (int l = 0; l < 1000; l++)
				{
					if (ProjectileID.Sets.IsAGolfBall[Main.projectile[l].type] && Main.projectile[l].owner == whoAmI)
					{
						Main.projectile[l].Kill();
					}
				}
				GetPreferredGolfBallToUse(out var projType);
				Projectile.NewProjectile(GetProjectileSource_TileInteraction(tuple.Item1, tuple.Item2), (float)(tuple.Item1 * 16) + 8.5f, tuple.Item2 * 16 + 6, 0f, 0f, projType, 0, 0f, whoAmI, 0f, -1f);
			}
		}
		return result;
	}

	public void GetPreferredGolfBallToUse(out int projType)
	{
		projType = 721;
		Item item = inventory[selectedItem];
		if (!item.IsAir && item.shoot > 0 && ProjectileID.Sets.IsAGolfBall[item.shoot])
		{
			projType = item.shoot;
		}
		else
		{
			if (LoaderManager.Get<AccessorySlotLoader>().PreferredGolfBall(ref projType))
			{
				return;
			}
			for (int num = 19; num >= 0; num--)
			{
				if (IsItemSlotUnlockedAndUsable(num))
				{
					_ = num % 10;
					Item item2 = armor[num];
					if (!item2.IsAir && item2.shoot > 0 && ProjectileID.Sets.IsAGolfBall[item2.shoot])
					{
						projType = item2.shoot;
						return;
					}
				}
			}
			for (int i = 0; i < 50; i++)
			{
				Item item3 = inventory[i];
				if (!item3.IsAir && item3.shoot > 0 && ProjectileID.Sets.IsAGolfBall[item3.shoot])
				{
					projType = item3.shoot;
					break;
				}
			}
		}
	}

	private void ItemCheck_MinionAltFeatureUse(Item sItem, bool cShoot)
	{
		if (sItem.shoot > 0 && ProjectileID.Sets.MinionTargettingFeature[sItem.shoot] && altFunctionUse == 2 && cShoot && ItemTimeIsZero)
		{
			ApplyItemTime(sItem);
			if (whoAmI == Main.myPlayer)
			{
				MinionNPCTargetAim(doNotDisableIfTheTargetIsTheSame: false);
			}
		}
	}

	private void ItemCheck_TurretAltFeatureUse(Item sItem, bool cShoot)
	{
		if (sItem.shoot <= 0 || !ProjectileID.Sets.TurretFeature[sItem.shoot] || altFunctionUse != 2 || !cShoot || !ItemTimeIsZero)
		{
			return;
		}
		ApplyItemTime(sItem);
		if (whoAmI != Main.myPlayer)
		{
			return;
		}
		for (int i = 0; i < 1000; i++)
		{
			Projectile projectile = Main.projectile[i];
			if (projectile.active && projectile.owner == Main.myPlayer && ProjectileID.Sets.TurretFeature[projectile.type])
			{
				projectile.Kill();
			}
		}
	}

	private void EmitMaxManaEffect()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		SoundEngine.PlaySound(25);
		for (int i = 0; i < 5; i++)
		{
			int num = Dust.NewDust(position, width, height, 45, 0f, 0f, 255, default(Color), (float)Main.rand.Next(20, 26) * 0.1f);
			Main.dust[num].noLight = true;
			Main.dust[num].noGravity = true;
			Dust obj = Main.dust[num];
			obj.velocity *= 0.5f;
		}
	}

	private void ItemCheck_EmitHeldItemLight(Item sItem)
	{
		//IL_0738: Unknown result type (might be due to invalid IL or missing references)
		//IL_073f: Unknown result type (might be due to invalid IL or missing references)
		//IL_066a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0680: Unknown result type (might be due to invalid IL or missing references)
		//IL_0686: Unknown result type (might be due to invalid IL or missing references)
		//IL_060b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0612: Unknown result type (might be due to invalid IL or missing references)
		//IL_053d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0553: Unknown result type (might be due to invalid IL or missing references)
		//IL_0559: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0704: Unknown result type (might be due to invalid IL or missing references)
		//IL_058b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0595: Unknown result type (might be due to invalid IL or missing references)
		//IL_059a: Unknown result type (might be due to invalid IL or missing references)
		//IL_05cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e33: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e3a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0de2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0de9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d78: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d7f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d30: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d37: Unknown result type (might be due to invalid IL or missing references)
		//IL_09dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_09e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_090a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0924: Unknown result type (might be due to invalid IL or missing references)
		//IL_092a: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0390: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f03: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f0a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ebb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ec2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c98: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c9f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bc6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0be0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0be6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b67: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b6e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a95: Unknown result type (might be due to invalid IL or missing references)
		//IL_0aaf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ab5: Unknown result type (might be due to invalid IL or missing references)
		//IL_095c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0966: Unknown result type (might be due to invalid IL or missing references)
		//IL_096b: Unknown result type (might be due to invalid IL or missing references)
		//IL_099c: Unknown result type (might be due to invalid IL or missing references)
		//IL_09a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_09a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_082b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0835: Unknown result type (might be due to invalid IL or missing references)
		//IL_083a: Unknown result type (might be due to invalid IL or missing references)
		//IL_086b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0872: Unknown result type (might be due to invalid IL or missing references)
		//IL_0877: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_041f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0426: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ff3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ffa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0fa2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0fa9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c18: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c22: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c27: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c58: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c5f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c64: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ae7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0af1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0af6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b27: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b2e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b33: Unknown result type (might be due to invalid IL or missing references)
		//IL_044d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0452: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_1121: Unknown result type (might be due to invalid IL or missing references)
		//IL_1128: Unknown result type (might be due to invalid IL or missing references)
		//IL_112d: Unknown result type (might be due to invalid IL or missing references)
		//IL_10b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_10be: Unknown result type (might be due to invalid IL or missing references)
		//IL_1066: Unknown result type (might be due to invalid IL or missing references)
		//IL_106d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f45: Unknown result type (might be due to invalid IL or missing references)
		//IL_11f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_11fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_1202: Unknown result type (might be due to invalid IL or missing references)
		//IL_1207: Unknown result type (might be due to invalid IL or missing references)
		//IL_1184: Unknown result type (might be due to invalid IL or missing references)
		//IL_1189: Unknown result type (might be due to invalid IL or missing references)
		//IL_118a: Unknown result type (might be due to invalid IL or missing references)
		//IL_118f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1191: Unknown result type (might be due to invalid IL or missing references)
		//IL_1193: Unknown result type (might be due to invalid IL or missing references)
		//IL_1198: Unknown result type (might be due to invalid IL or missing references)
		//IL_119a: Unknown result type (might be due to invalid IL or missing references)
		//IL_119c: Unknown result type (might be due to invalid IL or missing references)
		//IL_11a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_11b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_11b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_11d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_11d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_1167: Unknown result type (might be due to invalid IL or missing references)
		//IL_116e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1173: Unknown result type (might be due to invalid IL or missing references)
		//IL_1326: Unknown result type (might be due to invalid IL or missing references)
		//IL_1340: Unknown result type (might be due to invalid IL or missing references)
		//IL_1345: Unknown result type (might be due to invalid IL or missing references)
		//IL_134a: Unknown result type (might be due to invalid IL or missing references)
		//IL_135a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1364: Unknown result type (might be due to invalid IL or missing references)
		//IL_1369: Unknown result type (might be due to invalid IL or missing references)
		//IL_136b: Unknown result type (might be due to invalid IL or missing references)
		//IL_136e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1373: Unknown result type (might be due to invalid IL or missing references)
		//IL_1374: Unknown result type (might be due to invalid IL or missing references)
		//IL_1375: Unknown result type (might be due to invalid IL or missing references)
		//IL_1217: Unknown result type (might be due to invalid IL or missing references)
		//IL_1238: Unknown result type (might be due to invalid IL or missing references)
		//IL_123e: Unknown result type (might be due to invalid IL or missing references)
		//IL_124f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1251: Unknown result type (might be due to invalid IL or missing references)
		//IL_1259: Unknown result type (might be due to invalid IL or missing references)
		//IL_1263: Unknown result type (might be due to invalid IL or missing references)
		//IL_1268: Unknown result type (might be due to invalid IL or missing references)
		//IL_1284: Unknown result type (might be due to invalid IL or missing references)
		//IL_128a: Unknown result type (might be due to invalid IL or missing references)
		//IL_128f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1294: Unknown result type (might be due to invalid IL or missing references)
		//IL_139b: Unknown result type (might be due to invalid IL or missing references)
		//IL_13a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_13a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_13a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_13a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_13ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_13cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_13dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_13de: Unknown result type (might be due to invalid IL or missing references)
		//IL_12a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_12bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_12c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_12c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_13ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_13ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_13f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_13fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_1403: Unknown result type (might be due to invalid IL or missing references)
		Vector2? handPosition = HandPosition;
		if (((ItemID.Sets.Torches[sItem.type] && !wet) || ItemID.Sets.WaterTorches[BiomeTorchHoldStyle(sItem.type)]) && !pulley && !happyFunTorchTime)
		{
			float R = 1f;
			float G = 0.95f;
			float B = 0.8f;
			int num = 0;
			int num4 = BiomeTorchHoldStyle(sItem.type);
			if (num4 >= ItemID.Count)
			{
				ItemLoader.GetItem(num4).HoldItem(this);
			}
			else
			{
				if (num4 == 523)
				{
					num = 8;
				}
				else if (num4 == 974)
				{
					num = 9;
				}
				else if (num4 == 1245)
				{
					num = 10;
				}
				else if (num4 == 1333)
				{
					num = 11;
				}
				else if (num4 == 2274)
				{
					num = 12;
				}
				else if (num4 == 3004)
				{
					num = 13;
				}
				else if (num4 == 3045)
				{
					num = 14;
				}
				else if (num4 == 3114)
				{
					num = 15;
				}
				else if (num4 == 4383)
				{
					num = 16;
				}
				else if (num4 == 4384)
				{
					num = 17;
				}
				else if (num4 == 4385)
				{
					num = 18;
				}
				else if (num4 == 4386)
				{
					num = 19;
				}
				else if (num4 == 4387)
				{
					num = 20;
				}
				else if (num4 == 4388)
				{
					num = 21;
				}
				else if (num4 == 5293)
				{
					num = 22;
				}
				else if (num4 == 5353)
				{
					num = 23;
				}
				else if (num4 >= 427)
				{
					num = num4 - 426;
				}
				num = (int)MathHelper.Clamp((float)num, 0f, (float)(TorchID.Count - 1));
				TorchID.TorchColor(num, out R, out G, out B);
				int num5 = TorchID.Dust[num];
				int maxValue = 30;
				if (itemAnimation > 0)
				{
					maxValue = 7;
				}
				if (direction == -1)
				{
					if (Main.rand.Next(maxValue) == 0)
					{
						int num6 = Dust.NewDust(new Vector2(itemLocation.X - 16f, itemLocation.Y - 14f * gravDir), 4, 4, num5, 0f, 0f, 100);
						if (Main.rand.Next(3) != 0)
						{
							Main.dust[num6].noGravity = true;
						}
						Dust obj = Main.dust[num6];
						obj.velocity *= 0.3f;
						Main.dust[num6].velocity.Y -= 1.5f;
						Main.dust[num6].position = RotatedRelativePoint(Main.dust[num6].position);
						if (num5 == 66)
						{
							Main.dust[num6].color = new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB);
							Main.dust[num6].noGravity = true;
						}
					}
					Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X - 12f + velocity.X, itemLocation.Y - 14f + velocity.Y)), R, G, B);
				}
				else
				{
					if (Main.rand.Next(maxValue) == 0)
					{
						int num7 = Dust.NewDust(new Vector2(itemLocation.X + 6f, itemLocation.Y - 14f * gravDir), 4, 4, num5, 0f, 0f, 100);
						if (Main.rand.Next(3) != 0)
						{
							Main.dust[num7].noGravity = true;
						}
						Dust obj2 = Main.dust[num7];
						obj2.velocity *= 0.3f;
						Main.dust[num7].velocity.Y -= 1.5f;
						Main.dust[num7].position = RotatedRelativePoint(Main.dust[num7].position);
						if (num5 == 66)
						{
							Main.dust[num7].color = new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB);
							Main.dust[num7].noGravity = true;
						}
					}
					Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X + 12f + velocity.X, itemLocation.Y - 14f + velocity.Y)), R, G, B);
				}
			}
		}
		if ((sItem.type == 105 || sItem.type == 713) && !wet && !pulley)
		{
			int maxValue2 = 20;
			if (itemAnimation > 0)
			{
				maxValue2 = 7;
			}
			if (direction == -1)
			{
				if (Main.rand.Next(maxValue2) == 0)
				{
					int num8 = Dust.NewDust(new Vector2(itemLocation.X - 12f, itemLocation.Y - 20f * gravDir), 4, 4, 6, 0f, 0f, 100);
					if (Main.rand.Next(3) != 0)
					{
						Main.dust[num8].noGravity = true;
					}
					Dust obj3 = Main.dust[num8];
					obj3.velocity *= 0.3f;
					Main.dust[num8].velocity.Y -= 1.5f;
					Main.dust[num8].position = RotatedRelativePoint(Main.dust[num8].position);
				}
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X - 16f + velocity.X, itemLocation.Y - 14f)), 1f, 0.95f, 0.8f);
			}
			else
			{
				if (Main.rand.Next(maxValue2) == 0)
				{
					int num9 = Dust.NewDust(new Vector2(itemLocation.X + 4f, itemLocation.Y - 20f * gravDir), 4, 4, 6, 0f, 0f, 100);
					if (Main.rand.Next(3) != 0)
					{
						Main.dust[num9].noGravity = true;
					}
					Dust obj4 = Main.dust[num9];
					obj4.velocity *= 0.3f;
					Main.dust[num9].velocity.Y -= 1.5f;
					Main.dust[num9].position = RotatedRelativePoint(Main.dust[num9].position);
				}
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X + 6f + velocity.X, itemLocation.Y - 14f)), 1f, 0.95f, 0.8f);
			}
		}
		else if (sItem.type == 148 && !wet && !pulley)
		{
			int maxValue3 = 10;
			if (itemAnimation > 0)
			{
				maxValue3 = 7;
			}
			if (direction == -1)
			{
				if (Main.rand.Next(maxValue3) == 0)
				{
					int num10 = Dust.NewDust(new Vector2(itemLocation.X - 12f, itemLocation.Y - 20f * gravDir), 4, 4, 172, 0f, 0f, 100);
					if (Main.rand.Next(3) != 0)
					{
						Main.dust[num10].noGravity = true;
					}
					Dust obj5 = Main.dust[num10];
					obj5.velocity *= 0.3f;
					Main.dust[num10].velocity.Y -= 1.5f;
					Main.dust[num10].position = RotatedRelativePoint(Main.dust[num10].position);
				}
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X - 16f + velocity.X, itemLocation.Y - 14f)), 0f, 0.5f, 1f);
			}
			else
			{
				if (Main.rand.Next(maxValue3) == 0)
				{
					int num11 = Dust.NewDust(new Vector2(itemLocation.X + 4f, itemLocation.Y - 20f * gravDir), 4, 4, 172, 0f, 0f, 100);
					if (Main.rand.Next(3) != 0)
					{
						Main.dust[num11].noGravity = true;
					}
					Dust obj6 = Main.dust[num11];
					obj6.velocity *= 0.3f;
					Main.dust[num11].velocity.Y -= 1.5f;
					Main.dust[num11].position = RotatedRelativePoint(Main.dust[num11].position);
				}
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X + 6f + velocity.X, itemLocation.Y - 14f)), 0f, 0.5f, 1f);
			}
		}
		else if (sItem.type == 3117 && !wet && !pulley)
		{
			itemLocation.X -= direction * 4;
			int maxValue4 = 10;
			if (itemAnimation > 0)
			{
				maxValue4 = 7;
			}
			if (direction == -1)
			{
				if (Main.rand.Next(maxValue4) == 0)
				{
					int num2 = Dust.NewDust(new Vector2(itemLocation.X - 10f, itemLocation.Y - 20f * gravDir), 4, 4, 242, 0f, 0f, 100);
					if (Main.rand.Next(3) != 0)
					{
						Main.dust[num2].noGravity = true;
					}
					Dust obj7 = Main.dust[num2];
					obj7.velocity *= 0.3f;
					Main.dust[num2].velocity.Y -= 1.5f;
					Main.dust[num2].position = RotatedRelativePoint(Main.dust[num2].position);
				}
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X - 16f + velocity.X, itemLocation.Y - 14f)), 0.9f, 0.1f, 0.75f);
			}
			else
			{
				if (Main.rand.Next(maxValue4) == 0)
				{
					int num3 = Dust.NewDust(new Vector2(itemLocation.X + 6f, itemLocation.Y - 20f * gravDir), 4, 4, 242, 0f, 0f, 100);
					if (Main.rand.Next(3) != 0)
					{
						Main.dust[num3].noGravity = true;
					}
					Dust obj8 = Main.dust[num3];
					obj8.velocity *= 0.3f;
					Main.dust[num3].velocity.Y -= 1.5f;
					Main.dust[num3].position = RotatedRelativePoint(Main.dust[num3].position);
				}
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X + 6f + velocity.X, itemLocation.Y - 14f)), 0.9f, 0.1f, 0.75f);
			}
		}
		else if (sItem.type == 5322 && !wet && !pulley)
		{
			float r = 0.2f;
			float g = 0.3f;
			float b = 0.32f;
			if (direction == -1)
			{
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X - 16f + velocity.X, itemLocation.Y - 14f)), r, g, b);
			}
			else
			{
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X + 6f + velocity.X, itemLocation.Y - 14f)), r, g, b);
			}
		}
		if (sItem.type == 282 && !pulley)
		{
			if (direction == -1)
			{
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X - 16f + velocity.X, itemLocation.Y - 14f)), 0.7f, 1f, 0.8f);
			}
			else
			{
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X + 6f + velocity.X, itemLocation.Y - 14f)), 0.7f, 1f, 0.8f);
			}
		}
		if (sItem.type == 3002 && !pulley)
		{
			float r2 = 1.05f;
			float g2 = 0.95f;
			float b2 = 0.55f;
			if (direction == -1)
			{
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X - 16f + velocity.X, itemLocation.Y - 14f)), r2, g2, b2);
			}
			else
			{
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X + 6f + velocity.X, itemLocation.Y - 14f)), r2, g2, b2);
			}
			spelunkerTimer++;
			if (spelunkerTimer >= 10)
			{
				spelunkerTimer = 0;
				Main.instance.SpelunkerProjectileHelper.AddSpotToCheck(base.Center);
			}
		}
		if (sItem.type == 286 && !pulley)
		{
			if (direction == -1)
			{
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X - 16f + velocity.X, itemLocation.Y - 14f)), 0.7f, 0.8f, 1f);
			}
			else
			{
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X + 6f + velocity.X, itemLocation.Y - 14f)), 0.7f, 0.8f, 1f);
			}
		}
		if (sItem.type == 3112 && !pulley)
		{
			if (direction == -1)
			{
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X - 16f + velocity.X, itemLocation.Y - 14f)), 1f, 0.6f, 0.85f);
			}
			else
			{
				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X + 6f + velocity.X, itemLocation.Y - 14f)), 1f, 0.6f, 0.85f);
			}
		}
		if (sItem.type == 4776 && !pulley)
		{
			Vector2 vec = RotatedRelativePoint(new Vector2(itemLocation.X + 6f + velocity.X, itemLocation.Y - 14f));
			if (direction == -1)
			{
				vec = RotatedRelativePoint(new Vector2(itemLocation.X - 16f + velocity.X, itemLocation.Y - 14f));
			}
			Vector3 rgb = (DelegateMethods.v3_1 = new Vector3(0.9f, 0.35f, 1f));
			Point p = vec.ToTileCoordinates();
			DelegateMethods.v2_1 = p.ToVector2();
			DelegateMethods.f_1 = 4.5f;
			Utils.PlotTileArea(p.X, p.Y, DelegateMethods.SpreadLightOpen_StopForSolids);
			Lighting.AddLight(vec, rgb);
		}
		if (sItem.type == 3542 && handPosition.HasValue)
		{
			Vector2 vector = handPosition.Value - velocity;
			for (int i = 0; i < 4; i++)
			{
				Dust dust = Main.dust[Dust.NewDust(base.Center, 0, 0, 242, direction * 2, 0f, 150, default(Color), 1.3f)];
				dust.position = vector;
				dust.velocity *= 0f;
				dust.noGravity = true;
				dust.fadeIn = 1f;
				dust.velocity += velocity;
				if (Main.rand.Next(2) == 0)
				{
					dust.position += Utils.RandomVector2(Main.rand, -4f, 4f);
					dust.scale += Main.rand.NextFloat();
					if (Main.rand.Next(2) == 0)
					{
						dust.customData = this;
					}
				}
			}
		}
		if (sItem.type != 4952 || pulley || isPettingAnimal)
		{
			return;
		}
		Vector2 pos = itemLocation + new Vector2((float)(8 * direction), -10f * gravDir);
		Vector3 rgb2 = new Vector3(1f, 0.7f, 0.8f) * 1.3f;
		Vector2 vector2 = RotatedRelativePoint(pos);
		Lighting.AddLight(vector2, rgb2);
		if (Main.rand.Next(40) == 0)
		{
			Vector2 vector3 = Main.rand.NextVector2Circular(4f, 4f);
			Dust dust2 = Dust.NewDustPerfect(vector2 + vector3, 43, Vector2.Zero, 254, new Color(255, 255, 0, 255), 0.3f);
			if (vector3 != Vector2.Zero)
			{
				dust2.velocity = vector2.DirectionTo(dust2.position) * 0.2f;
			}
			dust2.fadeIn = 0.3f;
			dust2.noLightEmittence = true;
			dust2.customData = this;
		}
	}

	public bool CanVisuallyHoldItem(Item item)
	{
		if (item.holdStyle == 4)
		{
			if (isPettingAnimal)
			{
				return false;
			}
			if (pulley)
			{
				return false;
			}
			if (gravDir == -1f)
			{
				return false;
			}
			if (velocity.Y != 0f)
			{
				return false;
			}
			if (mount.Active)
			{
				return false;
			}
		}
		if (item.holdStyle == 6 && isPettingAnimal)
		{
			return false;
		}
		if (item.holdStyle == 5 && isPettingAnimal)
		{
			return false;
		}
		return true;
	}

	private void ItemCheck_ApplyHoldStyle(float mountOffset, Item sItem, Rectangle heldItemFrame)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		ItemCheck_ApplyHoldStyle_Inner(mountOffset, sItem, heldItemFrame);
		ItemLoader.HoldStyle(sItem, this, heldItemFrame);
	}

	private void ItemCheck_ApplyHoldStyle_Inner(float mountOffset, Item sItem, Rectangle heldItemFrame)
	{
		//IL_0cbc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c4a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c6e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c78: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0385: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0dc7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e11: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e16: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e1a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e1f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e21: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e26: Unknown result type (might be due to invalid IL or missing references)
		//IL_0601: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e97: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ee7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0eec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ef0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ef5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ef7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0efc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d4e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d58: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d5d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d61: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d66: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d6b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d6d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d72: Unknown result type (might be due to invalid IL or missing references)
		//IL_0767: Unknown result type (might be due to invalid IL or missing references)
		//IL_0788: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_07fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_081e: Unknown result type (might be due to invalid IL or missing references)
		//IL_084c: Unknown result type (might be due to invalid IL or missing references)
		//IL_086c: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_089b: Unknown result type (might be due to invalid IL or missing references)
		//IL_08bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0313: Unknown result type (might be due to invalid IL or missing references)
		//IL_031d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_08f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0912: Unknown result type (might be due to invalid IL or missing references)
		//IL_0917: Unknown result type (might be due to invalid IL or missing references)
		//IL_091e: Unknown result type (might be due to invalid IL or missing references)
		//IL_092c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0932: Unknown result type (might be due to invalid IL or missing references)
		//IL_0954: Unknown result type (might be due to invalid IL or missing references)
		//IL_0963: Unknown result type (might be due to invalid IL or missing references)
		//IL_0968: Unknown result type (might be due to invalid IL or missing references)
		//IL_096d: Unknown result type (might be due to invalid IL or missing references)
		if (isPettingAnimal)
		{
			int num10 = miscCounter % 14 / 7;
			CompositeArmStretchAmount stretch = CompositeArmStretchAmount.ThreeQuarters;
			if (num10 == 1)
			{
				stretch = CompositeArmStretchAmount.Full;
			}
			float num2 = 0.3f;
			if (isTheAnimalBeingPetSmall)
			{
				num2 = 0.2f;
			}
			SetCompositeArmBack(enabled: true, stretch, (float)Math.PI * -2f * num2 * (float)direction);
		}
		if (!CanVisuallyHoldItem(sItem))
		{
			return;
		}
		if (sItem.holdStyle == 1 && !pulley)
		{
			if (Main.dedServ)
			{
				itemLocation.X = position.X + (float)width * 0.5f + 20f * (float)direction;
			}
			else if (sItem.type == 930)
			{
				itemLocation.X = position.X + (float)(width / 2) * 0.5f - 12f - (float)(2 * direction);
				float x = position.X + (float)(width / 2) + (float)(38 * direction);
				if (direction == 1)
				{
					x -= 10f;
				}
				float y = MountedCenter.Y - 4f * gravDir;
				if (gravDir == -1f)
				{
					y -= 8f;
				}
				RotateRelativePoint(ref x, ref y);
				int num3 = 0;
				for (int i = 54; i < 58; i++)
				{
					if (inventory[i].stack > 0 && inventory[i].ammo == 931)
					{
						num3 = inventory[i].type;
						break;
					}
				}
				if (num3 == 0)
				{
					for (int j = 0; j < 54; j++)
					{
						if (inventory[j].stack > 0 && inventory[j].ammo == 931)
						{
							num3 = inventory[j].type;
							break;
						}
					}
				}
				switch (num3)
				{
				case 931:
					num3 = 127;
					break;
				case 1614:
					num3 = 187;
					break;
				case 5377:
					num3 = 169;
					break;
				case 5378:
					num3 = 75;
					break;
				case 5379:
					num3 = 66;
					break;
				case 5380:
					num3 = 310;
					break;
				}
				if (num3 > 0)
				{
					int num4 = Dust.NewDust(new Vector2(x, y + gfxOffY), 6, 6, num3, 0f, 0f, 100, default(Color), 1.6f);
					Main.dust[num4].noGravity = true;
					Main.dust[num4].velocity.Y -= 4f * gravDir;
					if (num3 == 66)
					{
						Main.dust[num4].color = Main.hslToRgb(Main.GlobalTimeWrappedHourly * 0.6f % 1f, 1f, 0.5f);
						Main.dust[num4].scale *= 0.5f;
						Dust obj = Main.dust[num4];
						obj.velocity *= 0.75f;
					}
				}
			}
			else if (sItem.type == 968)
			{
				itemLocation.X = position.X + (float)width * 0.5f + (float)(8 * direction);
				if (whoAmI == Main.myPlayer)
				{
					int num5 = (int)(itemLocation.X + (float)heldItemFrame.Width * 0.8f * (float)direction) / 16;
					int num6 = (int)(itemLocation.Y + mountOffset + (float)(heldItemFrame.Height / 2)) / 16;
					if (Main.tile[num5, num6] == null)
					{
						Main.tile[num5, num6] = default(Tile);
					}
					if (Main.tile[num5, num6].active() && TileID.Sets.Campfire[Main.tile[num5, num6].type] && Main.tile[num5, num6].frameY < 54)
					{
						miscTimer++;
						if (Main.rand.Next(5) == 0)
						{
							miscTimer++;
						}
						if (miscTimer > 900)
						{
							miscTimer = 0;
							sItem.SetDefaults(969);
							if (selectedItem == 58)
							{
								Main.mouseItem.SetDefaults(969);
							}
							for (int k = 0; k < 58; k++)
							{
								if (inventory[k].type == sItem.type && k != selectedItem && inventory[k].stack < inventory[k].maxStack)
								{
									SoundEngine.PlaySound(7);
									inventory[k].stack++;
									sItem.SetDefaults();
									if (selectedItem == 58)
									{
										Main.mouseItem.SetDefaults();
									}
								}
							}
						}
					}
					else
					{
						miscTimer = 0;
					}
				}
			}
			else if (sItem.type == 856)
			{
				itemLocation.X = position.X + (float)width * 0.5f + (float)(4 * direction);
			}
			else if (sItem.fishingPole > 0)
			{
				itemLocation.X = position.X + (float)width * 0.5f + (float)heldItemFrame.Width * 0.18f * (float)direction;
			}
			else
			{
				itemLocation.X = position.X + (float)width * 0.5f + ((float)heldItemFrame.Width * 0.5f + 2f) * (float)direction;
				if (sItem.type == 282 || sItem.type == 286 || sItem.type == 3112 || sItem.type == 4776)
				{
					itemLocation.X -= direction * 2;
					itemLocation.Y += 4f;
				}
				else if (sItem.type == 3002)
				{
					itemLocation.X -= 4 * direction;
					itemLocation.Y += 2f;
				}
			}
			itemLocation.Y = position.Y + 24f + mountOffset;
			if (sItem.type == 856)
			{
				itemLocation.Y = position.Y + 34f + mountOffset;
			}
			if (sItem.type == 930)
			{
				itemLocation.Y = position.Y + 9f + mountOffset;
			}
			if (sItem.fishingPole > 0)
			{
				itemLocation.Y += 4f;
			}
			else if (sItem.type == 3476)
			{
				itemLocation.X = base.Center.X + (float)(14 * direction);
				itemLocation.Y = MountedCenter.Y;
			}
			else if (sItem.type == 3779)
			{
				itemLocation.X = base.Center.X + (float)(6 * direction);
				itemLocation.Y = MountedCenter.Y + 6f;
			}
			else if (sItem.type == 4952)
			{
				itemLocation.X = base.Center.X + (float)(2 * direction);
				itemLocation.Y = MountedCenter.Y + 26f;
			}
			else if (sItem.type == 353)
			{
				itemLocation.X = base.Center.X + (float)(6 * direction);
				itemLocation.Y = MountedCenter.Y + 11f;
			}
			else if (ItemID.Sets.IsFood[sItem.type])
			{
				itemLocation.X = base.Center.X + (float)(4 * direction);
				itemLocation.Y = MountedCenter.Y + (float)(heldItemFrame.Height / 2);
			}
			else if (sItem.type == 4049 && Main.rand.Next(4) == 0)
			{
				Dust dust = Dust.NewDustPerfect(base.Center + new Vector2((float)(direction * 23), gravDir * 6f), 31, Vector2.Zero, 127, default(Color), 0.7f);
				dust.noGravity = true;
				dust.velocity = Main.rand.NextVector2Circular(1f, 1f) + new Vector2(0f, -1f);
			}
			itemRotation = 0f;
			if (gravDir == -1f)
			{
				itemRotation = 0f - itemRotation;
				itemLocation.Y = position.Y + (float)height + (position.Y - itemLocation.Y) + mountOffset;
				if (sItem.type == 930)
				{
					itemLocation.Y -= 24f;
				}
			}
		}
		else if (sItem.holdStyle == 2 && !pulley)
		{
			if (sItem.type == 946 || sItem.type == 4707)
			{
				itemRotation = 0f;
				itemLocation.X = position.X + (float)width * 0.5f - (float)(16 * direction);
				itemLocation.Y = position.Y + 22f + mountOffset;
				fallStart = (int)(position.Y / 16f);
				if (gravDir == -1f)
				{
					itemRotation = 0f - itemRotation;
					itemLocation.Y = position.Y + (float)height + (position.Y - itemLocation.Y);
					if (velocity.Y < -2f && !controlDown)
					{
						velocity.Y = -2f;
					}
				}
				else if (velocity.Y > 2f && !controlDown)
				{
					velocity.Y = 2f;
				}
			}
			else
			{
				itemLocation.X = position.X + (float)width * 0.5f + (float)(6 * direction);
				itemLocation.Y = position.Y + 16f + mountOffset;
				itemRotation = 0.79f * (float)(-direction);
				if (gravDir == -1f)
				{
					itemRotation = 0f - itemRotation;
					itemLocation.Y = position.Y + (float)height + (position.Y - itemLocation.Y);
				}
			}
		}
		else if (sItem.holdStyle == 3 && !pulley)
		{
			if (!Main.dedServ)
			{
				itemLocation.X = position.X + (float)width * 0.5f - (float)heldItemFrame.Width * 0.5f - (float)(direction * 2);
				itemLocation.Y = MountedCenter.Y - (float)heldItemFrame.Height * 0.5f;
				itemRotation = 0f;
			}
		}
		else if (sItem.holdStyle == 4)
		{
			if (!Main.dedServ)
			{
				float num7 = Utils.ToRotation(new Vector2((float)(10 * direction), 10f)) + (float)Math.PI / 4f;
				itemRotation = num7;
				if (direction == -1)
				{
					itemRotation += (float)Math.PI / 2f;
				}
				CompositeArmStretchAmount stretch2 = CompositeArmStretchAmount.Full;
				CompositeArmStretchAmount stretch3 = CompositeArmStretchAmount.ThreeQuarters;
				float num8 = -(float)Math.PI / 10f;
				if (direction == -1)
				{
					num8 *= -1f;
				}
				float num9 = itemRotation - (float)Math.PI / 4f + (float)Math.PI;
				if (direction == 1)
				{
					num9 += (float)Math.PI / 2f;
				}
				float rotation = num9 + num8;
				float rotation2 = num9 - num8;
				Vector2 vector = (num9 + (float)Math.PI / 2f).ToRotationVector2() * 2f;
				itemLocation = MountedCenter.Floor() + vector;
				SetCompositeArmFront(enabled: true, stretch2, rotation);
				SetCompositeArmBack(enabled: true, stretch3, rotation2);
				FlipItemLocationAndRotationForGravity();
			}
		}
		else if (sItem.holdStyle == 5 && !pulley)
		{
			if (!Main.dedServ)
			{
				itemRotation = 0f;
				itemLocation.X = base.Center.X - (float)(8 * direction);
				itemLocation.Y = position.Y + 40f + mountOffset;
				Vector2 vector2 = Main.OffsetsPlayerHeadgear[bodyFrame.Y / 56];
				itemLocation += vector2;
				CompositeArmStretchAmount stretch4 = CompositeArmStretchAmount.Quarter;
				SetCompositeArmBack(enabled: true, stretch4, -(float)Math.PI / 4f * (float)direction);
				CompositeArmStretchAmount stretch5 = CompositeArmStretchAmount.Full;
				SetCompositeArmFront(enabled: true, stretch5, -0.39269912f * (float)direction);
				FlipItemLocationAndRotationForGravity();
			}
		}
		else if (sItem.holdStyle == 6 && !pulley && !Main.dedServ)
		{
			itemRotation = 0f;
			itemLocation.X = base.Center.X + (float)(8 * direction);
			itemLocation.Y = position.Y + 40f + mountOffset - 2f;
			Vector2 vector3 = Main.OffsetsPlayerHeadgear[bodyFrame.Y / 56];
			itemLocation += vector3;
			CompositeArmStretchAmount stretch6 = CompositeArmStretchAmount.ThreeQuarters;
			SetCompositeArmBack(enabled: true, stretch6, (float)Math.PI * -3f / 5f * (float)direction);
			FlipItemLocationAndRotationForGravity();
		}
	}

	private void ItemCheck_ApplyManaRegenDelay(Item sItem)
	{
		if (GetManaCost(sItem) > 0)
		{
			manaRegenDelay = (int)maxRegenDelay;
		}
	}

	public Vector2 GetFrontHandPosition(CompositeArmStretchAmount stretch, float rotation)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		float num = rotation + (float)Math.PI / 2f;
		Vector2 vector = default(Vector2);
		((Vector2)(ref vector))._002Ector((float)Math.Cos(num), (float)Math.Sin(num));
		switch (stretch)
		{
		case CompositeArmStretchAmount.Full:
			vector *= 10f;
			break;
		case CompositeArmStretchAmount.None:
			vector *= 4f;
			break;
		case CompositeArmStretchAmount.Quarter:
			vector *= 6f;
			break;
		case CompositeArmStretchAmount.ThreeQuarters:
			vector *= 8f;
			break;
		}
		if (direction == -1)
		{
			vector += new Vector2(4f, -2f);
			vector += Utils.RotatedBy(new Vector2(0f, -3f), rotation + (float)Math.PI / 2f);
		}
		else
		{
			vector += new Vector2(-4f, -2f);
			vector += Utils.RotatedBy(new Vector2(0f, 3f), rotation + (float)Math.PI / 2f);
		}
		return MountedCenter + vector;
	}

	public Vector2 GetBackHandPosition(CompositeArmStretchAmount stretch, float rotation)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		float num = rotation + (float)Math.PI / 2f;
		Vector2 vector = default(Vector2);
		((Vector2)(ref vector))._002Ector((float)Math.Cos(num), (float)Math.Sin(num));
		switch (stretch)
		{
		case CompositeArmStretchAmount.Full:
			vector *= new Vector2(10f, 12f);
			break;
		case CompositeArmStretchAmount.None:
			vector *= new Vector2(4f, 6f);
			break;
		case CompositeArmStretchAmount.Quarter:
			vector *= new Vector2(6f, 8f);
			break;
		case CompositeArmStretchAmount.ThreeQuarters:
			vector *= new Vector2(8f, 10f);
			break;
		}
		vector = ((direction != -1) ? (vector + new Vector2(6f, -2f)) : (vector + new Vector2(-6f, -2f)));
		return MountedCenter + vector;
	}

	public void ItemCheck_ApplyUseStyle(float mountOffset, Item sItem, Rectangle heldItemFrame)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		ItemCheck_ApplyUseStyle_Inner(mountOffset, sItem, heldItemFrame);
		ItemLoader.UseStyle(sItem, this, heldItemFrame);
	}

	private void ItemCheck_ApplyUseStyle_Inner(float mountOffset, Item sItem, Rectangle heldItemFrame)
	{
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_090d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0931: Unknown result type (might be due to invalid IL or missing references)
		//IL_0936: Unknown result type (might be due to invalid IL or missing references)
		//IL_093b: Unknown result type (might be due to invalid IL or missing references)
		//IL_097c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0990: Unknown result type (might be due to invalid IL or missing references)
		//IL_0995: Unknown result type (might be due to invalid IL or missing references)
		//IL_099c: Unknown result type (might be due to invalid IL or missing references)
		//IL_09a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_09b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_09b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_09be: Unknown result type (might be due to invalid IL or missing references)
		//IL_09c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_09c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_09c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0761: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_09f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_09fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a05: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a0b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a10: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a15: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a1c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a32: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a37: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a3e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a44: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a49: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a4e: Unknown result type (might be due to invalid IL or missing references)
		//IL_049b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0318: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cbd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cd1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ced: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cf3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cf5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cfa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0cff: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0329: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0bf3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b66: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1054: Unknown result type (might be due to invalid IL or missing references)
		//IL_10a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04df: Unknown result type (might be due to invalid IL or missing references)
		//IL_1315: Unknown result type (might be due to invalid IL or missing references)
		//IL_1335: Unknown result type (might be due to invalid IL or missing references)
		//IL_0db9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0dc3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0dd4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ddf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0de4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0de9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_1371: Unknown result type (might be due to invalid IL or missing references)
		//IL_137b: Unknown result type (might be due to invalid IL or missing references)
		//IL_13a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1221: Unknown result type (might be due to invalid IL or missing references)
		//IL_1272: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c49: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c93: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c98: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c9c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ca1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ca3: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ca8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1554: Unknown result type (might be due to invalid IL or missing references)
		//IL_1578: Unknown result type (might be due to invalid IL or missing references)
		//IL_1582: Unknown result type (might be due to invalid IL or missing references)
		//IL_13e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_15ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_15b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_15c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_15cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_15d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_15d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_15de: Unknown result type (might be due to invalid IL or missing references)
		//IL_15e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_15f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_15f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0557: Unknown result type (might be due to invalid IL or missing references)
		//IL_057c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_18c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_18ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_14f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_14fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_1501: Unknown result type (might be due to invalid IL or missing references)
		//IL_150c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1513: Unknown result type (might be due to invalid IL or missing references)
		//IL_151f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1524: Unknown result type (might be due to invalid IL or missing references)
		//IL_1529: Unknown result type (might be due to invalid IL or missing references)
		//IL_152e: Unknown result type (might be due to invalid IL or missing references)
		//IL_161c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1621: Unknown result type (might be due to invalid IL or missing references)
		//IL_1623: Unknown result type (might be due to invalid IL or missing references)
		//IL_1637: Unknown result type (might be due to invalid IL or missing references)
		//IL_164d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1650: Unknown result type (might be due to invalid IL or missing references)
		//IL_1655: Unknown result type (might be due to invalid IL or missing references)
		//IL_1669: Unknown result type (might be due to invalid IL or missing references)
		//IL_166e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1673: Unknown result type (might be due to invalid IL or missing references)
		//IL_16cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_16d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_16d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_16dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_058d: Unknown result type (might be due to invalid IL or missing references)
		//IL_040a: Unknown result type (might be due to invalid IL or missing references)
		//IL_063c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0641: Unknown result type (might be due to invalid IL or missing references)
		//IL_0643: Unknown result type (might be due to invalid IL or missing references)
		//IL_0648: Unknown result type (might be due to invalid IL or missing references)
		//IL_064d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0652: Unknown result type (might be due to invalid IL or missing references)
		//IL_20c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_2111: Unknown result type (might be due to invalid IL or missing references)
		//IL_2116: Unknown result type (might be due to invalid IL or missing references)
		//IL_211a: Unknown result type (might be due to invalid IL or missing references)
		//IL_211f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2121: Unknown result type (might be due to invalid IL or missing references)
		//IL_2126: Unknown result type (might be due to invalid IL or missing references)
		//IL_1818: Unknown result type (might be due to invalid IL or missing references)
		//IL_14b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_14b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_174c: Unknown result type (might be due to invalid IL or missing references)
		//IL_174e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1755: Unknown result type (might be due to invalid IL or missing references)
		//IL_175c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1770: Unknown result type (might be due to invalid IL or missing references)
		//IL_1775: Unknown result type (might be due to invalid IL or missing references)
		//IL_177b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1780: Unknown result type (might be due to invalid IL or missing references)
		//IL_1785: Unknown result type (might be due to invalid IL or missing references)
		//IL_1729: Unknown result type (might be due to invalid IL or missing references)
		//IL_172e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f49: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f53: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f64: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f6f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f74: Unknown result type (might be due to invalid IL or missing references)
		//IL_0f79: Unknown result type (might be due to invalid IL or missing references)
		//IL_059e: Unknown result type (might be due to invalid IL or missing references)
		//IL_191f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ace: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ad3: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ad5: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ada: Unknown result type (might be due to invalid IL or missing references)
		//IL_1adf: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bdb: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bee: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bf3: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bf7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bfc: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bfe: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c03: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c08: Unknown result type (might be due to invalid IL or missing references)
		//IL_19c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_19cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_19d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_19d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_19d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_19db: Unknown result type (might be due to invalid IL or missing references)
		//IL_19e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_19e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_1dd1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1dd6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ddd: Unknown result type (might be due to invalid IL or missing references)
		//IL_1de5: Unknown result type (might be due to invalid IL or missing references)
		//IL_1df7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1dfc: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e06: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e0b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e10: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e12: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e28: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e35: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e3b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e56: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e60: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e65: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e8d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e94: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ec1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ec7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ec9: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ee4: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ef3: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ef8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f13: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f2f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f39: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f3e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f4e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f55: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f5f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f64: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f69: Unknown result type (might be due to invalid IL or missing references)
		//IL_1fa0: Unknown result type (might be due to invalid IL or missing references)
		//IL_1fa7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1fd4: Unknown result type (might be due to invalid IL or missing references)
		//IL_1fda: Unknown result type (might be due to invalid IL or missing references)
		//IL_1fdc: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ff7: Unknown result type (might be due to invalid IL or missing references)
		//IL_2006: Unknown result type (might be due to invalid IL or missing references)
		//IL_200b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2026: Unknown result type (might be due to invalid IL or missing references)
		//IL_2042: Unknown result type (might be due to invalid IL or missing references)
		//IL_204c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2051: Unknown result type (might be due to invalid IL or missing references)
		//IL_2061: Unknown result type (might be due to invalid IL or missing references)
		//IL_2068: Unknown result type (might be due to invalid IL or missing references)
		//IL_2072: Unknown result type (might be due to invalid IL or missing references)
		//IL_2077: Unknown result type (might be due to invalid IL or missing references)
		//IL_207c: Unknown result type (might be due to invalid IL or missing references)
		if (Main.dedServ)
		{
			return;
		}
		if (sItem.useStyle == 1)
		{
			if (sItem.type > -1 && Item.claw[sItem.type])
			{
				if ((double)itemAnimation < (double)itemAnimationMax * 0.333)
				{
					float num = 10f;
					itemLocation.X = position.X + (float)width * 0.5f + ((float)heldItemFrame.Width * 0.5f - num) * (float)direction;
					itemLocation.Y = position.Y + 26f + mountOffset;
				}
				else if ((double)itemAnimation < (double)itemAnimationMax * 0.666)
				{
					float num12 = 8f;
					itemLocation.X = position.X + (float)width * 0.5f + ((float)heldItemFrame.Width * 0.5f - num12) * (float)direction;
					num12 = 24f;
					itemLocation.Y = position.Y + num12 + mountOffset;
				}
				else
				{
					float num23 = 6f;
					itemLocation.X = position.X + (float)width * 0.5f - ((float)heldItemFrame.Width * 0.5f - num23) * (float)direction;
					num23 = 20f;
					itemLocation.Y = position.Y + num23 + mountOffset;
				}
				itemRotation = ((float)itemAnimation / (float)itemAnimationMax - 0.5f) * (float)(-direction) * 3.5f - (float)direction * 0.3f;
			}
			else
			{
				Vector2 zero = Vector2.Zero;
				if ((double)itemAnimation < (double)itemAnimationMax * 0.333)
				{
					float num33 = 10f;
					if (heldItemFrame.Width > 32)
					{
						num33 = 14f;
					}
					if (heldItemFrame.Width >= 52)
					{
						num33 = 24f;
					}
					if (heldItemFrame.Width >= 64)
					{
						num33 = 28f;
					}
					if (heldItemFrame.Width >= 92)
					{
						num33 = 38f;
					}
					if (sItem.type == 2330 || sItem.type == 2320 || sItem.type == 2341)
					{
						num33 += 8f;
					}
					if (sItem.type == 671)
					{
						num33 += 12f;
					}
					itemLocation.X = position.X + (float)width * 0.5f + ((float)heldItemFrame.Width * 0.5f - num33) * (float)direction;
					itemLocation.Y = position.Y + 24f + mountOffset;
					((Vector2)(ref zero))._002Ector(-4f, 1f);
				}
				else if ((double)itemAnimation < (double)itemAnimationMax * 0.666)
				{
					float num35 = 10f;
					if (heldItemFrame.Width > 32)
					{
						num35 = 18f;
					}
					if (heldItemFrame.Width >= 52)
					{
						num35 = 24f;
					}
					if (heldItemFrame.Width >= 64)
					{
						num35 = 28f;
					}
					if (heldItemFrame.Width >= 92)
					{
						num35 = 38f;
					}
					if (sItem.type == 2330 || sItem.type == 2320 || sItem.type == 2341)
					{
						num35 += 4f;
					}
					if (sItem.type == 671)
					{
						num35 += 6f;
					}
					itemLocation.X = position.X + (float)width * 0.5f + ((float)heldItemFrame.Width * 0.5f - num35) * (float)direction;
					num35 = 10f;
					if (heldItemFrame.Height > 32)
					{
						num35 = 8f;
					}
					if (heldItemFrame.Height > 52)
					{
						num35 = 12f;
					}
					if (heldItemFrame.Height > 64)
					{
						num35 = 14f;
					}
					if (sItem.type == 2330 || sItem.type == 2320 || sItem.type == 2341)
					{
						num35 += 4f;
					}
					if (sItem.type == 671)
					{
						num35 += 10f;
					}
					itemLocation.Y = position.Y + num35 + mountOffset;
					((Vector2)(ref zero))._002Ector(-6f, -4f);
				}
				else
				{
					float num36 = 6f;
					if (heldItemFrame.Width > 32)
					{
						num36 = 14f;
					}
					if (heldItemFrame.Width >= 48)
					{
						num36 = 18f;
					}
					if (heldItemFrame.Width >= 52)
					{
						num36 = 24f;
					}
					if (heldItemFrame.Width >= 64)
					{
						num36 = 28f;
					}
					if (heldItemFrame.Width >= 92)
					{
						num36 = 38f;
					}
					if (sItem.type == 2330 || sItem.type == 2320 || sItem.type == 2341)
					{
						num36 += 4f;
					}
					if (sItem.type == 671)
					{
						num36 += 8f;
					}
					itemLocation.X = position.X + (float)width * 0.5f - ((float)heldItemFrame.Width * 0.5f - num36) * (float)direction;
					num36 = 10f;
					if (heldItemFrame.Height > 32)
					{
						num36 = 10f;
					}
					if (heldItemFrame.Height > 52)
					{
						num36 = 12f;
					}
					if (heldItemFrame.Height > 64)
					{
						num36 = 14f;
					}
					if (sItem.type == 2330 || sItem.type == 2320 || sItem.type == 2341)
					{
						num36 += 4f;
					}
					if (sItem.type == 671)
					{
						num36 += 8f;
					}
					itemLocation.Y = position.Y + num36 + mountOffset;
					((Vector2)(ref zero))._002Ector(4f, -2f);
				}
				if (sItem.type > -1 && ItemID.Sets.UsesBetterMeleeItemLocation[sItem.type])
				{
					itemLocation += zero * Directions;
				}
				itemRotation = ((float)itemAnimation / (float)itemAnimationMax - 0.5f) * (float)(-direction) * 3.5f - (float)direction * 0.3f;
			}
			if (gravDir == -1f)
			{
				itemRotation = 0f - itemRotation;
				itemLocation.Y = position.Y + (float)height + (position.Y - itemLocation.Y);
			}
		}
		else if (sItem.useStyle == 7)
		{
			itemRotation = (float)itemAnimation / (float)itemAnimationMax * (float)direction * 2f + -1.4f * (float)direction;
			if ((double)itemAnimation < (double)itemAnimationMax * 0.5)
			{
				itemLocation.X = position.X + (float)width * 0.5f + ((float)heldItemFrame.Width * 0.5f - 9f - itemRotation * 12f * (float)direction) * (float)direction;
				itemLocation.Y = position.Y + 38f + itemRotation * (float)direction * 4f + mountOffset;
			}
			else
			{
				itemLocation.X = position.X + (float)width * 0.5f + ((float)heldItemFrame.Width * 0.5f - 9f - itemRotation * 16f * (float)direction) * (float)direction;
				itemLocation.Y = position.Y + 38f + itemRotation * (float)direction + mountOffset;
			}
			if (gravDir == -1f)
			{
				itemRotation = 0f - itemRotation;
				itemLocation.Y = position.Y + (float)height + (position.Y - itemLocation.Y);
			}
		}
		else if (sItem.useStyle == 9)
		{
			float num37 = (float)itemAnimation / (float)itemAnimationMax;
			float t = 1f - num37;
			t = Utils.GetLerpValue(0f, 0.7f, t, clamped: true);
			itemRotation = t * (float)(-direction) * 2f + 0.7f * (float)direction;
			itemLocation = MountedCenter + new Vector2((float)(direction * 10) * ((float)itemAnimation / (float)itemAnimationMax), 0f);
			float num38 = 8f;
			float num39 = 7f;
			float num2 = (float)Math.PI * 2f / 5f;
			float num3 = (0f - num2) * 0.5f + (1f - t) * num2;
			num3 += (float)Math.PI / 10f;
			Vector2 vector = base.Center + new Vector2((float)direction * num38, 0f) + num3.ToRotationVector2() * num39 * new Vector2((float)direction, 1f);
			itemLocation = vector;
			float num4 = num3 - (float)Math.PI / 2f;
			if (direction == -1)
			{
				num4 = 0f - num4;
			}
			SetCompositeArmFront(enabled: true, CompositeArmStretchAmount.Full, num4);
			itemLocation = GetFrontHandPosition(CompositeArmStretchAmount.Full, num4);
			itemLocation -= MountedCenter;
			itemLocation *= MathHelper.Lerp(1.5f, 1.2f, t);
			itemLocation += MountedCenter;
			itemLocation.X += (float)direction * MathHelper.Lerp(8f, 2f, t);
			if (gravDir == -1f)
			{
				itemRotation = 0f - itemRotation;
				itemLocation.Y = position.Y + (float)height + (position.Y - itemLocation.Y);
			}
		}
		else if (sItem.useStyle == 6)
		{
			float num5 = 1f - (float)itemAnimation / (float)itemAnimationMax;
			num5 *= 6f;
			if (num5 > 1f)
			{
				num5 = 1f;
			}
			itemRotation = (1f - num5) * (float)direction * 2f - 1.4f * (float)direction;
			if (num5 >= 0.5f)
			{
				itemLocation.X = position.X + (float)width * 0.5f + ((float)heldItemFrame.Width * 0.5f - 9f - itemRotation * 12f * (float)direction) * (float)direction;
				itemLocation.Y = position.Y + 38f + itemRotation * (float)direction * 4f + mountOffset;
			}
			else
			{
				itemLocation.X = position.X + (float)width * 0.5f + ((float)heldItemFrame.Width * 0.5f - 9f - itemRotation * 16f * (float)direction) * (float)direction;
				itemLocation.Y = position.Y + 38f + itemRotation * (float)direction + mountOffset;
			}
			if (gravDir == -1f)
			{
				itemRotation = 0f - itemRotation;
				itemLocation.Y = position.Y + (float)height + (position.Y - itemLocation.Y);
			}
		}
		else if (sItem.useStyle == 2)
		{
			itemLocation = MountedCenter + Utils.RotatedBy(new Vector2((float)(10 * direction), -10f), itemRotation + (float)Math.PI / 4f * (float)direction);
			float num6 = 1f - (float)itemAnimation / (float)itemAnimationMax;
			CompositeArmStretchAmount compositeArmStretchAmount = CompositeArmStretchAmount.Full;
			if (num6 > 0.25f && num6 <= 0.5f)
			{
				compositeArmStretchAmount = CompositeArmStretchAmount.ThreeQuarters;
			}
			if (num6 > 0.5f && num6 <= 0.75f)
			{
				compositeArmStretchAmount = CompositeArmStretchAmount.Quarter;
			}
			if (num6 > 0.75f && num6 <= 1f)
			{
				compositeArmStretchAmount = CompositeArmStretchAmount.None;
			}
			SetCompositeArmFront(enabled: true, compositeArmStretchAmount, -(float)Math.PI / 2f * (float)direction);
			SetCompositeArmBack(enabled: true, compositeArmStretchAmount, -(float)Math.PI / 2f * (float)direction);
			int num7 = 8;
			switch (compositeArmStretchAmount)
			{
			case CompositeArmStretchAmount.Full:
				num7 = 8;
				break;
			case CompositeArmStretchAmount.ThreeQuarters:
				num7 = 6;
				break;
			case CompositeArmStretchAmount.Quarter:
				num7 = 4;
				break;
			case CompositeArmStretchAmount.None:
				num7 = 2;
				break;
			}
			itemLocation = MountedCenter + new Vector2((float)((num7 + 10 - heldItemFrame.Width / 2) * direction), (float)(heldItemFrame.Height / 2 - 4));
			if (gravDir == -1f)
			{
				itemRotation = 0f - itemRotation;
				itemLocation.Y = position.Y + (float)height + (position.Y - itemLocation.Y);
			}
		}
		else if (sItem.useStyle == 11)
		{
			float num8 = 1f - (float)itemAnimation / (float)itemAnimationMax;
			num8 *= 2f;
			CompositeArmStretchAmount compositeArmStretchAmount2 = CompositeArmStretchAmount.Full;
			if (num8 > 0.25f && num8 <= 0.5f)
			{
				compositeArmStretchAmount2 = CompositeArmStretchAmount.ThreeQuarters;
			}
			if (num8 > 0.5f && num8 <= 0.75f)
			{
				compositeArmStretchAmount2 = CompositeArmStretchAmount.Quarter;
			}
			if (num8 > 0.75f && num8 <= 1.25f)
			{
				compositeArmStretchAmount2 = CompositeArmStretchAmount.None;
			}
			if (num8 > 1.25f && num8 <= 1.5f)
			{
				compositeArmStretchAmount2 = CompositeArmStretchAmount.Quarter;
			}
			if (num8 > 1.5f && num8 <= 1.75f)
			{
				compositeArmStretchAmount2 = CompositeArmStretchAmount.ThreeQuarters;
			}
			if (num8 > 1.75f && num8 <= 2f)
			{
				compositeArmStretchAmount2 = CompositeArmStretchAmount.Full;
			}
			SetCompositeArmFront(enabled: true, compositeArmStretchAmount2, -(float)Math.PI / 4f * (float)direction);
			SetCompositeArmBack(enabled: true, CompositeArmStretchAmount.Full, -(float)Math.PI / 16f);
			int num9 = 8;
			switch (compositeArmStretchAmount2)
			{
			case CompositeArmStretchAmount.Full:
				num9 = 8;
				break;
			case CompositeArmStretchAmount.ThreeQuarters:
				num9 = 6;
				break;
			case CompositeArmStretchAmount.Quarter:
				num9 = 4;
				break;
			case CompositeArmStretchAmount.None:
				num9 = 2;
				break;
			}
			itemLocation = MountedCenter + new Vector2((float)((num9 + 22 - heldItemFrame.Width / 2) * direction), (float)(heldItemFrame.Height / 2 - 8));
			if (gravDir == -1f)
			{
				itemRotation = 0f - itemRotation;
				itemLocation.Y = position.Y + (float)height + (position.Y - itemLocation.Y);
			}
		}
		else if (sItem.useStyle == 3)
		{
			if ((double)itemAnimation > (double)itemAnimationMax * 0.666)
			{
				itemLocation.X = -1000f;
				itemLocation.Y = -1000f;
				itemRotation = -1.3f * (float)direction;
			}
			else
			{
				itemLocation.X = position.X + (float)width * 0.5f + ((float)heldItemFrame.Width * 0.5f - 4f) * (float)direction;
				itemLocation.Y = position.Y + 24f + mountOffset;
				float num10 = (float)itemAnimation / (float)itemAnimationMax * (float)heldItemFrame.Width * (float)direction * GetAdjustedItemScale(sItem) * 1.2f - (float)(10 * direction);
				if (num10 > -4f && direction == -1)
				{
					num10 = -8f;
				}
				if (num10 < 4f && direction == 1)
				{
					num10 = 8f;
				}
				itemLocation.X -= num10;
				itemRotation = 0.8f * (float)direction;
				if (sItem.type == 946 || sItem.type == 4707)
				{
					itemLocation.X -= 6 * direction;
				}
			}
			if (gravDir == -1f)
			{
				itemRotation = 0f - itemRotation;
				itemLocation.Y = position.Y + (float)height + (position.Y - itemLocation.Y);
			}
		}
		else if (sItem.useStyle == 4)
		{
			int num11 = 0;
			int num13 = 0;
			if (sItem.type == 3601)
			{
				num11 = 10;
			}
			if (sItem.type == 5114)
			{
				num11 = 10;
				num13 = -2;
			}
			if (sItem.type == 5120)
			{
				num11 = 10;
			}
			itemRotation = 0f;
			itemLocation.X = position.X + (float)width * 0.5f + ((float)heldItemFrame.Width * 0.5f - 9f - itemRotation * 14f * (float)direction - 4f - (float)num11) * (float)direction;
			itemLocation.Y = position.Y + (float)heldItemFrame.Height * 0.5f + 4f + mountOffset + (float)num13;
			if (gravDir == -1f)
			{
				itemRotation = 0f - itemRotation;
				itemLocation.Y = position.Y + (float)height + (position.Y - itemLocation.Y);
			}
		}
		else if (sItem.useStyle == 5)
		{
			if (sItem.type == 3779)
			{
				itemRotation = 0f;
				itemLocation.X = base.Center.X + (float)(6 * direction);
				itemLocation.Y = MountedCenter.Y + 6f;
			}
			else if (sItem.type == 4262)
			{
				itemRotation = 0f;
				itemLocation.X = base.Center.X + (float)(-heldItemFrame.Width) * 0.5f + (float)(direction * -6);
				itemLocation.Y = MountedCenter.Y - 6f;
				if (Main.rand.Next(20) == 0)
				{
					int num14 = Main.rand.Next(570, 573);
					Vector2 vector4 = default(Vector2);
					((Vector2)(ref vector4))._002Ector(base.Center.X + (float)(direction * 30) - 6f, itemLocation.Y - 30f);
					Vector2 vector5 = default(Vector2);
					((Vector2)(ref vector5))._002Ector(Main.WindForVisuals * 2f + (float)direction * 0.3f, -0.5f);
					vector5.X *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
					vector5.Y *= 1f + (float)Main.rand.Next(-50, 51) * 0.01f;
					if (num14 == 572)
					{
						vector4.X -= 8f;
					}
					if (num14 == 571)
					{
						vector4.X -= 4f;
					}
					Gore.NewGore(vector4, vector5, num14, 0.8f);
				}
			}
			else if (Item.staff[sItem.type])
			{
				float num15 = 6f;
				if (sItem.type == 3476)
				{
					num15 = 14f;
				}
				itemLocation = MountedCenter;
				itemLocation += (itemRotation.ToRotationVector2() * num15 * (float)direction).Floor();
			}
			else
			{
				itemLocation.X = position.X + (float)width * 0.5f - (float)heldItemFrame.Width * 0.5f - (float)(direction * 2);
				itemLocation.Y = MountedCenter.Y - (float)heldItemFrame.Height * 0.5f;
			}
			if (sItem.type != 5065)
			{
				return;
			}
			_ = itemRotation;
			Vector2 vector6 = itemLocation + itemRotation.ToRotationVector2() * 38f * (float)direction;
			Vector2 vector7 = itemRotation.ToRotationVector2() * 5f * (float)direction;
			if (itemAnimation % 2 == 0)
			{
				Color newColor = Main.hslToRgb(0.92f, 1f, 0.5f);
				int num16 = Dust.NewDust(vector6, 0, 0, 267, 0f, 0f, 0, newColor);
				Main.dust[num16].position = vector6 - velocity + Main.rand.NextVector2Circular(10f, 10f);
				Main.dust[num16].noGravity = true;
				Main.dust[num16].scale = 0.3f;
				Main.dust[num16].fadeIn = Main.rand.NextFloat() * 1.2f;
				Main.dust[num16].velocity = Main.rand.NextVector2Circular(1f, 1f) + velocity;
				if (num16 != 6000)
				{
					Dust dust5 = Dust.CloneDust(num16);
					dust5.scale /= 2f;
					dust5.fadeIn *= 0.85f;
					dust5.color = new Color(255, 255, 255, 255);
				}
			}
			if (itemAnimation % 4 == 0)
			{
				ParticleOrchestrator.RequestParticleSpawn(clientOnly: true, ParticleOrchestraType.PrincessWeapon, new ParticleOrchestraSettings
				{
					PositionInWorld = vector6,
					MovementVector = vector7 * 0.1f + Main.rand.NextVector2Circular(2f, 2f) + velocity
				}, whoAmI);
			}
		}
		else if (sItem.useStyle == 13)
		{
			int useAnimation = itemAnimationMax;
			if (itemTimeMax != 0)
			{
				useAnimation = itemTimeMax;
			}
			if (useAnimation == 0)
			{
				useAnimation = sItem.useAnimation;
			}
			float num17 = 1f - (float)(itemAnimation % useAnimation) / (float)useAnimation;
			CompositeArmStretchAmount stretch = CompositeArmStretchAmount.Quarter;
			if (num17 > 0.33f && num17 <= 0.66f)
			{
				stretch = CompositeArmStretchAmount.ThreeQuarters;
			}
			if (num17 > 0.66f && num17 <= 1f)
			{
				stretch = CompositeArmStretchAmount.Full;
			}
			float rotation = itemRotation * Directions.Y - (float)Math.PI / 2f * (float)direction;
			SetCompositeArmFront(enabled: true, stretch, rotation);
		}
		else if (sItem.useStyle == 8)
		{
			Projectile projectile = null;
			if (ownedProjectileCounts[722] > 0)
			{
				for (int i = 0; i < 1000; i++)
				{
					Projectile projectile2 = Main.projectile[i];
					if (projectile2.active && projectile2.owner == whoAmI && projectile2.type == 722)
					{
						projectile = projectile2;
						break;
					}
				}
			}
			float num18 = 1f;
			if (projectile != null)
			{
				num18 = MathHelper.Lerp(0.6f, 1f, Utils.GetLerpValue(0f, 800f, Vector2.Distance(MountedCenter, projectile.Center), clamped: true));
			}
			num18 = 1f;
			if (itemAnimation >= sItem.useAnimation - 1 && itemAnimation <= sItem.useAnimation)
			{
				float num19 = Utils.ToRotation(new Vector2((float)(10 * direction), 10f)) + (float)Math.PI / 4f;
				itemRotation = num19;
				if (direction == -1)
				{
					itemRotation += (float)Math.PI / 2f;
				}
				_ = (float)itemAnimation / (float)itemAnimationMax;
				CompositeArmStretchAmount stretch2 = CompositeArmStretchAmount.Full;
				CompositeArmStretchAmount stretch3 = CompositeArmStretchAmount.ThreeQuarters;
				float num20 = -(float)Math.PI / 10f;
				if (direction == -1)
				{
					num20 *= -1f;
				}
				float num21 = itemRotation - (float)Math.PI / 4f + (float)Math.PI;
				if (direction == 1)
				{
					num21 += (float)Math.PI / 2f;
				}
				float rotation2 = num21 + num20;
				float rotation3 = num21 - num20;
				Vector2 vector8 = (num21 + (float)Math.PI / 2f).ToRotationVector2() * -2f;
				itemLocation = (MountedCenter + vector8).Floor();
				SetCompositeArmFront(enabled: true, stretch2, rotation2);
				SetCompositeArmBack(enabled: true, stretch3, rotation3);
			}
			else if (itemAnimation > sItem.useAnimation)
			{
				float num22 = 0f - Utils.GetLerpValue(itemAnimationMax, itemAnimationMax * 5, itemAnimation, clamped: true);
				num22 *= num18;
				CompositeArmStretchAmount stretch4 = CompositeArmStretchAmount.Full;
				CompositeArmStretchAmount stretch5 = CompositeArmStretchAmount.ThreeQuarters;
				float num24 = -(float)Math.PI / 10f;
				num24 *= 0f - num22;
				itemRotation = (float)Math.PI / 2f * (float)(-direction) + (float)Math.PI + (float)Math.PI * num22 * (float)(-direction);
				float num40 = -(float)Math.PI / 5f * (float)direction;
				if (direction < 1)
				{
					num24 *= -1f;
				}
				float rotation4 = num40 + num24;
				float rotation5 = num40 - num24;
				Vector2 vector9 = default(Vector2);
				((Vector2)(ref vector9))._002Ector((float)(10 * direction), num22 * -6f);
				itemLocation = (MountedCenter + vector9).Floor();
				SetCompositeArmFront(enabled: true, stretch4, rotation4);
				SetCompositeArmBack(enabled: true, stretch5, rotation5);
			}
			else
			{
				float num25 = 1f - (float)itemAnimation / (float)itemAnimationMax;
				CompositeArmStretchAmount stretch6 = CompositeArmStretchAmount.Full;
				CompositeArmStretchAmount stretch7 = CompositeArmStretchAmount.ThreeQuarters;
				if (num25 > 0.6f)
				{
					stretch7 = CompositeArmStretchAmount.Quarter;
				}
				float num26 = -(float)Math.PI / 10f;
				if (direction == -1)
				{
					num26 *= -1f;
				}
				num26 *= 1f - num25 * 2.2f;
				itemRotation = (num25 * (float)Math.PI * 1.6f + -(float)Math.PI / 2f) * num18 * (float)(-direction) + (float)Math.PI;
				float num27 = (num25 * (float)Math.PI * 0.6f + (float)Math.PI * 2f / 5f) * (float)(-direction) + (float)Math.PI - (float)Math.PI / 4f + (float)Math.PI;
				if (direction == 1)
				{
					num27 += (float)Math.PI / 2f;
				}
				float rotation6 = num27 + num26;
				float rotation7 = num27 - num26;
				Vector2 vector10 = (num27 + (float)Math.PI / 2f).ToRotationVector2() * (-5f * (1f - num25));
				itemLocation = (MountedCenter + vector10).Floor();
				SetCompositeArmFront(enabled: true, stretch6, rotation6);
				SetCompositeArmBack(enabled: true, stretch7, rotation7);
			}
			FlipItemLocationAndRotationForGravity();
		}
		else if (sItem.useStyle == 12)
		{
			itemRotation = 0f;
			itemLocation.X = MountedCenter.X - (float)(8 * direction);
			itemLocation.Y = position.Y + 40f + mountOffset;
			Vector2 vector11 = Main.OffsetsPlayerHeadgear[bodyFrame.Y / 56];
			itemLocation += vector11;
			float num28 = itemAnimationMax;
			if (num28 == 0f)
			{
				num28 = sItem.useAnimation;
			}
			float num29 = 1f - (float)itemAnimation / num28;
			num29 *= 2f;
			float num30 = (float)Math.Cos(num29 * (float)Math.PI) * 0.2f;
			CompositeArmStretchAmount compositeArmStretchAmount3 = CompositeArmStretchAmount.Full;
			if (num29 > 0.25f && num29 <= 0.5f)
			{
				compositeArmStretchAmount3 = CompositeArmStretchAmount.ThreeQuarters;
			}
			if (num29 > 0.5f && num29 <= 0.75f)
			{
				compositeArmStretchAmount3 = CompositeArmStretchAmount.Quarter;
			}
			if (num29 > 0.75f && num29 <= 1.25f)
			{
				compositeArmStretchAmount3 = CompositeArmStretchAmount.None;
			}
			if (num29 > 1.25f && num29 <= 1.5f)
			{
				compositeArmStretchAmount3 = CompositeArmStretchAmount.Quarter;
			}
			if (num29 > 1.5f && num29 <= 1.75f)
			{
				compositeArmStretchAmount3 = CompositeArmStretchAmount.ThreeQuarters;
			}
			if (num29 > 1.75f && num29 <= 2f)
			{
				compositeArmStretchAmount3 = CompositeArmStretchAmount.Full;
			}
			SetCompositeArmFront(enabled: true, compositeArmStretchAmount3, (-(float)Math.PI / 4f + num30) * (float)direction);
			CompositeArmStretchAmount stretch8 = CompositeArmStretchAmount.Quarter;
			SetCompositeArmBack(enabled: true, stretch8, (-(float)Math.PI / 4f - num30 * 0.5f) * (float)direction);
			FlipItemLocationAndRotationForGravity();
			if (sItem.type != 4715 || compositeArmStretchAmount3 != CompositeArmStretchAmount.ThreeQuarters)
			{
				return;
			}
			Vector2 vector2 = itemLocation + new Vector2((float)heldItemFrame.Width, (float)(-heldItemFrame.Height)) * new Vector2((float)direction, gravDir) * 0.3f;
			Dust dust6 = Dust.NewDustPerfect(vector2, 228, Main.rand.NextVector2CircularEdge(1f, 1f));
			dust6.noGravity = true;
			dust6.noLight = true;
			dust6.velocity *= 2f;
			float num31 = 0.5f;
			for (float num32 = 0f; num32 < 1f; num32 += 0.5f)
			{
				if (Main.rand.Next(3) == 0)
				{
					Dust dust3 = Dust.NewDustPerfect(vector2, 278, Vector2.UnitY.RotatedBy(num32 * ((float)Math.PI * 2f) + Main.rand.NextFloat() * num31 - num31 * 0.5f + (float)Math.PI / 2f) * (2f + Main.rand.NextFloat() * 1f), 150, Color.Lerp(Color.White, Color.HotPink, Main.rand.NextFloat() * 0.5f + 0.5f), 0.45f);
					dust3.noGravity = true;
					dust3.velocity *= 0.5f;
					dust3.customData = this;
					dust3.position += dust3.velocity * 6f;
				}
			}
			for (float num34 = 0f; num34 < 1f; num34 += 0.5f)
			{
				if (Main.rand.Next(3) == 0)
				{
					Dust dust4 = Dust.NewDustPerfect(vector2, 278, Vector2.UnitY.RotatedBy(num34 * ((float)Math.PI * 2f) + Main.rand.NextFloat() * num31 - num31 * 0.5f + (float)Math.PI / 2f) * (0.5f + Main.rand.NextFloat() * 1f), 150, Color.Lerp(Color.White, Color.Gold, Main.rand.NextFloat() * 0.5f + 0.5f), 0.45f);
					dust4.noGravity = true;
					dust4.velocity *= 0.5f;
					dust4.customData = this;
					dust4.position += dust4.velocity * 6f;
				}
			}
		}
		else if (sItem.useStyle == 14 && !Main.dedServ)
		{
			itemRotation = 0f;
			itemLocation.X = base.Center.X + (float)(6 * direction);
			itemLocation.Y = position.Y + 40f + mountOffset - 8f;
			Vector2 vector3 = Main.OffsetsPlayerHeadgear[bodyFrame.Y / 56];
			itemLocation += vector3;
			CompositeArmStretchAmount stretch9 = CompositeArmStretchAmount.Full;
			SetCompositeArmBack(enabled: true, stretch9, (float)Math.PI * -3f / 4f * (float)direction);
			FlipItemLocationAndRotationForGravity();
		}
	}

	public void FlipItemLocationAndRotationForGravity()
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (gravDir == -1f)
		{
			itemRotation = 0f - itemRotation;
			float num = position.Y - itemLocation.Y;
			itemLocation.Y = base.Bottom.Y + num;
		}
	}

	private void ItemCheck_StartActualUse(Item sItem)
	{
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		bool flag = sItem.type == 4711;
		if (sItem.pick > 0 || sItem.axe > 0 || sItem.hammer > 0 || flag)
		{
			toolTime = 1;
		}
		if (grappling[0] > -1 || sItem.useTurnOnAnimationStart)
		{
			pulley = false;
			pulleyDir = 1;
			if (controlRight)
			{
				direction = 1;
			}
			else if (controlLeft)
			{
				direction = -1;
			}
		}
		StartChanneling(sItem);
		attackCD = 0;
		ResetMeleeHitCooldowns();
		ApplyItemAnimation(sItem);
		bool flag2 = ItemID.Sets.SkipsInitialUseSound[sItem.type];
		if (sItem.UseSound.HasValue && !flag2)
		{
			SoundEngine.PlaySound(sItem.UseSound, base.Center);
		}
	}

	private void FreeUpPetsAndMinions(Item sItem)
	{
		if (ProjectileID.Sets.MinionSacrificable[sItem.shoot])
		{
			List<int> list = new List<int>();
			float num = 0f;
			for (int i = 0; i < 1000; i++)
			{
				if (!Main.projectile[i].active || Main.projectile[i].owner != whoAmI || !Main.projectile[i].minion)
				{
					continue;
				}
				int j;
				for (j = 0; j < list.Count; j++)
				{
					if (Main.projectile[list[j]].minionSlots > Main.projectile[i].minionSlots)
					{
						list.Insert(j, i);
						break;
					}
				}
				if (j == list.Count)
				{
					list.Add(i);
				}
				num += Main.projectile[i].minionSlots;
			}
			float num2 = ItemID.Sets.StaffMinionSlotsRequired[sItem.type];
			float num3 = 0f;
			int num4 = 388;
			int num5 = -1;
			for (int k = 0; k < list.Count; k++)
			{
				int type3 = Main.projectile[list[k]].type;
				if (type3 == 626)
				{
					list.RemoveAt(k);
					k--;
				}
				if (type3 == 627)
				{
					if (Main.projectile[(int)Main.projectile[list[k]].localAI[1]].type == 628)
					{
						num5 = list[k];
					}
					list.RemoveAt(k);
					k--;
				}
			}
			if (num5 != -1)
			{
				list.Add(num5);
				list.Add(Projectile.GetByUUID(Main.projectile[num5].owner, Main.projectile[num5].ai[0]));
			}
			for (int l = 0; l < list.Count; l++)
			{
				if (!(num - num3 > (float)maxMinions - num2 + 1E-05f))
				{
					break;
				}
				int type2 = Main.projectile[list[l]].type;
				if (type2 == num4 || type2 == 625 || type2 == 628 || type2 == 623)
				{
					continue;
				}
				if (type2 == 388 && num4 == 387)
				{
					num4 = 388;
				}
				if (type2 == 387 && num4 == 388)
				{
					num4 = 387;
				}
				num3 += Main.projectile[list[l]].minionSlots;
				if (type2 == 626 || type2 == 627)
				{
					Projectile projectile = Main.projectile[list[l]];
					int byUUID = Projectile.GetByUUID(projectile.owner, projectile.ai[0]);
					if (Main.projectile.IndexInRange(byUUID))
					{
						Projectile projectile2 = Main.projectile[byUUID];
						if (projectile2.type != 625)
						{
							projectile2.localAI[1] = projectile.localAI[1];
						}
						projectile2 = Main.projectile[(int)projectile.localAI[1]];
						projectile2.ai[0] = projectile.ai[0];
						projectile2.ai[1] = 1f;
						projectile2.netUpdate = true;
					}
				}
				Main.projectile[list[l]].Kill();
			}
			list.Clear();
			if (num + num2 >= 9f)
			{
				AchievementsHelper.HandleSpecialEvent(this, 6);
			}
			return;
		}
		for (int m = 0; m < 1000; m++)
		{
			Projectile projectile3 = Main.projectile[m];
			if (projectile3.active && projectile3.owner == whoAmI)
			{
				if (projectile3.type == sItem.shoot)
				{
					projectile3.Kill();
				}
				if (sItem.shoot == 72 && (projectile3.type == 86 || projectile3.type == 87))
				{
					projectile3.Kill();
				}
				if (sItem.type == 5131 && (projectile3.type == 881 || projectile3.type == 934))
				{
					projectile3.Kill();
				}
			}
		}
	}

	private void ApplyPotionDelay(Item sItem)
	{
		if (sItem.type == 3001)
		{
			int minValue = 2400;
			int num = 4200;
			potionDelay = Main.rand.Next(minValue, num + 1);
			if (pStone)
			{
				potionDelay = (int)((float)potionDelay * PhilosopherStoneDurationMultiplier);
			}
			AddBuff(21, potionDelay);
		}
		else if (sItem.type == 227)
		{
			potionDelay = restorationDelayTime;
			AddBuff(21, potionDelay);
		}
		else if (sItem.type == 5)
		{
			potionDelay = mushroomDelayTime;
			AddBuff(21, potionDelay);
			TryToResetHungerToNeutral();
		}
		else
		{
			potionDelay = potionDelayTime;
			AddBuff(21, potionDelay);
		}
	}

	private void ApplyLifeAndOrMana(Item item)
	{
		int num = GetHealLife(item, quickHeal: true);
		int healMana = GetHealMana(item, quickHeal: true);
		if (item.type == 3001)
		{
			int healLife = item.healLife;
			int num2 = 120;
			num = Main.rand.Next(healLife, num2 + 1);
			if (Main.myPlayer == whoAmI)
			{
				float num3 = Main.rand.NextFloat();
				int num4 = 0;
				if (num3 <= 0.1f)
				{
					num4 = 240;
				}
				else if (num3 <= 0.3f)
				{
					num4 = 120;
				}
				else if (num3 <= 0.6f)
				{
					num4 = 60;
				}
				if (num4 > 0)
				{
					SetImmuneTimeForAllTypes(num4);
				}
			}
		}
		statLife += num;
		statMana += healMana;
		if (statLife > statLifeMax2)
		{
			statLife = statLifeMax2;
		}
		if (statMana > statManaMax2)
		{
			statMana = statManaMax2;
		}
		if (num > 0 && Main.myPlayer == whoAmI)
		{
			HealEffect(num);
		}
		if (healMana > 0)
		{
			AddBuff(94, manaSickTime);
			if (Main.myPlayer == whoAmI)
			{
				ManaEffect(healMana);
			}
		}
	}

	private bool ItemCheck_CheckCanUse(Item sItem)
	{
		if (sItem.IsAir || !CombinedHooks.CanUseItem(this, sItem))
		{
			return false;
		}
		int num = whoAmI;
		bool flag = true;
		int num2 = (int)((float)Main.mouseX + Main.screenPosition.X) / 16;
		int num3 = (int)((float)Main.mouseY + Main.screenPosition.Y) / 16;
		if (gravDir == -1f)
		{
			num3 = (int)(Main.screenPosition.Y + (float)Main.screenHeight - (float)Main.mouseY) / 16;
		}
		if (sItem.type == 3335 && (extraAccessory || !Main.expertMode))
		{
			flag = false;
		}
		if (pulley && sItem.fishingPole > 0)
		{
			flag = false;
		}
		if (pulley && ItemID.Sets.IsAKite[sItem.type])
		{
			flag = false;
		}
		if (sItem.type == 3611 && (WiresUI.Settings.ToolMode & (WiresUI.Settings.MultiToolMode.Red | WiresUI.Settings.MultiToolMode.Green | WiresUI.Settings.MultiToolMode.Blue | WiresUI.Settings.MultiToolMode.Yellow | WiresUI.Settings.MultiToolMode.Actuator)) == 0)
		{
			flag = false;
		}
		if (sItem.type == 5451 && ownedProjectileCounts[1020] > 0)
		{
			flag = false;
		}
		if ((sItem.type == 3611 || sItem.type == 3625) && wireOperationsCooldown > 0)
		{
			flag = false;
		}
		if (!CheckDD2CrystalPaymentLock(sItem))
		{
			flag = false;
		}
		if (sItem.shoot > -1 && ProjectileID.Sets.IsADD2Turret[sItem.shoot] && !downedDD2EventAnyDifficulty && !DD2Event.Ongoing)
		{
			flag = false;
		}
		int pushYUp;
		if (sItem.shoot > -1 && ProjectileID.Sets.IsADD2Turret[sItem.shoot] && DD2Event.Ongoing && num == Main.myPlayer)
		{
			FindSentryRestingSpot(sItem.shoot, out var worldX, out var worldY, out pushYUp);
			if (WouldSpotOverlapWithSentry(worldX, worldY, sItem.shoot == 688 || sItem.shoot == 689 || sItem.shoot == 690))
			{
				flag = false;
			}
		}
		if (sItem.shoot > -1 && ProjectileID.Sets.IsADD2Turret[sItem.shoot] && num == Main.myPlayer)
		{
			FindSentryRestingSpot(sItem.shoot, out var worldX2, out var worldY2, out pushYUp);
			worldX2 /= 16;
			worldY2 /= 16;
			worldY2--;
			if (sItem.shoot == 688 || sItem.shoot == 689 || sItem.shoot == 690)
			{
				if (Collision.SolidTiles(worldX2, worldX2, worldY2 - 2, worldY2))
				{
					flag = false;
				}
			}
			else if (WorldGen.SolidTile(worldX2, worldY2))
			{
				flag = false;
			}
		}
		if (wet && (sItem.shoot == 85 || sItem.shoot == 15 || sItem.shoot == 34))
		{
			flag = false;
		}
		if (sItem.makeNPC > 0 && !NPC.CanReleaseNPCs(whoAmI))
		{
			flag = false;
		}
		if (whoAmI == Main.myPlayer && sItem.type == 603 && !Main.runningCollectorsEdition)
		{
			flag = false;
		}
		if (sItem.type == 1071 || sItem.type == 1072)
		{
			bool flag2 = false;
			for (int i = 0; i < 58; i++)
			{
				if (inventory[i].PaintOrCoating)
				{
					flag2 = true;
					break;
				}
			}
			if (!flag2)
			{
				flag = false;
			}
		}
		if (noItems)
		{
			flag = false;
		}
		if (sItem.tileWand > 0)
		{
			int tileWand = sItem.tileWand;
			flag = false;
			for (int j = 0; j < 58; j++)
			{
				if (tileWand == inventory[j].type && inventory[j].stack > 0)
				{
					flag = true;
					break;
				}
			}
		}
		if (sItem.shoot == 6 || sItem.shoot == 19 || sItem.shoot == 33 || sItem.shoot == 52 || sItem.shoot == 113 || sItem.shoot == 320 || sItem.shoot == 333 || sItem.shoot == 383 || sItem.shoot == 491 || sItem.shoot == 867 || sItem.shoot == 902 || sItem.shoot == 866)
		{
			for (int k = 0; k < 1000; k++)
			{
				if (Main.projectile[k].active && Main.projectile[k].owner == Main.myPlayer && Main.projectile[k].type == sItem.shoot)
				{
					flag = false;
				}
			}
		}
		if (sItem.shoot == 106)
		{
			int num4 = 0;
			for (int l = 0; l < 1000; l++)
			{
				if (Main.projectile[l].active && Main.projectile[l].owner == Main.myPlayer && Main.projectile[l].type == sItem.shoot)
				{
					num4++;
				}
			}
			if (num4 >= 6)
			{
				flag = false;
			}
		}
		if (sItem.shoot == 272)
		{
			int num5 = 0;
			for (int m = 0; m < 1000; m++)
			{
				if (Main.projectile[m].active && Main.projectile[m].owner == Main.myPlayer && Main.projectile[m].type == sItem.shoot)
				{
					num5++;
				}
			}
			if (num5 >= 10)
			{
				flag = false;
			}
		}
		if (sItem.shoot == 1000)
		{
			int num6 = 0;
			for (int n = 0; n < 1000; n++)
			{
				if (Main.projectile[n].active && Main.projectile[n].owner == Main.myPlayer && Main.projectile[n].type == sItem.shoot)
				{
					num6++;
				}
			}
			if (num6 >= 3)
			{
				flag = false;
			}
		}
		if (sItem.shoot == 13 || sItem.shoot == 32 || (sItem.shoot >= 230 && sItem.shoot <= 235) || sItem.shoot == 315 || sItem.shoot == 331 || sItem.shoot == 372)
		{
			for (int num7 = 0; num7 < 1000; num7++)
			{
				if (Main.projectile[num7].active && Main.projectile[num7].owner == Main.myPlayer && Main.projectile[num7].type == sItem.shoot && Main.projectile[num7].ai[0] != 2f)
				{
					flag = false;
				}
			}
		}
		if (sItem.shoot == 332)
		{
			int num8 = 0;
			for (int num9 = 0; num9 < 1000; num9++)
			{
				if (Main.projectile[num9].active && Main.projectile[num9].owner == Main.myPlayer && Main.projectile[num9].type == sItem.shoot && Main.projectile[num9].ai[0] != 2f)
				{
					num8++;
				}
			}
			if (num8 >= 3)
			{
				flag = false;
			}
		}
		if (sItem.potion && potionDelay > 0)
		{
			flag = false;
		}
		if (sItem.mana > 0 && silence)
		{
			flag = false;
		}
		if (sItem.mana > 0 && flag)
		{
			flag = ItemCheck_PayMana(sItem, flag);
		}
		if (sItem.type == 43 && Main.IsItDay())
		{
			flag = false;
		}
		if (sItem.type == 544 && Main.IsItDay())
		{
			flag = false;
		}
		if (sItem.type == 556 && Main.IsItDay())
		{
			flag = false;
		}
		if (sItem.type == 557 && Main.IsItDay())
		{
			flag = false;
		}
		if (sItem.type == 70 && !ZoneCorrupt)
		{
			flag = false;
		}
		if (sItem.type == 1133 && !ZoneJungle)
		{
			flag = false;
		}
		if (sItem.type == 5120 && !ZoneSnow)
		{
			flag = false;
		}
		if (sItem.type == 1844 && (Main.dayTime || Main.pumpkinMoon || Main.snowMoon || DD2Event.Ongoing))
		{
			flag = false;
		}
		if (sItem.type == 1958 && (Main.dayTime || Main.pumpkinMoon || Main.snowMoon || DD2Event.Ongoing))
		{
			flag = false;
		}
		if (sItem.type == 2767 && (!Main.dayTime || Main.eclipse || !Main.hardMode))
		{
			flag = false;
		}
		if (sItem.type == 4271 && (Main.dayTime || Main.bloodMoon))
		{
			flag = false;
		}
		if (sItem.type == 3601 && (!NPC.downedGolemBoss || !Main.hardMode || NPC.AnyDanger() || NPC.AnyoneNearCultists()))
		{
			flag = false;
		}
		if (!SummonItemCheck(sItem))
		{
			flag = false;
		}
		if (sItem.shoot == 17 && flag && num == Main.myPlayer && !ItemCheck_IsValidDirtRodTarget(Main.tile[num2, num3]))
		{
			flag = false;
		}
		if (sItem.chlorophyteExtractinatorConsumable && flag && num == Main.myPlayer)
		{
			Tile tile = Main.tile[num2, num3];
			if (!tile.active() || (tile.type != 642 && tile.type != 219))
			{
				flag = false;
			}
		}
		if (sItem.fishingPole > 0)
		{
			flag = ItemCheck_CheckFishingBobbers(flag);
		}
		if (ItemID.Sets.HasAProjectileThatHasAUsabilityCheck[sItem.type])
		{
			flag = ItemCheck_CheckUsabilityOfProjectiles(flag);
		}
		if (sItem.shoot == 17 && flag && num == Main.myPlayer)
		{
			if (ItemCheck_IsValidDirtRodTarget(Main.tile[num2, num3]))
			{
				WorldGen.KillTile(num2, num3, fail: false, effectOnly: false, noItem: true);
				if (!Main.tile[num2, num3].active())
				{
					if (Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 4, num2, num3);
					}
				}
				else
				{
					flag = false;
				}
			}
			else
			{
				flag = false;
			}
		}
		if (flag)
		{
			flag = HasAmmo(sItem, flag);
		}
		return flag;
	}

	private bool ItemCheck_CheckUsabilityOfProjectiles(bool canUse)
	{
		for (int i = 0; i < 1000; i++)
		{
			Projectile projectile = Main.projectile[i];
			if (projectile.active && projectile.owner == whoAmI)
			{
				projectile.CheckUsability(this, ref canUse);
			}
		}
		return canUse;
	}

	private bool ItemCheck_CheckFishingBobbers(bool canUse)
	{
		for (int i = 0; i < 1000; i++)
		{
			Projectile projectile = Main.projectile[i];
			if (!projectile.active || projectile.owner != whoAmI || !projectile.bobber)
			{
				continue;
			}
			canUse = false;
			if (whoAmI != Main.myPlayer || projectile.ai[0] != 0f)
			{
				continue;
			}
			projectile.ai[0] = 1f;
			float num = -10f;
			if (projectile.wet && projectile.velocity.Y > num)
			{
				projectile.velocity.Y = num;
			}
			projectile.netUpdate2 = true;
			if (projectile.ai[1] < 0f && projectile.localAI[1] != 0f)
			{
				ItemCheck_CheckFishingBobber_PickAndConsumeBait(projectile, out var pullTheBobber, out var baitTypeUsed);
				if (pullTheBobber)
				{
					ItemCheck_CheckFishingBobber_PullBobber(projectile, baitTypeUsed);
				}
			}
		}
		return canUse;
	}

	private void ItemCheck_CheckFishingBobber_PullBobber(Projectile bobber, int baitTypeUsed)
	{
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		if (baitTypeUsed == 2673)
		{
			if (Main.netMode != 1)
			{
				NPC.SpawnOnPlayer(whoAmI, 370);
			}
			else
			{
				NetMessage.SendData(61, -1, -1, null, whoAmI, 370f);
			}
			bobber.ai[0] = 2f;
		}
		else if (bobber.localAI[1] < 0f)
		{
			Point point = default(Point);
			((Point)(ref point))._002Ector((int)bobber.position.X, (int)bobber.position.Y);
			int num = (int)(0f - bobber.localAI[1]);
			if (num == 618)
			{
				point.Y += 64;
			}
			if (Main.netMode == 1)
			{
				NetMessage.SendData(130, -1, -1, null, point.X / 16, point.Y / 16, num);
			}
			else
			{
				if (num == 682)
				{
					NPC.unlockedSlimeRedSpawn = true;
				}
				NPC.NewNPC(new EntitySource_FishedOut(this), point.X, point.Y, num);
				bobber.ai[0] = 2f;
				WorldGen.CheckAchievement_RealEstateAndTownSlimes();
			}
		}
		else if (Main.rand.Next(7) == 0 && !accFishingLine)
		{
			bobber.ai[0] = 2f;
		}
		else
		{
			bobber.ai[1] = bobber.localAI[1];
		}
		bobber.netUpdate = true;
	}

	private void ItemCheck_CheckFishingBobber_PickAndConsumeBait(Projectile bobber, out bool pullTheBobber, out int baitTypeUsed)
	{
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		pullTheBobber = false;
		baitTypeUsed = 0;
		int num = -1;
		for (int i = 54; i < 58; i++)
		{
			if (inventory[i].stack > 0 && inventory[i].bait > 0)
			{
				num = i;
				break;
			}
		}
		if (num == -1)
		{
			for (int j = 0; j < 50; j++)
			{
				if (inventory[j].stack > 0 && inventory[j].bait > 0)
				{
					num = j;
					break;
				}
			}
		}
		if (num <= -1)
		{
			return;
		}
		Item item = inventory[num];
		bool flag = false;
		float num2 = 1f + (float)item.bait / 6f;
		if (num2 < 1f)
		{
			num2 = 1f;
		}
		if (accTackleBox)
		{
			num2 += 1f;
		}
		if (Main.rand.NextFloat() * num2 < 1f)
		{
			flag = true;
		}
		if (bobber.localAI[1] == -1f)
		{
			flag = true;
		}
		if (bobber.localAI[1] > 0f)
		{
			Item item2 = new Item();
			item2.SetDefaults((int)bobber.localAI[1]);
			if (item2.rare < 0)
			{
				flag = false;
			}
		}
		baitTypeUsed = item.type;
		if (baitTypeUsed == 2895)
		{
			flag = Main.rand.Next(20) == 0;
		}
		if (baitTypeUsed == 2673)
		{
			flag = true;
		}
		if (CombinedHooks.CanConsumeBait(this, item) ?? flag)
		{
			if (item.type == 4361 || item.type == 4362)
			{
				NPC.LadyBugKilled(base.Center, item.type == 4362);
			}
			item.stack--;
			if (item.stack <= 0)
			{
				item.SetDefaults();
			}
		}
		pullTheBobber = true;
	}

	private static bool ItemCheck_IsValidDirtRodTarget(Tile t)
	{
		if (t.active())
		{
			if (t.type != 0 && t.type != 2 && t.type != 23 && t.type != 109 && t.type != 199 && t.type != 477)
			{
				return t.type == 492;
			}
			return true;
		}
		return false;
	}

	private bool ItemCheck_PayMana(Item sItem, bool canUse)
	{
		bool flag = altFunctionUse == 2;
		bool flag2 = false;
		int num = (int)((float)sItem.mana * manaCost);
		if (sItem.type == 2795)
		{
			flag2 = true;
		}
		if (sItem.type == 3852 && flag)
		{
			num = (int)((float)(sItem.mana * 2) * manaCost);
		}
		if (sItem.shoot > 0 && ProjectileID.Sets.TurretFeature[sItem.shoot] && flag)
		{
			flag2 = true;
		}
		if (sItem.shoot > 0 && ProjectileID.Sets.MinionTargettingFeature[sItem.shoot] && flag)
		{
			flag2 = true;
		}
		if (sItem.type == 3006)
		{
			flag2 = true;
		}
		if (sItem.type != 3269 && !CheckMana(sItem, -1, !flag2))
		{
			canUse = false;
		}
		return canUse;
	}

	private void ItemCheck_TryPlacingWearablesOnMannequins(Item sItem)
	{
		if (!controlUseItem || !releaseUseItem || (sItem.headSlot <= 0 && sItem.bodySlot <= 0 && sItem.legSlot <= 0))
		{
			return;
		}
		if (sItem.useStyle == 0)
		{
			releaseUseItem = false;
		}
		if (!(position.X / 16f - (float)tileRangeX - (float)sItem.tileBoost <= (float)tileTargetX) || !((position.X + (float)width) / 16f + (float)tileRangeX + (float)sItem.tileBoost - 1f >= (float)tileTargetX) || !(position.Y / 16f - (float)tileRangeY - (float)sItem.tileBoost <= (float)tileTargetY) || !((position.Y + (float)height) / 16f + (float)tileRangeY + (float)sItem.tileBoost - 2f >= (float)tileTargetY))
		{
			return;
		}
		int num = tileTargetX;
		int num2 = tileTargetY;
		if (!Main.tile[num, num2].active() || (Main.tile[num, num2].type != 128 && Main.tile[num, num2].type != 269))
		{
			return;
		}
		int frameY = Main.tile[num, num2].frameY;
		int num3 = 0;
		if (sItem.bodySlot >= 0)
		{
			num3 = 1;
		}
		if (sItem.legSlot >= 0)
		{
			num3 = 2;
		}
		frameY /= 18;
		while (num3 > frameY)
		{
			num2++;
			frameY = Main.tile[num, num2].frameY;
			frameY /= 18;
		}
		while (num3 < frameY)
		{
			num2--;
			frameY = Main.tile[num, num2].frameY;
			frameY /= 18;
		}
		int num4;
		for (num4 = Main.tile[num, num2].frameX; num4 >= 100; num4 -= 100)
		{
		}
		if (num4 >= 36)
		{
			num4 -= 36;
		}
		num -= num4 / 18;
		int num5 = Main.tile[num, num2].frameX;
		WorldGen.KillTile(num, num2, fail: true);
		if (Main.netMode == 1)
		{
			NetMessage.SendData(17, -1, -1, null, 0, num, num2, 1f);
		}
		while (num5 >= 100)
		{
			num5 -= 100;
		}
		if (frameY == 0 && sItem.headSlot >= 0)
		{
			Main.blockMouse = true;
			Main.tile[num, num2].frameX = (short)(num5 + sItem.headSlot * 100);
			if (Main.netMode == 1)
			{
				NetMessage.SendTileSquare(-1, num, num2);
			}
			sItem.stack--;
			if (sItem.stack <= 0)
			{
				sItem.SetDefaults();
				Main.mouseItem.SetDefaults();
			}
			if (selectedItem == 58)
			{
				Main.mouseItem = sItem.Clone();
			}
			releaseUseItem = false;
			mouseInterface = true;
		}
		else if (frameY == 1 && sItem.bodySlot >= 0)
		{
			Main.blockMouse = true;
			Main.tile[num, num2].frameX = (short)(num5 + sItem.bodySlot * 100);
			if (Main.netMode == 1)
			{
				NetMessage.SendTileSquare(-1, num, num2);
			}
			sItem.stack--;
			if (sItem.stack <= 0)
			{
				sItem.SetDefaults();
				Main.mouseItem.SetDefaults();
			}
			if (selectedItem == 58)
			{
				Main.mouseItem = sItem.Clone();
			}
			releaseUseItem = false;
			mouseInterface = true;
		}
		else if (frameY == 2 && sItem.legSlot >= 0 && !ArmorIDs.Legs.Sets.MannequinIncompatible.Contains(sItem.legSlot))
		{
			Main.blockMouse = true;
			Main.tile[num, num2].frameX = (short)(num5 + sItem.legSlot * 100);
			if (Main.netMode == 1)
			{
				NetMessage.SendTileSquare(-1, num, num2);
			}
			sItem.stack--;
			if (sItem.stack <= 0)
			{
				sItem.SetDefaults();
				Main.mouseItem.SetDefaults();
			}
			if (selectedItem == 58)
			{
				Main.mouseItem = sItem.Clone();
			}
			releaseUseItem = false;
			mouseInterface = true;
		}
	}

	private void ApplyReuseDelay()
	{
		itemAnimation = reuseDelay;
		itemTime = reuseDelay;
		reuseDelay = 0;
	}

	private void ItemCheck_HackHoldStyles(Item sItem)
	{
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		if (sItem.fishingPole > 0)
		{
			sItem.holdStyle = 0;
			if (ItemTimeIsZero && itemAnimation == 0)
			{
				for (int i = 0; i < 1000; i++)
				{
					if (Main.projectile[i].active && Main.projectile[i].owner == whoAmI && Main.projectile[i].bobber)
					{
						sItem.holdStyle = 1;
					}
				}
			}
		}
		if (!ItemID.Sets.IsAKite[sItem.type])
		{
			return;
		}
		sItem.holdStyle = 0;
		if (!ItemTimeIsZero || itemAnimation != 0)
		{
			return;
		}
		for (int j = 0; j < 1000; j++)
		{
			if (Main.projectile[j].active && Main.projectile[j].owner == whoAmI && Main.projectile[j].type == sItem.shoot)
			{
				sItem.holdStyle = 1;
				ChangeDir((!(Main.projectile[j].Center.X - base.Center.X < 0f)) ? 1 : (-1));
			}
		}
	}

	private void ItemCheck_HandleMPItemAnimation(Item sItem)
	{
		TryAllowingItemReuse(sItem);
	}

	private void TryAllowingItemReuse(Item sItem)
	{
		if (CanAutoReuseItem(sItem))
		{
			releaseUseItem = true;
		}
	}

	public bool CanAutoReuseItem(Item sItem)
	{
		bool? flag2 = CombinedHooks.CanAutoReuseItem(this, sItem);
		if (flag2.HasValue)
		{
			return flag2.GetValueOrDefault();
		}
		bool flag = sItem.autoReuse;
		if (autoReuseGlove)
		{
			flag |= sItem.CountsAsClass(DamageClass.Melee) || sItem.CountsAsClass(DamageClass.SummonMeleeSpeed);
		}
		if (autoReuseAllWeapons && sItem.damage > 0 && (!sItem.channel || !channel))
		{
			flag = true;
		}
		return flag;
	}

	private void ItemCheck_HandleMount()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		if (!mount.Active)
		{
			return;
		}
		MountLoader.UseAbility(this, Vector2.Zero, toggleOn: false);
		if (whoAmI == Main.myPlayer && gravDir == -1f)
		{
			mount.Dismount(this);
		}
		else
		{
			if (mount.Type != 8)
			{
				return;
			}
			noItems = true;
			if (controlUseItem || controlUseTile)
			{
				StartChanneling();
				if (releaseUseItem && releaseUseTile)
				{
					mount.UseAbility(this, Vector2.Zero, toggleOn: true);
				}
				releaseUseItem = false;
				releaseUseTile = false;
			}
		}
	}

	public void StartChanneling()
	{
		channel = true;
		_channelShotCache = default(ChannelCancelKey);
	}

	public void StartChanneling(Item item)
	{
		if (item.channel)
		{
			channel = true;
			_channelShotCache = new ChannelCancelKey
			{
				ProjectileTypeExpected = item.shoot
			};
		}
	}

	public void TryUpdateChannel(Projectile projectile)
	{
		_channelShotCache.TryTracking(projectile);
	}

	public void TryCancelChannel(Projectile projectile)
	{
		if (_channelShotCache.Matches(projectile))
		{
			channel = false;
		}
	}

	public static bool WouldSpotOverlapWithSentry(int worldX, int worldY, bool lightningAura)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		Point value = default(Point);
		((Point)(ref value))._002Ector(worldX, worldY - 8);
		Point value2 = default(Point);
		((Point)(ref value2))._002Ector(worldX + 16, worldY - 8);
		Point value3 = default(Point);
		((Point)(ref value3))._002Ector(worldX - 16, worldY - 8);
		bool result = false;
		for (int i = 0; i < 1000; i++)
		{
			Projectile projectile = Main.projectile[i];
			if (projectile.active && projectile.sentry)
			{
				Rectangle hitbox = projectile.Hitbox;
				if (!lightningAura && hitbox.X > 30)
				{
					hitbox.X += hitbox.Width / 2;
					hitbox.Width = 30;
					hitbox.X -= hitbox.Width / 2;
				}
				if (((Rectangle)(ref hitbox)).Contains(value) || ((Rectangle)(ref hitbox)).Contains(value2) || ((Rectangle)(ref hitbox)).Contains(value3))
				{
					result = true;
					break;
				}
			}
		}
		return result;
	}

	public void FindSentryRestingSpot(int checkProj, out int worldX, out int worldY, out int pushYUp)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		Vector2 pointPoisition = Main.MouseWorld;
		LimitPointToPlayerReachableArea(ref pointPoisition);
		int num = (int)pointPoisition.X / 16;
		int i = (int)pointPoisition.Y / 16;
		worldX = num * 16 + 8;
		pushYUp = 41;
		switch (checkProj)
		{
		case 663:
			worldX += direction;
			break;
		case 665:
			pushYUp += 2;
			break;
		case 667:
			pushYUp += 3;
			break;
		case 677:
			worldX += direction;
			break;
		case 678:
			worldX += direction;
			break;
		case 691:
		case 692:
		case 693:
			pushYUp = 20;
			worldX += direction;
			pushYUp += 2;
			break;
		}
		if (!flag)
		{
			for (; i < Main.maxTilesY - 10 && Main.tile[num, i] != null && !WorldGen.SolidTile2(num, i) && Main.tile[num - 1, i] != null && !WorldGen.SolidTile2(num - 1, i) && Main.tile[num + 1, i] != null && !WorldGen.SolidTile2(num + 1, i); i++)
			{
			}
			i++;
		}
		i--;
		pushYUp -= 14;
		worldY = i * 16;
	}

	/// <summary>
	/// Kills <see cref="F:Terraria.Projectile.sentry" /> projectiles exceeding the players current <see cref="F:Terraria.Player.maxTurrets" />. The oldest projectiles, determined by <see cref="F:Terraria.Projectile.timeLeft" />, are killed. <br />
	/// Call this method immediately after spawning a <see cref="F:Terraria.Projectile.sentry" /> projectile.<br />
	/// </summary>
	public void UpdateMaxTurrets()
	{
		if (Main.myPlayer != whoAmI)
		{
			return;
		}
		List<Projectile> list = new List<Projectile>();
		for (int i = 0; i < 1000; i++)
		{
			if (Main.projectile[i].WipableTurret)
			{
				list.Add(Main.projectile[i]);
			}
		}
		int num = 0;
		while (list.Count > maxTurrets && ++num < 1000)
		{
			Projectile projectile = list[0];
			for (int j = 1; j < list.Count; j++)
			{
				if (list[j].timeLeft < projectile.timeLeft)
				{
					projectile = list[j];
				}
			}
			projectile.Kill();
			list.Remove(projectile);
		}
	}

	private void ItemCheck_ApplyPetBuffs(Item sItem)
	{
		if (whoAmI == Main.myPlayer && sItem.type == 603 && Main.runningCollectorsEdition)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 669)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 115)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 3060)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 3628)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 3062)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 3577)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 425)
		{
			int num = Main.rand.Next(3);
			if (num == 0)
			{
				num = 27;
			}
			if (num == 1)
			{
				num = 101;
			}
			if (num == 2)
			{
				num = 102;
			}
			for (int i = 0; i < maxBuffs; i++)
			{
				if (buffType[i] == 27 || buffType[i] == 101 || buffType[i] == 102)
				{
					DelBuff(i);
					i--;
				}
			}
			AddBuff(num, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 753)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 994)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1169)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1170)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1171)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1172)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1180)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1181)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1182)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1183)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1242)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1157)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1309)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1311)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1837)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1312)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1798)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1799)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1802)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1810)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1927)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 1959)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 2364)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 2365)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 3043)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer && sItem.type == 2420)
		{
			AddBuff(sItem.buffType, 3600);
		}
		if (whoAmI == Main.myPlayer)
		{
			switch (sItem.type)
			{
			case 2535:
			case 2551:
			case 2584:
			case 2587:
			case 2621:
			case 2749:
			case 3249:
			case 3474:
			case 3531:
			case 4269:
			case 4273:
			case 4281:
			case 4607:
			case 4758:
			case 5005:
			case 5069:
			case 5114:
				AddBuff(sItem.buffType, 3600);
				break;
			}
		}
		if (whoAmI == Main.myPlayer)
		{
			switch (sItem.type)
			{
			case 3855:
			case 3856:
			case 3857:
			case 4365:
			case 4366:
			case 4425:
			case 4550:
			case 4551:
			case 4603:
			case 4604:
			case 4605:
			case 4701:
			case 4735:
			case 4736:
			case 4737:
			case 4777:
			case 4797:
			case 4798:
			case 4799:
			case 4800:
			case 4801:
			case 4802:
			case 4803:
			case 4804:
			case 4805:
			case 4806:
			case 4807:
			case 4808:
			case 4809:
			case 4810:
			case 4811:
			case 4812:
			case 4813:
			case 4814:
			case 4815:
			case 4816:
			case 4817:
			case 4960:
			case 5088:
			case 5089:
			case 5090:
			case 5091:
			case 5098:
			case 5131:
			case 5276:
			case 5297:
			case 5332:
			case 5333:
			case 5400:
				AddBuff(sItem.buffType, 3600);
				break;
			}
		}
	}

	public float GetWeaponKnockback(Item sItem)
	{
		return GetWeaponKnockback(sItem, sItem.knockBack);
	}

	public float GetWeaponKnockback(Item sItem, float baseKnockback)
	{
		StatModifier modifier = GetTotalKnockback(sItem.DamageType);
		CombinedHooks.ModifyWeaponKnockback(this, sItem, ref modifier);
		return Math.Max(0f, modifier.ApplyTo(baseKnockback));
	}

	public int GetWeaponCrit(Item sItem)
	{
		float crit = (float)sItem.crit + GetTotalCritChance(sItem.DamageType);
		CombinedHooks.ModifyWeaponCrit(this, sItem, ref crit);
		return (int)(crit + 5E-06f);
	}

	public int GetWeaponDamage(Item sItem, bool forTooltip = false)
	{
		StatModifier modifier = GetTotalDamage(sItem.DamageType);
		if (AmmoID.Sets.IsArrow[sItem.useAmmo])
		{
			modifier = modifier.CombineWith(arrowDamage);
		}
		if (AmmoID.Sets.IsBullet[sItem.useAmmo])
		{
			modifier = modifier.CombineWith(bulletDamage);
		}
		if (AmmoID.Sets.IsSpecialist[sItem.useAmmo] || ItemID.Sets.IsRangedSpecialistWeapon[sItem.type])
		{
			modifier = modifier.CombineWith(specialistDamage);
		}
		CombinedHooks.ModifyWeaponDamage(this, sItem, ref modifier);
		float baseDamage = sItem.damage;
		if (forTooltip)
		{
			baseDamage *= ItemID.Sets.ToolTipDamageMultiplier[sItem.type];
		}
		return Math.Max(0, (int)(modifier.ApplyTo(baseDamage) + 5E-06f));
	}

	/// <summary>
	/// Whether or not the player has ammunition available for the given weapon.
	/// </summary>
	/// <param name="sItem">The weapon for which to try to find ammunition.</param>
	/// <returns>True if the player has ammo available; false otherwise.</returns>
	public bool HasAmmo(Item sItem)
	{
		return HasAmmo(sItem, canUse: true);
	}

	internal bool HasAmmo(Item sItem, bool canUse)
	{
		if (!canUse)
		{
			return false;
		}
		if (sItem.useAmmo != 0 && ChooseAmmo(sItem) == null)
		{
			return !ItemLoader.NeedsAmmo(sItem, this);
		}
		return true;
	}

	private bool PickAmmo_TryFindingSpecificMatches(int launcher, int ammo, out int pickedProjectileId)
	{
		pickedProjectileId = 0;
		if (AmmoID.Sets.SpecificLauncherAmmoProjectileMatches.TryGetValue(launcher, out var value) && value.TryGetValue(ammo, out pickedProjectileId))
		{
			return true;
		}
		return false;
	}

	/// <summary>
	/// A more-convenient-to-call variant of the vanilla PickAmmo method, which handles most vanilla ammunition logic to decide various common stats related to ammunition-consuming weapons.<br></br>
	/// The stats output by this method take into account any extra stats which the ammunition it finds may provide (read: it accounts for ammo damage and knockback).<br></br>
	/// </summary>
	/// <param name="weapon">The weapon for which to handle ammunition logic.</param>
	/// <param name="projToShoot">The projectile that should be shot based on the given weapon and the located ammunition.</param>
	/// <param name="speed">The speed at which the projectile that would be made by the given weapon and located ammunition should move.</param>
	/// <param name="damage">The damage value that the projectile shot should have, based on the given weapon and the located ammunition.</param>
	/// <param name="knockBack">The knockback value that the projectile shot should have, based on the given weapon and the located ammunition.</param>
	/// <param name="usedAmmoItemId">The numerical ID of the located ammunition.</param>
	/// <param name="dontConsume">
	/// Whether or not ammo consumption logic should be called upon.<br></br>
	/// This defaults to false, and if it is true for any reason, ammo will not be consumed at the end of the method.<br></br>
	/// This is useful for gathering the data needed based on PickAmmo's calculations without incidentally consuming any ammunition in the process.
	/// </param>
	/// <returns>True if ammo was found/chosen, and false otherwise.</returns>
	public bool PickAmmo(Item weapon, out int projToShoot, out float speed, out int damage, out float knockBack, out int usedAmmoItemId, bool dontConsume = false)
	{
		projToShoot = weapon.shoot;
		speed = weapon.shootSpeed;
		damage = GetWeaponDamage(weapon);
		knockBack = GetWeaponKnockback(weapon);
		bool canShoot = false;
		PickAmmo(weapon, ref projToShoot, ref speed, ref canShoot, ref damage, ref knockBack, out usedAmmoItemId, dontConsume);
		if (!canShoot)
		{
			projToShoot = 0;
			return false;
		}
		return true;
	}

	/// <summary>
	/// Attempts to select an ammo item stack from this player's inventory to shoot with the given weapon.
	/// </summary>
	/// <param name="weapon">The weapon for which this call should try to find ammo.</param>
	/// <returns>Null if no suitable ammo is found; otherwise, returns the first ammo item found.</returns>
	public Item ChooseAmmo(Item weapon)
	{
		Item item = null;
		bool flag = false;
		if (weapon.useAmmo == AmmoID.Coin)
		{
			for (int i = 0; i < 4; i++)
			{
				int num = 50 + i;
				if (inventory[num].stack > 0 && ItemLoader.CanChooseAmmo(weapon, inventory[i], this))
				{
					item = inventory[num];
					flag = true;
					break;
				}
			}
		}
		for (int j = 54; j < 58; j++)
		{
			if (inventory[j].stack > 0 && ItemLoader.CanChooseAmmo(weapon, inventory[j], this))
			{
				item = inventory[j];
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			for (int k = 0; k < 54; k++)
			{
				if (inventory[k].stack > 0 && ItemLoader.CanChooseAmmo(weapon, inventory[k], this))
				{
					item = inventory[k];
					break;
				}
			}
		}
		return item;
	}

	internal void PickAmmo(Item sItem, ref int projToShoot, ref float speed, ref bool canShoot, ref int totalDamage, ref float KnockBack, out int usedAmmoItemId, bool dontConsume = false)
	{
		usedAmmoItemId = 0;
		Item item = ChooseAmmo(sItem);
		canShoot = item != null;
		bool shootWithNoAmmo = false;
		if (!canShoot && !ItemLoader.NeedsAmmo(sItem, this))
		{
			item = ContentSamples.ItemsByType[sItem.useAmmo];
			if (item.ammo == sItem.useAmmo)
			{
				shootWithNoAmmo = (canShoot = true);
			}
		}
		if (!canShoot)
		{
			return;
		}
		usedAmmoItemId = item.type;
		StatModifier ammoDamage = GetTotalDamage(item.DamageType);
		if (AmmoID.Sets.IsArrow[item.ammo])
		{
			ammoDamage = ammoDamage.CombineWith(arrowDamage);
		}
		if (AmmoID.Sets.IsBullet[item.ammo])
		{
			ammoDamage = ammoDamage.CombineWith(bulletDamage);
		}
		if (AmmoID.Sets.IsSpecialist[item.ammo])
		{
			ammoDamage = ammoDamage.CombineWith(specialistDamage);
		}
		ammoDamage.Base = 0f;
		ammoDamage.Flat = totalDamage;
		ref float Damage = ref ammoDamage.Flat;
		int pickedProjectileId = -1;
		if (PickAmmo_TryFindingSpecificMatches(sItem.type, item.type, out pickedProjectileId))
		{
			projToShoot = pickedProjectileId;
		}
		else if (sItem.type == 1946)
		{
			projToShoot = 338 + item.type - 771;
		}
		else if (sItem.type == 3930)
		{
			projToShoot = 715 + item.type - AmmoID.Rocket;
		}
		else if (sItem.useAmmo == AmmoID.Rocket)
		{
			projToShoot += item.shoot;
		}
		else if (sItem.useAmmo == AmmoID.Solution)
		{
			projToShoot += item.shoot;
		}
		else if (item.shoot > 0)
		{
			projToShoot = item.shoot;
		}
		if (sItem.type == 3019 && projToShoot == 1)
		{
			projToShoot = 485;
		}
		if (sItem.type == 3052)
		{
			projToShoot = 495;
		}
		if (sItem.type == 4953 && projToShoot == 1)
		{
			projToShoot = 932;
		}
		if (sItem.type == 4381)
		{
			projToShoot = 819;
		}
		if (sItem.type == 4058 && projToShoot == 474)
		{
			projToShoot = 117;
		}
		if (projToShoot == 42)
		{
			if (item.type == 370)
			{
				projToShoot = 65;
				Damage += 5f;
			}
			else if (item.type == 408)
			{
				projToShoot = 68;
				Damage += 5f;
			}
			else if (item.type == 1246)
			{
				projToShoot = 354;
				Damage += 5f;
			}
		}
		if (inventory[selectedItem].type == 2888 && projToShoot == 1)
		{
			projToShoot = 469;
		}
		if (hasMoltenQuiver && projToShoot == 1)
		{
			projToShoot = 2;
			Damage += 2f;
		}
		speed += item.shootSpeed;
		if (magicQuiver && (sItem.useAmmo == AmmoID.Arrow || sItem.useAmmo == AmmoID.Stake))
		{
			KnockBack *= 1.1f;
			speed *= 1.1f;
		}
		if ((sItem.useAmmo == AmmoID.Arrow || sItem.useAmmo == AmmoID.Stake) && archery && speed < 20f)
		{
			speed *= 1.2f;
			if (speed > 20f)
			{
				speed = 20f;
			}
		}
		KnockBack += item.knockBack;
		ItemLoader.PickAmmo(sItem, item, this, ref projToShoot, ref speed, ref ammoDamage, ref KnockBack);
		totalDamage = (int)(ammoDamage.ApplyTo(item.damage) + 5E-06f);
		if (!dontConsume && !shootWithNoAmmo && item.consumable && !IsAmmoFreeThisShot(sItem, item, projToShoot))
		{
			CombinedHooks.OnConsumeAmmo(this, sItem, item);
			item.stack--;
			if (item.stack <= 0)
			{
				item.active = false;
				item.TurnToAir();
			}
		}
	}

	/// <summary>
	/// Determines whether or not the given ammunition should be conserved, based on the given weapon as wielded by this player.
	/// </summary>
	/// <param name="weapon">The weapon attempting to consume the ammo.</param>
	/// <param name="ammo">The ammo attempting to be conserved (i.e. not consumed).</param>
	/// <param name="projToShoot">The projectile that should be shot by the given weapon/ammo combination.</param>
	/// <returns>True if the ammo should be conserved on the given shot; false otherwise.</returns>
	public bool IsAmmoFreeThisShot(Item weapon, Item ammo, int projToShoot)
	{
		if (!CombinedHooks.CanConsumeAmmo(this, weapon, ammo))
		{
			return true;
		}
		if (weapon.consumeAmmoOnFirstShotOnly && !ItemAnimationJustStarted)
		{
			return true;
		}
		if (weapon.consumeAmmoOnLastShotOnly)
		{
			int useTime = CombinedHooks.TotalUseTime(weapon.useTime, this, weapon);
			if (itemAnimation > useTime && (!weapon.useLimitPerAnimation.HasValue || ItemUsesThisAnimation != weapon.useLimitPerAnimation - 1))
			{
				return true;
			}
		}
		bool flag2 = false;
		if (weapon.type == 3475 && Main.rand.Next(3) != 0)
		{
			flag2 = true;
		}
		if (weapon.type == 3930 && Main.rand.Next(2) == 0)
		{
			flag2 = true;
		}
		if (weapon.type == 3540 && Main.rand.Next(3) != 0)
		{
			flag2 = true;
		}
		if (weapon.type == 5134 && Main.rand.Next(3) == 0)
		{
			flag2 = true;
		}
		if (magicQuiver && AmmoID.Sets.IsArrow[weapon.useAmmo] && Main.rand.Next(5) == 0)
		{
			flag2 = true;
		}
		if (ammoBox && Main.rand.Next(5) == 0)
		{
			flag2 = true;
		}
		if (ammoPotion && Main.rand.Next(5) == 0)
		{
			flag2 = true;
		}
		if (weapon.type == 1782 && Main.rand.Next(3) == 0)
		{
			flag2 = true;
		}
		if (weapon.type == 98 && Main.rand.Next(3) == 0)
		{
			flag2 = true;
		}
		if (weapon.type == 2270 && Main.rand.Next(2) == 0)
		{
			flag2 = true;
		}
		if (weapon.type == 533 && Main.rand.Next(2) == 0)
		{
			flag2 = true;
		}
		if (weapon.type == 1929 && Main.rand.Next(2) == 0)
		{
			flag2 = true;
		}
		if (weapon.type == 1553 && Main.rand.Next(3) != 0)
		{
			flag2 = true;
		}
		if (huntressAmmoCost90 && Main.rand.Next(10) == 0)
		{
			flag2 = true;
		}
		if (chloroAmmoCost80 && Main.rand.Next(5) == 0)
		{
			flag2 = true;
		}
		if (ammoCost80 && Main.rand.Next(5) == 0)
		{
			flag2 = true;
		}
		if (ammoCost75 && Main.rand.Next(4) == 0)
		{
			flag2 = true;
		}
		if (ammo.CountsAsClass(DamageClass.Throwing))
		{
			if (ThrownCost50 && Main.rand.Next(100) < 50)
			{
				flag2 = true;
			}
			if (ThrownCost33 && Main.rand.Next(100) < 33)
			{
				flag2 = true;
			}
		}
		if (Main.remixWorld && weapon.type == 1319 && Main.rand.Next(2) == 0)
		{
			flag2 = true;
		}
		return flag2;
	}

	public void GetOtherPlayersPickTile(int x, int y, int pickDamage)
	{
		int tileId = hitTile.HitObject(x, y, 1);
		hitTile.AddDamage(tileId, pickDamage);
	}

	public void PickTile(int x, int y, int pickPower)
	{
		int num = hitTile.HitObject(x, y, 1);
		Tile tile = Main.tile[x, y];
		if (tile.type == 504)
		{
			return;
		}
		int num2 = GetPickaxeDamage(x, y, pickPower, num, tile);
		if (!WorldGen.CanKillTile(x, y))
		{
			num2 = 0;
		}
		if (Main.getGoodWorld)
		{
			num2 *= 2;
		}
		if (DoesPickTargetTransformOnKill(hitTile, num2, x, y, pickPower, num, tile))
		{
			num2 = 0;
		}
		if (hitTile.AddDamage(num, num2) >= 100)
		{
			AchievementsHelper.CurrentlyMining = true;
			ClearMiningCacheAt(x, y, 1);
			if (Main.netMode == 1 && Main.tileContainer[Main.tile[x, y].type])
			{
				if (Main.tile[x, y].type == 470 || Main.tile[x, y].type == 475)
				{
					NetMessage.SendData(17, -1, -1, null, 20, x, y);
				}
				else
				{
					WorldGen.KillTile(x, y, fail: true);
					NetMessage.SendData(17, -1, -1, null, 0, x, y, 1f);
				}
				if (Main.tile[x, y].type == 21 || (Main.tile[x, y].type < TileID.Count && TileID.Sets.BasicChest[Main.tile[x, y].type]))
				{
					NetMessage.SendData(34, -1, -1, null, 1, x, y);
				}
				if (Main.tile[x, y].type == 467)
				{
					NetMessage.SendData(34, -1, -1, null, 5, x, y);
				}
				if (Main.tile[x, y].type == 88)
				{
					NetMessage.SendData(34, -1, -1, null, 3, x, y);
				}
				if (Main.tile[x, y].type >= TileID.Count)
				{
					if (TileID.Sets.BasicChest[Main.tile[x, y].type])
					{
						NetMessage.SendData(34, -1, -1, null, 101, x, y, 0f, 0, Main.tile[x, y].type);
					}
					if (TileID.Sets.BasicDresser[Main.tile[x, y].type])
					{
						NetMessage.SendData(34, -1, -1, null, 103, x, y, 0f, 0, Main.tile[x, y].type);
					}
				}
			}
			else
			{
				bool flag = Main.tile[x, y].active();
				WorldGen.KillTile(x, y);
				if (!Main.dedServ && flag && !Main.tile[x, y].active())
				{
					AchievementsHelper.HandleMining();
				}
				if (Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 0, x, y);
				}
			}
			AchievementsHelper.CurrentlyMining = false;
		}
		else
		{
			WorldGen.KillTile(x, y, fail: true);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 0, x, y, 1f);
				NetMessage.SendData(125, -1, -1, null, Main.myPlayer, x, y, num2);
			}
		}
		if (num2 != 0)
		{
			hitTile.Prune();
		}
	}

	private void ClearMiningCacheAt(int x, int y, int hitTileCacheType)
	{
		hitReplace.TryClearingAndPruning(x, y, 1);
		hitTile.TryClearingAndPruning(x, y, 1);
	}

	public bool isNearFairy()
	{
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		if (NPC.npcsFoundForCheckActive[583] || NPC.npcsFoundForCheckActive[584] || NPC.npcsFoundForCheckActive[585])
		{
			for (int i = 0; i < 200; i++)
			{
				if (Main.npc[i].active && (Main.npc[i].type == 583 || Main.npc[i].type == 584 || Main.npc[i].type == 585) && Vector2.Distance(Main.npc[i].Center, base.Center) < (float)NPC.sWidth)
				{
					return true;
				}
			}
		}
		return false;
	}

	public bool isNearNPC(int type, float range = -1f)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		if (range == -1f)
		{
			range = NPC.sWidth;
		}
		if (NPC.npcsFoundForCheckActive[type])
		{
			for (int i = 0; i < 200; i++)
			{
				if (Main.npc[i].active && Main.npc[i].type == type && Vector2.Distance(Main.npc[i].Center, base.Center) < range)
				{
					return true;
				}
			}
		}
		return false;
	}

	public bool HasEnoughPickPowerToHurtTile(int x, int y)
	{
		Item bestPickaxe = GetBestPickaxe();
		if (bestPickaxe == null)
		{
			return false;
		}
		Tile tile = Main.tile[x, y];
		_ = ref tile.type;
		int hitBufferIndex = hitTile.HitObject(x, y, 1);
		if (GetPickaxeDamage(x, y, bestPickaxe.pick, hitBufferIndex, tile) == 0)
		{
			return false;
		}
		return true;
	}

	private int GetPickaxeDamage(int x, int y, int pickPower, int hitBufferIndex, Tile tileTarget)
	{
		int num = 0;
		if (Main.tileNoFail[tileTarget.type])
		{
			num = 100;
		}
		ModTile modTile = TileLoader.GetTile(tileTarget.type);
		num = ((modTile == null) ? ((Main.tileDungeon[tileTarget.type] || tileTarget.type == 25 || tileTarget.type == 58 || tileTarget.type == 117 || tileTarget.type == 203) ? (num + pickPower / 2) : ((tileTarget.type != 85) ? ((tileTarget.type != 48 && tileTarget.type != 232) ? ((tileTarget.type == 226) ? (num + pickPower / 4) : ((tileTarget.type != 107 && tileTarget.type != 221) ? ((tileTarget.type != 108 && tileTarget.type != 222) ? ((tileTarget.type == 111 || tileTarget.type == 223) ? (num + pickPower / 4) : ((tileTarget.type != 211) ? (num + pickPower) : (num + pickPower / 5))) : (num + pickPower / 3)) : (num + pickPower / 2))) : (num + pickPower * 2)) : ((!Main.getGoodWorld) ? (num + pickPower / 3) : (num + pickPower / 4)))) : (num + (int)((float)pickPower / modTile.MineResist)));
		if (tileTarget.type == 211 && pickPower < 200)
		{
			num = 0;
		}
		if ((tileTarget.type == 25 || tileTarget.type == 203) && pickPower < 65)
		{
			num = 0;
		}
		else if (tileTarget.type == 117 && pickPower < 65)
		{
			num = 0;
		}
		else if (tileTarget.type == 37 && pickPower < 50)
		{
			num = 0;
		}
		else if ((tileTarget.type == 22 || tileTarget.type == 204) && (double)y > Main.worldSurface && pickPower < 55)
		{
			num = 0;
		}
		else if (tileTarget.type == 56 && pickPower < 55)
		{
			num = 0;
		}
		else if (tileTarget.type == 77 && pickPower < 65 && y >= Main.UnderworldLayer)
		{
			num = 0;
		}
		else if (tileTarget.type == 58 && pickPower < 65)
		{
			num = 0;
		}
		else if ((tileTarget.type == 226 || tileTarget.type == 237) && pickPower < 210)
		{
			num = 0;
		}
		else if (tileTarget.type == 137 && pickPower < 210)
		{
			if ((uint)(tileTarget.frameY / 18 - 1) <= 3u)
			{
				num = 0;
			}
		}
		else if (Main.tileDungeon[tileTarget.type] && pickPower < 100 && (double)y > Main.worldSurface)
		{
			if ((double)x < (double)Main.maxTilesX * 0.35 || (double)x > (double)Main.maxTilesX * 0.65)
			{
				num = 0;
			}
		}
		else if (tileTarget.type == 107 && pickPower < 100)
		{
			num = 0;
		}
		else if (tileTarget.type == 108 && pickPower < 110)
		{
			num = 0;
		}
		else if (tileTarget.type == 111 && pickPower < 150)
		{
			num = 0;
		}
		else if (tileTarget.type == 221 && pickPower < 100)
		{
			num = 0;
		}
		else if (tileTarget.type == 222 && pickPower < 110)
		{
			num = 0;
		}
		else if (tileTarget.type == 223 && pickPower < 150)
		{
			num = 0;
		}
		else
		{
			TileLoader.PickPowerCheck(tileTarget, pickPower, ref num);
		}
		if (tileTarget.type == 147 || tileTarget.type == 0 || tileTarget.type == 40 || tileTarget.type == 53 || tileTarget.type == 57 || tileTarget.type == 59 || tileTarget.type == 123 || tileTarget.type == 224 || tileTarget.type == 397)
		{
			num += pickPower;
		}
		if (tileTarget.type == 404)
		{
			num += 5;
		}
		if (tileTarget.type == 165 || Main.tileRope[tileTarget.type] || tileTarget.type == 199)
		{
			num = 100;
		}
		if (tileTarget.type == 128 || tileTarget.type == 269)
		{
			if (tileTarget.frameX == 18 || tileTarget.frameX == 54)
			{
				x--;
				tileTarget = Main.tile[x, y];
				hitTile.UpdatePosition(hitBufferIndex, x, y);
			}
			if (tileTarget.frameX >= 100)
			{
				num = 0;
				Main.blockMouse = true;
			}
		}
		if (tileTarget.type == 334)
		{
			if (tileTarget.frameY == 0)
			{
				y++;
				tileTarget = Main.tile[x, y];
				hitTile.UpdatePosition(hitBufferIndex, x, y);
			}
			if (tileTarget.frameY == 36)
			{
				y--;
				tileTarget = Main.tile[x, y];
				hitTile.UpdatePosition(hitBufferIndex, x, y);
			}
			int frameX = tileTarget.frameX;
			bool flag = frameX >= 5000;
			bool flag2 = false;
			if (!flag)
			{
				int num2 = frameX / 18;
				num2 %= 3;
				x -= num2;
				tileTarget = Main.tile[x, y];
				if (tileTarget.frameX >= 5000)
				{
					flag = true;
				}
			}
			if (flag)
			{
				frameX = tileTarget.frameX;
				int num3 = 0;
				while (frameX >= 5000)
				{
					frameX -= 5000;
					num3++;
				}
				if (num3 != 0)
				{
					flag2 = true;
				}
			}
			if (flag2)
			{
				num = 0;
				Main.blockMouse = true;
			}
		}
		return num;
	}

	private bool DoesPickTargetTransformOnKill(HitTile hitCounter, int damage, int x, int y, int pickPower, int bufferIndex, Tile tileTarget)
	{
		if (hitCounter.AddDamage(bufferIndex, damage, updateAmount: false) >= 100 && (tileTarget.type == 2 || tileTarget.type == 477 || tileTarget.type == 492 || tileTarget.type == 23 || tileTarget.type == 60 || tileTarget.type == 70 || tileTarget.type == 109 || tileTarget.type == 199 || Main.tileMoss[tileTarget.type] || tileTarget.type == 662 || tileTarget.type == 661 || TileID.Sets.tileMossBrick[tileTarget.type] || tileTarget.type == 633))
		{
			return true;
		}
		return false;
	}

	public bool ItemFitsWeaponRack(Item i)
	{
		bool flag = false;
		if (i.fishingPole > 0)
		{
			flag = true;
		}
		int netID = i.netID;
		if (netID == 905 || netID == 1326 || netID == 5335)
		{
			flag = true;
		}
		if ((i.damage > 0 || flag) && i.useStyle != 0)
		{
			return i.stack > 0;
		}
		return false;
	}

	public void PlaceWeapon(int x, int y)
	{
		if (Main.tile[x, y].active() && Main.tile[x, y].type == 334)
		{
			int frameY = Main.tile[x, y].frameY;
			int num = 1;
			frameY /= 18;
			while (num > frameY)
			{
				y++;
				frameY = Main.tile[x, y].frameY;
				frameY /= 18;
			}
			while (num < frameY)
			{
				y--;
				frameY = Main.tile[x, y].frameY;
				frameY /= 18;
			}
			int num2 = Main.tile[x, y].frameX;
			int num3 = 0;
			while (num2 >= 5000)
			{
				num2 -= 5000;
				num3++;
			}
			if (num3 != 0)
			{
				num2 = (num3 - 1) * 18;
			}
			bool flag = false;
			if (num2 >= 54)
			{
				num2 -= 54;
				flag = true;
			}
			x -= num2 / 18;
			int num4 = Main.tile[x, y].frameX;
			WorldGen.KillTile(x, y, fail: true);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 0, x, y, 1f);
			}
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 0, x + 1, y, 1f);
			}
			while (num4 >= 5000)
			{
				num4 -= 5000;
			}
			Main.blockMouse = true;
			int num5 = 5000;
			int num6 = 10000;
			if (flag)
			{
				num5 = 20000;
				num6 = 25000;
			}
			Main.tile[x, y].frameX = (short)(inventory[selectedItem].netID + num5 + 100);
			Main.tile[x + 1, y].frameX = (short)(inventory[selectedItem].prefix + num6);
			if (Main.netMode == 1)
			{
				NetMessage.SendTileSquare(-1, x, y);
			}
			if (Main.netMode == 1)
			{
				NetMessage.SendTileSquare(-1, x + 1, y);
			}
			inventory[selectedItem].stack--;
			if (inventory[selectedItem].stack <= 0)
			{
				inventory[selectedItem].SetDefaults();
				Main.mouseItem.SetDefaults();
			}
			if (selectedItem == 58)
			{
				Main.mouseItem = inventory[selectedItem].Clone();
			}
			releaseUseItem = false;
			mouseInterface = true;
		}
	}

	public bool ItemFitsItemFrame(Item i)
	{
		return i.stack > 0;
	}

	public Color GetImmuneAlpha(Color newColor, float alphaReduction)
	{
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		float num = (float)(255 - immuneAlpha) / 255f;
		if (alphaReduction > 0f)
		{
			num *= 1f - alphaReduction;
		}
		if (shimmerTransparency > 0f)
		{
			if ((double)shimmerTransparency >= 0.8)
			{
				return Color.Transparent;
			}
			num *= 1f - shimmerTransparency;
			num *= 1f - shimmerTransparency;
			num *= 1f - shimmerTransparency;
		}
		if (immuneAlpha > 125)
		{
			return Color.Transparent;
		}
		return Color.Multiply(newColor, num);
	}

	public Color GetImmuneAlphaPure(Color newColor, float alphaReduction)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		float num = (float)(255 - immuneAlpha) / 255f;
		if (alphaReduction > 0f)
		{
			num *= 1f - alphaReduction;
		}
		if (shimmerTransparency > 0f)
		{
			num *= 1f - shimmerTransparency;
		}
		return Color.Multiply(newColor, num);
	}

	public Color GetDeathAlpha(Color newColor)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		int num2 = ((Color)(ref newColor)).R + (int)((double)immuneAlpha * 0.9);
		int g = ((Color)(ref newColor)).G + (int)((double)immuneAlpha * 0.5);
		int b = ((Color)(ref newColor)).B + (int)((double)immuneAlpha * 0.5);
		int num = ((Color)(ref newColor)).A + (int)((double)immuneAlpha * 0.4);
		if (num < 0)
		{
			num = 0;
		}
		if (num > 255)
		{
			num = 255;
		}
		return new Color(num2, g, b, num);
	}

	public void addDPS(int dmg)
	{
		if (dpsStarted)
		{
			dpsLastHit = DateTime.Now;
			dpsDamage += dmg;
			dpsEnd = DateTime.Now;
		}
		else
		{
			dpsStarted = true;
			dpsStart = DateTime.Now;
			dpsEnd = DateTime.Now;
			dpsLastHit = DateTime.Now;
			dpsDamage = dmg;
		}
	}

	public void checkDPSTime()
	{
		int num = 3;
		if (dpsStarted && (DateTime.Now - dpsLastHit).Seconds >= num)
		{
			dpsStarted = false;
		}
	}

	public int getDPS()
	{
		TimeSpan timeSpan = dpsEnd - dpsStart;
		float num = (float)timeSpan.Milliseconds / 1000f;
		num += (float)timeSpan.Seconds;
		num += (float)timeSpan.Minutes / 60f;
		if (num >= 3f)
		{
			dpsStart = DateTime.Now;
			dpsStart = dpsStart.AddSeconds(-1.0);
			dpsDamage = (int)((float)dpsDamage / num);
			timeSpan = dpsEnd - dpsStart;
			num = (float)timeSpan.Milliseconds / 1000f;
			num += (float)timeSpan.Seconds;
			num += (float)timeSpan.Minutes / 60f;
		}
		if (num < 1f)
		{
			num = 1f;
		}
		return (int)((float)dpsDamage / num);
	}

	public long DropCoins()
	{
		IEntitySource itemSource_Death = GetItemSource_Death();
		long num = 0L;
		for (int i = 0; i < 59; i++)
		{
			if (inventory[i].IsACoin)
			{
				int num2 = Item.NewItem(itemSource_Death, (int)position.X, (int)position.Y, width, height, inventory[i].type);
				int num3 = inventory[i].stack / 2;
				if (Main.expertMode)
				{
					num3 = (int)((double)inventory[i].stack * 0.25);
				}
				if (Main.masterMode)
				{
					num3 = 0;
				}
				num3 = inventory[i].stack - num3;
				inventory[i].stack -= num3;
				if (inventory[i].type == 71)
				{
					num += num3;
				}
				if (inventory[i].type == 72)
				{
					num += (long)num3 * 100L;
				}
				if (inventory[i].type == 73)
				{
					num += (long)num3 * 10000L;
				}
				if (inventory[i].type == 74)
				{
					num += (long)num3 * 1000000L;
				}
				if (inventory[i].stack <= 0)
				{
					inventory[i] = new Item();
				}
				Main.item[num2].stack = num3;
				Main.item[num2].velocity.Y = (float)Main.rand.Next(-20, 1) * 0.2f;
				Main.item[num2].velocity.X = (float)Main.rand.Next(-20, 21) * 0.2f;
				Main.item[num2].noGrabDelay = 100;
				if (Main.netMode == 1)
				{
					NetMessage.SendData(21, -1, -1, null, num2);
				}
				if (i == 58)
				{
					Main.mouseItem = inventory[i].Clone();
				}
			}
		}
		lostCoins = num;
		lostCoinString = Main.ValueToCoins(lostCoins);
		return num;
	}

	public void DropItems()
	{
		IEntitySource itemSource_Death = GetItemSource_Death();
		List<Item> startInventory = PlayerLoader.GetStartingItems(this, from item in DropItems_GetDefaults()
			where !item.IsAir
			select item, mediumCoreDeath: true);
		Dictionary<int, int> startCounts = new Dictionary<int, int>();
		foreach (Item item2 in startInventory)
		{
			if (!startCounts.ContainsKey(item2.netID))
			{
				startCounts[item2.netID] = 0;
			}
			startCounts[item2.netID] += item2.stack;
		}
		startCounts[ModContent.ItemType<StartBag>()] = 1;
		AccessorySlotLoader.ModSlotPlayer(this).DropItems(itemSource_Death);
		for (int i = 0; i < 59; i++)
		{
			if (inventory[i].stack > 0)
			{
				int type2 = inventory[i].type;
				Item itemToDrop = inventory[i];
				if (startCounts.TryGetValue(type2, out var startCount))
				{
					int j = Math.Min(itemToDrop.stack, startCount);
					itemToDrop.stack -= j;
					startCounts[type2] -= j;
				}
				if (itemToDrop.stack > 0)
				{
					TryDroppingSingleItem(itemSource_Death, itemToDrop);
				}
			}
			inventory[i].TurnToAir();
			if (i < armor.Length)
			{
				TryDroppingSingleItem(itemSource_Death, armor[i]);
			}
			if (i < dye.Length)
			{
				TryDroppingSingleItem(itemSource_Death, dye[i]);
			}
			if (i < miscEquips.Length)
			{
				TryDroppingSingleItem(itemSource_Death, miscEquips[i]);
			}
			if (i < miscDyes.Length)
			{
				TryDroppingSingleItem(itemSource_Death, miscDyes[i]);
			}
		}
		EquipmentLoadout[] loadouts = Loadouts;
		for (int type = 0; type < loadouts.Length; type++)
		{
			loadouts[type].TryDroppingItems(this, itemSource_Death);
		}
		DropItems_End(startInventory);
	}

	private IEnumerable<Item> DropItems_GetDefaults()
	{
		Item[] inventory = new Item[this.inventory.Length];
		for (int i = 0; i < inventory.Length; i++)
		{
			inventory[i] = new Item();
		}
		inventory[0].SetDefaults(3507);
		inventory[0].Prefix(-1);
		inventory[1].SetDefaults(3509);
		inventory[1].Prefix(-1);
		inventory[2].SetDefaults(3506);
		inventory[2].Prefix(-1);
		return inventory;
	}

	private void DropItems_End(IList<Item> startInventory)
	{
		PlayerLoader.SetStartInventory(this, startInventory);
		Main.mouseItem.TurnToAir();
	}

	public void TryDroppingSingleItem(IEntitySource source, Item theItem)
	{
		if (theItem.stack > 0)
		{
			int num = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, theItem);
			Item obj = Main.item[num];
			obj.velocity.Y = (float)Main.rand.Next(-20, 1) * 0.2f;
			obj.velocity.X = (float)Main.rand.Next(-20, 21) * 0.2f;
			obj.noGrabDelay = 100;
			obj.newAndShiny = false;
			if (Main.netMode == 1)
			{
				NetMessage.SendData(21, -1, -1, null, num);
			}
		}
		theItem.TurnToAir(fullReset: true);
	}

	public object Clone()
	{
		return MemberwiseClone();
	}

	public void CopyVisuals(Player other)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		skinVariant = other.skinVariant;
		direction = other.direction;
		selectedItem = other.selectedItem;
		extraAccessory = other.extraAccessory;
		skinColor = other.skinColor;
		eyeColor = other.eyeColor;
		hair = other.hair;
		hairColor = other.hairColor;
		shirtColor = other.shirtColor;
		underShirtColor = other.underShirtColor;
		pantsColor = other.pantsColor;
		shoeColor = other.shoeColor;
		position = other.position;
		velocity = other.velocity;
		statLife = other.statLife;
		statLifeMax = other.statLifeMax;
		statLifeMax2 = other.statLifeMax2;
		statMana = other.statMana;
		statManaMax = other.statManaMax;
		statManaMax2 = other.statManaMax2;
		hideMisc = other.hideMisc;
		for (int i = 0; i < 59; i++)
		{
			inventory[i] = other.inventory[i].Clone();
			if (i < armor.Length)
			{
				armor[i] = other.armor[i].Clone();
			}
			if (i < dye.Length)
			{
				dye[i] = other.dye[i].Clone();
			}
			if (i < miscEquips.Length)
			{
				miscEquips[i] = other.miscEquips[i].Clone();
			}
			if (i < miscDyes.Length)
			{
				miscDyes[i] = other.miscDyes[i].Clone();
			}
			if (i < hideVisibleAccessory.Length)
			{
				hideVisibleAccessory[i] = other.hideVisibleAccessory[i];
			}
		}
	}

	public Player clientClone()
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		using (new Item.DisableCloneMethod("Item.Clone is bad for performance, and should not be called during Player.clientClone or ModPlayer.CopyClientStateTo. Use Item.CopyNetStateTo instead"))
		{
			Player player = _clientClone ?? (_clientClone = new Player());
			player.zone1 = zone1;
			player.zone2 = zone2;
			player.zone3 = zone3;
			player.zone4 = zone4;
			player.zone5 = zone5;
			player.voidVaultInfo = voidVaultInfo;
			player.luck = luck;
			BiomeLoader.CopyCustomBiomesTo(this, player);
			player.extraAccessory = extraAccessory;
			player.MinionRestTargetPoint = MinionRestTargetPoint;
			player.MinionAttackTargetNPC = MinionAttackTargetNPC;
			player.direction = direction;
			player.selectedItem = selectedItem;
			player.controlUp = controlUp;
			player.controlDown = controlDown;
			player.controlLeft = controlLeft;
			player.controlRight = controlRight;
			player.controlJump = controlJump;
			player.controlUseItem = controlUseItem;
			player.controlDownHold = controlDownHold;
			player.isOperatingAnotherEntity = isOperatingAnotherEntity;
			player.autoReuseAllWeapons = autoReuseAllWeapons;
			player.statLife = statLife;
			player.statLifeMax = statLifeMax;
			player.statMana = statMana;
			player.statManaMax = statManaMax;
			player.position.X = position.X;
			player.tileEntityAnchor = tileEntityAnchor;
			player.chest = chest;
			player.talkNPC = talkNPC;
			player.piggyBankProjTracker = piggyBankProjTracker;
			player.voidLensChest = voidLensChest;
			player.hideVisibleAccessory = hideVisibleAccessory;
			player.hideMisc = hideMisc;
			player.shieldRaised = shieldRaised;
			for (int i = 0; i < 59; i++)
			{
				inventory[i].CopyNetStateTo(player.inventory[i]);
				if (i < armor.Length)
				{
					armor[i].CopyNetStateTo(player.armor[i]);
				}
				if (i < dye.Length)
				{
					dye[i].CopyNetStateTo(player.dye[i]);
				}
				if (i < miscEquips.Length)
				{
					miscEquips[i].CopyNetStateTo(player.miscEquips[i]);
				}
				if (i < miscDyes.Length)
				{
					miscDyes[i].CopyNetStateTo(player.miscDyes[i]);
				}
				if (i < bank.item.Length)
				{
					bank.item[i].CopyNetStateTo(player.bank.item[i]);
				}
				if (i < bank2.item.Length)
				{
					bank2.item[i].CopyNetStateTo(player.bank2.item[i]);
				}
				if (i < bank3.item.Length)
				{
					bank3.item[i].CopyNetStateTo(player.bank3.item[i]);
				}
				if (i < bank4.item.Length)
				{
					bank4.item[i].CopyNetStateTo(player.bank4.item[i]);
				}
			}
			CloneLoadouts(player);
			trashItem.CopyNetStateTo(player.trashItem);
			for (int j = 0; j < maxBuffs; j++)
			{
				player.buffType[j] = buffType[j];
				player.buffTime[j] = buffTime[j];
			}
			DpadRadial.CopyTo(player.DpadRadial);
			CircularRadial.CopyTo(player.CircularRadial);
			PlayerLoader.CopyClientState(this, player);
			return player;
		}
	}

	private void CloneLoadouts(Player clonePlayer)
	{
		Item[] array = armor;
		Item[] array2 = clonePlayer.armor;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].CopyNetStateTo(array2[i]);
		}
		array = dye;
		array2 = clonePlayer.dye;
		for (int j = 0; j < array.Length; j++)
		{
			array[j].CopyNetStateTo(array2[j]);
		}
		for (int k = 0; k < Loadouts.Length; k++)
		{
			array = Loadouts[k].Armor;
			array2 = clonePlayer.Loadouts[k].Armor;
			for (int l = 0; l < array.Length; l++)
			{
				array[l].CopyNetStateTo(array2[l]);
			}
			array = Loadouts[k].Dye;
			array2 = clonePlayer.Loadouts[k].Dye;
			for (int m = 0; m < array.Length; m++)
			{
				array[m].CopyNetStateTo(array2[m]);
			}
		}
	}

	public static bool CheckSpawn(int x, int y)
	{
		bool flag = Main.tileSolid[379];
		Main.tileSolid[379] = true;
		bool result = CheckSpawn_Internal(x, y);
		Main.tileSolid[379] = flag;
		return result;
	}

	private static bool CheckSpawn_Internal(int x, int y)
	{
		if (x < 10 || x > Main.maxTilesX - 10 || y < 10 || y > Main.maxTilesX - 10)
		{
			return false;
		}
		if (Main.tile[x, y - 1] == null)
		{
			return false;
		}
		if (!Main.tile[x, y - 1].active() || !TileID.Sets.IsValidSpawnPoint[Main.tile[x, y - 1].type])
		{
			return false;
		}
		for (int i = x - 1; i <= x + 1; i++)
		{
			for (int j = y - 3; j < y; j++)
			{
				if (Main.tile[i, j] == null)
				{
					return false;
				}
				if (Main.tile[i, j].nactive() && Main.tileSolid[Main.tile[i, j].type] && !Main.tileSolidTop[Main.tile[i, j].type])
				{
					Main.NewText(Language.GetTextValue("Game.BedObstructed"), byte.MaxValue, 240, 20);
					return false;
				}
			}
		}
		if (!WorldGen.StartRoomCheck(x, y - 1))
		{
			return false;
		}
		return true;
	}

	public void FindSpawn()
	{
		for (int i = 0; i < 200; i++)
		{
			if (spN[i] == null)
			{
				SpawnX = -1;
				SpawnY = -1;
				break;
			}
			if (spN[i] == Main.worldName && spI[i] == Main.worldID)
			{
				SpawnX = spX[i];
				SpawnY = spY[i];
				break;
			}
		}
	}

	public void RemoveSpawn()
	{
		SpawnX = -1;
		SpawnY = -1;
		for (int i = 0; i < 200 && spN[i] != null; i++)
		{
			if (spN[i] == Main.worldName && spI[i] == Main.worldID)
			{
				for (int j = i; j < 199; j++)
				{
					spN[j] = spN[j + 1];
					spI[j] = spI[j + 1];
					spX[j] = spX[j + 1];
					spY[j] = spY[j + 1];
				}
				spN[199] = null;
				spI[199] = 0;
				spX[199] = 0;
				spY[199] = 0;
				break;
			}
		}
	}

	public void ChangeSpawn(int x, int y)
	{
		for (int i = 0; i < 200 && spN[i] != null; i++)
		{
			if (spN[i] == Main.worldName && spI[i] == Main.worldID)
			{
				for (int num = i; num > 0; num--)
				{
					spN[num] = spN[num - 1];
					spI[num] = spI[num - 1];
					spX[num] = spX[num - 1];
					spY[num] = spY[num - 1];
				}
				spN[0] = Main.worldName;
				spI[0] = Main.worldID;
				spX[0] = x;
				spY[0] = y;
				FindSpawn();
				return;
			}
		}
		for (int num2 = 199; num2 > 0; num2--)
		{
			if (spN[num2 - 1] != null)
			{
				spN[num2] = spN[num2 - 1];
				spI[num2] = spI[num2 - 1];
				spX[num2] = spX[num2 - 1];
				spY[num2] = spY[num2 - 1];
			}
		}
		spN[0] = Main.worldName;
		spI[0] = Main.worldID;
		spX[0] = x;
		spY[0] = y;
		FindSpawn();
	}

	public static void SavePlayer(PlayerFileData playerFile, bool skipMapSave = false)
	{
		try
		{
			Main.Achievements.Save();
			InternalSaveMap(playerFile.IsCloudSave);
			if (!Main.ServerSideCharacter)
			{
				FileUtilities.ProtectedInvoke(delegate
				{
					InternalSavePlayerFile(playerFile);
				});
			}
		}
		catch (Exception exception)
		{
			FancyErrorPrinter.ShowFileSavingFailError(exception, playerFile.Path);
			if (!Main.gameMenu)
			{
				WorldGen.SaveAndQuit();
			}
			Utils.ShowFancyErrorMessage($"{Language.GetTextValue("tModLoader.PlayerSaveFail")}\n\n{exception}", Main.menuMode);
			throw;
		}
	}

	private static void InternalSavePlayerFile(PlayerFileData playerFile)
	{
		if (playerFile.ServerSideCharacter)
		{
			return;
		}
		string path = playerFile.Path;
		Player player = playerFile.Player;
		bool isCloudSave = playerFile.IsCloudSave;
		if (string.IsNullOrEmpty(path))
		{
			return;
		}
		RijndaelManaged rijndaelManaged = new RijndaelManaged();
		using Stream stream = new MemoryStream(2000);
		using CryptoStream cryptoStream = new CryptoStream(stream, rijndaelManaged.CreateEncryptor(ENCRYPTION_KEY, ENCRYPTION_KEY), CryptoStreamMode.Write);
		using BinaryWriter binaryWriter = new BinaryWriter(cryptoStream);
		PlayerLoader.PreSavePlayer(player);
		binaryWriter.Write(279);
		playerFile.Metadata.Write(binaryWriter);
		Serialize(playerFile, player, binaryWriter);
		binaryWriter.Flush();
		cryptoStream.FlushFinalBlock();
		stream.Flush();
		byte[] bytes = ((MemoryStream)stream).ToArray();
		PlayerLoader.PostSavePlayer(player);
		TagCompound tag = PlayerIO.SaveData(player);
		BackupIO.Player.ArchivePlayer(path, isCloudSave);
		if (FileUtilities.Exists(path, isCloudSave))
		{
			FileUtilities.Copy(path, path + ".bak", isCloudSave);
		}
		FileUtilities.WriteAllBytes(path, bytes, isCloudSave);
		PlayerIO.Save(tag, path, isCloudSave);
	}

	private static void Serialize(PlayerFileData playerFile, Player newPlayer, BinaryWriter fileIO)
	{
		fileIO.Write(newPlayer.name);
		fileIO.Write(newPlayer.difficulty);
		fileIO.Write(playerFile.GetPlayTime().Ticks);
		PlayerIO.WriteVanillaHair(newPlayer.hair, fileIO);
		PlayerIO.WriteByteVanillaHairDye(newPlayer.hairDye, fileIO);
		BitsByte bitsByte = (byte)0;
		for (int i = 0; i < 8; i++)
		{
			bitsByte[i] = newPlayer.hideVisibleAccessory[i];
		}
		fileIO.Write(bitsByte);
		bitsByte = (byte)0;
		for (int j = 0; j < 2; j++)
		{
			bitsByte[j] = newPlayer.hideVisibleAccessory[j + 8];
		}
		fileIO.Write(bitsByte);
		fileIO.Write(newPlayer.hideMisc);
		fileIO.Write((byte)newPlayer.skinVariant);
		fileIO.Write(newPlayer.statLife);
		fileIO.Write(100 + newPlayer.ConsumedLifeCrystals * 20 + newPlayer.ConsumedLifeFruit * 5);
		fileIO.Write(newPlayer.statMana);
		fileIO.Write(20 + newPlayer.ConsumedManaCrystals * 20);
		fileIO.Write(newPlayer.extraAccessory);
		fileIO.Write(newPlayer.unlockedBiomeTorches);
		fileIO.Write(newPlayer.UsingBiomeTorches);
		fileIO.Write(newPlayer.ateArtisanBread);
		fileIO.Write(newPlayer.usedAegisCrystal);
		fileIO.Write(newPlayer.usedAegisFruit);
		fileIO.Write(newPlayer.usedArcaneCrystal);
		fileIO.Write(newPlayer.usedGalaxyPearl);
		fileIO.Write(newPlayer.usedGummyWorm);
		fileIO.Write(newPlayer.usedAmbrosia);
		fileIO.Write(newPlayer.downedDD2EventAnyDifficulty);
		fileIO.Write(newPlayer.taxMoney);
		fileIO.Write(newPlayer.numberOfDeathsPVE);
		fileIO.Write(newPlayer.numberOfDeathsPVP);
		fileIO.Write(((Color)(ref newPlayer.hairColor)).R);
		fileIO.Write(((Color)(ref newPlayer.hairColor)).G);
		fileIO.Write(((Color)(ref newPlayer.hairColor)).B);
		fileIO.Write(((Color)(ref newPlayer.skinColor)).R);
		fileIO.Write(((Color)(ref newPlayer.skinColor)).G);
		fileIO.Write(((Color)(ref newPlayer.skinColor)).B);
		fileIO.Write(((Color)(ref newPlayer.eyeColor)).R);
		fileIO.Write(((Color)(ref newPlayer.eyeColor)).G);
		fileIO.Write(((Color)(ref newPlayer.eyeColor)).B);
		fileIO.Write(((Color)(ref newPlayer.shirtColor)).R);
		fileIO.Write(((Color)(ref newPlayer.shirtColor)).G);
		fileIO.Write(((Color)(ref newPlayer.shirtColor)).B);
		fileIO.Write(((Color)(ref newPlayer.underShirtColor)).R);
		fileIO.Write(((Color)(ref newPlayer.underShirtColor)).G);
		fileIO.Write(((Color)(ref newPlayer.underShirtColor)).B);
		fileIO.Write(((Color)(ref newPlayer.pantsColor)).R);
		fileIO.Write(((Color)(ref newPlayer.pantsColor)).G);
		fileIO.Write(((Color)(ref newPlayer.pantsColor)).B);
		fileIO.Write(((Color)(ref newPlayer.shoeColor)).R);
		fileIO.Write(((Color)(ref newPlayer.shoeColor)).G);
		fileIO.Write(((Color)(ref newPlayer.shoeColor)).B);
		for (int k = 0; k < newPlayer.armor.Length; k++)
		{
			ItemIO.WriteVanillaID(newPlayer.armor[k], fileIO);
			ItemIO.WriteByteVanillaPrefix(newPlayer.armor[k], fileIO);
		}
		for (int l = 0; l < newPlayer.dye.Length; l++)
		{
			ItemIO.WriteVanillaID(newPlayer.dye[l], fileIO);
			ItemIO.WriteByteVanillaPrefix(newPlayer.dye[l], fileIO);
		}
		for (int m = 0; m < 58; m++)
		{
			ItemIO.WriteVanillaID(newPlayer.inventory[m], fileIO);
			fileIO.Write(newPlayer.inventory[m].stack);
			ItemIO.WriteByteVanillaPrefix(newPlayer.inventory[m], fileIO);
			fileIO.Write(newPlayer.inventory[m].favorited);
		}
		for (int n = 0; n < newPlayer.miscEquips.Length; n++)
		{
			ItemIO.WriteVanillaID(newPlayer.miscEquips[n], fileIO);
			ItemIO.WriteByteVanillaPrefix(newPlayer.miscEquips[n], fileIO);
			ItemIO.WriteVanillaID(newPlayer.miscDyes[n], fileIO);
			ItemIO.WriteByteVanillaPrefix(newPlayer.miscDyes[n], fileIO);
		}
		for (int num = 0; num < 40; num++)
		{
			ItemIO.WriteVanillaID(newPlayer.bank.item[num], fileIO);
			fileIO.Write(newPlayer.bank.item[num].stack);
			ItemIO.WriteByteVanillaPrefix(newPlayer.bank.item[num], fileIO);
		}
		for (int num3 = 0; num3 < 40; num3++)
		{
			ItemIO.WriteVanillaID(newPlayer.bank2.item[num3], fileIO);
			fileIO.Write(newPlayer.bank2.item[num3].stack);
			ItemIO.WriteByteVanillaPrefix(newPlayer.bank2.item[num3], fileIO);
		}
		for (int num4 = 0; num4 < 40; num4++)
		{
			ItemIO.WriteVanillaID(newPlayer.bank3.item[num4], fileIO);
			fileIO.Write(newPlayer.bank3.item[num4].stack);
			ItemIO.WriteByteVanillaPrefix(newPlayer.bank3.item[num4], fileIO);
		}
		for (int num5 = 0; num5 < 40; num5++)
		{
			ItemIO.WriteVanillaID(newPlayer.bank4.item[num5], fileIO);
			fileIO.Write(newPlayer.bank4.item[num5].stack);
			ItemIO.WriteByteVanillaPrefix(newPlayer.bank4.item[num5], fileIO);
			fileIO.Write(newPlayer.bank4.item[num5].favorited);
		}
		fileIO.Write(newPlayer.voidVaultInfo);
		for (int num6 = 0; num6 < 44; num6++)
		{
			fileIO.Write(0);
			fileIO.Write(0);
		}
		for (int num7 = 0; num7 < 200; num7++)
		{
			if (newPlayer.spN[num7] == null)
			{
				fileIO.Write(-1);
				break;
			}
			fileIO.Write(newPlayer.spX[num7]);
			fileIO.Write(newPlayer.spY[num7]);
			fileIO.Write(newPlayer.spI[num7]);
			fileIO.Write(newPlayer.spN[num7]);
		}
		fileIO.Write(newPlayer.hbLocked);
		for (int num8 = 0; num8 < InfoDisplayLoader.DefaultDisplayCount; num8++)
		{
			fileIO.Write(newPlayer.hideInfo[num8]);
		}
		fileIO.Write(newPlayer.anglerQuestsFinished);
		for (int num9 = 0; num9 < newPlayer.DpadRadial.Bindings.Length; num9++)
		{
			fileIO.Write(newPlayer.DpadRadial.Bindings[num9]);
		}
		for (int num10 = 0; num10 < BuilderToggleLoader.DefaultDisplayCount; num10++)
		{
			fileIO.Write(newPlayer.builderAccStatus[num10]);
		}
		fileIO.Write(newPlayer.bartenderQuestLog);
		fileIO.Write(newPlayer.dead);
		if (newPlayer.dead)
		{
			fileIO.Write(newPlayer.respawnTimer);
		}
		long value = DateTime.UtcNow.ToBinary();
		fileIO.Write(value);
		fileIO.Write(newPlayer.golferScoreAccumulated);
		newPlayer.creativeTracker.Save(fileIO);
		newPlayer.SaveTemporaryItemSlotContents(fileIO);
		CreativePowerManager.Instance.SaveToPlayer(newPlayer, fileIO);
		BitsByte bitsByte2 = default(BitsByte);
		bitsByte2[0] = newPlayer.unlockedSuperCart;
		bitsByte2[1] = newPlayer.enabledSuperCart;
		fileIO.Write(bitsByte2);
		fileIO.Write(newPlayer.CurrentLoadoutIndex);
		for (int num2 = 0; num2 < newPlayer.Loadouts.Length; num2++)
		{
			newPlayer.Loadouts[num2].Serialize(fileIO);
		}
	}

	private void SaveTemporaryItemSlotContents(BinaryWriter writer)
	{
		Item itemByIndex = Main.CreativeMenu.GetItemByIndex(0);
		BitsByte bitsByte = (byte)0;
		bitsByte[0] = !Main.mouseItem.IsAir;
		bitsByte[1] = !itemByIndex.IsAir;
		bitsByte[2] = !Main.guideItem.IsAir;
		bitsByte[3] = !Main.reforgeItem.IsAir;
		ItemSerializationContext context = ItemSerializationContext.SavingAndLoading;
		writer.Write(bitsByte);
		if (bitsByte[0])
		{
			Main.mouseItem.Serialize(writer, context);
		}
		if (bitsByte[1])
		{
			itemByIndex.Serialize(writer, context);
		}
		if (bitsByte[2])
		{
			Main.guideItem.Serialize(writer, context);
		}
		if (bitsByte[3])
		{
			Main.reforgeItem.Serialize(writer, context);
		}
	}

	private void LoadTemporaryItemSlotContents(BinaryReader reader)
	{
		BitsByte bitsByte = reader.ReadByte();
		ItemSerializationContext context = ItemSerializationContext.SavingAndLoading;
		if (bitsByte[0])
		{
			_temporaryItemSlots[0] = new Item();
			_temporaryItemSlots[0].DeserializeFrom(reader, context);
		}
		if (bitsByte[1])
		{
			_temporaryItemSlots[1] = new Item();
			_temporaryItemSlots[1].DeserializeFrom(reader, context);
		}
		if (bitsByte[2])
		{
			_temporaryItemSlots[2] = new Item();
			_temporaryItemSlots[2].DeserializeFrom(reader, context);
		}
		if (bitsByte[3])
		{
			_temporaryItemSlots[3] = new Item();
			_temporaryItemSlots[3].DeserializeFrom(reader, context);
		}
	}

	public void SetPlayerDataToOutOfClassFields()
	{
		Item mouseItem = new Item();
		if (_temporaryItemSlots[0] != null)
		{
			mouseItem = _temporaryItemSlots[0].Clone();
		}
		Main.mouseItem = mouseItem;
		mouseItem = new Item();
		if (_temporaryItemSlots[1] != null)
		{
			mouseItem = _temporaryItemSlots[1].Clone();
		}
		Main.CreativeMenu.SetItembyIndex(mouseItem, 0);
		mouseItem = new Item();
		if (_temporaryItemSlots[2] != null)
		{
			mouseItem = _temporaryItemSlots[2].Clone();
		}
		Main.guideItem = mouseItem;
		mouseItem = new Item();
		if (_temporaryItemSlots[3] != null)
		{
			mouseItem = _temporaryItemSlots[3].Clone();
		}
		Main.reforgeItem = mouseItem;
		CreativePowerManager.Instance.ApplyLoadedDataToPlayer(this);
	}

	public static void ClearPlayerTempInfo()
	{
		Main.mouseItem.TurnToAir();
		Main.guideItem.TurnToAir();
		Main.reforgeItem.TurnToAir();
		Main.CreativeMenu.GetItemByIndex(0).TurnToAir();
	}

	public static void InternalSaveMap(bool isCloudSave)
	{
		if (string.IsNullOrEmpty(Main.playerPathName))
		{
			return;
		}
		try
		{
			if (Main.mapEnabled)
			{
				Main.Map.Save();
			}
		}
		catch
		{
		}
		if (!isCloudSave)
		{
			Utils.TryCreatingDirectory(Main.PlayerPath);
		}
	}

	public static PlayerFileData LoadPlayer(string playerPath, bool cloudSave)
	{
		PlayerFileData playerFileData = new PlayerFileData(playerPath, cloudSave);
		if (cloudSave && SocialAPI.Cloud == null)
		{
			return playerFileData;
		}
		if (Main.rand == null)
		{
			Main.rand = new UnifiedRandom((int)DateTime.Now.Ticks);
		}
		Player player = new Player();
		bool gotToReadName = false;
		using (new Main.CurrentPlayerOverride(player))
		{
			try
			{
				RijndaelManaged rijndaelManaged = new RijndaelManaged();
				rijndaelManaged.Padding = PaddingMode.None;
				using (MemoryStream stream = new MemoryStream(FileUtilities.ReadAllBytes(playerPath, cloudSave)))
				{
					using CryptoStream input = new CryptoStream(stream, rijndaelManaged.CreateDecryptor(ENCRYPTION_KEY, ENCRYPTION_KEY), CryptoStreamMode.Read);
					using BinaryReader binaryReader = new BinaryReader(input);
					int num = binaryReader.ReadInt32();
					if (num >= 135)
					{
						playerFileData.Metadata = FileMetadata.Read(binaryReader, FileType.Player);
					}
					else
					{
						playerFileData.Metadata = FileMetadata.FromCurrentSettings(FileType.Player);
					}
					if (num > 279)
					{
						player.loadStatus = 1;
						player.name = binaryReader.ReadString();
						playerFileData.Player = player;
						return playerFileData;
					}
					Deserialize(playerFileData, player, binaryReader, num, out gotToReadName);
				}
				player.PlayerFrame();
				player.loadStatus = 0;
				playerFileData.Player = player;
				return playerFileData;
			}
			catch (CustomModDataException e)
			{
				playerFileData.customDataFail = e;
			}
			catch
			{
			}
			Player player2 = new Player();
			player2.loadStatus = 2;
			if (gotToReadName && player.name.Length <= nameLen)
			{
				player2.name = player.name;
			}
			else
			{
				player2.name = playerPath.Replace('/', Path.DirectorySeparatorChar).Split(Path.DirectorySeparatorChar)[^1].Split('.')[0];
			}
			playerFileData.Player = player2;
			return playerFileData;
		}
	}

	public Player SerializedClone()
	{
		Player player = new Player();
		_visualCloneStream.Seek(0L, SeekOrigin.Begin);
		Serialize(_visualCloneDummyData, this, _visualCloneWriter);
		_visualCloneStream.Seek(0L, SeekOrigin.Begin);
		Deserialize(_visualCloneDummyData, player, _visualCloneReader, PlayerIO.SaveData(this), 279, out var _);
		return player;
	}

	private static void Deserialize(PlayerFileData data, Player newPlayer, BinaryReader fileIO, int release, out bool gotToReadName)
	{
		if (!PlayerIO.TryLoadData(data.Path, data.IsCloudSave, out var tag))
		{
			tag = null;
		}
		Deserialize(data, newPlayer, fileIO, tag, release, out gotToReadName);
	}

	private static void Deserialize(PlayerFileData data, Player newPlayer, BinaryReader fileIO, TagCompound modData, int release, out bool gotToReadName)
	{
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_032b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_033e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0343: Unknown result type (might be due to invalid IL or missing references)
		//IL_034a: Unknown result type (might be due to invalid IL or missing references)
		//IL_034f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0356: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0362: Unknown result type (might be due to invalid IL or missing references)
		//IL_0367: Unknown result type (might be due to invalid IL or missing references)
		//IL_036e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0373: Unknown result type (might be due to invalid IL or missing references)
		//IL_0384: Unknown result type (might be due to invalid IL or missing references)
		//IL_0389: Unknown result type (might be due to invalid IL or missing references)
		//IL_039a: Unknown result type (might be due to invalid IL or missing references)
		//IL_039f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0408: Unknown result type (might be due to invalid IL or missing references)
		//IL_040d: Unknown result type (might be due to invalid IL or missing references)
		gotToReadName = false;
		newPlayer.name = fileIO.ReadString();
		gotToReadName = true;
		if (release >= 10)
		{
			if (release >= 17)
			{
				newPlayer.difficulty = fileIO.ReadByte();
			}
			else if (fileIO.ReadBoolean())
			{
				newPlayer.difficulty = 2;
			}
		}
		if (release >= 138)
		{
			data.SetPlayTime(new TimeSpan(fileIO.ReadInt64()));
		}
		else
		{
			data.SetPlayTime(TimeSpan.Zero);
		}
		newPlayer.hair = fileIO.ReadInt32();
		if (release >= 82)
		{
			newPlayer.hairDye = fileIO.ReadByte();
		}
		if (release >= 124)
		{
			BitsByte bitsByte = fileIO.ReadByte();
			for (int i = 0; i < 8; i++)
			{
				newPlayer.hideVisibleAccessory[i] = bitsByte[i];
			}
			bitsByte = fileIO.ReadByte();
			for (int j = 0; j < 2; j++)
			{
				newPlayer.hideVisibleAccessory[j + 8] = bitsByte[j];
			}
		}
		else if (release >= 83)
		{
			BitsByte bitsByte2 = fileIO.ReadByte();
			for (int k = 0; k < 8; k++)
			{
				newPlayer.hideVisibleAccessory[k] = bitsByte2[k];
			}
		}
		if (release >= 119)
		{
			newPlayer.hideMisc = fileIO.ReadByte();
		}
		if (release <= 17)
		{
			if (newPlayer.hair == 5 || newPlayer.hair == 6 || newPlayer.hair == 9 || newPlayer.hair == 11)
			{
				newPlayer.Male = false;
			}
			else
			{
				newPlayer.Male = true;
			}
		}
		else if (release < 107)
		{
			newPlayer.Male = fileIO.ReadBoolean();
		}
		else
		{
			newPlayer.skinVariant = fileIO.ReadByte();
		}
		if (release < 161 && newPlayer.skinVariant == 7)
		{
			newPlayer.skinVariant = 9;
		}
		newPlayer.statLife = fileIO.ReadInt32();
		newPlayer.statLifeMax = fileIO.ReadInt32();
		if (newPlayer.statLifeMax > 500)
		{
			newPlayer.statLifeMax = 500;
		}
		newPlayer.statMana = fileIO.ReadInt32();
		newPlayer.statManaMax = fileIO.ReadInt32();
		if (newPlayer.statManaMax > 200)
		{
			newPlayer.statManaMax = 200;
		}
		newPlayer.ConsumedLifeCrystals = (newPlayer.statLifeMax - 100) / 20;
		newPlayer.ConsumedLifeFruit = (newPlayer.statLifeMax - 400) / 5;
		newPlayer.ConsumedManaCrystals = (newPlayer.statManaMax - 20) / 20;
		if (release >= 125)
		{
			newPlayer.extraAccessory = fileIO.ReadBoolean();
		}
		if (release >= 229)
		{
			newPlayer.unlockedBiomeTorches = fileIO.ReadBoolean();
			newPlayer.UsingBiomeTorches = fileIO.ReadBoolean();
			if (release >= 256)
			{
				newPlayer.ateArtisanBread = fileIO.ReadBoolean();
			}
			if (release >= 260)
			{
				newPlayer.usedAegisCrystal = fileIO.ReadBoolean();
				newPlayer.usedAegisFruit = fileIO.ReadBoolean();
				newPlayer.usedArcaneCrystal = fileIO.ReadBoolean();
				newPlayer.usedGalaxyPearl = fileIO.ReadBoolean();
				newPlayer.usedGummyWorm = fileIO.ReadBoolean();
				newPlayer.usedAmbrosia = fileIO.ReadBoolean();
			}
		}
		if (release >= 182)
		{
			newPlayer.downedDD2EventAnyDifficulty = fileIO.ReadBoolean();
		}
		if (release >= 128)
		{
			newPlayer.taxMoney = fileIO.ReadInt32();
		}
		if (release >= 254)
		{
			newPlayer.numberOfDeathsPVE = fileIO.ReadInt32();
		}
		if (release >= 254)
		{
			newPlayer.numberOfDeathsPVP = fileIO.ReadInt32();
		}
		newPlayer.hairColor = fileIO.ReadRGB();
		newPlayer.skinColor = fileIO.ReadRGB();
		newPlayer.eyeColor = fileIO.ReadRGB();
		newPlayer.shirtColor = fileIO.ReadRGB();
		newPlayer.underShirtColor = fileIO.ReadRGB();
		newPlayer.pantsColor = fileIO.ReadRGB();
		newPlayer.shoeColor = fileIO.ReadRGB();
		Main.player[Main.myPlayer].hairColor = newPlayer.hairColor;
		Main.player[Main.myPlayer].skinColor = newPlayer.skinColor;
		Main.player[Main.myPlayer].eyeColor = newPlayer.eyeColor;
		Main.player[Main.myPlayer].shirtColor = newPlayer.shirtColor;
		Main.player[Main.myPlayer].underShirtColor = newPlayer.underShirtColor;
		Main.player[Main.myPlayer].pantsColor = newPlayer.pantsColor;
		Main.player[Main.myPlayer].shoeColor = newPlayer.shoeColor;
		if (release >= 38)
		{
			if (release < 124)
			{
				int num = 11;
				if (release >= 81)
				{
					num = 16;
				}
				for (int l = 0; l < num; l++)
				{
					int num12 = l;
					if (num12 >= 8)
					{
						num12 += 2;
					}
					newPlayer.armor[num12].netDefaults(fileIO.ReadInt32());
					newPlayer.armor[num12].Prefix(fileIO.ReadByte());
				}
			}
			else
			{
				int num23 = 20;
				for (int m = 0; m < num23; m++)
				{
					newPlayer.armor[m].netDefaults(fileIO.ReadInt32());
					newPlayer.armor[m].Prefix(fileIO.ReadByte());
				}
			}
			if (release >= 47)
			{
				int num32 = 3;
				if (release >= 81)
				{
					num32 = 8;
				}
				if (release >= 124)
				{
					num32 = 10;
				}
				for (int n = 0; n < num32; n++)
				{
					int num33 = n;
					newPlayer.dye[num33].netDefaults(fileIO.ReadInt32());
					newPlayer.dye[num33].Prefix(fileIO.ReadByte());
				}
			}
			if (release >= 58)
			{
				for (int num34 = 0; num34 < 58; num34++)
				{
					int num35 = fileIO.ReadInt32();
					if (num35 >= ItemID.Count)
					{
						newPlayer.inventory[num34].netDefaults(0);
						fileIO.ReadInt32();
						fileIO.ReadByte();
						if (release >= 114)
						{
							fileIO.ReadBoolean();
						}
					}
					else
					{
						newPlayer.inventory[num34].netDefaults(num35);
						newPlayer.inventory[num34].stack = fileIO.ReadInt32();
						newPlayer.inventory[num34].Prefix(fileIO.ReadByte());
						if (release >= 114)
						{
							newPlayer.inventory[num34].favorited = fileIO.ReadBoolean();
						}
					}
				}
			}
			else
			{
				for (int num36 = 0; num36 < 48; num36++)
				{
					int num37 = fileIO.ReadInt32();
					if (num37 >= ItemID.Count)
					{
						newPlayer.inventory[num36].netDefaults(0);
						fileIO.ReadInt32();
						fileIO.ReadByte();
					}
					else
					{
						newPlayer.inventory[num36].netDefaults(num37);
						newPlayer.inventory[num36].stack = fileIO.ReadInt32();
						newPlayer.inventory[num36].Prefix(fileIO.ReadByte());
					}
				}
			}
			if (release >= 117)
			{
				if (release < 136)
				{
					for (int num2 = 0; num2 < 5; num2++)
					{
						if (num2 != 1)
						{
							int num3 = fileIO.ReadInt32();
							if (num3 >= ItemID.Count)
							{
								newPlayer.miscEquips[num2].netDefaults(0);
								fileIO.ReadByte();
							}
							else
							{
								newPlayer.miscEquips[num2].netDefaults(num3);
								newPlayer.miscEquips[num2].Prefix(fileIO.ReadByte());
							}
							num3 = fileIO.ReadInt32();
							if (num3 >= ItemID.Count)
							{
								newPlayer.miscDyes[num2].netDefaults(0);
								fileIO.ReadByte();
							}
							else
							{
								newPlayer.miscDyes[num2].netDefaults(num3);
								newPlayer.miscDyes[num2].Prefix(fileIO.ReadByte());
							}
						}
					}
				}
				else
				{
					for (int num4 = 0; num4 < 5; num4++)
					{
						int num5 = fileIO.ReadInt32();
						if (num5 >= ItemID.Count)
						{
							newPlayer.miscEquips[num4].netDefaults(0);
							fileIO.ReadByte();
						}
						else
						{
							newPlayer.miscEquips[num4].netDefaults(num5);
							newPlayer.miscEquips[num4].Prefix(fileIO.ReadByte());
						}
						num5 = fileIO.ReadInt32();
						if (num5 >= ItemID.Count)
						{
							newPlayer.miscDyes[num4].netDefaults(0);
							fileIO.ReadByte();
						}
						else
						{
							newPlayer.miscDyes[num4].netDefaults(num5);
							newPlayer.miscDyes[num4].Prefix(fileIO.ReadByte());
						}
					}
				}
			}
			if (release >= 58)
			{
				for (int num6 = 0; num6 < 40; num6++)
				{
					newPlayer.bank.item[num6].netDefaults(fileIO.ReadInt32());
					newPlayer.bank.item[num6].stack = fileIO.ReadInt32();
					newPlayer.bank.item[num6].Prefix(fileIO.ReadByte());
				}
				for (int num7 = 0; num7 < 40; num7++)
				{
					newPlayer.bank2.item[num7].netDefaults(fileIO.ReadInt32());
					newPlayer.bank2.item[num7].stack = fileIO.ReadInt32();
					newPlayer.bank2.item[num7].Prefix(fileIO.ReadByte());
				}
			}
			else
			{
				for (int num8 = 0; num8 < 20; num8++)
				{
					newPlayer.bank.item[num8].netDefaults(fileIO.ReadInt32());
					newPlayer.bank.item[num8].stack = fileIO.ReadInt32();
					newPlayer.bank.item[num8].Prefix(fileIO.ReadByte());
				}
				for (int num9 = 0; num9 < 20; num9++)
				{
					newPlayer.bank2.item[num9].netDefaults(fileIO.ReadInt32());
					newPlayer.bank2.item[num9].stack = fileIO.ReadInt32();
					newPlayer.bank2.item[num9].Prefix(fileIO.ReadByte());
				}
			}
			if (release >= 182)
			{
				for (int num10 = 0; num10 < 40; num10++)
				{
					newPlayer.bank3.item[num10].netDefaults(fileIO.ReadInt32());
					newPlayer.bank3.item[num10].stack = fileIO.ReadInt32();
					newPlayer.bank3.item[num10].Prefix(fileIO.ReadByte());
				}
			}
			if (release >= 198)
			{
				for (int num11 = 0; num11 < 40; num11++)
				{
					newPlayer.bank4.item[num11].netDefaults(fileIO.ReadInt32());
					newPlayer.bank4.item[num11].stack = fileIO.ReadInt32();
					newPlayer.bank4.item[num11].Prefix(fileIO.ReadByte());
					if (release >= 255)
					{
						newPlayer.bank4.item[num11].favorited = fileIO.ReadBoolean();
					}
				}
			}
			if (release >= 199)
			{
				newPlayer.voidVaultInfo = fileIO.ReadByte();
			}
		}
		else
		{
			for (int num13 = 0; num13 < 8; num13++)
			{
				newPlayer.armor[num13].SetDefaults(ItemID.FromLegacyName(fileIO.ReadString(), release));
				if (release >= 36)
				{
					newPlayer.armor[num13].Prefix(fileIO.ReadByte());
				}
			}
			if (release >= 6)
			{
				for (int num14 = 8; num14 < 11; num14++)
				{
					newPlayer.armor[num14].SetDefaults(ItemID.FromLegacyName(fileIO.ReadString(), release));
					if (release >= 36)
					{
						newPlayer.armor[num14].Prefix(fileIO.ReadByte());
					}
				}
			}
			for (int num15 = 0; num15 < 44; num15++)
			{
				newPlayer.inventory[num15].SetDefaults(ItemID.FromLegacyName(fileIO.ReadString(), release));
				newPlayer.inventory[num15].stack = fileIO.ReadInt32();
				if (release >= 36)
				{
					newPlayer.inventory[num15].Prefix(fileIO.ReadByte());
				}
			}
			if (release >= 15)
			{
				for (int num16 = 44; num16 < 48; num16++)
				{
					newPlayer.inventory[num16].SetDefaults(ItemID.FromLegacyName(fileIO.ReadString(), release));
					newPlayer.inventory[num16].stack = fileIO.ReadInt32();
					if (release >= 36)
					{
						newPlayer.inventory[num16].Prefix(fileIO.ReadByte());
					}
				}
			}
			for (int num17 = 0; num17 < 20; num17++)
			{
				newPlayer.bank.item[num17].SetDefaults(ItemID.FromLegacyName(fileIO.ReadString(), release));
				newPlayer.bank.item[num17].stack = fileIO.ReadInt32();
				if (release >= 36)
				{
					newPlayer.bank.item[num17].Prefix(fileIO.ReadByte());
				}
			}
			if (release >= 20)
			{
				for (int num18 = 0; num18 < 20; num18++)
				{
					newPlayer.bank2.item[num18].SetDefaults(ItemID.FromLegacyName(fileIO.ReadString(), release));
					newPlayer.bank2.item[num18].stack = fileIO.ReadInt32();
					if (release >= 36)
					{
						newPlayer.bank2.item[num18].Prefix(fileIO.ReadByte());
					}
				}
			}
		}
		if (release < 58)
		{
			for (int num19 = 40; num19 < 48; num19++)
			{
				newPlayer.inventory[num19 + 10] = newPlayer.inventory[num19].Clone();
				newPlayer.inventory[num19].SetDefaults();
			}
		}
		if (release >= 11)
		{
			int num20 = 22;
			if (release < 74)
			{
				num20 = 10;
			}
			if (release >= 252)
			{
				num20 = 44;
			}
			for (int num21 = 0; num21 < num20; num21++)
			{
				newPlayer.buffType[num21] = fileIO.ReadInt32();
				newPlayer.buffTime[num21] = fileIO.ReadInt32();
				if (newPlayer.buffType[num21] == 0)
				{
					num21--;
					num20--;
				}
			}
		}
		for (int num22 = 0; num22 < 200; num22++)
		{
			int num24 = fileIO.ReadInt32();
			if (num24 == -1)
			{
				break;
			}
			newPlayer.spX[num22] = num24;
			newPlayer.spY[num22] = fileIO.ReadInt32();
			newPlayer.spI[num22] = fileIO.ReadInt32();
			newPlayer.spN[num22] = fileIO.ReadString();
		}
		if (release >= 16)
		{
			newPlayer.hbLocked = fileIO.ReadBoolean();
		}
		if (release >= 115)
		{
			int num25 = 13;
			for (int num26 = 0; num26 < num25; num26++)
			{
				newPlayer.hideInfo[num26] = fileIO.ReadBoolean();
			}
		}
		if (release >= 98)
		{
			newPlayer.anglerQuestsFinished = fileIO.ReadInt32();
		}
		if (release >= 162)
		{
			for (int num27 = 0; num27 < 4; num27++)
			{
				newPlayer.DpadRadial.Bindings[num27] = fileIO.ReadInt32();
			}
		}
		if (release >= 164)
		{
			int num28 = 8;
			if (release >= 167)
			{
				num28 = 10;
			}
			if (release >= 197)
			{
				num28 = 11;
			}
			if (release >= 230)
			{
				num28 = 12;
			}
			for (int num29 = 0; num29 < num28; num29++)
			{
				newPlayer.builderAccStatus[num29] = fileIO.ReadInt32();
			}
			if (release < 210)
			{
				newPlayer.builderAccStatus[0] = 1;
			}
			if (release < 249)
			{
				bool flag = false;
				for (int num30 = 0; num30 < 58; num30++)
				{
					if (newPlayer.inventory[num30].type == 3611)
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					newPlayer.builderAccStatus[1] = 1;
				}
			}
		}
		if (release >= 181)
		{
			newPlayer.bartenderQuestLog = fileIO.ReadInt32();
		}
		if (release >= 200)
		{
			newPlayer.dead = fileIO.ReadBoolean();
			if (newPlayer.dead)
			{
				newPlayer.respawnTimer = Utils.Clamp(fileIO.ReadInt32(), 0, 60000);
			}
		}
		newPlayer.lastTimePlayerWasSaved = 0L;
		if (release >= 202)
		{
			newPlayer.lastTimePlayerWasSaved = fileIO.ReadInt64();
		}
		else
		{
			newPlayer.lastTimePlayerWasSaved = DateTime.UtcNow.ToBinary();
		}
		if (release >= 206)
		{
			newPlayer.golferScoreAccumulated = fileIO.ReadInt32();
		}
		if (release >= 218)
		{
			newPlayer.creativeTracker.Load(fileIO, release);
		}
		if (release >= 214)
		{
			newPlayer.LoadTemporaryItemSlotContents(fileIO);
		}
		newPlayer.savedPerPlayerFieldsThatArentInThePlayerClass = new SavedPlayerDataWithAnnoyingRules();
		CreativePowerManager.Instance.ResetDataForNewPlayer(newPlayer);
		if (release >= 220)
		{
			CreativePowerManager.Instance.LoadToPlayer(newPlayer, fileIO, release);
		}
		if (release >= 253)
		{
			BitsByte bitsByte3 = fileIO.ReadByte();
			newPlayer.unlockedSuperCart = bitsByte3[0];
			newPlayer.enabledSuperCart = bitsByte3[1];
		}
		else
		{
			newPlayer.unlockedSuperCart = newPlayer.HasItemInAnyInventory(3353);
		}
		if (release >= 262)
		{
			int value = fileIO.ReadInt32();
			newPlayer.CurrentLoadoutIndex = Utils.Clamp(value, 0, newPlayer.Loadouts.Length - 1);
			for (int num31 = 0; num31 < newPlayer.Loadouts.Length; num31++)
			{
				newPlayer.Loadouts[num31].Deserialize(fileIO, release);
			}
		}
		if (modData != null)
		{
			PlayerIO.Load(newPlayer, modData);
		}
		LoadPlayer_LastMinuteFixes(newPlayer);
	}

	private static void AdjustRespawnTimerForWorldJoining(Player newPlayer)
	{
		if (Main.myPlayer != newPlayer.whoAmI || !newPlayer.dead)
		{
			return;
		}
		long num = DateTime.UtcNow.ToBinary() - newPlayer.lastTimePlayerWasSaved;
		if (num > 0)
		{
			int num2 = Utils.Clamp((int)(Utils.Clamp(new TimeSpan(num).TotalSeconds, 0.0, 1000.0) * 60.0), 0, newPlayer.respawnTimer);
			newPlayer.respawnTimer -= num2;
			if (newPlayer.respawnTimer == 0)
			{
				newPlayer.dead = false;
			}
		}
	}

	public void FixLoadedData()
	{
		FixLoadedData_Items(armor);
		FixLoadedData_Items(dye);
		FixLoadedData_Items(inventory);
		FixLoadedData_Items(miscEquips);
		FixLoadedData_Items(miscDyes);
		FixLoadedData_Items(bank.item);
		FixLoadedData_Items(bank2.item);
		FixLoadedData_Items(bank3.item);
		FixLoadedData_Items(bank4.item);
		FixLoadedData_Items(_temporaryItemSlots);
		FixLoadedData_EliminiateDuplicateAccessories(armor);
		for (int i = 0; i < Loadouts.Length; i++)
		{
			Loadouts[i].FixLoadedData();
		}
	}

	public static void FixLoadedData_EliminiateDuplicateAccessories(Item[] armorArray)
	{
		for (int i = 3; i < 10; i++)
		{
			Item item = armorArray[i];
			if (item.IsAir || item._globals.Length != 0)
			{
				continue;
			}
			for (int j = i + 1; j < 10; j++)
			{
				Item item2 = armorArray[j];
				if (item2.type == item.type)
				{
					item2.TurnToAir();
				}
			}
		}
	}

	private void FixLoadedData_Items(Item[] items)
	{
		for (int i = 0; i < items.Length; i++)
		{
			if (items[i] != null)
			{
				items[i].FixAgainstExploit();
			}
		}
	}

	private static void LoadPlayer_LastMinuteFixes(Player newPlayer)
	{
		newPlayer.skinVariant = (int)MathHelper.Clamp((float)newPlayer.skinVariant, 0f, (float)(PlayerVariantID.Count - 1));
		for (int j = 3; j < 10; j++)
		{
			LoadPlayer_LastMinuteFixes(newPlayer, newPlayer.armor[j]);
		}
		ModAccessorySlotPlayer modSlotPlayer = AccessorySlotLoader.ModSlotPlayer(newPlayer);
		for (int i = 0; i < modSlotPlayer.SlotCount; i++)
		{
			LoadPlayer_LastMinuteFixes(newPlayer, modSlotPlayer.exAccessorySlot[i]);
		}
		LoadPlayer_Finish(newPlayer);
	}

	private static void LoadPlayer_LastMinuteFixes(Player newPlayer, Item item)
	{
		Item[] armor = newPlayer.armor;
		newPlayer.armor = new Item[1] { item };
		int i = 0;
		int type = newPlayer.armor[i].type;
		if (type == 908 || type == 5000)
		{
			newPlayer.lavaMax += 420;
		}
		if (type == 906 || type == 4038 || type == 3999 || type == 4003)
		{
			newPlayer.lavaMax += 420;
		}
		if (newPlayer.wingsLogic == 0 && newPlayer.armor[i].wingSlot >= 0)
		{
			newPlayer.wingsLogic = newPlayer.armor[i].wingSlot;
			newPlayer.equippedWings = newPlayer.armor[i];
		}
		if (type == 158 || type == 396 || type == 1250 || type == 1251 || type == 1252)
		{
			newPlayer.noFallDmg = true;
		}
		if (type == 860 || type == 535)
		{
			newPlayer.pStone = true;
		}
		newPlayer.lavaTime = newPlayer.lavaMax;
		newPlayer.armor = armor;
	}

	private static void LoadPlayer_Finish(Player newPlayer)
	{
		newPlayer.FixLoadedData();
		newPlayer.ResetEffects();
	}

	public static PlayerFileData GetFileData(string file, bool cloudSave)
	{
		if (file == null || (cloudSave && SocialAPI.Cloud == null))
		{
			return null;
		}
		PlayerFileData playerFileData = LoadPlayer(file, cloudSave);
		if (playerFileData.Player != null)
		{
			if (playerFileData.Player.loadStatus != 0 && playerFileData.Player.loadStatus != 1)
			{
				CustomModDataException customDataFail = playerFileData.customDataFail;
				if (FileUtilities.Exists(file + ".bak", cloudSave))
				{
					FileUtilities.Move(file + ".bak", file, cloudSave);
					PlayerIO.LoadBackup(file, cloudSave);
				}
				playerFileData = LoadPlayer(file, cloudSave);
				if (playerFileData.Player == null)
				{
					return null;
				}
				playerFileData.customDataFail = customDataFail;
			}
			return playerFileData;
		}
		return null;
	}

	public Color GetHairColor(bool useLighting = true)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		Color color = Lighting.GetColor((int)((double)position.X + (double)width * 0.5) / 16, (int)(((double)position.Y + (double)height * 0.25) / 16.0));
		return GameShaders.Hair.GetColor(hairDye, this, useLighting ? color : Color.White);
	}

	/// <summary>
	/// Checks if the player has the specified item in their <see cref="F:Terraria.Player.inventory" />. <br />
	/// Does not check Void Bag. <br />
	/// Use <see cref="M:Terraria.Player.CountItem(System.Int32,System.Int32)" /> instead to count the total amount if needed. <br />
	/// </summary>
	/// <param name="type">The item type to count</param>
	/// <returns>True if the player has the item</returns>
	public bool HasItem(int type)
	{
		for (int i = 0; i < 58; i++)
		{
			if (type == inventory[i].type && inventory[i].stack > 0)
			{
				return true;
			}
		}
		return false;
	}

	/// <summary>
	/// Similar to <see cref="M:Terraria.Player.HasItem(System.Int32)" />, but checks the provided Item[] <paramref name="collection" /> for items instead. Useful for checking other Item arrays, such as <see cref="F:Terraria.Player.armor" /> or <see cref="F:Terraria.Player.bank" />.
	/// </summary>
	public bool HasItem(int type, Item[] collection)
	{
		for (int i = 0; i < collection.Length; i++)
		{
			if (type == collection[i].type && collection[i].stack > 0)
			{
				return true;
			}
		}
		return false;
	}

	/// <summary>
	/// Similar to <see cref="M:Terraria.Player.HasItem(System.Int32)" />, but also checks the Void Bag.
	/// </summary>
	public bool HasItemInInventoryOrOpenVoidBag(int type)
	{
		if (!HasItem(type))
		{
			if (useVoidBag())
			{
				return HasItem(type, bank4.item);
			}
			return false;
		}
		return true;
	}

	public bool HasItemInAnyInventory(int type)
	{
		if (HasItem(type, inventory))
		{
			return true;
		}
		if (HasItem(type, armor))
		{
			return true;
		}
		if (HasItem(type, dye))
		{
			return true;
		}
		if (HasItem(type, miscEquips))
		{
			return true;
		}
		if (HasItem(type, miscDyes))
		{
			return true;
		}
		if (HasItem(type, bank.item))
		{
			return true;
		}
		if (HasItem(type, bank2.item))
		{
			return true;
		}
		if (HasItem(type, bank3.item))
		{
			return true;
		}
		if (HasItem(type, bank4.item))
		{
			return true;
		}
		return false;
	}

	public int FindItem(int netid)
	{
		for (int i = 0; i < 58; i++)
		{
			if (netid == inventory[i].netID && inventory[i].stack > 0)
			{
				return i;
			}
		}
		return -1;
	}

	public int FindItem(List<int> netids)
	{
		for (int i = 0; i < 58; i++)
		{
			if (inventory[i].stack > 0 && netids.Contains(inventory[i].netID))
			{
				return i;
			}
		}
		return -1;
	}

	public int FindItem(bool[] validtypes)
	{
		for (int i = 0; i < 58; i++)
		{
			if (inventory[i].stack > 0 && validtypes[inventory[i].type])
			{
				return i;
			}
		}
		return -1;
	}

	public int FindItem(int type, Item[] collection)
	{
		for (int i = 0; i < collection.Length; i++)
		{
			if (inventory[i].stack > 0 && type == collection[i].type)
			{
				return i;
			}
		}
		return -1;
	}

	public int FindItemInInventoryOrOpenVoidBag(int type, out bool inVoidBag)
	{
		inVoidBag = false;
		int num = FindItem(type);
		if (num == -1 && useVoidBag())
		{
			num = FindItem(type, bank4.item);
			if (num == -1)
			{
				return -1;
			}
			inVoidBag = true;
		}
		return num;
	}

	public Player()
	{
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_0385: Unknown result type (might be due to invalid IL or missing references)
		//IL_038a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0482: Unknown result type (might be due to invalid IL or missing references)
		//IL_0487: Unknown result type (might be due to invalid IL or missing references)
		//IL_0496: Unknown result type (might be due to invalid IL or missing references)
		//IL_049b: Unknown result type (might be due to invalid IL or missing references)
		//IL_04aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_04af: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04da: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0509: Unknown result type (might be due to invalid IL or missing references)
		//IL_050e: Unknown result type (might be due to invalid IL or missing references)
		//IL_051d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0522: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_05bf: Unknown result type (might be due to invalid IL or missing references)
		ResetDamageClassData();
		buffType = new int[maxBuffs];
		buffTime = new int[maxBuffs];
		buffImmune = new bool[BuffLoader.BuffCount];
		ownedProjectileCounts = new int[ProjectileLoader.ProjectileCount];
		npcTypeNoAggro = new bool[NPCLoader.NPCCount];
		PlayerLoader.SetupPlayer(this);
		LoaderManager.Get<BiomeLoader>().SetupPlayer(this);
		width = 20;
		height = 42;
		name = string.Empty;
		bodyFrame.Width = 40;
		bodyFrame.Height = 56;
		legFrame.Width = 40;
		legFrame.Height = 56;
		tileEntityAnchor.Clear();
		doorHelper = new DoorOpeningHelper();
		for (int i = 0; i < 59; i++)
		{
			if (i < armor.Length)
			{
				armor[i] = new Item();
			}
			inventory[i] = new Item();
		}
		for (int j = 0; j < 40; j++)
		{
			bank.item[j] = new Item();
			bank2.item[j] = new Item();
			bank3.item[j] = new Item();
			bank4.item[j] = new Item();
		}
		for (int k = 0; k < dye.Length; k++)
		{
			dye[k] = new Item();
		}
		for (int l = 0; l < miscEquips.Length; l++)
		{
			miscEquips[l] = new Item();
		}
		for (int m = 0; m < miscDyes.Length; m++)
		{
			miscDyes[m] = new Item();
		}
		trashItem = new Item();
		lastVisualizedSelectedItem = new Item();
		grappling[0] = -1;
		statManaMax = 20;
		extraAccessory = false;
		ateArtisanBread = false;
		usedAegisCrystal = false;
		usedAegisFruit = false;
		usedArcaneCrystal = false;
		usedGalaxyPearl = false;
		usedGummyWorm = false;
		usedAmbrosia = false;
		PlayerLoader.ModifyMaxStats(this);
		for (int n = 0; n < adjTile.Length; n++)
		{
			adjTile[n] = false;
			oldAdjTile[n] = false;
		}
		hitTile = new HitTile();
		hitReplace = new HitTile();
		mount = new Mount();
		talkNPC = -1;
		piggyBankProjTracker.Clear();
		voidLensChest.Clear();
		creativeTracker = new CreativeUnlocksTracker();
		builderAccStatus[0] = 1;
	}

	public void MagicConch()
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		bool flag = position.X / 16f < (float)(Main.maxTilesX / 2);
		bool flag2 = false;
		int num = 50;
		int num2 = 50;
		int num3 = WorldGen.beachDistance - num - num2;
		if (flag)
		{
			num3 = Main.maxTilesX - num3 - 1 - num2;
		}
		else
		{
			num3 -= num2 / 2;
		}
		_ = (float)Main.maxTilesY / 1200f;
		_ = (float)Main.maxTilesY / 1200f;
		new RandomTeleportationAttemptSettings
		{
			avoidAnyLiquid = true,
			avoidHurtTiles = true,
			attemptsBeforeGivingUp = 1000,
			maximumFallDistanceFromOrignalPoint = 300
		};
		Vector2 vector = Vector2.Zero;
		int num4 = flag.ToDirectionInt();
		int startX = (flag ? (Main.maxTilesX - 50) : 50);
		flag2 = true;
		if (!TeleportHelpers.RequestMagicConchTeleportPosition(this, -num4, startX, out var landingPoint))
		{
			flag2 = false;
			startX = ((!flag) ? (Main.maxTilesX - 50) : 50);
			if (TeleportHelpers.RequestMagicConchTeleportPosition(this, num4, startX, out landingPoint))
			{
				flag2 = true;
			}
		}
		if (flag2)
		{
			vector = landingPoint.ToWorldCoordinates(8f, 16f) - new Vector2((float)(width / 2), (float)height);
		}
		if (flag2)
		{
			Vector2 newPos = vector;
			Teleport(newPos, 5);
			velocity = Vector2.Zero;
			if (Main.netMode == 2)
			{
				RemoteClient.CheckSection(whoAmI, position);
				NetMessage.SendData(65, -1, -1, null, 0, whoAmI, newPos.X, newPos.Y, 5);
			}
		}
		else
		{
			Vector2 newPos2 = position;
			Teleport(newPos2, 5);
			velocity = Vector2.Zero;
			if (Main.netMode == 2)
			{
				RemoteClient.CheckSection(whoAmI, position);
				NetMessage.SendData(65, -1, -1, null, 0, whoAmI, newPos2.X, newPos2.Y, 5, 1);
			}
		}
	}

	public void Shellphone_Spawn()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		int floorX = Main.spawnTileX;
		int floorY = Main.spawnTileY;
		Spawn_GetPositionAtWorldSpawn(ref floorX, ref floorY);
		if (Main.netMode != 1 && !Spawn_IsAreaAValidWorldSpawn(floorX, floorY))
		{
			Spawn_ForceClearArea(floorX, floorY);
		}
		Vector2 newPos = Utils.ToWorldCoordinates(new Point(floorX, floorY), 8f, 0f) - new Vector2((float)(width / 2), (float)height);
		Teleport(newPos, 11);
		velocity = Vector2.Zero;
		if (Main.netMode == 2)
		{
			RemoteClient.CheckSection(whoAmI, position);
			NetMessage.SendData(65, -1, -1, null, 0, whoAmI, newPos.X, newPos.Y, 11);
		}
	}

	public void DemonConch()
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		bool canSpawn = false;
		int num = Main.maxTilesX / 2;
		int num2 = 100;
		int num3 = num2 / 2;
		int teleportStartY = Main.UnderworldLayer + 20;
		int teleportRangeY = 80;
		RandomTeleportationAttemptSettings settings = new RandomTeleportationAttemptSettings
		{
			mostlySolidFloor = true,
			avoidAnyLiquid = true,
			avoidLava = true,
			avoidHurtTiles = true,
			avoidWalls = true,
			attemptsBeforeGivingUp = 1000,
			maximumFallDistanceFromOrignalPoint = 30
		};
		Vector2 vector = CheckForGoodTeleportationSpot(ref canSpawn, num - num3, num2, teleportStartY, teleportRangeY, settings);
		if (!canSpawn)
		{
			vector = CheckForGoodTeleportationSpot(ref canSpawn, num - num2, num3, teleportStartY, teleportRangeY, settings);
		}
		if (!canSpawn)
		{
			vector = CheckForGoodTeleportationSpot(ref canSpawn, num + num3, num3, teleportStartY, teleportRangeY, settings);
		}
		if (canSpawn)
		{
			Vector2 newPos = vector;
			Teleport(newPos, 7);
			velocity = Vector2.Zero;
			if (Main.netMode == 2)
			{
				RemoteClient.CheckSection(whoAmI, position);
				NetMessage.SendData(65, -1, -1, null, 0, whoAmI, newPos.X, newPos.Y, 7);
			}
		}
		else
		{
			Vector2 newPos2 = position;
			Teleport(newPos2, 7);
			velocity = Vector2.Zero;
			if (Main.netMode == 2)
			{
				RemoteClient.CheckSection(whoAmI, position);
				NetMessage.SendData(65, -1, -1, null, 0, whoAmI, newPos2.X, newPos2.Y, 7, 1);
			}
		}
	}

	public void TeleportationPotion()
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		bool canSpawn = false;
		int teleportStartX = 100;
		int teleportRangeX = Main.maxTilesX - 200;
		int teleportStartY = 100;
		int underworldLayer = Main.UnderworldLayer;
		Vector2 vector = CheckForGoodTeleportationSpot(ref canSpawn, teleportStartX, teleportRangeX, teleportStartY, underworldLayer, new RandomTeleportationAttemptSettings
		{
			avoidLava = true,
			avoidHurtTiles = true,
			maximumFallDistanceFromOrignalPoint = 100,
			attemptsBeforeGivingUp = 1000
		});
		if (canSpawn)
		{
			Vector2 newPos = vector;
			Teleport(newPos, 2);
			velocity = Vector2.Zero;
			if (Main.netMode == 2)
			{
				RemoteClient.CheckSection(whoAmI, position);
				NetMessage.SendData(65, -1, -1, null, 0, whoAmI, newPos.X, newPos.Y, 2);
			}
		}
		else
		{
			Vector2 newPos2 = position;
			Teleport(newPos2, 2);
			velocity = Vector2.Zero;
			if (Main.netMode == 2)
			{
				RemoteClient.CheckSection(whoAmI, position);
				NetMessage.SendData(65, -1, -1, null, 0, whoAmI, newPos2.X, newPos2.Y, 2, 1);
			}
		}
	}

	public Vector2 CheckForGoodTeleportationSpot(ref bool canSpawn, int teleportStartX, int teleportRangeX, int teleportStartY, int teleportRangeY, RandomTeleportationAttemptSettings settings)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_053a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0413: Unknown result type (might be due to invalid IL or missing references)
		//IL_041d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0422: Unknown result type (might be due to invalid IL or missing references)
		//IL_0424: Unknown result type (might be due to invalid IL or missing references)
		//IL_0426: Unknown result type (might be due to invalid IL or missing references)
		//IL_0428: Unknown result type (might be due to invalid IL or missing references)
		//IL_042d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0444: Unknown result type (might be due to invalid IL or missing references)
		//IL_0449: Unknown result type (might be due to invalid IL or missing references)
		//IL_0455: Unknown result type (might be due to invalid IL or missing references)
		//IL_045a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0464: Unknown result type (might be due to invalid IL or missing references)
		//IL_0469: Unknown result type (might be due to invalid IL or missing references)
		//IL_046b: Unknown result type (might be due to invalid IL or missing references)
		//IL_046d: Unknown result type (might be due to invalid IL or missing references)
		//IL_046f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0474: Unknown result type (might be due to invalid IL or missing references)
		//IL_048b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0490: Unknown result type (might be due to invalid IL or missing references)
		//IL_049c: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_04af: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04db: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0511: Unknown result type (might be due to invalid IL or missing references)
		//IL_0516: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		int num4 = width;
		Vector2 vector = new Vector2((float)num2, (float)num3) * 16f + new Vector2((float)(-num4 / 2 + 8), (float)(-height));
		while (!canSpawn && num < settings.attemptsBeforeGivingUp)
		{
			num++;
			num2 = teleportStartX + Main.rand.Next(teleportRangeX);
			num3 = teleportStartY + Main.rand.Next(teleportRangeY);
			int num5 = 5;
			num2 = (int)MathHelper.Clamp((float)num2, (float)num5, (float)(Main.maxTilesX - num5));
			num3 = (int)MathHelper.Clamp((float)num3, (float)num5, (float)(Main.maxTilesY - num5));
			vector = new Vector2((float)num2, (float)num3) * 16f + new Vector2((float)(-num4 / 2 + 8), (float)(-height));
			if (Collision.SolidCollision(vector, num4, height))
			{
				continue;
			}
			if (Main.tile[num2, num3] == null)
			{
				Main.tile[num2, num3] = default(Tile);
			}
			if ((settings.avoidWalls && Main.tile[num2, num3].wall > 0) || (Main.tile[num2, num3].wall == 87 && (double)num3 > Main.worldSurface && !NPC.downedPlantBoss) || (Main.wallDungeon[Main.tile[num2, num3].wall] && (double)num3 > Main.worldSurface && !NPC.downedBoss3))
			{
				continue;
			}
			int num6 = 0;
			while (num6 < settings.maximumFallDistanceFromOrignalPoint)
			{
				if (Main.tile[num2, num3 + num6] == null)
				{
					Main.tile[num2, num3 + num6] = default(Tile);
				}
				Tile tile = Main.tile[num2, num3 + num6];
				vector = new Vector2((float)num2, (float)(num3 + num6)) * 16f + new Vector2((float)(-num4 / 2 + 8), (float)(-height));
				Collision.SlopeCollision(vector, velocity, num4, height, gravDir);
				if (!Collision.SolidCollision(vector, num4, height))
				{
					num6++;
					continue;
				}
				if (tile.active() && !tile.inActive() && Main.tileSolid[tile.type])
				{
					break;
				}
				num6++;
			}
			vector.Y -= 16f;
			int i = (int)vector.X / 16;
			int j = (int)vector.Y / 16;
			int num7 = (int)(vector.X + (float)num4 * 0.5f) / 16;
			int j2 = (int)(vector.Y + (float)height) / 16;
			Tile tileSafely = Framing.GetTileSafely(i, j);
			Tile tileSafely2 = Framing.GetTileSafely(num7, j2);
			if (settings.avoidAnyLiquid && tileSafely2.liquid > 0)
			{
				continue;
			}
			if (settings.mostlySolidFloor)
			{
				Tile tileSafely3 = Framing.GetTileSafely(num7 - 1, j2);
				Tile tileSafely4 = Framing.GetTileSafely(num7 + 1, j2);
				if (!tileSafely3.active() || tileSafely3.inActive() || !Main.tileSolid[tileSafely3.type] || Main.tileSolidTop[tileSafely3.type] || !tileSafely4.active() || tileSafely4.inActive() || !Main.tileSolid[tileSafely4.type] || Main.tileSolidTop[tileSafely4.type])
				{
					continue;
				}
			}
			if ((settings.avoidWalls && tileSafely.wall > 0) || (settings.avoidAnyLiquid && Collision.WetCollision(vector, num4, height)) || (settings.avoidLava && Collision.LavaCollision(vector, num4, height)) || (settings.avoidHurtTiles && Collision.AnyHurtingTiles(vector, num4, height)) || Collision.SolidCollision(vector, num4, height) || num6 >= settings.maximumFallDistanceFromOrignalPoint - 1)
			{
				continue;
			}
			Vector2 vector2 = Vector2.UnitX * 16f;
			if (Collision.TileCollision(vector - vector2, vector2, width, height, fallThrough: false, fall2: false, (int)gravDir) != vector2)
			{
				continue;
			}
			vector2 = -Vector2.UnitX * 16f;
			if (Collision.TileCollision(vector - vector2, vector2, width, height, fallThrough: false, fall2: false, (int)gravDir) != vector2)
			{
				continue;
			}
			vector2 = Vector2.UnitY * 16f;
			if (!(Collision.TileCollision(vector - vector2, vector2, width, height, fallThrough: false, fall2: false, (int)gravDir) != vector2))
			{
				vector2 = -Vector2.UnitY * 16f;
				if (!(Collision.TileCollision(vector - vector2, vector2, width, height, fallThrough: false, fall2: false, (int)gravDir) != vector2))
				{
					canSpawn = true;
					num3 += num6;
					break;
				}
			}
		}
		return vector;
	}

	public void GetAnglerReward(NPC angler, int questItemType)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		EntitySource_Gift source = new EntitySource_Gift(angler);
		int questsDone = anglerQuestsFinished;
		float anglerRewardRarityMultiplier = GetAnglerRewardRarityMultiplier(questsDone);
		anglerRewardRarityMultiplier *= (float)(currentShoppingSettings.PriceAdjustment + 1.0) / 2f;
		List<Item> rewardItems = new List<Item>();
		GetItemSettings anglerRewardSettings = GetItemSettings.NPCEntityToPlayerInventorySettings;
		GetAnglerReward_MainReward(rewardItems, source, questsDone, anglerRewardRarityMultiplier, questItemType, ref anglerRewardSettings);
		GetAnglerReward_Decoration(rewardItems, source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
		GetAnglerReward_Money(rewardItems, source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
		GetAnglerReward_Bait(rewardItems, source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
		PlayerLoader.AnglerQuestReward(this, anglerRewardRarityMultiplier, rewardItems);
		foreach (Item rewardItem in rewardItems)
		{
			rewardItem.position = base.Center;
			Item getItem = GetItem(whoAmI, rewardItem, GetItemSettings.NPCEntityToPlayerInventorySettings);
			if (getItem.stack > 0)
			{
				int number = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, getItem.type, getItem.stack, noBroadcast: false, 0, noGrabDelay: true);
				if (Main.netMode == 1)
				{
					NetMessage.SendData(21, -1, -1, null, number, 1f);
				}
			}
		}
	}

	public static float GetAnglerRewardRarityMultiplier(int questsDone)
	{
		float num = 1f;
		num = ((questsDone <= 50) ? (num - (float)questsDone * 0.01f) : ((questsDone <= 100) ? (0.5f - (float)(questsDone - 50) * 0.005f) : ((questsDone > 150) ? 0.15f : (0.25f - (float)(questsDone - 100) * 0.002f))));
		return num * 0.9f;
	}

	private void GetAnglerReward_MainReward(List<Item> rewardItems, IEntitySource source, int questsDone, float rarityReduction, int questItemType, ref GetItemSettings anglerRewardSettings)
	{
		Item item = new Item();
		item.type = 0;
		switch (questsDone)
		{
		case 5:
			item.SetDefaults(2428);
			break;
		case 10:
			item.SetDefaults(2367);
			break;
		case 15:
			item.SetDefaults(2368);
			break;
		case 20:
			item.SetDefaults(2369);
			break;
		case 25:
			item.SetDefaults(3031);
			break;
		case 30:
			item.SetDefaults(2294);
			break;
		default:
		{
			if (questItemType == 2451 && Main.hardMode)
			{
				item.SetDefaults((Main.rand.Next(2) == 0) ? 5303 : 5302);
				break;
			}
			if (questItemType == 2451 && !Main.hardMode && Main.rand.Next(2) == 0)
			{
				item.SetDefaults((Main.rand.Next(2) == 0) ? 5303 : 5302);
				break;
			}
			List<int> list = new List<int> { 2373, 2374, 2375, 3120, 3037, 3096, 5139 };
			float num = 1f;
			for (int i = 0; i < 3; i++)
			{
				num *= 1f - 1f / (float)(int)(40f * rarityReduction);
			}
			for (int j = 0; j < 3; j++)
			{
				num *= 1f - 1f / (float)(int)(30f * rarityReduction);
			}
			num *= 1f - 1f / (float)(int)(25f * rarityReduction);
			float num2 = 1f - num;
			num2 *= 0.8f;
			if (questsDone > 75 && Main.rand.Next((int)(250f * rarityReduction)) == 0)
			{
				item.SetDefaults(2294);
				break;
			}
			if (Main.hardMode && questsDone > 25 && Main.rand.Next((int)(100f * rarityReduction)) == 0)
			{
				item.SetDefaults(2422);
				break;
			}
			if (Main.hardMode && questsDone > 10 && Main.rand.Next((int)(70f * rarityReduction)) == 0)
			{
				item.SetDefaults(2494);
				break;
			}
			if (questsDone > 10 && Main.rand.Next((int)(70f * rarityReduction)) == 0)
			{
				item.SetDefaults(3031);
				break;
			}
			if (questsDone > 10 && Main.rand.Next((int)(70f * rarityReduction)) == 0)
			{
				item.SetDefaults(3032);
				break;
			}
			if (Main.rand.Next((int)(80f * rarityReduction)) == 0)
			{
				item.SetDefaults(3183);
				break;
			}
			if (Main.rand.Next((int)(60f * rarityReduction)) == 0)
			{
				item.SetDefaults(2360);
				break;
			}
			if (Main.rand.Next((int)(60f * rarityReduction)) == 0)
			{
				item.SetDefaults(4067);
				break;
			}
			if (Main.rand.Next((int)(80f * rarityReduction)) == 0)
			{
				item.SetDefaults(2417);
				break;
			}
			if (Main.rand.Next((int)(80f * rarityReduction)) == 0)
			{
				item.SetDefaults(2498);
				break;
			}
			if (DropAnglerAccByMissing(list, num2, out var botheredRollingForADrop, out var itemIdToDrop))
			{
				item.SetDefaults(itemIdToDrop);
				break;
			}
			if (!botheredRollingForADrop && Main.rand.NextDouble() < (double)num2)
			{
				int defaults = Utils.SelectRandom(Main.rand, list.ToArray());
				item.SetDefaults(defaults);
				break;
			}
			switch (Main.rand.Next(3))
			{
			case 0:
				item.SetDefaults(2354);
				item.stack = Main.rand.Next(2, 6);
				break;
			case 1:
				item.SetDefaults(2355);
				item.stack = Main.rand.Next(2, 6);
				break;
			default:
				item.SetDefaults(2356);
				item.stack = Main.rand.Next(2, 6);
				break;
			}
			break;
		}
		}
		rewardItems.Add(item);
		if (item.type == 2417)
		{
			Item item2 = new Item();
			Item item3 = new Item();
			item2.SetDefaults(2418);
			rewardItems.Add(item2);
			item3.SetDefaults(2419);
			rewardItems.Add(item3);
		}
		else if (item.type == 2498)
		{
			Item item4 = new Item();
			Item item5 = new Item();
			item4.SetDefaults(2499);
			rewardItems.Add(item4);
			item5.SetDefaults(2500);
			rewardItems.Add(item5);
		}
	}

	private void GetAnglerReward_Decoration(List<Item> rewardItems, IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings)
	{
		float num3 = 1f - rarityReduction;
		int num = 100;
		float num2 = MathHelper.Lerp(num3, 1f, Math.Min(1f, (float)questsDone / (float)num));
		if (num2 >= 1f || Main.rand.NextFloat() <= num2)
		{
			Item item = new Item();
			item.type = 0;
			item.SetDefaults(Main.rand.Next(19) switch
			{
				1 => 2443, 
				2 => 2444, 
				3 => 2445, 
				4 => 2497, 
				5 => 2495, 
				6 => 2446, 
				7 => 2447, 
				8 => 2448, 
				9 => 2449, 
				10 => 2490, 
				11 => 2496, 
				12 => 5235, 
				13 => 5252, 
				14 => 5256, 
				15 => 5259, 
				16 => 5263, 
				17 => 5264, 
				18 => 5265, 
				_ => 2442, 
			});
			rewardItems.Add(item);
		}
	}

	private void GetAnglerReward_Bait(List<Item> rewardItems, IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings)
	{
		if (Main.rand.Next((int)(100f * rarityReduction)) <= 50)
		{
			Item item = new Item();
			if (Main.rand.Next((int)(15f * rarityReduction)) == 0)
			{
				item.SetDefaults(2676);
			}
			else if (Main.rand.Next((int)(5f * rarityReduction)) == 0)
			{
				item.SetDefaults(2675);
			}
			else
			{
				item.SetDefaults(2674);
			}
			if (Main.rand.Next(25) <= questsDone)
			{
				item.stack++;
			}
			if (Main.rand.Next(50) <= questsDone)
			{
				item.stack++;
			}
			if (Main.rand.Next(100) <= questsDone)
			{
				item.stack++;
			}
			if (Main.rand.Next(150) <= questsDone)
			{
				item.stack++;
			}
			if (Main.rand.Next(200) <= questsDone)
			{
				item.stack++;
			}
			if (Main.rand.Next(250) <= questsDone)
			{
				item.stack++;
			}
			rewardItems.Add(item);
		}
	}

	private void GetAnglerReward_Money(List<Item> rewardItems, IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings)
	{
		Item item = new Item();
		int num = (questsDone + 50) / 2;
		num = (int)((float)(num * Main.rand.Next(50, 201)) * 0.015f);
		num = (int)((double)num * 1.5);
		if (Main.hardMode)
		{
			num *= 2;
		}
		if (Main.expertMode)
		{
			num *= 2;
		}
		if (num > 100)
		{
			num /= 100;
			if (num > 10)
			{
				num = 10;
			}
			if (num < 1)
			{
				num = 1;
			}
			item.SetDefaults(73);
			item.stack = num;
		}
		else
		{
			if (num > 99)
			{
				num = 99;
			}
			if (num < 1)
			{
				num = 1;
			}
			item.SetDefaults(72);
			item.stack = num;
		}
		rewardItems.Add(item);
	}

	public bool DropAnglerAccByMissing(List<int> itemIdsOfAccsWeWant, float totalChance, out bool botheredRollingForADrop, out int itemIdToDrop)
	{
		botheredRollingForADrop = false;
		itemIdToDrop = 0;
		List<int> list = new List<int>(itemIdsOfAccsWeWant);
		Item[] array = inventory;
		for (int i = 0; i < array.Length; i++)
		{
			RemoveAnglerAccOptionsFromRewardPool(list, array[i]);
		}
		array = armor;
		for (int j = 0; j < array.Length; j++)
		{
			RemoveAnglerAccOptionsFromRewardPool(list, array[j]);
		}
		array = bank.item;
		for (int k = 0; k < array.Length; k++)
		{
			RemoveAnglerAccOptionsFromRewardPool(list, array[k]);
		}
		array = bank2.item;
		for (int l = 0; l < array.Length; l++)
		{
			RemoveAnglerAccOptionsFromRewardPool(list, array[l]);
		}
		array = bank3.item;
		for (int m = 0; m < array.Length; m++)
		{
			RemoveAnglerAccOptionsFromRewardPool(list, array[m]);
		}
		array = bank4.item;
		for (int n = 0; n < array.Length; n++)
		{
			RemoveAnglerAccOptionsFromRewardPool(list, array[n]);
		}
		for (int num = 0; num < Loadouts.Length; num++)
		{
			array = Loadouts[num].Armor;
			for (int num2 = 0; num2 < array.Length; num2++)
			{
				RemoveAnglerAccOptionsFromRewardPool(list, array[num2]);
			}
		}
		if (list.Count == 0)
		{
			return false;
		}
		bool flag = false;
		if (Main.rand.NextDouble() < (double)totalChance)
		{
			flag = true;
		}
		botheredRollingForADrop = true;
		if (flag)
		{
			itemIdToDrop = Main.rand.NextFromList(list.ToArray());
			return true;
		}
		return false;
	}

	private void RemoveAnglerAccOptionsFromRewardPool(List<int> itemIdsOfAccsWeWant, Item itemToTestAgainst)
	{
		if (!itemToTestAgainst.IsAir)
		{
			switch (itemToTestAgainst.type)
			{
			default:
				itemIdsOfAccsWeWant.Remove(itemToTestAgainst.type);
				break;
			case 3721:
			case 5064:
				itemIdsOfAccsWeWant.Remove(2373);
				itemIdsOfAccsWeWant.Remove(2375);
				itemIdsOfAccsWeWant.Remove(2374);
				break;
			case 3036:
			case 3123:
			case 3124:
			case 5358:
			case 5359:
			case 5360:
			case 5361:
				itemIdsOfAccsWeWant.Remove(3120);
				itemIdsOfAccsWeWant.Remove(3037);
				itemIdsOfAccsWeWant.Remove(3096);
				break;
			case 5140:
			case 5141:
			case 5142:
			case 5143:
			case 5144:
			case 5145:
			case 5146:
				itemIdsOfAccsWeWant.Remove(5139);
				break;
			}
		}
	}

	public void GetDyeTraderReward(NPC dyeTrader)
	{
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		int num = -1;
		EntitySource_Gift source = new EntitySource_Gift(dyeTrader);
		List<int> list = new List<int>
		{
			3560, 3028, 3041, 3040, 3025, 3190, 3027, 3026, 3554, 3553,
			3555, 2872, 3534, 2871
		};
		if (Main.hardMode)
		{
			list.Add(3039);
			list.Add(3038);
			list.Add(3598);
			list.Add(3597);
			list.Add(3600);
			list.Add(3042);
			list.Add(3533);
			list.Add(3561);
			if (NPC.downedMechBossAny)
			{
				list.Add(2883);
				list.Add(2869);
				list.Add(2873);
				list.Add(2870);
			}
			if (NPC.downedPlantBoss)
			{
				list.Add(2878);
				list.Add(2879);
				list.Add(2884);
				list.Add(2885);
			}
			if (NPC.downedMartians)
			{
				list.Add(2864);
				list.Add(3556);
			}
			if (NPC.downedMoonlord)
			{
				list.Add(3024);
			}
		}
		PlayerLoader.GetDyeTraderReward(this, list);
		num = list[Main.rand.Next(list.Count)];
		Item item = new Item();
		item.SetDefaults(num);
		item.stack = 6;
		item.position = base.Center;
		Item item2 = GetItem(whoAmI, item, GetItemSettings.NPCEntityToPlayerInventorySettings);
		if (item2.stack > 0)
		{
			int number = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, 0, noGrabDelay: true);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(21, -1, -1, null, number, 1f);
			}
		}
	}

	public bool CheckMana(int amount, bool pay = false, bool blockQuickMana = false)
	{
		int num = (int)((float)amount * manaCost);
		if (statMana >= num)
		{
			if (pay)
			{
				statMana -= num;
			}
			return true;
		}
		if (manaFlower && !blockQuickMana)
		{
			QuickMana();
			if (statMana >= num)
			{
				if (pay)
				{
					statMana -= num;
				}
				return true;
			}
			return false;
		}
		return false;
	}

	public void TryPortalJumping()
	{
		if (!mount.Active && !dead && !isLockedToATile)
		{
			PortalHelper.TryGoingThroughPortals(this);
		}
	}

	public bool ConsumeSolarFlare()
	{
		if (setSolar && solarShields > 0)
		{
			solarShields--;
			for (int i = 0; i < maxBuffs; i++)
			{
				if (buffType[i] >= 170 && buffType[i] <= 172)
				{
					DelBuff(i);
				}
			}
			if (solarShields > 0 && whoAmI == Main.myPlayer)
			{
				AddBuff(170 + solarShields - 1, 5, quiet: false);
			}
			solarCounter = 0;
			return true;
		}
		return false;
	}

	public void KeyDoubleTap(int keyDir)
	{
		int num = 0;
		if (Main.ReversedUpDownArmorSetBonuses)
		{
			num = 1;
		}
		if (keyDir != num)
		{
			return;
		}
		if (setVortex && !mount.Active)
		{
			vortexStealthActive = !vortexStealthActive;
		}
		if (setForbidden)
		{
			MinionRestTargetAim();
			if (!setForbiddenCooldownLocked)
			{
				CommandForbiddenStorm();
			}
		}
	}

	public void UpdateForbiddenSetLock()
	{
		List<int> list = new List<int>();
		for (int i = 0; i < 1000; i++)
		{
			Projectile projectile = Main.projectile[i];
			if (projectile.active && projectile.type == 656 && projectile.owner == whoAmI)
			{
				list.Add(i);
			}
		}
		setForbiddenCooldownLocked = list.Count > 1;
	}

	public void CommandForbiddenStorm()
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0325: Unknown result type (might be due to invalid IL or missing references)
		//IL_032a: Unknown result type (might be due to invalid IL or missing references)
		List<int> list = new List<int>();
		for (int i = 0; i < 1000; i++)
		{
			Projectile projectile = Main.projectile[i];
			if (projectile.active && projectile.type == 656 && projectile.owner == whoAmI)
			{
				list.Add(i);
			}
		}
		bool flag = StrayMethods.CanSpawnSandstormFriendly(MinionRestTargetPoint, 30, 30);
		bool num5 = MinionRestTargetPoint == Vector2.Zero;
		Vector2 center = base.Center;
		Vector2 endPoint = MinionRestTargetPoint;
		if (num5)
		{
			endPoint = center;
		}
		int samplesToTake = 10;
		float samplingWidth = 60f;
		Collision.AimingLaserScan(center, endPoint, samplingWidth, samplesToTake, out var vectorTowardsTarget, out var samples);
		bool flag2 = false;
		float[] array = samples;
		for (int j = 0; j < array.Length; j++)
		{
			if (Math.Abs(array[j] - ((Vector2)(ref vectorTowardsTarget)).Length()) < 10f)
			{
				flag2 = true;
				break;
			}
		}
		float num2 = 0f;
		for (int k = 0; k < samples.Length; k++)
		{
			if (samples[k] > num2)
			{
				num2 = samples[k];
			}
		}
		if (list.Count <= 1)
		{
			Vector2 vector = center + vectorTowardsTarget.SafeNormalize(Vector2.Zero) * num2;
			Vector2 vector2 = vector - center;
			if (((Vector2)(ref vector2)).Length() > 0f)
			{
				for (float num3 = 0f; num3 < ((Vector2)(ref vector2)).Length(); num3 += 15f)
				{
					Vector2 vector3 = center + vector2 * (num3 / ((Vector2)(ref vector2)).Length());
					Dust obj = Main.dust[Dust.NewDust(vector3, 0, 0, 269)];
					obj.position = vector3;
					obj.fadeIn = 0.5f;
					obj.scale = 0.7f;
					obj.velocity *= 0.4f;
					obj.noLight = true;
				}
			}
			for (float num4 = 0f; num4 < (float)Math.PI * 2f; num4 += (float)Math.PI / 15f)
			{
				Dust obj2 = Main.dust[Dust.NewDust(vector, 0, 0, 269)];
				obj2.position = vector;
				obj2.fadeIn = 1f;
				obj2.scale = 0.3f;
				obj2.noLight = true;
			}
		}
		flag &= list.Count <= 1;
		flag = flag && flag2;
		if (flag)
		{
			flag = CheckMana(20, pay: true);
			if (flag)
			{
				manaRegenDelay = (int)maxRegenDelay;
			}
		}
		if (!flag)
		{
			return;
		}
		foreach (int item in list)
		{
			Projectile projectile2 = Main.projectile[item];
			if (!(projectile2.ai[0] >= 780f))
			{
				projectile2.ai[0] = 780f + projectile2.ai[0] % 60f;
				projectile2.netUpdate = true;
			}
		}
		int damage = (int)GetTotalDamage(DamageClass.MagicSummonHybrid).ApplyTo(20f);
		IEntitySource projectileSource_SetBonus = GetProjectileSource_SetBonus(3);
		_ = Main.projectile[Projectile.NewProjectile(projectileSource_SetBonus, MinionRestTargetPoint, Vector2.Zero, 656, damage, 0f, Main.myPlayer)];
	}

	public void KeyHoldDown(int keyDir, int holdTime)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		if (Main.ReversedUpDownArmorSetBonuses)
		{
			num = 1;
		}
		if (keyDir == num)
		{
			if (setStardust && holdTime >= 60)
			{
				MinionRestTargetPoint = Vector2.Zero;
			}
			if (setForbidden && holdTime >= 60)
			{
				MinionRestTargetPoint = Vector2.Zero;
			}
		}
	}

	public void MinionNPCTargetAim(bool doNotDisableIfTheTargetIsTheSame)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		Vector2 mouseWorld = Main.MouseWorld;
		int num = -1;
		for (int i = 0; i < 200; i++)
		{
			if (Main.npc[i].CanBeChasedBy(this) && (num == -1 || Main.npc[i].Hitbox.Distance(mouseWorld) < Main.npc[num].Hitbox.Distance(mouseWorld)))
			{
				num = i;
			}
		}
		if (MinionAttackTargetNPC == num && !doNotDisableIfTheTargetIsTheSame)
		{
			MinionAttackTargetNPC = -1;
		}
		else
		{
			MinionAttackTargetNPC = num;
		}
	}

	public void MinionRestTargetAim()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		Vector2 mouseWorld = Main.MouseWorld;
		float y = mouseWorld.Y;
		int num = (int)mouseWorld.X / 16;
		int num2 = (int)y / 16;
		int num3 = 0;
		if (Main.tile[num, num2].nactive() && Main.tileSolid[Main.tile[num, num2].type] && !Main.tileSolidTop[Main.tile[num, num2].type])
		{
			int num4 = 0;
			int num5 = 0;
			while (num5 > -20 && num2 + num5 > 1)
			{
				int num6 = num2 + num5;
				if (Main.tile[num, num6].nactive() && Main.tileSolid[Main.tile[num, num6].type] && !Main.tileSolidTop[Main.tile[num, num6].type])
				{
					num4 = num5;
					num5--;
					continue;
				}
				num4 = num5;
				break;
			}
			int num7 = 0;
			for (int i = 0; i < 20 && num2 + i < Main.maxTilesY; i++)
			{
				int num8 = num2 + i;
				if (Main.tile[num, num8].nactive() && Main.tileSolid[Main.tile[num, num8].type] && !Main.tileSolidTop[Main.tile[num, num8].type])
				{
					num7 = i;
					continue;
				}
				num7 = i;
				break;
			}
			num3 = ((num7 <= -num4) ? (num7 + 3) : (num4 - 2));
		}
		int num9 = num2 + num3;
		bool flag = false;
		for (int j = num9; j < num9 + 5; j++)
		{
			if (WorldGen.SolidTileAllowBottomSlope(num, j))
			{
				flag = true;
			}
		}
		while (!flag)
		{
			num9++;
			for (int k = num9; k < num9 + 5; k++)
			{
				if (WorldGen.SolidTileAllowBottomSlope(num, k))
				{
					flag = true;
				}
			}
		}
		Vector2 vector = default(Vector2);
		((Vector2)(ref vector))._002Ector((float)(num * 16 + 8), (float)(num9 * 16));
		if (Distance(vector) <= 1000f)
		{
			MinionRestTargetPoint = vector;
		}
	}

	public void UpdateMinionTarget()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		if (whoAmI != Main.myPlayer)
		{
			return;
		}
		if (Distance(MinionRestTargetPoint) > 1000f)
		{
			MinionRestTargetPoint = Vector2.Zero;
		}
		if (MinionAttackTargetNPC != -1 && (!Main.npc[MinionAttackTargetNPC].CanBeChasedBy(this) || Main.npc[MinionAttackTargetNPC].Hitbox.Distance(base.Center) > 3000f))
		{
			MinionAttackTargetNPC = -1;
		}
		if (stardustGuardian && HasMinionRestTarget)
		{
			Vector2 minionRestTargetPoint = MinionRestTargetPoint;
			float num = (float)miscCounter / 150f;
			float num2 = (float)Math.PI * 2f / 3f;
			for (int i = 0; i < 3; i++)
			{
				int num3 = Dust.NewDust(minionRestTargetPoint, 0, 0, 135, 0f, 0f, 100, default(Color), 1.5f);
				Main.dust[num3].noGravity = true;
				Main.dust[num3].velocity = Vector2.Zero;
				Main.dust[num3].noLight = true;
				Main.dust[num3].position = minionRestTargetPoint + (num * ((float)Math.PI * 2f) + num2 * (float)i).ToRotationVector2() * 4f;
				Main.dust[num3].shader = GameShaders.Armor.GetSecondaryShader(cPet, this);
			}
		}
	}

	public void NebulaLevelup(int type)
	{
		if (whoAmI != Main.myPlayer)
		{
			return;
		}
		int timeToAdd = 480;
		for (int i = 0; i < maxBuffs; i++)
		{
			if (buffType[i] >= type && buffType[i] < type + 3)
			{
				DelBuff(i);
			}
		}
		switch (type)
		{
		case 173:
			nebulaLevelLife = (int)MathHelper.Clamp((float)(nebulaLevelLife + 1), 0f, 3f);
			AddBuff(type + nebulaLevelLife - 1, timeToAdd);
			break;
		case 176:
			nebulaLevelMana = (int)MathHelper.Clamp((float)(nebulaLevelMana + 1), 0f, 3f);
			AddBuff(type + nebulaLevelMana - 1, timeToAdd);
			break;
		case 179:
			nebulaLevelDamage = (int)MathHelper.Clamp((float)(nebulaLevelDamage + 1), 0f, 3f);
			AddBuff(type + nebulaLevelDamage - 1, timeToAdd);
			break;
		}
	}

	public void UpdateTouchingTiles()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		TouchedTiles.Clear();
		List<Point> list = null;
		List<Point> list2 = null;
		if (!Collision.IsClearSpotTest(position + velocity, 16f, width, height, fallThrough: false, fall2: false, (int)gravDir, checkCardinals: true, checkSlopes: true))
		{
			list = Collision.FindCollisionTile((Math.Sign(velocity.Y) == 1) ? 2 : 3, position + velocity, 16f, width, height, fallThrough: false, fall2: false, (int)gravDir);
		}
		if (!Collision.IsClearSpotTest(position, Math.Abs(velocity.Y), width, height, fallThrough: false, fall2: false, (int)gravDir, checkCardinals: true, checkSlopes: true))
		{
			list2 = Collision.FindCollisionTile((Math.Sign(velocity.Y) == 1) ? 2 : 3, position, Math.Abs(velocity.Y), width, height, fallThrough: false, fall2: false, (int)gravDir, checkCardinals: true, checkSlopes: true);
		}
		if (list != null && list2 != null)
		{
			for (int i = 0; i < list2.Count; i++)
			{
				if (!list.Contains(list2[i]))
				{
					list.Add(list2[i]);
				}
			}
		}
		if (list == null && list2 != null)
		{
			list = list2;
		}
		if (list != null)
		{
			TouchedTiles = list;
		}
	}

	/// <summary> Gets the instance of the specified ModPlayer type. This will throw exceptions on failure. </summary>
	/// <exception cref="T:System.Collections.Generic.KeyNotFoundException" />
	/// <exception cref="T:System.IndexOutOfRangeException" />
	public T GetModPlayer<T>() where T : ModPlayer
	{
		return GetModPlayer(ModContent.GetInstance<T>());
	}

	/// <summary> Gets the local instance of the type of the specified ModPlayer instance. This will throw exceptions on failure. </summary>
	/// <exception cref="T:System.Collections.Generic.KeyNotFoundException" />
	/// <exception cref="T:System.IndexOutOfRangeException" />
	/// <exception cref="T:System.NullReferenceException" />
	public T GetModPlayer<T>(T baseInstance) where T : ModPlayer
	{
		return (modPlayers[baseInstance.Index] as T) ?? throw new KeyNotFoundException("Instance of '" + typeof(T).Name + "' does not exist on the current player.");
	}

	/// <summary> Gets the instance of the specified ModPlayer type. </summary>
	public bool TryGetModPlayer<T>(out T result) where T : ModPlayer
	{
		return TryGetModPlayer(ModContent.GetInstance<T>(), out result);
	}

	/// <summary> Safely attempts to get the local instance of the type of the specified ModPlayer instance. </summary>
	/// <returns> Whether or not the requested instance has been found. </returns>
	public bool TryGetModPlayer<T>(T baseInstance, out T result) where T : ModPlayer
	{
		if (baseInstance == null || baseInstance.Index < 0 || baseInstance.Index >= modPlayers.Length)
		{
			result = null;
			return false;
		}
		result = modPlayers[baseInstance.Index] as T;
		return result != null;
	}

	public void DropFromItem(int itemType)
	{
		DropAttemptInfo dropAttemptInfo = default(DropAttemptInfo);
		dropAttemptInfo.player = this;
		dropAttemptInfo.item = itemType;
		dropAttemptInfo.IsExpertMode = Main.expertMode;
		dropAttemptInfo.IsMasterMode = Main.masterMode;
		dropAttemptInfo.IsInSimulation = false;
		dropAttemptInfo.rng = Main.rand;
		DropAttemptInfo info = dropAttemptInfo;
		Main.ItemDropSolver.TryDropping(info);
	}

	/// <summary>
	/// Will spawn an item like <see cref="M:Terraria.Player.QuickSpawnItem(Terraria.DataStructures.IEntitySource,System.Int32,System.Int32)" />, but clones it (handy when you need to retain item infos)
	/// </summary>
	/// <param name="source">The spawn context</param>
	/// <param name="item">The item you want to be cloned</param>
	/// <param name="stack">The stack to give the item. Note that this will override maxStack if it's higher.</param>
	[Obsolete("Use Player.QuickSpawnItem(IEntitySource source, Item item, int stack) instead.")]
	public int QuickSpawnClonedItem(IEntitySource source, Item item, int stack = 1)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		int index = Item.NewItem(source, getRect(), item);
		Main.item[index].stack = stack;
		if (Main.netMode == 1)
		{
			NetMessage.SendData(21, -1, -1, null, index, 1f);
		}
		return index;
	}

	/// <inheritdoc cref="M:Terraria.Player.QuickSpawnClonedItem(Terraria.DataStructures.IEntitySource,Terraria.Item,System.Int32)" />
	public int QuickSpawnItem(IEntitySource source, Item item, int stack = 1)
	{
		return QuickSpawnClonedItem(source, item, stack);
	}

	/// <summary><inheritdoc cref="M:Terraria.Player.QuickSpawnClonedItem(Terraria.DataStructures.IEntitySource,Terraria.Item,System.Int32)" /></summary>
	/// <returns>Returns the Item instance</returns>
	public Item QuickSpawnClonedItemDirect(IEntitySource source, Item item, int stack = 1)
	{
		return Main.item[QuickSpawnClonedItem(source, item, stack)];
	}

	/// <summary><inheritdoc cref="M:Terraria.Player.QuickSpawnClonedItem(Terraria.DataStructures.IEntitySource,Terraria.Item,System.Int32)" /></summary>
	/// <returns>Returns the Item instance</returns>
	public Item QuickSpawnItemDirect(IEntitySource source, Item item, int stack = 1)
	{
		return Main.item[QuickSpawnClonedItem(source, item, stack)];
	}

	/// <summary><inheritdoc cref="M:Terraria.Player.QuickSpawnItem(Terraria.DataStructures.IEntitySource,System.Int32,System.Int32)" /></summary>
	/// <returns>Returns the Item instance</returns>
	public Item QuickSpawnItemDirect(IEntitySource source, int type, int stack = 1)
	{
		return Main.item[QuickSpawnItem(source, type, stack)];
	}

	/// <summary> Returns whether or not this Player currently has a (de)buff of the provided type. </summary>
	public bool HasBuff(int type)
	{
		return FindBuffIndex(type) != -1;
	}

	/// <inheritdoc cref="M:Terraria.Player.HasBuff(System.Int32)" />
	public bool HasBuff<T>() where T : ModBuff
	{
		return HasBuff(ModContent.BuffType<T>());
	}

	internal void ResetDamageClassData()
	{
		damageData = new DamageClassData[DamageClassLoader.DamageClassCount];
		for (int i = 0; i < damageData.Length; i++)
		{
			damageData[i] = new DamageClassData();
			DamageClassLoader.DamageClasses[i].SetDefaultStats(this);
		}
	}

	/// <summary>
	/// Gets the damage modifier for this damage type on this player.
	/// This returns a reference, and as such, you can freely modify this method's return value with operators.
	/// </summary>
	public ref StatModifier GetDamage<T>() where T : DamageClass
	{
		return ref GetDamage(ModContent.GetInstance<T>());
	}

	/// <summary>
	/// Gets the damage modifier for this damage type on this player.
	/// This returns a reference, and as such, you can freely modify this method's return value with operators.
	/// </summary>
	public ref StatModifier GetDamage(DamageClass damageClass)
	{
		return ref damageData[damageClass.Type].damage;
	}

	/// <summary>
	/// Gets the crit chance modifier for this damage type on this player.
	/// This returns a reference, and as such, you can freely modify this method's return value with operators.
	/// </summary>
	public ref float GetCritChance<T>() where T : DamageClass
	{
		return ref GetCritChance(ModContent.GetInstance<T>());
	}

	/// <summary>
	/// Gets the crit chance modifier for this damage type on this player.
	/// This returns a reference, and as such, you can freely modify this method's return value with operators.
	/// </summary>
	public ref float GetCritChance(DamageClass damageClass)
	{
		return ref damageData[damageClass.Type].critChance;
	}

	/// <summary>
	/// Gets the attack speed modifier for this damage type on this player.
	/// This returns a reference, and as such, you can freely modify this method's return values with operators.
	/// Setting this such that it results in zero or a negative value will throw an exception.
	/// NOTE: Due to the nature of attack speed modifiers, modifications to Flat will do nothing for this modifier.
	/// </summary>
	public ref float GetAttackSpeed<T>() where T : DamageClass
	{
		return ref GetAttackSpeed(ModContent.GetInstance<T>());
	}

	/// <summary>
	/// Gets the attack speed modifier for this damage type on this player.
	/// This returns a reference, and as such, you can freely modify this method's return values with operators.
	/// </summary>
	public ref float GetAttackSpeed(DamageClass damageClass)
	{
		return ref damageData[damageClass.Type].attackSpeed;
	}

	/// <summary>
	/// Gets the armor penetration modifier for this damage type on this player.
	/// This returns a reference, and as such, you can freely modify this method's return value with operators.
	/// </summary>
	public ref float GetArmorPenetration<T>() where T : DamageClass
	{
		return ref GetArmorPenetration(ModContent.GetInstance<T>());
	}

	/// <summary>
	/// Gets the armor penetration modifier for this damage type on this player.
	/// This returns a reference, and as such, you can freely modify this method's return value with operators.
	/// </summary>
	public ref float GetArmorPenetration(DamageClass damageClass)
	{
		return ref damageData[damageClass.Type].armorPen;
	}

	/// <summary>
	/// Gets the knockback modifier for this damage type on this player.
	/// This returns a reference, and as such, you can freely modify this method's return value with operators.
	/// </summary>
	public ref StatModifier GetKnockback<T>() where T : DamageClass
	{
		return ref GetKnockback(ModContent.GetInstance<T>());
	}

	/// <summary>
	/// Gets the knockback modifier for this damage type on this player.
	/// This returns a reference, and as such, you can freely modify this method's return value with operators.
	/// </summary>
	public ref StatModifier GetKnockback(DamageClass damageClass)
	{
		return ref damageData[damageClass.Type].knockback;
	}

	/// <inheritdoc cref="M:Terraria.Player.GetTotalDamage(Terraria.ModLoader.DamageClass)" />
	public StatModifier GetTotalDamage<T>() where T : DamageClass
	{
		return GetTotalDamage(ModContent.GetInstance<T>());
	}

	/// <summary>
	/// Calculates a total damage modifier for the player for the provided <see cref="T:Terraria.ModLoader.DamageClass" />.<br />
	/// Use in conjunction with <see cref="M:Terraria.ModLoader.StatModifier.ApplyTo(System.Single)" /> to calculate a final damage value for a given <see cref="T:Terraria.ModLoader.DamageClass" /> and base damage: <c>int finalDamage = (int)player.GetTotalDamage(item.DamageType).ApplyTo(30);</c>
	/// </summary>
	/// <remarks>The modifiers calculated here are important due to the possibility of
	/// damage classes inheriting modifiers from other damage classes. For instance, an attack
	/// can be classified as multiple damage types and each could have different modifiers to apply to the damage
	/// </remarks>
	/// <param name="damageClass">The <see cref="T:Terraria.ModLoader.DamageClass" /> to use for total damage calculation</param>
	/// <returns>All modifiers combined</returns>
	public StatModifier GetTotalDamage(DamageClass damageClass)
	{
		StatModifier stat = damageData[damageClass.Type].damage;
		for (int i = 0; i < damageData.Length; i++)
		{
			if (i != damageClass.Type)
			{
				StatInheritanceData inheritanceData = damageClass.GetModifierInheritance(DamageClassLoader.DamageClasses[i]);
				stat = stat.CombineWith(damageData[i].damage.Scale(inheritanceData.damageInheritance));
			}
		}
		return stat;
	}

	public float GetTotalCritChance<T>() where T : DamageClass
	{
		return GetTotalCritChance(ModContent.GetInstance<T>());
	}

	public float GetTotalCritChance(DamageClass damageClass)
	{
		float stat = damageData[damageClass.Type].critChance;
		for (int i = 0; i < damageData.Length; i++)
		{
			if (i != damageClass.Type)
			{
				StatInheritanceData inheritanceData = damageClass.GetModifierInheritance(DamageClassLoader.DamageClasses[i]);
				stat += damageData[i].critChance * inheritanceData.critChanceInheritance;
			}
		}
		return stat;
	}

	public float GetTotalAttackSpeed<T>() where T : DamageClass
	{
		return GetTotalAttackSpeed(ModContent.GetInstance<T>());
	}

	public float GetTotalAttackSpeed(DamageClass damageClass)
	{
		float stat = damageData[damageClass.Type].attackSpeed;
		for (int i = 0; i < damageData.Length; i++)
		{
			if (i != damageClass.Type)
			{
				StatInheritanceData inheritanceData = damageClass.GetModifierInheritance(DamageClassLoader.DamageClasses[i]);
				stat += (damageData[i].attackSpeed - 1f) * inheritanceData.attackSpeedInheritance;
			}
		}
		return stat;
	}

	public float GetTotalArmorPenetration<T>() where T : DamageClass
	{
		return GetTotalArmorPenetration(ModContent.GetInstance<T>());
	}

	public float GetTotalArmorPenetration(DamageClass damageClass)
	{
		float stat = damageData[damageClass.Type].armorPen;
		for (int i = 0; i < damageData.Length; i++)
		{
			if (i != damageClass.Type)
			{
				StatInheritanceData inheritanceData = damageClass.GetModifierInheritance(DamageClassLoader.DamageClasses[i]);
				stat += damageData[i].armorPen * inheritanceData.armorPenInheritance;
			}
		}
		return stat;
	}

	public StatModifier GetTotalKnockback<T>() where T : DamageClass
	{
		return GetTotalKnockback(ModContent.GetInstance<T>());
	}

	public StatModifier GetTotalKnockback(DamageClass damageClass)
	{
		StatModifier stat = damageData[damageClass.Type].knockback;
		for (int i = 0; i < damageData.Length; i++)
		{
			if (i != damageClass.Type)
			{
				StatInheritanceData inheritanceData = damageClass.GetModifierInheritance(DamageClassLoader.DamageClasses[i]);
				stat = stat.CombineWith(damageData[i].knockback.Scale(inheritanceData.knockbackInheritance));
			}
		}
		return stat;
	}

	public int GetWeaponArmorPenetration(Item sItem)
	{
		return (int)((float)sItem.ArmorPenetration + GetTotalArmorPenetration(sItem.DamageType));
	}

	public float GetWeaponAttackSpeed(Item sItem)
	{
		float attackSpeed = GetTotalAttackSpeed(sItem.DamageType);
		return 1f + (attackSpeed - 1f) * ItemID.Sets.BonusAttackSpeedMultiplier[sItem.type];
	}

	/// <summary>
	/// Determines if the player is in specified ModBiome. This will throw exceptions on failure.
	/// </summary>
	/// <exception cref="T:System.IndexOutOfRangeException" />
	/// <exception cref="T:System.NullReferenceException" />
	public bool InModBiome(ModBiome baseInstance)
	{
		return modBiomeFlags[baseInstance.ZeroIndexType];
	}

	/// <inheritdoc cref="M:Terraria.Player.InModBiome(Terraria.ModLoader.ModBiome)" />
	public bool InModBiome<T>() where T : ModBiome
	{
		return InModBiome(ModContent.GetInstance<T>());
	}

	/// <summary>
	/// Calculates whether or not the player is in the purity/forest biome.
	/// </summary>
	public bool InZonePurity()
	{
		bool num = ZoneBeach || ZoneCorrupt || ZoneCrimson || ZoneDesert || ZoneDungeon || ZoneGemCave;
		bool two = ZoneGlowshroom || ZoneGranite || ZoneGraveyard || ZoneHallow || ZoneHive || ZoneJungle;
		bool three = ZoneLihzhardTemple || ZoneMarble || ZoneMeteor || ZoneSnow || ZoneUnderworldHeight;
		bool four = modBiomeFlags.Cast<bool>().Contains(value: true);
		return !(num || two || three || four);
	}

	/// <summary>
	/// Invoked in UpdateVisibleAccessories. Runs common code for both modded slots and vanilla slots based on provided Items.
	/// </summary>
	public void UpdateVisibleAccessories(Item item, bool invisible, int slot = -1, bool modded = false)
	{
		if (eocDash > 0 && shield == -1 && item.shieldSlot != -1)
		{
			shield = item.shieldSlot;
			if (cShieldFallback != -1)
			{
				cShield = cShieldFallback;
			}
		}
		if (shieldRaised && shield == -1 && item.shieldSlot != -1)
		{
			shield = item.shieldSlot;
			if (cShieldFallback != -1)
			{
				cShield = cShieldFallback;
			}
		}
		if (ItemIsVisuallyIncompatible(item))
		{
			return;
		}
		if (item.wingSlot > 0)
		{
			if (invisible && (velocity.Y == 0f || mount.Active))
			{
				return;
			}
			wings = item.wingSlot;
		}
		if (!invisible)
		{
			UpdateVisibleAccessory(slot, item, modded);
		}
	}

	/// <summary>
	/// Drops the ref'd item from the player at the position, and than turns the ref'd Item to air.
	/// </summary>
	public void DropItem(IEntitySource source, Vector2 position, ref Item item)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (item.stack > 0)
		{
			int itemDropId = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, item);
			Item obj = Main.item[itemDropId];
			obj.velocity.Y = (float)Main.rand.Next(-20, 1) * 0.2f;
			obj.velocity.X = (float)Main.rand.Next(-20, 21) * 0.2f;
			obj.noGrabDelay = 100;
			obj.newAndShiny = false;
			if (Main.netMode == 1)
			{
				NetMessage.SendData(21, -1, -1, null, itemDropId);
			}
		}
		item.TurnToAir();
	}

	public int GetHealLife(Item item, bool quickHeal = false)
	{
		int healValue = item.healLife;
		ItemLoader.GetHealLife(item, this, quickHeal, ref healValue);
		PlayerLoader.GetHealLife(this, item, quickHeal, ref healValue);
		if (healValue <= 0)
		{
			return 0;
		}
		return healValue;
	}

	public int GetHealMana(Item item, bool quickHeal = false)
	{
		int healValue = item.healMana;
		ItemLoader.GetHealMana(item, this, quickHeal, ref healValue);
		PlayerLoader.GetHealMana(this, item, quickHeal, ref healValue);
		if (healValue <= 0)
		{
			return 0;
		}
		return healValue;
	}

	/// <summary>
	/// Calculates the mana needed to use the given item.
	/// </summary>
	/// <param name="item">The item to check.</param>
	/// <returns>The amount of mana needed to use <paramref name="item" />. Cannot be less than <c>0</c>.</returns>
	public int GetManaCost(Item item)
	{
		float reduce = manaCost;
		float mult = 1f;
		if (spaceGun && ItemID.Sets.IsSpaceGun[item.type])
		{
			mult = 0f;
		}
		if (item.type == 3852 && altFunctionUse == 2)
		{
			mult = 2f;
		}
		CombinedHooks.ModifyManaCost(this, item, ref reduce, ref mult);
		int mana = (int)((float)item.mana * reduce * mult);
		if (mana < 0)
		{
			return 0;
		}
		return mana;
	}

	/// <summary>
	/// Determines if this player has enough mana to use an item.
	/// <br /> If the player doesn't have enough mana and <paramref name="blockQuickMana" /> is <see langword="false" />, the player will activate any missing mana effects they have and try again.
	/// <br /> The <paramref name="pay" /> parameter can be used to consume the mana amount.
	/// </summary>
	/// <param name="item">The item to use.</param>
	/// <param name="amount">The amount of mana needed. If <c>-1</c>, calculate using <see cref="M:Terraria.Player.GetManaCost(Terraria.Item)" />.</param>
	/// <param name="pay">If <see langword="true" />, actually use the mana requested.</param>
	/// <param name="blockQuickMana">If <see langword="true" />, prevent on missing mana effects like the Mana Flower from activating if the player doesn't have enough mana.</param>
	/// <returns><see langword="true" /> if the player has enough mana to use the item, <see langword="false" /> otherwise.</returns>
	public bool CheckMana(Item item, int amount = -1, bool pay = false, bool blockQuickMana = false)
	{
		if (amount <= -1)
		{
			amount = GetManaCost(item);
		}
		if (statMana >= amount)
		{
			if (pay)
			{
				CombinedHooks.OnConsumeMana(this, item, amount);
				statMana -= amount;
			}
			return true;
		}
		if (blockQuickMana)
		{
			return false;
		}
		CombinedHooks.OnMissingMana(this, item, amount);
		if (statMana < amount && manaFlower)
		{
			QuickMana();
		}
		if (statMana >= amount)
		{
			if (pay)
			{
				CombinedHooks.OnConsumeMana(this, item, amount);
				statMana -= amount;
			}
			return true;
		}
		return false;
	}

	/// <summary>
	/// Adds to either Player.immuneTime or Player.hurtCooldowns based on the cooldownCounterId
	/// </summary>
	/// <param name="cooldownCounterId">See <see cref="T:Terraria.ID.ImmunityCooldownID" /> for valid ids.</param>
	/// <param name="immuneTime">Extra immunity time to add</param>
	public void AddImmuneTime(int cooldownCounterId, int immuneTime)
	{
		if (cooldownCounterId < 0)
		{
			this.immuneTime += immuneTime;
		}
		else
		{
			hurtCooldowns[cooldownCounterId] += immuneTime;
		}
	}

	public ref ExtraJumpState GetJumpState<T>(T baseInstance) where T : ExtraJump
	{
		return ref extraJumps[baseInstance.Type];
	}

	public ref ExtraJumpState GetJumpState<T>() where T : ExtraJump
	{
		return ref GetJumpState(ModContent.GetInstance<T>());
	}

	/// <summary>
	/// Returns <see langword="true" /> if any extra jump is <see cref="P:Terraria.DataStructures.ExtraJumpState.Available" /> and <see cref="M:Terraria.ModLoader.ExtraJump.CanStart(Terraria.Player)" />.<br />
	/// Setting <see cref="F:Terraria.Player.blockExtraJumps" /> will cause this method to return <see langword="false" /> instead.
	/// </summary>
	public bool AnyExtraJumpUsable()
	{
		if (blockExtraJumps)
		{
			return false;
		}
		foreach (ExtraJump jump in ExtraJumpLoader.OrderedJumps)
		{
			if (GetJumpState(jump).Available && jump.CanStart(this) && PlayerLoader.CanStartExtraJump(jump, this))
			{
				return true;
			}
		}
		return false;
	}

	/// <summary>
	/// Cancels any extra jump in progress.<br />
	/// Sets all <see cref="P:Terraria.DataStructures.ExtraJumpState.Active" /> flags to <see langword="false" /> and calls OnExtraJumpEnded hooks.<br />
	/// Also sets <see cref="F:Terraria.Player.jump" /> to 0 if a an extra jump was active.<br /><br />
	///
	/// Used by vanilla when performing an action which would cancel jumping, such as grappling, grabbing a rope or getting frozen.<br /><br />
	///
	/// To prevent the use of remaining jumps, use <see cref="M:Terraria.Player.ConsumeAllExtraJumps" /> or <see cref="F:Terraria.Player.blockExtraJumps" />.<br />
	/// To cancel a regular jump as well, do <c>Player.jump = 0;</c>
	/// </summary>
	public void StopExtraJumpInProgress()
	{
		ExtraJumpLoader.StopActiveJump(this, out var anyJumpCancelled);
		if (anyJumpCancelled)
		{
			jump = 0;
		}
	}

	public IEntitySource GetSource_Accessory(Item item, string? context = null)
	{
		return new EntitySource_ItemUse(this, item, context);
	}

	public IEntitySource GetSource_Accessory_OnHurt(Item item, Entity? attacker, string? context = null)
	{
		return new EntitySource_ItemUse_OnHurt(this, item, attacker, context);
	}

	public IEntitySource GetSource_Accessory_OnHurt(Item item, PlayerDeathReason damageSource, string? context = null)
	{
		Entity attacker;
		return GetSource_Accessory_OnHurt(item, (whoAmI == Main.myPlayer && damageSource.TryGetCausingEntity(out attacker)) ? attacker : null, context);
	}

	public IEntitySource GetSource_OnHurt(PlayerDeathReason damageSource, string? context = null)
	{
		Entity attacker;
		return GetSource_OnHurt((whoAmI == Main.myPlayer && damageSource.TryGetCausingEntity(out attacker)) ? attacker : null, context);
	}

	public IEntitySource GetSource_OpenItem(int itemType, string? context = null)
	{
		return new EntitySource_ItemOpen(this, itemType, context);
	}

	public IEntitySource GetSource_ItemUse(Item item, string? context = null)
	{
		return new EntitySource_ItemUse(this, item, context);
	}

	public IEntitySource GetSource_ItemUse_WithPotentialAmmo(Item item, int ammoItemId, string? context = null)
	{
		return new EntitySource_ItemUse_WithAmmo(this, item, ammoItemId, context);
	}
}
