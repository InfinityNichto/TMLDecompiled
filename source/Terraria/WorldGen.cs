using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using MonoMod.Cil;
using ReLogic.Utilities;
using Terraria.Audio;
using Terraria.Chat;
using Terraria.DataStructures;
using Terraria.Enums;
using Terraria.GameContent;
using Terraria.GameContent.Achievements;
using Terraria.GameContent.Biomes;
using Terraria.GameContent.Creative;
using Terraria.GameContent.Events;
using Terraria.GameContent.Generation;
using Terraria.GameContent.Tile_Entities;
using Terraria.GameContent.UI.States;
using Terraria.Graphics.Capture;
using Terraria.ID;
using Terraria.IO;
using Terraria.Localization;
using Terraria.Map;
using Terraria.ModLoader;
using Terraria.ModLoader.IO;
using Terraria.ObjectData;
using Terraria.Utilities;
using Terraria.WorldBuilding;

namespace Terraria;

public class WorldGen
{
	public static class WorldSize
	{
		public const int Small = 0;

		public const int Medium = 1;

		public const int Large = 2;
	}

	public static class SavedOreTiers
	{
		public static int Copper = 7;

		public static int Iron = 6;

		public static int Silver = 9;

		public static int Gold = 8;

		public static int Cobalt = 107;

		public static int Mythril = 108;

		public static int Adamantite = 111;
	}

	public static class Hooks
	{
		public delegate void WorldGenConfigProcessEvent(ref WorldGenConfiguration config);

		public static event WorldGenConfigProcessEvent OnWorldGenConfigProcess;

		public static event Action OnWorldLoad;

		public static void Initialize()
		{
			Player.Hooks.OnEnterWorld += delegate(Player player)
			{
				if (player.whoAmI == Main.myPlayer)
				{
					WorldLoaded();
					if (Main.netMode != 1)
					{
						Main.FixUIScale();
					}
				}
			};
			OnWorldLoad += mysticLogsEvent.StartWorld;
			OnWorldLoad += Main.checkHalloween;
			OnWorldLoad += Main.checkXMas;
		}

		public static void WorldLoaded()
		{
			if (Hooks.OnWorldLoad != null)
			{
				Hooks.OnWorldLoad();
			}
		}

		public static void ProcessWorldGenConfig(ref WorldGenConfiguration config)
		{
			if (Hooks.OnWorldGenConfigProcess != null)
			{
				Hooks.OnWorldGenConfigProcess(ref config);
			}
		}
	}

	public static class Spread
	{
		public static void Wall(int x, int y, int wallType)
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
			//IL_010b: Unknown result type (might be due to invalid IL or missing references)
			//IL_011e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0127: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_0115: Unknown result type (might be due to invalid IL or missing references)
			//IL_0147: Unknown result type (might be due to invalid IL or missing references)
			//IL_014e: Unknown result type (might be due to invalid IL or missing references)
			//IL_015d: Unknown result type (might be due to invalid IL or missing references)
			//IL_013e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0170: Unknown result type (might be due to invalid IL or missing references)
			//IL_0177: Unknown result type (might be due to invalid IL or missing references)
			//IL_0186: Unknown result type (might be due to invalid IL or missing references)
			//IL_0167: Unknown result type (might be due to invalid IL or missing references)
			//IL_0190: Unknown result type (might be due to invalid IL or missing references)
			if (!InWorld(x, y))
			{
				return;
			}
			ushort wall = (ushort)wallType;
			List<Point> list = new List<Point>();
			List<Point> list2 = new List<Point>();
			HashSet<Point> hashSet = new HashSet<Point>();
			list2.Add(new Point(x, y));
			Point item2 = default(Point);
			while (list2.Count > 0)
			{
				list.Clear();
				list.AddRange(list2);
				list2.Clear();
				while (list.Count > 0)
				{
					Point item = list[0];
					if (!InWorld(item.X, item.Y, 1))
					{
						list.Remove(item);
						continue;
					}
					hashSet.Add(item);
					list.Remove(item);
					Tile tile = Main.tile[item.X, item.Y];
					if (SolidTile(item.X, item.Y) || tile.wall != 0)
					{
						if (tile.active() && tile.wall == 0)
						{
							tile.wall = wall;
						}
						continue;
					}
					tile.wall = wall;
					((Point)(ref item2))._002Ector(item.X - 1, item.Y);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					((Point)(ref item2))._002Ector(item.X + 1, item.Y);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					((Point)(ref item2))._002Ector(item.X, item.Y - 1);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					((Point)(ref item2))._002Ector(item.X, item.Y + 1);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
				}
			}
		}

		public static void Wall2(int x, int y, int wallType)
		{
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_0131: Unknown result type (might be due to invalid IL or missing references)
			//IL_013a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0148: Unknown result type (might be due to invalid IL or missing references)
			//IL_0119: Unknown result type (might be due to invalid IL or missing references)
			//IL_0103: Unknown result type (might be due to invalid IL or missing references)
			//IL_015c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0165: Unknown result type (might be due to invalid IL or missing references)
			//IL_0173: Unknown result type (might be due to invalid IL or missing references)
			//IL_0153: Unknown result type (might be due to invalid IL or missing references)
			//IL_0187: Unknown result type (might be due to invalid IL or missing references)
			//IL_018e: Unknown result type (might be due to invalid IL or missing references)
			//IL_019e: Unknown result type (might be due to invalid IL or missing references)
			//IL_017e: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0211: Unknown result type (might be due to invalid IL or missing references)
			//IL_021a: Unknown result type (might be due to invalid IL or missing references)
			//IL_022a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0208: Unknown result type (might be due to invalid IL or missing references)
			//IL_023e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0247: Unknown result type (might be due to invalid IL or missing references)
			//IL_0257: Unknown result type (might be due to invalid IL or missing references)
			//IL_0235: Unknown result type (might be due to invalid IL or missing references)
			//IL_026b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0274: Unknown result type (might be due to invalid IL or missing references)
			//IL_0284: Unknown result type (might be due to invalid IL or missing references)
			//IL_0262: Unknown result type (might be due to invalid IL or missing references)
			//IL_0298: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_02af: Unknown result type (might be due to invalid IL or missing references)
			//IL_028f: Unknown result type (might be due to invalid IL or missing references)
			//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
			//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_02da: Unknown result type (might be due to invalid IL or missing references)
			//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e5: Unknown result type (might be due to invalid IL or missing references)
			if (!InWorld(x, y))
			{
				return;
			}
			ushort num = (ushort)wallType;
			int num2 = 0;
			int maxWallOut = maxWallOut2;
			List<Point> list = new List<Point>();
			List<Point> list2 = new List<Point>();
			HashSet<Point> hashSet = new HashSet<Point>();
			list2.Add(new Point(x, y));
			Point item2 = default(Point);
			while (list2.Count > 0)
			{
				list.Clear();
				list.AddRange(list2);
				list2.Clear();
				while (list.Count > 0)
				{
					Point item = list[0];
					if (!InWorld(item.X, item.Y, 1))
					{
						list.Remove(item);
						continue;
					}
					hashSet.Add(item);
					list.Remove(item);
					Tile tile = Main.tile[item.X, item.Y];
					if (tile.wall == num || WallID.Sets.CannotBeReplacedByWallSpread[tile.wall])
					{
						continue;
					}
					if (!SolidTile(item.X, item.Y))
					{
						bool flag = WallID.Sets.WallSpreadStopsAtAir[num];
						if (flag && tile.wall == 0)
						{
							list.Remove(item);
							continue;
						}
						num2++;
						if (num2 >= maxWallOut)
						{
							list.Remove(item);
							continue;
						}
						tile.wall = num;
						((Point)(ref item2))._002Ector(item.X - 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						((Point)(ref item2))._002Ector(item.X + 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						((Point)(ref item2))._002Ector(item.X, item.Y - 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						((Point)(ref item2))._002Ector(item.X, item.Y + 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						if (flag)
						{
							((Point)(ref item2))._002Ector(item.X - 1, item.Y - 1);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							((Point)(ref item2))._002Ector(item.X + 1, item.Y - 1);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							((Point)(ref item2))._002Ector(item.X - 1, item.Y + 1);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							((Point)(ref item2))._002Ector(item.X + 1, item.Y + 1);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							((Point)(ref item2))._002Ector(item.X - 2, item.Y);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							((Point)(ref item2))._002Ector(item.X + 2, item.Y);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
						}
					}
					else if (tile.active())
					{
						tile.wall = num;
					}
				}
			}
		}

		public static void Moss(int x, int y)
		{
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_0083: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0099: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_0114: Unknown result type (might be due to invalid IL or missing references)
			//IL_011d: Unknown result type (might be due to invalid IL or missing references)
			//IL_012b: Unknown result type (might be due to invalid IL or missing references)
			//IL_013e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0147: Unknown result type (might be due to invalid IL or missing references)
			//IL_0155: Unknown result type (might be due to invalid IL or missing references)
			//IL_0135: Unknown result type (might be due to invalid IL or missing references)
			//IL_0168: Unknown result type (might be due to invalid IL or missing references)
			//IL_016f: Unknown result type (might be due to invalid IL or missing references)
			//IL_017f: Unknown result type (might be due to invalid IL or missing references)
			//IL_015f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0192: Unknown result type (might be due to invalid IL or missing references)
			//IL_0199: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_0189: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
			if (!InWorld(x, y))
			{
				return;
			}
			ushort mossWall = GenVars.mossWall;
			ushort mossTile = GenVars.mossTile;
			List<Point> list = new List<Point>();
			List<Point> list2 = new List<Point>();
			HashSet<Point> hashSet = new HashSet<Point>();
			list2.Add(new Point(x, y));
			Point item2 = default(Point);
			while (list2.Count > 0)
			{
				list.Clear();
				list.AddRange(list2);
				list2.Clear();
				while (list.Count > 0)
				{
					Point item = list[0];
					if (!InWorld(item.X, item.Y, 1))
					{
						list.Remove(item);
						continue;
					}
					hashSet.Add(item);
					list.Remove(item);
					Tile tile = Main.tile[item.X, item.Y];
					if (SolidTile(item.X, item.Y) || tile.wall != 0)
					{
						if (tile.active())
						{
							if (tile.wall == 0)
							{
								tile.wall = mossWall;
							}
							if (tile.type == 1)
							{
								tile.type = mossTile;
							}
						}
						continue;
					}
					tile.wall = mossWall;
					((Point)(ref item2))._002Ector(item.X - 1, item.Y);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					((Point)(ref item2))._002Ector(item.X + 1, item.Y);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					((Point)(ref item2))._002Ector(item.X, item.Y - 1);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					((Point)(ref item2))._002Ector(item.X, item.Y + 1);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
				}
			}
		}

		public static void Gem(int x, int y)
		{
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			//IL_0079: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_0209: Unknown result type (might be due to invalid IL or missing references)
			//IL_0211: Unknown result type (might be due to invalid IL or missing references)
			//IL_021d: Unknown result type (might be due to invalid IL or missing references)
			//IL_011c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0124: Unknown result type (might be due to invalid IL or missing references)
			//IL_0230: Unknown result type (might be due to invalid IL or missing references)
			//IL_0238: Unknown result type (might be due to invalid IL or missing references)
			//IL_0244: Unknown result type (might be due to invalid IL or missing references)
			//IL_0227: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_0152: Unknown result type (might be due to invalid IL or missing references)
			//IL_0158: Unknown result type (might be due to invalid IL or missing references)
			//IL_0257: Unknown result type (might be due to invalid IL or missing references)
			//IL_025d: Unknown result type (might be due to invalid IL or missing references)
			//IL_026b: Unknown result type (might be due to invalid IL or missing references)
			//IL_024e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0188: Unknown result type (might be due to invalid IL or missing references)
			//IL_018e: Unknown result type (might be due to invalid IL or missing references)
			//IL_027e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0284: Unknown result type (might be due to invalid IL or missing references)
			//IL_0292: Unknown result type (might be due to invalid IL or missing references)
			//IL_0275: Unknown result type (might be due to invalid IL or missing references)
			//IL_029c: Unknown result type (might be due to invalid IL or missing references)
			if (!InWorld(x, y))
			{
				return;
			}
			List<Point> list = new List<Point>();
			List<Point> list2 = new List<Point>();
			HashSet<Point> hashSet = new HashSet<Point>();
			list2.Add(new Point(x, y));
			Point item2 = default(Point);
			while (list2.Count > 0)
			{
				list.Clear();
				list.AddRange(list2);
				list2.Clear();
				while (list.Count > 0)
				{
					Point item = list[0];
					if (!InWorld(item.X, item.Y, 1))
					{
						list.Remove(item);
						continue;
					}
					hashSet.Add(item);
					list.Remove(item);
					Tile tile = Main.tile[item.X, item.Y];
					if (SolidTile(item.X, item.Y) || tile.wall != 0)
					{
						if (tile.active())
						{
							if (Gemmable(tile.type))
							{
								tile.type = randGemTile();
							}
							Tile tile2 = Main.tile[item.X - 1, item.Y];
							if (Gemmable(tile2.type))
							{
								tile2.type = randGemTile();
							}
							tile2 = Main.tile[item.X + 1, item.Y];
							if (Gemmable(tile2.type))
							{
								tile2.type = randGemTile();
							}
							tile2 = Main.tile[item.X, item.Y - 1];
							if (Gemmable(tile2.type))
							{
								tile2.type = randGemTile();
							}
							tile2 = Main.tile[item.X, item.Y + 1];
							if (Gemmable(tile2.type))
							{
								tile2.type = randGemTile();
							}
						}
					}
					else
					{
						tile.wall = (ushort)(48 + randGem());
						if (!tile.active() && genRand.Next(2) == 0)
						{
							PlaceTile(item.X, item.Y, 178, mute: true, forced: false, -1, randGem());
						}
						((Point)(ref item2))._002Ector(item.X - 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						((Point)(ref item2))._002Ector(item.X + 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						((Point)(ref item2))._002Ector(item.X, item.Y - 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						((Point)(ref item2))._002Ector(item.X, item.Y + 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
					}
				}
			}
		}

		public static void Spider(int x, int y)
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_029b: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_0124: Unknown result type (might be due to invalid IL or missing references)
			//IL_012b: Unknown result type (might be due to invalid IL or missing references)
			//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_02da: Unknown result type (might be due to invalid IL or missing references)
			//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_02ed: Unknown result type (might be due to invalid IL or missing references)
			//IL_02f4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0303: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_0316: Unknown result type (might be due to invalid IL or missing references)
			//IL_031d: Unknown result type (might be due to invalid IL or missing references)
			//IL_032c: Unknown result type (might be due to invalid IL or missing references)
			//IL_030d: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
			//IL_0177: Unknown result type (might be due to invalid IL or missing references)
			//IL_017e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0157: Unknown result type (might be due to invalid IL or missing references)
			//IL_015e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0336: Unknown result type (might be due to invalid IL or missing references)
			//IL_0200: Unknown result type (might be due to invalid IL or missing references)
			//IL_0207: Unknown result type (might be due to invalid IL or missing references)
			//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0240: Unknown result type (might be due to invalid IL or missing references)
			//IL_0247: Unknown result type (might be due to invalid IL or missing references)
			//IL_0271: Unknown result type (might be due to invalid IL or missing references)
			//IL_0278: Unknown result type (might be due to invalid IL or missing references)
			if (!InWorld(x, y))
			{
				return;
			}
			byte wall = 62;
			List<Point> list = new List<Point>();
			List<Point> list2 = new List<Point>();
			HashSet<Point> hashSet = new HashSet<Point>();
			list2.Add(new Point(x, y));
			Point item2 = default(Point);
			while (list2.Count > 0)
			{
				list.Clear();
				list.AddRange(list2);
				list2.Clear();
				while (list.Count > 0)
				{
					Point item = list[0];
					if (!InWorld(item.X, item.Y, 1))
					{
						list.Remove(item);
						continue;
					}
					hashSet.Add(item);
					list.Remove(item);
					Tile tile = Main.tile[item.X, item.Y];
					if (SolidTile(item.X, item.Y) || tile.wall != 0)
					{
						if (tile.active() && tile.wall == 0)
						{
							tile.wall = wall;
						}
						continue;
					}
					tile.wall = wall;
					SquareWallFrame(item.X, item.Y);
					if (!tile.active())
					{
						tile.liquid = 0;
						tile.lava(lava: false);
						if (SolidTile(item.X, item.Y + 1) && genRand.Next(3) == 0)
						{
							if (genRand.Next(15) == 0)
							{
								AddBuriedChest(item.X, item.Y, 939, notNearOtherChests: true, 15, trySlope: false, 0);
							}
							else
							{
								PlacePot(item.X, item.Y, 28, genRand.Next(19, 21));
							}
						}
						if (!tile.active())
						{
							if (SolidTile(item.X, item.Y - 1) && genRand.Next(3) == 0)
							{
								PlaceTight(item.X, item.Y, spiders: true);
							}
							else if (SolidTile(item.X, item.Y + 1))
							{
								PlaceTile(item.X, item.Y, 187, mute: true, forced: false, -1, 9 + genRand.Next(5));
								if (genRand.Next(3) == 0)
								{
									if (!tile.active())
									{
										PlaceSmallPile(item.X, item.Y, 34 + genRand.Next(4), 1, 185);
									}
									if (!tile.active())
									{
										PlaceSmallPile(item.X, item.Y, 48 + genRand.Next(6), 0, 185);
									}
								}
							}
						}
					}
					((Point)(ref item2))._002Ector(item.X - 1, item.Y);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					((Point)(ref item2))._002Ector(item.X + 1, item.Y);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					((Point)(ref item2))._002Ector(item.X, item.Y - 1);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					((Point)(ref item2))._002Ector(item.X, item.Y + 1);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
				}
			}
		}

		public static void WallDungeon(int x, int y, int wallType)
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
			//IL_010b: Unknown result type (might be due to invalid IL or missing references)
			//IL_011e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0127: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_0115: Unknown result type (might be due to invalid IL or missing references)
			//IL_0147: Unknown result type (might be due to invalid IL or missing references)
			//IL_014e: Unknown result type (might be due to invalid IL or missing references)
			//IL_015d: Unknown result type (might be due to invalid IL or missing references)
			//IL_013e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0170: Unknown result type (might be due to invalid IL or missing references)
			//IL_0177: Unknown result type (might be due to invalid IL or missing references)
			//IL_0186: Unknown result type (might be due to invalid IL or missing references)
			//IL_0167: Unknown result type (might be due to invalid IL or missing references)
			//IL_0190: Unknown result type (might be due to invalid IL or missing references)
			if (!InWorld(x, y))
			{
				return;
			}
			ushort num = (ushort)wallType;
			List<Point> list = new List<Point>();
			List<Point> list2 = new List<Point>();
			HashSet<Point> hashSet = new HashSet<Point>();
			list2.Add(new Point(x, y));
			Point item2 = default(Point);
			while (list2.Count > 0)
			{
				list.Clear();
				list.AddRange(list2);
				list2.Clear();
				while (list.Count > 0)
				{
					Point item = list[0];
					if (!InWorld(item.X, item.Y, 1))
					{
						list.Remove(item);
						continue;
					}
					hashSet.Add(item);
					list.Remove(item);
					Tile tile = Main.tile[item.X, item.Y];
					if (!SolidTile(item.X, item.Y) && tile.wall != num && tile.wall > 0 && tile.wall != 244)
					{
						tile.wall = num;
						((Point)(ref item2))._002Ector(item.X - 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						((Point)(ref item2))._002Ector(item.X + 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						((Point)(ref item2))._002Ector(item.X, item.Y - 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						((Point)(ref item2))._002Ector(item.X, item.Y + 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
					}
					else if (tile.active())
					{
						tile.wall = num;
					}
				}
			}
		}

		private static bool Gemmable(int type)
		{
			if (type != 0 && type != 1 && type != 40 && type != 59 && type != 60 && type != 70 && type != 147)
			{
				return type == 161;
			}
			return true;
		}
	}

	public static class TenthAnniversaryWorldInfo
	{
		public static int[] GoodPrefixIdsForAccessory = new int[4] { 65, 68, 72, 76 };

		public static int[] GoodPrefixIdsForMeleeWeapon = new int[3] { 81, 59, 57 };

		public static int[] GoodPrefixIdsForRangedWeapon = new int[3] { 82, 57, 60 };

		public static int[] GoodPrefixIdsForMagicWeapon = new int[3] { 83, 57, 60 };

		public static int[] GoodPrefixIdsForSummonerWeapon = new int[3] { 83, 57, 60 };
	}

	public struct GrowTreeSettings
	{
		public delegate bool IsTileFitForTreeGroundTest(int tileType);

		public delegate bool IsWallTypeFitForTreeBack(int wallType);

		public static class Profiles
		{
			public static GrowTreeSettings GemTree_Ruby = new GrowTreeSettings
			{
				GroundTest = GemTreeGroundTest,
				WallTest = GemTreeWallTest,
				TreeHeightMax = 12,
				TreeHeightMin = 7,
				TreeTileType = 587,
				TreeTopPaddingNeeded = 4,
				SaplingTileType = 590
			};

			public static GrowTreeSettings GemTree_Diamond = new GrowTreeSettings
			{
				GroundTest = GemTreeGroundTest,
				WallTest = GemTreeWallTest,
				TreeHeightMax = 12,
				TreeHeightMin = 7,
				TreeTileType = 588,
				TreeTopPaddingNeeded = 4,
				SaplingTileType = 590
			};

			public static GrowTreeSettings GemTree_Topaz = new GrowTreeSettings
			{
				GroundTest = GemTreeGroundTest,
				WallTest = GemTreeWallTest,
				TreeHeightMax = 12,
				TreeHeightMin = 7,
				TreeTileType = 583,
				TreeTopPaddingNeeded = 4,
				SaplingTileType = 590
			};

			public static GrowTreeSettings GemTree_Amethyst = new GrowTreeSettings
			{
				GroundTest = GemTreeGroundTest,
				WallTest = GemTreeWallTest,
				TreeHeightMax = 12,
				TreeHeightMin = 7,
				TreeTileType = 584,
				TreeTopPaddingNeeded = 4,
				SaplingTileType = 590
			};

			public static GrowTreeSettings GemTree_Sappphire = new GrowTreeSettings
			{
				GroundTest = GemTreeGroundTest,
				WallTest = GemTreeWallTest,
				TreeHeightMax = 12,
				TreeHeightMin = 7,
				TreeTileType = 585,
				TreeTopPaddingNeeded = 4,
				SaplingTileType = 590
			};

			public static GrowTreeSettings GemTree_Emerald = new GrowTreeSettings
			{
				GroundTest = GemTreeGroundTest,
				WallTest = GemTreeWallTest,
				TreeHeightMax = 12,
				TreeHeightMin = 7,
				TreeTileType = 586,
				TreeTopPaddingNeeded = 4,
				SaplingTileType = 590
			};

			public static GrowTreeSettings GemTree_Amber = new GrowTreeSettings
			{
				GroundTest = GemTreeGroundTest,
				WallTest = GemTreeWallTest,
				TreeHeightMax = 12,
				TreeHeightMin = 7,
				TreeTileType = 589,
				TreeTopPaddingNeeded = 4,
				SaplingTileType = 590
			};

			public static GrowTreeSettings VanityTree_Sakura = new GrowTreeSettings
			{
				GroundTest = VanityTreeGroundTest,
				WallTest = DefaultTreeWallTest,
				TreeHeightMax = 12,
				TreeHeightMin = 7,
				TreeTileType = 596,
				TreeTopPaddingNeeded = 4,
				SaplingTileType = 595
			};

			public static GrowTreeSettings VanityTree_Willow = new GrowTreeSettings
			{
				GroundTest = VanityTreeGroundTest,
				WallTest = DefaultTreeWallTest,
				TreeHeightMax = 12,
				TreeHeightMin = 7,
				TreeTileType = 616,
				TreeTopPaddingNeeded = 4,
				SaplingTileType = 615
			};

			public static GrowTreeSettings Tree_Ash = new GrowTreeSettings
			{
				GroundTest = AshTreeGroundTest,
				WallTest = DefaultTreeWallTest,
				TreeHeightMax = 12,
				TreeHeightMin = 7,
				TreeTileType = 634,
				TreeTopPaddingNeeded = 4,
				SaplingTileType = 20
			};

			public static bool TryGetFromItemId(int itemType, out GrowTreeSettings profile)
			{
				switch (itemType)
				{
				default:
					profile = default(GrowTreeSettings);
					return false;
				case 4857:
					profile = GemTree_Amber;
					return true;
				case 4852:
					profile = GemTree_Amethyst;
					return true;
				case 4856:
					profile = GemTree_Diamond;
					return true;
				case 4854:
					profile = GemTree_Emerald;
					return true;
				case 4855:
					profile = GemTree_Ruby;
					return true;
				case 4853:
					profile = GemTree_Sappphire;
					return true;
				case 4851:
					profile = GemTree_Topaz;
					return true;
				case 4907:
					profile = VanityTree_Willow;
					return true;
				case 4871:
					profile = VanityTree_Sakura;
					return true;
				}
			}

			public static bool TryGetFromTreeId(int tileType, out GrowTreeSettings profile)
			{
				switch (tileType)
				{
				default:
					profile = default(GrowTreeSettings);
					return false;
				case 589:
					profile = GemTree_Amber;
					return true;
				case 584:
					profile = GemTree_Amethyst;
					return true;
				case 588:
					profile = GemTree_Diamond;
					return true;
				case 586:
					profile = GemTree_Emerald;
					return true;
				case 587:
					profile = GemTree_Ruby;
					return true;
				case 585:
					profile = GemTree_Sappphire;
					return true;
				case 583:
					profile = GemTree_Topaz;
					return true;
				case 616:
					profile = VanityTree_Willow;
					return true;
				case 596:
					profile = VanityTree_Sakura;
					return true;
				case 634:
					profile = Tree_Ash;
					return true;
				}
			}
		}

		public ushort TreeTileType;

		public int TreeHeightMin;

		public int TreeHeightMax;

		public int TreeTopPaddingNeeded;

		public IsTileFitForTreeGroundTest GroundTest;

		public IsWallTypeFitForTreeBack WallTest;

		public ushort SaplingTileType;
	}

	public struct CheckTreeSettings
	{
		public delegate bool GroundValidTest(int groundTileType);

		public GroundValidTest IsGroundValid;
	}

	public enum SpecialKillTileContext
	{
		None,
		MowingTheGrass
	}

	public delegate bool GetTreeFoliageDataMethod(int i, int j, int xoffset, ref int treeFrame, ref int treeStyle, out int floorY, out int topTextureFrameWidth, out int topTextureFrameHeight);

	public struct TileMergeCullCache
	{
		public bool CullTop;

		public bool CullBottom;

		public bool CullLeft;

		public bool CullRight;

		public bool CullTopLeft;

		public bool CullTopRight;

		public bool CullBottomLeft;

		public bool CullBottomRight;

		public void Cull(ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight)
		{
			if (CullTop)
			{
				up = -1;
			}
			if (CullBottom)
			{
				down = -1;
			}
			if (CullLeft)
			{
				left = -1;
			}
			if (CullRight)
			{
				right = -1;
			}
			if (CullTopLeft)
			{
				upLeft = -1;
			}
			if (CullTopRight)
			{
				upRight = -1;
			}
			if (CullBottomLeft)
			{
				downLeft = -1;
			}
			if (CullBottomRight)
			{
				downRight = -1;
			}
		}
	}

	public delegate void GenPassDetour(orig_GenPassDetour orig, object self, GenerationProgress progress, GameConfiguration configuration);

	public delegate void orig_GenPassDetour(object self, GenerationProgress progress, GameConfiguration configuration);

	public static TownRoomManager TownManager = new TownRoomManager();

	private static Queue<Action<StructureMap>> _postGenActions = new Queue<Action<StructureMap>>();

	public static int tileReframeCount;

	public static bool noMapUpdate;

	public static int treeBG1;

	public static int treeBG2;

	public static int treeBG3;

	public static int treeBG4;

	public static int corruptBG;

	public static int jungleBG;

	public static int snowBG;

	public static int hallowBG;

	public static int crimsonBG;

	public static int desertBG;

	public static int oceanBG;

	public static int mushroomBG;

	public static int underworldBG;

	public static readonly int oceanDistance = 250;

	public static readonly int beachDistance = 380;

	public static readonly int shimmerSafetyDistance = 150;

	public static bool crimson;

	public static int[] tileCounts = new int[TileID.Count];

	public static int totalEvil;

	public static int totalBlood;

	public static int totalGood;

	public static int totalSolid;

	public static int totalEvil2;

	public static int totalBlood2;

	public static int totalGood2;

	public static int totalSolid2;

	public static byte tEvil;

	public static byte tBlood;

	public static byte tGood;

	public static string currentWorldSeed;

	public static int totalX;

	public static int totalD;

	public static bool IsGeneratingHardMode;

	public static bool noTileActions;

	public static bool spawnEye;

	public static int spawnHardBoss;

	public static volatile bool gen;

	public static bool shadowOrbSmashed;

	public static int shadowOrbCount;

	public static int altarCount;

	public static bool spawnMeteor;

	public static bool loadFailed = false;

	public static bool loadSuccess = false;

	public static bool worldCleared;

	public static bool worldBackup;

	public static bool loadBackup = false;

	private static int lastMaxTilesX;

	private static int lastMaxTilesY;

	private static bool mergeUp;

	private static bool mergeDown;

	private static bool mergeLeft;

	private static bool mergeRight;

	private static bool stopDrops;

	public static bool noLiquidCheck;

	public static bool AllowedToSpreadInfections = true;

	[ThreadStatic]
	public static UnifiedRandom _genRand;

	[ThreadStatic]
	public static int _genRandSeed = -2;

	public static int _lastSeed;

	public static string statusText = "";

	public static bool destroyObject;

	public static int spawnDelay;

	public static int prioritizedTownNPCType;

	public static int numTileCount;

	public static int maxTileCount = 3500;

	public static int maxWallOut2 = 5000;

	public static Dictionary<Point, bool> CountedTiles = new Dictionary<Point, bool>(maxTileCount);

	public static int lavaCount;

	public static int iceCount;

	public static int sandCount;

	public static int rockCount;

	public static int shroomCount;

	public static int maxRoomTiles = 750;

	public static int numRoomTiles;

	public static int[] roomX = new int[maxRoomTiles];

	public static int[] roomY = new int[maxRoomTiles];

	public static int roomCeilingsCount;

	public static int[] roomCeilingX = new int[maxRoomTiles];

	public static int[] roomCeilingY = new int[maxRoomTiles];

	public static int roomX1;

	public static int roomX2;

	public static int roomY1;

	public static int roomY2;

	public static bool canSpawn;

	public static bool[] houseTile = new bool[TileID.Count];

	public static int bestX;

	public static int bestY;

	public static int hiScore;

	private static bool roomTorch;

	private static bool roomDoor;

	private static bool roomChair;

	private static bool roomTable;

	private static bool roomOccupied;

	private static bool roomEvil;

	private static bool roomHasStinkbug;

	private static bool roomHasEchoStinkbug;

	public static int WorldGenParam_Evil = -1;

	public static readonly int cactusWaterWidth = 50;

	public static readonly int cactusWaterHeight = 25;

	public static readonly int cactusWaterLimit = 25;

	public static MysticLogFairiesEvent mysticLogsEvent = new MysticLogFairiesEvent();

	private static bool currentlyTryingToUseAlternateHousingSpot;

	private static int sharedRoomX;

	public static TownNPCRoomCheckFailureReason roomCheckFailureReason = TownNPCRoomCheckFailureReason.None;

	public const int WorldSizeSmallX = 4200;

	public const int WorldSizeSmallY = 1200;

	public const int WorldSizeMediumX = 6400;

	public const int WorldSizeMediumY = 1800;

	public const int WorldSizeLargeX = 8400;

	public const int WorldSizeLargeY = 2400;

	public const int InfectionAndGrassSpreadOuterWorldBuffer = 10;

	public static bool generatingWorld = false;

	private static int[,] trapDiag = new int[4, 2];

	private static bool[] gem = new bool[6];

	private static int[] mossType = new int[3];

	private static ushort neonMossType;

	private static int tileCounterNum;

	private static int tileCounterMax = 20;

	private static int[] tileCounterX = new int[tileCounterMax];

	private static int[] tileCounterY = new int[tileCounterMax];

	private static WorldGenerator _generator;

	public static int SmallConsecutivesFound = 0;

	public static int SmallConsecutivesEliminated = 0;

	public static bool tempRemixWorldGen = false;

	public static bool remixWorldGen = false;

	public static bool everythingWorldGen = false;

	public static bool noTrapsWorldGen = false;

	public static bool drunkWorldGen = false;

	public static bool getGoodWorldGen = false;

	public static bool tempTenthAnniversaryWorldGen = false;

	public static bool tenthAnniversaryWorldGen = false;

	public static bool dontStarveWorldGen = false;

	public static bool notTheBees = false;

	public static bool drunkWorldGenText = false;

	public static bool placingTraps = false;

	public const bool USE_FRAMING_SKIP_FOR_UNIMPORTANT_TILES_IN_WORLDGEN = false;

	private const int ItemSpawnProtectionTime = 18000;

	private static List<Color> _coatingColors = new List<Color>();

	private static int catTailDistance = 8;

	public static TreeTopsInfo TreeTops = new TreeTopsInfo();

	public static BackgroundChangeFlashInfo BackgroundsCache = new BackgroundChangeFlashInfo();

	private static int maxTreeShakes = 500;

	private static int numTreeShakes = 0;

	private static int[] treeShakeX = new int[maxTreeShakes];

	private static int[] treeShakeY = new int[maxTreeShakes];

	private static bool fossilBreak = false;

	public static Queue<Point> ExploitDestroyQueue = new Queue<Point>();

	private static bool growGrassUnderground = false;

	public const bool BUBBLES_SOLID_STATE_FOR_HOUSING = true;

	public static int grassSpread;

	private static Point[] heartPos = (Point[])(object)new Point[100];

	private static int heartCount;

	private const int strip_w = 200;

	private const int strip_h = 50;

	private static readonly Vertical64BitStrips bitStrip = new Vertical64BitStrips(202);

	public static bool noMapUpdateRefresh = false;

	private static bool skipFramingDuringGen = false;

	internal static Dictionary<string, GenPass> _vanillaGenPasses = new Dictionary<string, GenPass>();

	public static UnifiedRandom genRand
	{
		get
		{
			if (_lastSeed != _genRandSeed)
			{
				_genRand = new UnifiedRandom(_lastSeed);
				_genRandSeed = _lastSeed;
			}
			if (_genRand == null)
			{
				_genRand = new UnifiedRandom(_lastSeed);
				_genRandSeed = _lastSeed;
			}
			return _genRand;
		}
	}

	public static double oceanLevel => (Main.worldSurface + Main.rockLayer) / 2.0 + 40.0;

	public static bool SkipFramingBecauseOfGen
	{
		get
		{
			if (generatingWorld)
			{
				return skipFramingDuringGen;
			}
			return false;
		}
	}

	public static IReadOnlyDictionary<string, GenPass> VanillaGenPasses => _vanillaGenPasses;

	public static void SetupStatueList()
	{
		List<Point16> list = new List<Point16>();
		for (int i = 0; i < 44; i++)
		{
			list.Add(new Point16(105, i));
		}
		list[34] = new Point16(349, 0);
		list[43] = new Point16(105, 50);
		list.Add(new Point16(105, 63));
		list.Add(new Point16(105, 64));
		list.Add(new Point16(105, 65));
		list.Add(new Point16(105, 66));
		list.Add(new Point16(105, 68));
		list.Add(new Point16(105, 69));
		list.Add(new Point16(105, 70));
		list.Add(new Point16(105, 71));
		list.Add(new Point16(105, 72));
		list.Add(new Point16(105, 73));
		list.Add(new Point16(105, 75));
		list.Add(new Point16(105, 51));
		list.Add(new Point16(105, 52));
		list.Add(new Point16(105, 53));
		list.Add(new Point16(105, 54));
		list.Add(new Point16(105, 55));
		list.Add(new Point16(105, 56));
		list.Add(new Point16(105, 57));
		list.Add(new Point16(105, 58));
		list.Add(new Point16(105, 59));
		list.Add(new Point16(105, 60));
		list.Add(new Point16(105, 61));
		list.Add(new Point16(105, 62));
		list.Add(new Point16(105, 77));
		list.Add(new Point16(105, 78));
		list.Add(new Point16(105, 67));
		list.Add(new Point16(105, 74));
		list.Add(new Point16(105, 37));
		list.Add(new Point16(105, 2));
		GenVars.statueList = list.ToArray();
	}

	public static void PlaceStatueTrap(int x, int y)
	{
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		for (int i = -10; i <= 10; i++)
		{
			for (int j = -10; j <= 10; j++)
			{
				Tile tile = Main.tile[x + i, y + j + 1];
				Tile tile2 = Main.tile[x + i, y + j];
				if (!tile2.active() && SolidTile2(tile) && tile.type != 162)
				{
					PlaceTile(x + i, y + j, 135, mute: true);
					if (tile2.active() && tile2.type == 135)
					{
						WorldUtils.WireLine(new Point(x, y), new Point(x + i, y + j));
						return;
					}
				}
			}
		}
	}

	private static EntitySource_TileBreak GetProjectileSource_TileBreak(int x, int y)
	{
		return new EntitySource_TileBreak(x, y);
	}

	private static EntitySource_TileBreak GetNPCSource_TileBreak(int x, int y)
	{
		return new EntitySource_TileBreak(x, y);
	}

	public static EntitySource_ShakeTree GetNPCSource_ShakeTree(int x, int y)
	{
		return new EntitySource_ShakeTree(x, y);
	}

	private static EntitySource_ShakeTree GetProjectileSource_ShakeTree(int x, int y)
	{
		return new EntitySource_ShakeTree(x, y);
	}

	private static EntitySource_ShakeTree GetItemSource_ShakeTree(int x, int y)
	{
		return new EntitySource_ShakeTree(x, y);
	}

	private static IEntitySource GetProjectileSource_PlayerOrWires(int x, int y, bool fromWiring, Player player)
	{
		if (fromWiring)
		{
			return new EntitySource_Wiring(x, y);
		}
		return new EntitySource_TileInteraction(player, x, y);
	}

	public static bool EmptyLiquid(int x, int y)
	{
		if (!InWorld(x, y))
		{
			return false;
		}
		Tile tile = Main.tile[x, y];
		if (tile == null)
		{
			return false;
		}
		tile.liquidType();
		if (tile.nactive() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type])
		{
			return false;
		}
		tile.Clear(TileDataType.Liquid);
		SquareTileFrame(x, y, resetFrame: false);
		if (Main.netMode != 0)
		{
			NetMessage.sendWater(x, y);
		}
		else
		{
			Liquid.AddWater(x, y);
		}
		return true;
	}

	public static bool PlaceLiquid(int x, int y, byte liquidType, byte amount)
	{
		if (!InWorld(x, y))
		{
			return false;
		}
		Tile tile = Main.tile[x, y];
		if (tile == null)
		{
			return false;
		}
		byte b = tile.liquidType();
		if (tile.nactive() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type])
		{
			return false;
		}
		if (tile.liquid == 0 || liquidType == b)
		{
			tile.liquidType(liquidType);
			if (amount + tile.liquid > 255)
			{
				amount = (byte)(255 - tile.liquid);
			}
			tile.liquid += amount;
			SquareTileFrame(x, y);
			if (Main.netMode != 0)
			{
				NetMessage.sendWater(x, y);
			}
			return true;
		}
		int liquidMergeTileType = 0;
		bool waterNearby = b == 0;
		bool lavaNearby = b == 1;
		bool honeyNearby = b == 2;
		bool shimmerNearby = b == 3;
		int liquidMergeType = 0;
		Liquid.GetLiquidMergeTypes(liquidType, out liquidMergeTileType, out liquidMergeType, waterNearby, lavaNearby, honeyNearby, shimmerNearby);
		if (liquidMergeTileType != 0)
		{
			tile.liquid = 0;
			tile.liquidType(0);
			PlaceTile(x, y, liquidMergeTileType, mute: true);
			SquareTileFrame(x, y);
			if (Main.netMode != 0)
			{
				NetMessage.SendTileSquare(-1, x - 1, y - 1, GetLiquidChangeType(liquidType, b));
			}
			return true;
		}
		return false;
	}

	public static void PlayLiquidChangeSound(TileChangeType eventType, int x, int y, int count = 1)
	{
		switch (eventType)
		{
		case TileChangeType.LavaWater:
			SoundEngine.PlaySound(SoundID.LiquidsWaterLava, x * 16 + count * 8, y * 16 + count * 8);
			break;
		case TileChangeType.HoneyWater:
			SoundEngine.PlaySound(SoundID.LiquidsHoneyWater, x * 16 + count * 8, y * 16 + count * 8);
			break;
		case TileChangeType.HoneyLava:
			SoundEngine.PlaySound(SoundID.LiquidsHoneyLava, x * 16 + count * 8, y * 16 + count * 8);
			break;
		case TileChangeType.ShimmerWater:
			SoundEngine.PlaySound(19, x * 16 + count * 8, y * 16 + count * 8, 4);
			break;
		case TileChangeType.ShimmerLava:
			SoundEngine.PlaySound(19, x * 16 + count * 8, y * 16 + count * 8, 4);
			break;
		case TileChangeType.ShimmerHoney:
			SoundEngine.PlaySound(19, x * 16 + count * 8, y * 16 + count * 8, 4);
			break;
		}
	}

	public static TileChangeType GetLiquidChangeType(int liquidType, int otherLiquidType)
	{
		if ((liquidType == 0 && otherLiquidType == 1) || (liquidType == 1 && otherLiquidType == 0))
		{
			return TileChangeType.LavaWater;
		}
		if ((liquidType == 0 && otherLiquidType == 2) || (liquidType == 2 && otherLiquidType == 0))
		{
			return TileChangeType.HoneyWater;
		}
		if ((liquidType == 1 && otherLiquidType == 2) || (liquidType == 2 && otherLiquidType == 1))
		{
			return TileChangeType.HoneyLava;
		}
		if ((liquidType == 0 && otherLiquidType == 3) || (liquidType == 3 && otherLiquidType == 0))
		{
			return TileChangeType.ShimmerWater;
		}
		if ((liquidType == 1 && otherLiquidType == 3) || (liquidType == 3 && otherLiquidType == 1))
		{
			return TileChangeType.ShimmerLava;
		}
		if ((liquidType == 2 && otherLiquidType == 3) || (liquidType == 3 && otherLiquidType == 2))
		{
			return TileChangeType.ShimmerHoney;
		}
		return TileChangeType.None;
	}

	public static bool MoveTownNPC(int x, int y, int n)
	{
		if (!StartRoomCheck(x, y))
		{
			string newText = Lang.inter[40].Value;
			switch (roomCheckFailureReason)
			{
			case TownNPCRoomCheckFailureReason.HoleInWallIsTooBig:
				newText = Language.GetTextValue("TownNPCHousingFailureReasons.HoleInWallIsTooBig");
				break;
			case TownNPCRoomCheckFailureReason.RoomCheckStartedInASolidTile:
				newText = Language.GetTextValue("TownNPCHousingFailureReasons.RoomCheckStartedInASolidTile");
				break;
			case TownNPCRoomCheckFailureReason.RoomIsTooBig:
				newText = Language.GetTextValue("TownNPCHousingFailureReasons.RoomIsTooBig");
				break;
			case TownNPCRoomCheckFailureReason.RoomIsTooSmall:
				newText = Language.GetTextValue("TownNPCHousingFailureReasons.RoomIsTooSmall");
				break;
			case TownNPCRoomCheckFailureReason.TooCloseToWorldEdge:
				newText = Language.GetTextValue("TownNPCHousingFailureReasons.TooCloseToWorldEdge");
				break;
			}
			Main.NewText(newText, byte.MaxValue, 240, 20);
			return false;
		}
		if (!RoomNeeds(prioritizedTownNPCType))
		{
			int num = 0;
			int num2 = ((!roomTorch) ? 1 : 0) + ((!roomDoor) ? 1 : 0) + ((!roomTable) ? 1 : 0) + ((!roomChair) ? 1 : 0);
			string[] array = new string[num2];
			if (!roomTorch)
			{
				array[num] = Language.GetTextValue("Game.HouseLightSource");
				num++;
			}
			if (!roomDoor)
			{
				array[num] = Language.GetTextValue("Game.HouseDoor");
				num++;
			}
			if (!roomTable)
			{
				array[num] = Language.GetTextValue("Game.HouseTable");
				num++;
			}
			if (!roomChair)
			{
				array[num] = Language.GetTextValue("Game.HouseChair");
				num++;
			}
			string key = "Game.HouseMissing_" + num2;
			object[] array2 = array;
			object[] args = array2;
			Main.NewText(Language.GetTextValue(key, args), byte.MaxValue, 240, 20);
			return false;
		}
		int type = prioritizedTownNPCType;
		if (n >= 0)
		{
			type = Main.npc[n].type;
		}
		bool flag = NPCID.Sets.IsTownPet[type];
		if (roomHasStinkbug && !flag)
		{
			Main.NewText(Language.GetTextValue("TownNPCHousingFailureReasons.RoomHasAStinkbug"), byte.MaxValue, 240, 20);
			return false;
		}
		if (roomHasEchoStinkbug && !flag)
		{
			Main.NewText(Language.GetTextValue("TownNPCHousingFailureReasons.RoomHasAnEchoStinkbug"), byte.MaxValue, 240, 20);
			return false;
		}
		ScoreRoom(-1, type);
		if (hiScore <= 0)
		{
			if (roomOccupied)
			{
				Main.NewText(Lang.inter[41].Value, byte.MaxValue, 240, 20);
			}
			else if (roomEvil)
			{
				Main.NewText(Lang.inter[42].Value, byte.MaxValue, 240, 20);
			}
			else
			{
				Main.NewText(Lang.inter[40].Value, byte.MaxValue, 240, 20);
			}
			return false;
		}
		if (n >= 0 && !CheckSpecialTownNPCSpawningConditions(Main.npc[n].type))
		{
			Main.NewText(Lang.inter[55].Value + " " + Main.npc[n].TypeName, byte.MaxValue, 240, 20);
			return false;
		}
		return true;
	}

	public static void moveRoom(int x, int y, int n)
	{
		if (Main.netMode == 1)
		{
			NetMessage.SendData(60, -1, -1, null, n, x, y);
			return;
		}
		prioritizedTownNPCType = Main.npc[n].type;
		Main.npc[n].homeless = true;
		SpawnTownNPC(x, y);
		TownManager.SetRoom(Main.npc[n].type, Main.npc[n].homeTileX, Main.npc[n].homeTileY);
	}

	public static bool IsNPCEvictable(int n)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		if (n < 0)
		{
			return false;
		}
		Rectangle hitbox = Main.LocalPlayer.Hitbox;
		((Rectangle)(ref hitbox)).Inflate(Main.LogicCheckScreenWidth / 2, Main.LogicCheckScreenHeight / 2);
		NPC nPC = Main.npc[n];
		Rectangle value = default(Rectangle);
		((Rectangle)(ref value))._002Ector(nPC.homeTileX * 16, nPC.homeTileY * 16, 16, 16);
		return ((Rectangle)(ref hitbox)).Intersects(value);
	}

	public static void kickOut(int n)
	{
		if (Main.netMode == 1)
		{
			NetMessage.SendData(60, -1, -1, null, n, 0f, 0f, 1f);
			return;
		}
		Main.npc[n].homeless = true;
		TownManager.KickOut(Main.npc[n]);
	}

	public static bool IsThereASpawnablePrioritizedTownNPC(int x, int y, ref bool canSpawnNewTownNPC)
	{
		if (CheckSpecialTownNPCSpawningConditions(prioritizedTownNPCType) && NPC.AnyNPCs(prioritizedTownNPCType))
		{
			canSpawnNewTownNPC = false;
			return true;
		}
		List<int> list = new List<int>();
		TownManager.AddOccupantsToList(x, y, list);
		for (int i = 0; i < list.Count; i++)
		{
			int num = list[i];
			if (Main.townNPCCanSpawn[num] && !NPC.AnyNPCs(num) && CheckSpecialTownNPCSpawningConditions(num))
			{
				prioritizedTownNPCType = num;
				canSpawnNewTownNPC = true;
				return true;
			}
		}
		for (int j = 0; j < NPCLoader.NPCCount; j++)
		{
			if (!Main.townNPCCanSpawn[j] || !CheckSpecialTownNPCSpawningConditions(j))
			{
				continue;
			}
			if (NPC.AnyNPCs(j))
			{
				Main.townNPCCanSpawn[j] = false;
				continue;
			}
			if (TownManager.HasRoomQuick(j))
			{
				prioritizedTownNPCType = j;
				canSpawnNewTownNPC = true;
				return true;
			}
			if (!NPCID.Sets.IsTownPet[prioritizedTownNPCType] || NPCID.Sets.IsTownPet[j])
			{
				prioritizedTownNPCType = j;
				canSpawnNewTownNPC = true;
				return true;
			}
		}
		return false;
	}

	public static bool IsThereASpawnablePrioritizedTownNPC_Old(int x, int y)
	{
		if (CheckSpecialTownNPCSpawningConditions(prioritizedTownNPCType) && NPC.AnyNPCs(prioritizedTownNPCType))
		{
			return true;
		}
		List<int> list = new List<int>();
		TownManager.AddOccupantsToList(x, y, list);
		for (int i = 0; i < list.Count; i++)
		{
			int num = list[i];
			if (Main.townNPCCanSpawn[num] && !NPC.AnyNPCs(num) && CheckSpecialTownNPCSpawningConditions(num))
			{
				prioritizedTownNPCType = num;
				return true;
			}
		}
		int num2 = -1;
		for (int j = 0; j < Main.townNPCCanSpawn.Length; j++)
		{
			if (!Main.townNPCCanSpawn[j] || !CheckSpecialTownNPCSpawningConditions(j))
			{
				continue;
			}
			if (NPC.AnyNPCs(j))
			{
				Main.townNPCCanSpawn[j] = false;
			}
			else if (TownManager.HasRoomQuick(j))
			{
				if (num2 == -1)
				{
					num2 = j;
				}
			}
			else if (!NPCID.Sets.IsTownPet[prioritizedTownNPCType] || NPCID.Sets.IsTownPet[j])
			{
				prioritizedTownNPCType = j;
				return true;
			}
		}
		if (num2 != -1)
		{
			prioritizedTownNPCType = num2;
			return true;
		}
		return false;
	}

	public static bool CheckSpecialTownNPCSpawningConditions(int type)
	{
		if (!NPCLoader.CheckConditions(type))
		{
			return false;
		}
		if (type == 160)
		{
			if (!NPC.unlockedTruffleSpawn && (double)roomY2 > Main.worldSurface)
			{
				return false;
			}
			Housing_GetTestedRoomBounds(out var startX, out var endX, out var startY, out var endY);
			int num = 0;
			for (int i = startX + 1; i < endX; i++)
			{
				for (int j = startY + 2; j < endY + 2; j++)
				{
					Tile tile = Main.tile[i, j];
					if (tile.active() && (tile.type == 70 || tile.type == 71 || tile.type == 72 || tile.type == 528))
					{
						num++;
					}
				}
			}
			if (num >= SceneMetrics.MushroomTileThreshold)
			{
				return true;
			}
			return false;
		}
		return true;
	}

	public static void UnspawnTravelNPC()
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		int num = -1;
		for (int i = 0; i < 200; i++)
		{
			if (Main.npc[i].active && Main.npc[i].type == 368)
			{
				num = i;
				break;
			}
		}
		if (num < 0)
		{
			return;
		}
		int num2 = (int)(Main.npc[num].Center.X / 16f);
		int num3 = (int)(Main.npc[num].Center.Y / 16f);
		bool flag = true;
		Rectangle value = default(Rectangle);
		((Rectangle)(ref value))._002Ector(num2 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num3 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
		for (int j = 0; j < 255; j++)
		{
			if (Main.player[j].active)
			{
				Rectangle val = new Rectangle((int)Main.player[j].position.X, (int)Main.player[j].position.Y, Main.player[j].width, Main.player[j].height);
				if (((Rectangle)(ref val)).Intersects(value))
				{
					flag = false;
					break;
				}
			}
		}
		if (flag)
		{
			string fullName = Main.npc[num].FullName;
			if (Main.netMode == 0)
			{
				Main.NewText(Lang.misc[35].Format(fullName), 50, 125);
			}
			else if (Main.netMode == 2)
			{
				ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[35].Key, Main.npc[num].GetFullNetName()), new Color(50, 125, 255));
			}
			Main.npc[num].active = false;
			Main.npc[num].netSkip = -1;
			Main.npc[num].life = 0;
			NetMessage.SendData(23, -1, -1, null, num);
		}
	}

	public static void SpawnTravelNPC()
	{
		//IL_07cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0665: Unknown result type (might be due to invalid IL or missing references)
		//IL_066a: Unknown result type (might be due to invalid IL or missing references)
		//IL_066e: Unknown result type (might be due to invalid IL or missing references)
		if (Main.eclipse || !Main.dayTime || (Main.invasionType > 0 && Main.invasionDelay == 0 && Main.invasionSize > 0))
		{
			return;
		}
		for (int i = 0; i < 200; i++)
		{
			if (Main.npc[i].active && Main.npc[i].type == 368)
			{
				return;
			}
		}
		Chest.SetupTravelShop();
		NetMessage.SendTravelShop(-1);
		int num = 0;
		int[] array = new int[200];
		int num6 = 0;
		for (int j = 0; j < 200; j++)
		{
			if (Main.npc[j].active && Main.npc[j].townNPC && Main.npc[j].type != 37 && !Main.npc[j].homeless)
			{
				array[num6] = j;
				num6++;
			}
		}
		if (num6 == 0)
		{
			return;
		}
		num = array[Main.rand.Next(num6)];
		bestX = Main.npc[num].homeTileX;
		bestY = Main.npc[num].homeTileY;
		int minValue = bestX;
		int num7 = bestX;
		int num8 = bestY;
		int num9 = bestX;
		while (num9 > bestX - 10 && (SolidTile(num9, num8) || Main.tileSolidTop[Main.tile[num9, num8].type]) && (!Main.tile[num9, num8 - 1].active() || !Main.tileSolid[Main.tile[num9, num8 - 1].type] || Main.tileSolidTop[Main.tile[num9, num8 - 1].type]) && (!Main.tile[num9, num8 - 2].active() || !Main.tileSolid[Main.tile[num9, num8 - 2].type] || Main.tileSolidTop[Main.tile[num9, num8 - 2].type]) && (!Main.tile[num9, num8 - 3].active() || !Main.tileSolid[Main.tile[num9, num8 - 3].type] || Main.tileSolidTop[Main.tile[num9, num8 - 3].type]))
		{
			minValue = num9;
			num9--;
		}
		for (int k = bestX; k < bestX + 10 && (SolidTile(k, num8) || Main.tileSolidTop[Main.tile[k, num8].type]) && (!Main.tile[k, num8 - 1].active() || !Main.tileSolid[Main.tile[k, num8 - 1].type] || Main.tileSolidTop[Main.tile[k, num8 - 1].type]) && (!Main.tile[k, num8 - 2].active() || !Main.tileSolid[Main.tile[k, num8 - 2].type] || Main.tileSolidTop[Main.tile[k, num8 - 2].type]) && (!Main.tile[k, num8 - 3].active() || !Main.tileSolid[Main.tile[k, num8 - 3].type] || Main.tileSolidTop[Main.tile[k, num8 - 3].type]); k++)
		{
			num7 = k;
		}
		for (int l = 0; l < 30; l++)
		{
			int num10 = Main.rand.Next(minValue, num7 + 1);
			if (l < 20)
			{
				if (num10 < bestX - 1 || num10 > bestX + 1)
				{
					bestX = num10;
					break;
				}
			}
			else if (num10 != bestX)
			{
				bestX = num10;
				break;
			}
		}
		int num11 = bestX;
		int num12 = bestY;
		bool flag = false;
		if (!flag && !((double)num12 > Main.worldSurface))
		{
			Rectangle value = default(Rectangle);
			for (int m = 20; m < 500; m++)
			{
				for (int n = 0; n < 2; n++)
				{
					num11 = ((n != 0) ? (bestX - m * 2) : (bestX + m * 2));
					if (num11 > 10 && num11 < Main.maxTilesX - 10)
					{
						int num13 = bestY - m;
						double num2 = bestY + m;
						if (num13 < 10)
						{
							num13 = 10;
						}
						if (num2 > Main.worldSurface)
						{
							num2 = Main.worldSurface;
						}
						for (int num3 = num13; (double)num3 < num2; num3++)
						{
							num12 = num3;
							if (!Main.tile[num11, num12].nactive() || !Main.tileSolid[Main.tile[num11, num12].type])
							{
								continue;
							}
							if (Main.tile[num11, num12 - 3].liquid != 0 || Main.tile[num11, num12 - 2].liquid != 0 || Main.tile[num11, num12 - 1].liquid != 0 || Collision.SolidTiles(num11 - 1, num11 + 1, num12 - 3, num12 - 1))
							{
								break;
							}
							flag = true;
							((Rectangle)(ref value))._002Ector(num11 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num12 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
							for (int num4 = 0; num4 < 255; num4++)
							{
								if (Main.player[num4].active)
								{
									Rectangle val = new Rectangle((int)Main.player[num4].position.X, (int)Main.player[num4].position.Y, Main.player[num4].width, Main.player[num4].height);
									if (((Rectangle)(ref val)).Intersects(value))
									{
										flag = false;
										break;
									}
								}
							}
							break;
						}
					}
					if (flag)
					{
						break;
					}
				}
				if (flag)
				{
					break;
				}
			}
		}
		int num5 = NPC.NewNPC(NPC.GetSpawnSourceForTownSpawn(), num11 * 16, num12 * 16, 368, 1);
		Main.npc[num5].homeTileX = bestX;
		Main.npc[num5].homeTileY = bestY;
		Main.npc[num5].homeless = true;
		if (num11 < bestX)
		{
			Main.npc[num5].direction = 1;
		}
		else if (num11 > bestX)
		{
			Main.npc[num5].direction = -1;
		}
		Main.npc[num5].netUpdate = true;
		string fullName = Main.npc[num5].FullName;
		if (Main.netMode == 0)
		{
			Main.NewText(Language.GetTextValue("Announcement.HasArrived", fullName), 50, 125);
		}
		else if (Main.netMode == 2)
		{
			ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasArrived", Main.npc[num5].GetFullNetName()), new Color(50, 125, 255));
		}
	}

	public static TownNPCSpawnResult SpawnTownNPC(int x, int y)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0558: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0403: Unknown result type (might be due to invalid IL or missing references)
		if (Main.wallHouse[Main.tile[x, y].wall])
		{
			canSpawn = true;
		}
		if (!canSpawn)
		{
			return TownNPCSpawnResult.Blocked;
		}
		if (!StartRoomCheck(x, y))
		{
			return TownNPCSpawnResult.Blocked;
		}
		if (!RoomNeeds(prioritizedTownNPCType))
		{
			return TownNPCSpawnResult.Blocked;
		}
		int num = FindAHomelessNPC();
		int type = prioritizedTownNPCType;
		if (num != -1)
		{
			type = Main.npc[num].type;
		}
		Point roomPosition = Point.Zero;
		bool flag = NPCID.Sets.IsTownPet[type] && TownManager.HasRoom(type, out roomPosition);
		if ((roomHasStinkbug || roomHasEchoStinkbug) && !flag)
		{
			return TownNPCSpawnResult.Blocked;
		}
		ScoreRoom(-1, type);
		if (hiScore <= 0)
		{
			return TownNPCSpawnResult.Blocked;
		}
		bool canSpawnNewTownNPC = true;
		if (!IsThereASpawnablePrioritizedTownNPC(bestX, bestY, ref canSpawnNewTownNPC))
		{
			return TownNPCSpawnResult.Blocked;
		}
		type = prioritizedTownNPCType;
		if (num != -1)
		{
			Main.townNPCCanSpawn[prioritizedTownNPCType] = false;
			Main.npc[num].homeTileX = bestX;
			Main.npc[num].homeTileY = bestY;
			Main.npc[num].homeless = false;
			AchievementsHelper.NotifyProgressionEvent(8);
			prioritizedTownNPCType = 0;
			return TownNPCSpawnResult.RelocatedHomeless;
		}
		if (canSpawnNewTownNPC && num == -1)
		{
			if (TownManager.HasRoom(type, out var roomPosition2) && !currentlyTryingToUseAlternateHousingSpot)
			{
				int num8 = bestX;
				int num2 = bestY;
				currentlyTryingToUseAlternateHousingSpot = true;
				TownNPCSpawnResult townNPCSpawnResult = SpawnTownNPC(roomPosition2.X, roomPosition2.Y - 2);
				currentlyTryingToUseAlternateHousingSpot = false;
				bestX = num8;
				bestY = num2;
				if (townNPCSpawnResult == TownNPCSpawnResult.Successful)
				{
					return townNPCSpawnResult;
				}
			}
			int num3 = bestX;
			int num4 = bestY;
			int npcTypeToSpawn = prioritizedTownNPCType;
			if (IsRoomConsideredAlreadyOccupied(num3, num4, npcTypeToSpawn))
			{
				return TownNPCSpawnResult.BlockedInfiHousing;
			}
			bool flag2 = false;
			Rectangle val;
			if (!flag2)
			{
				flag2 = true;
				Rectangle value = default(Rectangle);
				((Rectangle)(ref value))._002Ector(num3 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num4 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
				for (int i = 0; i < 255; i++)
				{
					if (Main.player[i].active)
					{
						val = new Rectangle((int)Main.player[i].position.X, (int)Main.player[i].position.Y, Main.player[i].width, Main.player[i].height);
						if (((Rectangle)(ref val)).Intersects(value))
						{
							flag2 = false;
							break;
						}
					}
				}
			}
			if (!flag2 && !((double)num4 > Main.worldSurface))
			{
				Rectangle value2 = default(Rectangle);
				for (int j = 1; j < 500; j++)
				{
					for (int k = 0; k < 2; k++)
					{
						num3 = ((k != 0) ? (bestX - j) : (bestX + j));
						if (num3 > 10 && num3 < Main.maxTilesX - 10)
						{
							int num5 = bestY - j;
							double num6 = bestY + j;
							if (num5 < 10)
							{
								num5 = 10;
							}
							if (num6 > Main.worldSurface)
							{
								num6 = Main.worldSurface;
							}
							for (int l = num5; (double)l < num6; l++)
							{
								num4 = l;
								if (!Main.tile[num3, num4].nactive() || !Main.tileSolid[Main.tile[num3, num4].type])
								{
									continue;
								}
								if (Collision.SolidTiles(num3 - 1, num3 + 1, num4 - 3, num4 - 1))
								{
									break;
								}
								flag2 = true;
								((Rectangle)(ref value2))._002Ector(num3 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num4 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
								for (int m = 0; m < 255; m++)
								{
									if (Main.player[m].active)
									{
										val = new Rectangle((int)Main.player[m].position.X, (int)Main.player[m].position.Y, Main.player[m].width, Main.player[m].height);
										if (((Rectangle)(ref val)).Intersects(value2))
										{
											flag2 = false;
											break;
										}
									}
								}
								break;
							}
						}
						if (flag2)
						{
							break;
						}
					}
					if (flag2)
					{
						break;
					}
				}
			}
			int num7 = NPC.NewNPC(NPC.GetSpawnSourceForTownSpawn(), num3 * 16, num4 * 16, type, 1);
			Main.townNPCCanSpawn[type] = false;
			Main.npc[num7].homeTileX = bestX;
			Main.npc[num7].homeTileY = bestY;
			if (num3 < bestX)
			{
				Main.npc[num7].direction = 1;
			}
			else if (num3 > bestX)
			{
				Main.npc[num7].direction = -1;
			}
			Main.npc[num7].netUpdate = true;
			string fullName = Main.npc[num7].FullName;
			if (Main.netMode == 0)
			{
				Main.NewText(Language.GetTextValue("Announcement.HasArrived", fullName), 50, 125);
			}
			else if (Main.netMode == 2)
			{
				ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasArrived", Main.npc[num7].GetFullNetName()), new Color(50, 125, 255));
			}
			AchievementsHelper.NotifyProgressionEvent(8);
			switch (Main.npc[num7].type)
			{
			case 160:
				AchievementsHelper.NotifyProgressionEvent(18);
				NPC.unlockedTruffleSpawn = true;
				NetMessage.SendData(7);
				break;
			case 17:
				NPC.unlockedMerchantSpawn = true;
				break;
			case 207:
				NPC.unlockedDyeTraderSpawn = true;
				break;
			case 18:
				NPC.unlockedNurseSpawn = true;
				break;
			case 19:
				NPC.unlockedArmsDealerSpawn = true;
				break;
			case 38:
				NPC.unlockedDemolitionistSpawn = true;
				break;
			case 208:
				NPC.unlockedPartyGirlSpawn = true;
				break;
			case 663:
				NPC.unlockedPrincessSpawn = true;
				break;
			case 678:
				NPC.unlockedSlimeGreenSpawn = true;
				break;
			}
			CheckAchievement_RealEstateAndTownSlimes();
			prioritizedTownNPCType = 0;
		}
		return TownNPCSpawnResult.Successful;
	}

	private static int FindAHomelessNPC()
	{
		int result = -1;
		for (int i = 0; i < 200; i++)
		{
			if (Main.npc[i].active && Main.npc[i].homeless && Main.npc[i].type == prioritizedTownNPCType && CheckSpecialTownNPCSpawningConditions(Main.npc[i].type))
			{
				result = i;
				break;
			}
		}
		return result;
	}

	private static bool IsRoomConsideredAlreadyOccupied(int spawnTileX, int spawnTileY, int npcTypeToSpawn)
	{
		bool result = false;
		for (int i = 0; i < 200; i++)
		{
			NPC nPC = Main.npc[i];
			if (nPC.active && nPC.townNPC && !nPC.homeless && nPC.homeTileX == spawnTileX && nPC.homeTileY == spawnTileY && !TownManager.CanNPCsLiveWithEachOther(npcTypeToSpawn, nPC))
			{
				result = true;
				break;
			}
		}
		return result;
	}

	public static void CheckAchievement_RealEstateAndTownSlimes()
	{
		bool[] array = new bool[NPCID.Count];
		for (int i = 0; i < 200; i++)
		{
			if (Main.npc[i].active && Main.npc[i].type >= 0 && Main.npc[i].type < NPCID.Count)
			{
				array[Main.npc[i].type] = true;
			}
		}
		if (array[38] && array[17] && array[107] && array[19] && array[22] && array[124] && array[228] && array[178] && array[18] && array[229] && array[209] && array[54] && array[108] && array[160] && array[20] && array[369] && array[207] && array[227] && array[208] && array[441] && array[353] && array[550] && array[588] && array[633] && array[663])
		{
			AchievementsHelper.NotifyProgressionEvent(17);
		}
		if (array[670] && array[678] && array[679] && array[680] && array[681] && array[682] && array[683] && array[684])
		{
			AchievementsHelper.NotifyProgressionEvent(26);
		}
	}

	public static bool RoomNeeds(int npcType)
	{
		roomChair = false;
		roomDoor = false;
		roomTable = false;
		roomTorch = false;
		for (int i = 0; i < TileID.Sets.RoomNeeds.CountsAsChair.Length; i++)
		{
			if (houseTile[TileID.Sets.RoomNeeds.CountsAsChair[i]])
			{
				roomChair = true;
				break;
			}
		}
		for (int j = 0; j < TileID.Sets.RoomNeeds.CountsAsTable.Length; j++)
		{
			if (houseTile[TileID.Sets.RoomNeeds.CountsAsTable[j]])
			{
				roomTable = true;
				break;
			}
		}
		for (int k = 0; k < TileID.Sets.RoomNeeds.CountsAsTorch.Length; k++)
		{
			if (houseTile[TileID.Sets.RoomNeeds.CountsAsTorch[k]])
			{
				roomTorch = true;
				break;
			}
		}
		for (int l = 0; l < TileID.Sets.RoomNeeds.CountsAsDoor.Length; l++)
		{
			if (houseTile[TileID.Sets.RoomNeeds.CountsAsDoor[l]])
			{
				roomDoor = true;
				break;
			}
		}
		if (roomChair && roomTable && roomDoor && roomTorch)
		{
			canSpawn = true;
		}
		else
		{
			canSpawn = false;
		}
		return canSpawn;
	}

	public static void QuickFindHome(int npc)
	{
		bool flag = Main.tileSolid[379];
		Main.tileSolid[379] = true;
		if (Main.npc[npc].homeTileX > 10 && Main.npc[npc].homeTileY > 10 && Main.npc[npc].homeTileX < Main.maxTilesX - 10 && Main.npc[npc].homeTileY < Main.maxTilesY)
		{
			canSpawn = false;
			StartRoomCheck(Main.npc[npc].homeTileX, Main.npc[npc].homeTileY - 1);
			if (!canSpawn)
			{
				for (int i = Main.npc[npc].homeTileX - 1; i < Main.npc[npc].homeTileX + 2; i++)
				{
					for (int j = Main.npc[npc].homeTileY - 1; j < Main.npc[npc].homeTileY + 2 && !StartRoomCheck(i, j); j++)
					{
					}
				}
			}
			if (!canSpawn)
			{
				int num = 10;
				for (int k = Main.npc[npc].homeTileX - num; k <= Main.npc[npc].homeTileX + num; k += 2)
				{
					for (int l = Main.npc[npc].homeTileY - num; l <= Main.npc[npc].homeTileY + num && !StartRoomCheck(k, l); l += 2)
					{
					}
				}
			}
			if (canSpawn)
			{
				RoomNeeds(Main.npc[npc].type);
				if (canSpawn)
				{
					ScoreRoom(npc, Main.npc[npc].type);
				}
				if (canSpawn && hiScore > 0)
				{
					canSpawn = IsRoomConsideredOccupiedForNPCIndex(npc);
				}
				if (canSpawn && hiScore > 0)
				{
					Main.npc[npc].homeTileX = bestX;
					Main.npc[npc].homeTileY = bestY;
					Main.npc[npc].homeless = false;
					AchievementsHelper.NotifyProgressionEvent(8);
					canSpawn = false;
				}
				else
				{
					Main.npc[npc].homeless = true;
				}
			}
			else
			{
				Main.npc[npc].homeless = true;
			}
		}
		Main.tileSolid[379] = flag;
	}

	private static bool IsRoomConsideredOccupiedForNPCIndex(int npc)
	{
		bool result = true;
		for (int i = 0; i < 200; i++)
		{
			if (i != npc)
			{
				NPC nPC = Main.npc[i];
				if (nPC.active && nPC.townNPC && !nPC.homeless && nPC.homeTileX == bestX && nPC.homeTileY == bestY && !TownManager.CanNPCsLiveWithEachOther(Main.npc[npc], nPC))
				{
					result = false;
					break;
				}
			}
		}
		return result;
	}

	private static bool ScoreRoom_IsThisRoomOccupiedBySomeone(int ignoreNPC = -1, int npcTypeAsking = -1)
	{
		for (int i = 0; i < 200; i++)
		{
			if (!Main.npc[i].active || !Main.npc[i].townNPC || ignoreNPC == i || Main.npc[i].homeless)
			{
				continue;
			}
			for (int j = 0; j < numRoomTiles; j++)
			{
				if (Main.npc[i].homeTileX != roomX[j] || Main.npc[i].homeTileY != roomY[j])
				{
					continue;
				}
				bool flag = false;
				for (int k = 0; k < numRoomTiles; k++)
				{
					if (Main.npc[i].homeTileX == roomX[k] && Main.npc[i].homeTileY - 1 == roomY[k])
					{
						if (!TownManager.CanNPCsLiveWithEachOther(npcTypeAsking, Main.npc[i]))
						{
							flag = true;
							break;
						}
						sharedRoomX = Main.npc[i].homeTileX;
					}
				}
				if (flag)
				{
					return true;
				}
			}
		}
		return false;
	}

	public static void CountTileTypesInArea(int[] tileTypeCounts, int startX, int endX, int startY, int endY)
	{
		for (int i = startX; i <= endX; i++)
		{
			for (int j = startY; j <= endY; j++)
			{
				if (Main.tile[i, j].active())
				{
					tileTypeCounts[Main.tile[i, j].type]++;
				}
			}
		}
	}

	public static int GetTileTypeCountByCategory(int[] tileTypeCounts, TileScanGroup group)
	{
		switch (group)
		{
		case TileScanGroup.None:
			return 0;
		case TileScanGroup.Corruption:
			return tileTypeCounts[23] + tileTypeCounts[24] + tileTypeCounts[25] + tileTypeCounts[32] + tileTypeCounts[112] + tileTypeCounts[163] + tileTypeCounts[400] + tileTypeCounts[398] + -5 * tileTypeCounts[27];
		case TileScanGroup.Crimson:
			return tileTypeCounts[199] + tileTypeCounts[203] + tileTypeCounts[200] + tileTypeCounts[401] + tileTypeCounts[399] + tileTypeCounts[234] + tileTypeCounts[352] - 5 * tileTypeCounts[27];
		case TileScanGroup.Hallow:
			return tileTypeCounts[109] + tileTypeCounts[110] + tileTypeCounts[113] + tileTypeCounts[117] + tileTypeCounts[116] + tileTypeCounts[164] + tileTypeCounts[403] + tileTypeCounts[402];
		case TileScanGroup.TotalGoodEvil:
		{
			int tileTypeCountByCategory4 = GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.Hallow);
			int tileTypeCountByCategory5 = GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.Corruption);
			int tileTypeCountByCategory3 = GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.Crimson);
			int num = 5 * tileTypeCounts[27];
			int num2 = tileTypeCountByCategory5 + tileTypeCountByCategory3 + num;
			return tileTypeCountByCategory4 - num2;
		}
		default:
			return 0;
		}
	}

	public static void ScoreRoom(int ignoreNPC = -1, int npcTypeAskingToScoreRoom = -1)
	{
		roomOccupied = false;
		roomEvil = false;
		sharedRoomX = -1;
		if (ScoreRoom_IsThisRoomOccupiedBySomeone(ignoreNPC, npcTypeAskingToScoreRoom))
		{
			roomOccupied = true;
			hiScore = -1;
			return;
		}
		hiScore = 0;
		int num = 0;
		int num2 = 50;
		Housing_GetTestedRoomBounds(out var startX, out var endX, out var startY, out var endY);
		int[] tileTypeCounts = new int[TileLoader.TileCount];
		CountTileTypesInArea(tileTypeCounts, startX + 1, endX - 1, startY + 2, endY + 1);
		int num3 = -GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.TotalGoodEvil);
		if (num3 < 50)
		{
			num3 = 0;
		}
		num2 -= num3;
		if (num3 > 0)
		{
			roomEvil = true;
		}
		if (num2 <= -250)
		{
			hiScore = num2;
			return;
		}
		startX = roomX1;
		endX = roomX2;
		startY = roomY1;
		endY = roomY2;
		for (int i = startX + 1; i < endX; i++)
		{
			for (int j = startY + 2; j < endY + 2; j++)
			{
				if (!Main.tile[i, j].nactive() || !ScoreRoom_CanBeHomeSpot(i, j))
				{
					continue;
				}
				num = num2;
				if (!Main.tileSolid[Main.tile[i, j].type] || Main.tileSolidTop[Main.tile[i, j].type] || Collision.SolidTiles(i - 1, i + 1, j - 3, j - 1) || !Main.tile[i - 1, j].nactive() || !Main.tileSolid[Main.tile[i - 1, j].type] || !Main.tile[i + 1, j].nactive() || !Main.tileSolid[Main.tile[i + 1, j].type])
				{
					continue;
				}
				int num4 = 0;
				int num5 = 0;
				for (int k = i - 2; k < i + 3; k++)
				{
					for (int l = j - 4; l < j; l++)
					{
						Tile tile = Main.tile[k, l];
						if (tile.nactive() && !TileID.Sets.IgnoredInHouseScore[tile.type] && (tile.type != 11 || IsOpenDoorAnchorFrame(k, l)))
						{
							if (k == i)
							{
								num4++;
							}
							else if (TileID.Sets.BasicChest[tile.type])
							{
								num5++;
							}
							else
							{
								num = ((tile.type != 10 && tile.type != 388) ? ((IsOpenDoorAnchorFrame(k, l) || tile.type == 389) ? (num - 20) : ((!Main.tileSolid[tile.type]) ? (num + 5) : (num - 5))) : (num - 20));
							}
						}
					}
				}
				if (sharedRoomX >= 0 && num >= 1 && Math.Abs(sharedRoomX - i) < 3)
				{
					num = 1;
				}
				if (num > 0 && num5 > 0)
				{
					num -= 30 * num5;
					if (num < 1)
					{
						num = 1;
					}
				}
				if (num > 0 && num4 > 0)
				{
					num -= 15 * num4;
					if (num <= 0)
					{
						num = 0;
					}
				}
				if (num <= hiScore)
				{
					continue;
				}
				bool flag = Housing_CheckIfInRoom(i, j);
				bool[] array = new bool[3];
				for (int m = 1; m <= 3; m++)
				{
					if (!Main.tile[i, j - m].active() || !Main.tileSolid[Main.tile[i, j - m].type])
					{
						array[m - 1] = true;
					}
					if (!Housing_CheckIfInRoom(i, j - m))
					{
						array[m - 1] = false;
					}
				}
				bool[] array2 = array;
				for (int n = 0; n < array2.Length; n++)
				{
					if (!array2[n])
					{
						flag = false;
						break;
					}
				}
				if (flag && !Housing_CheckIfIsCeiling(i, j))
				{
					hiScore = num;
					bestX = i;
					bestY = j;
				}
			}
		}
	}

	public static void Housing_GetTestedRoomBounds(out int startX, out int endX, out int startY, out int endY)
	{
		int num = 40;
		int num2 = 5;
		int num3 = 3;
		startX = roomX1 - num2 - 1 - num;
		endX = roomX2 + num2 + 1 + num;
		startY = roomY1 - num3 - 1 - num;
		endY = roomY2 + num3 + 1 + num;
		if (startX < 5)
		{
			startX = 5;
		}
		if (endX >= Main.maxTilesX - 5)
		{
			endX = Main.maxTilesX - 6;
		}
		if (startY < 5)
		{
			startY = 5;
		}
		if (endY >= Main.maxTilesY - 5)
		{
			endY = Main.maxTilesY - 6;
		}
	}

	private static bool ScoreRoom_CanBeHomeSpot(int x, int y)
	{
		Tile tile = Main.tile[x, y];
		if (tile.active() && tile.type == 379)
		{
			return false;
		}
		return true;
	}

	private static bool Housing_CheckIfIsCeiling(int i, int j)
	{
		bool result = false;
		for (int k = 0; k < roomCeilingsCount; k++)
		{
			if (roomCeilingX[k] == i)
			{
				if (roomCeilingY[k] == j)
				{
					result = true;
				}
				break;
			}
		}
		return result;
	}

	private static bool Housing_CheckIfInRoom(int i, int j)
	{
		bool result = false;
		for (int k = 0; k < numRoomTiles; k++)
		{
			if (roomX[k] == i && roomY[k] == j)
			{
				result = true;
				break;
			}
		}
		return result;
	}

	public static bool StartRoomCheck(int x, int y)
	{
		roomHasStinkbug = false;
		roomHasEchoStinkbug = false;
		roomX1 = x;
		roomX2 = x;
		roomY1 = y;
		roomY2 = y;
		numRoomTiles = 0;
		roomCeilingsCount = 0;
		for (int i = 0; i < houseTile.Length; i++)
		{
			houseTile[i] = false;
		}
		canSpawn = true;
		if (Main.tile[x, y].nactive() && Main.tileSolid[Main.tile[x, y].type])
		{
			roomCheckFailureReason = TownNPCRoomCheckFailureReason.RoomCheckStartedInASolidTile;
			canSpawn = false;
			return false;
		}
		roomCheckFailureReason = TownNPCRoomCheckFailureReason.None;
		CheckRoom(x, y);
		if (!canSpawn)
		{
			return false;
		}
		if (numRoomTiles < 60)
		{
			roomCheckFailureReason = TownNPCRoomCheckFailureReason.RoomIsTooSmall;
			canSpawn = false;
			return false;
		}
		if (canSpawn)
		{
			return true;
		}
		return false;
	}

	public static void CheckRoom(int x, int y)
	{
		if (!canSpawn)
		{
			return;
		}
		if (x < 10 || y < 10 || x >= Main.maxTilesX - 10 || y >= lastMaxTilesY - 10)
		{
			roomCheckFailureReason = TownNPCRoomCheckFailureReason.TooCloseToWorldEdge;
			canSpawn = false;
			return;
		}
		for (int i = 0; i < numRoomTiles; i++)
		{
			if (roomX[i] == x && roomY[i] == y)
			{
				return;
			}
		}
		roomX[numRoomTiles] = x;
		roomY[numRoomTiles] = y;
		bool flag = false;
		for (int j = 0; j < roomCeilingsCount; j++)
		{
			if (roomCeilingX[j] == x)
			{
				flag = true;
				if (roomCeilingY[j] > y)
				{
					roomCeilingY[j] = y;
				}
				break;
			}
		}
		if (!flag)
		{
			roomCeilingX[roomCeilingsCount] = x;
			roomCeilingY[roomCeilingsCount] = y;
			roomCeilingsCount++;
		}
		numRoomTiles++;
		if (numRoomTiles >= maxRoomTiles)
		{
			roomCheckFailureReason = TownNPCRoomCheckFailureReason.RoomIsTooBig;
			canSpawn = false;
			return;
		}
		if (Main.tile[x, y].nactive())
		{
			houseTile[Main.tile[x, y].type] = true;
			if (Main.tileSolid[Main.tile[x, y].type] || (Main.tile[x, y].type == 11 && (Main.tile[x, y].frameX == 0 || Main.tile[x, y].frameX == 54 || Main.tile[x, y].frameX == 72 || Main.tile[x, y].frameX == 126)) || Main.tile[x, y].type == 389 || (Main.tile[x, y].type == 386 && ((Main.tile[x, y].frameX < 36 && Main.tile[x, y].frameY == 18) || (Main.tile[x, y].frameX >= 36 && Main.tile[x, y].frameY == 0))) || (TileLoader.CloseDoorID(Main.tile[x, y]) >= 0 && (Main.tile[x, y].frameX == 0 || Main.tile[x, y].frameX == 54 || Main.tile[x, y].frameX == 72 || Main.tile[x, y].frameX == 126)))
			{
				return;
			}
		}
		if (x < roomX1)
		{
			roomX1 = x;
		}
		if (x > roomX2)
		{
			roomX2 = x;
		}
		if (y < roomY1)
		{
			roomY1 = y;
		}
		if (y > roomY2)
		{
			roomY2 = y;
		}
		if (Main.tile[x, y].type == 630)
		{
			roomHasStinkbug = true;
		}
		if (Main.tile[x, y].type == 631)
		{
			roomHasEchoStinkbug = true;
		}
		bool flag2 = false;
		bool flag3 = false;
		for (int k = -2; k < 3; k++)
		{
			if (Main.wallHouse[Main.tile[x + k, y].wall])
			{
				flag2 = true;
			}
			if (Main.tile[x + k, y].nactive() && (Main.tileSolid[Main.tile[x + k, y].type] || TileID.Sets.HousingWalls[Main.tile[x + k, y].type]))
			{
				flag2 = true;
			}
			if (Main.wallHouse[Main.tile[x, y + k].wall])
			{
				flag3 = true;
			}
			if (Main.tile[x, y + k].nactive() && (Main.tileSolid[Main.tile[x, y + k].type] || TileID.Sets.HousingWalls[Main.tile[x, y + k].type]))
			{
				flag3 = true;
			}
		}
		if (!flag2 || !flag3)
		{
			roomCheckFailureReason = TownNPCRoomCheckFailureReason.HoleInWallIsTooBig;
			canSpawn = false;
			return;
		}
		for (int l = x - 1; l < x + 2; l++)
		{
			for (int m = y - 1; m < y + 2; m++)
			{
				if ((l != x || m != y) && canSpawn)
				{
					CheckRoom(l, m);
				}
			}
		}
	}

	public static void dropMeteor()
	{
		bool flag = true;
		if (Main.netMode == 1)
		{
			return;
		}
		for (int i = 0; i < 255; i++)
		{
			if (Main.player[i].active)
			{
				flag = false;
				break;
			}
		}
		int num = 0;
		double num2 = (double)Main.maxTilesX / 4200.0;
		int num3 = (int)(400.0 * num2);
		for (int j = 5; j < Main.maxTilesX - 5; j++)
		{
			for (int k = 5; (double)k < Main.worldSurface; k++)
			{
				if (Main.tile[j, k].active() && Main.tile[j, k].type == 37)
				{
					num++;
					if (num > num3)
					{
						return;
					}
				}
			}
		}
		double num4 = 600.0;
		int num5 = 0;
		while (!flag)
		{
			double num6 = (double)Main.maxTilesX * 0.08;
			int num7 = Main.rand.Next(150, Main.maxTilesX - 150);
			while ((double)num7 > (double)Main.spawnTileX - num6 && (double)num7 < (double)Main.spawnTileX + num6)
			{
				num7 = Main.rand.Next(150, Main.maxTilesX - 150);
			}
			for (int l = (int)(Main.worldSurface * 0.3); l < Main.maxTilesY; l++)
			{
				Tile tile = Main.tile[num7, l];
				if (!tile.active() || !Main.tileSolid[tile.type] || TileID.Sets.Platforms[tile.type])
				{
					continue;
				}
				int num8 = 0;
				int num9 = 15;
				for (int m = num7 - num9; m < num7 + num9; m++)
				{
					for (int n = l - num9; n < l + num9; n++)
					{
						if (SolidTile(m, n))
						{
							num8++;
							if (Main.tile[m, n].type == 189 || Main.tile[m, n].type == 202)
							{
								num8 -= 100;
							}
						}
						else if (Main.tile[m, n].liquid > 0)
						{
							num8--;
						}
					}
				}
				if ((double)num8 >= num4)
				{
					flag = meteor(num7, l);
					if (flag)
					{
					}
				}
				else
				{
					num4 -= 0.5;
				}
				break;
			}
			num5++;
			if (num4 < 100.0 || num5 >= Main.maxTilesX * 5)
			{
				break;
			}
		}
	}

	public static bool meteor(int i, int j, bool ignorePlayers = false)
	{
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e0: Unknown result type (might be due to invalid IL or missing references)
		if (i < 50 || i > Main.maxTilesX - 50)
		{
			return false;
		}
		if (j < 50 || j > Main.maxTilesY - 50)
		{
			return false;
		}
		int num = 35;
		Rectangle rectangle = default(Rectangle);
		((Rectangle)(ref rectangle))._002Ector((i - num) * 16, (j - num) * 16, num * 2 * 16, num * 2 * 16);
		Rectangle value = default(Rectangle);
		for (int k = 0; k < 255; k++)
		{
			if (Main.player[k].active && !ignorePlayers)
			{
				((Rectangle)(ref value))._002Ector((int)(Main.player[k].position.X + (float)(Main.player[k].width / 2) - (float)(NPC.sWidth / 2) - (float)NPC.safeRangeX), (int)(Main.player[k].position.Y + (float)(Main.player[k].height / 2) - (float)(NPC.sHeight / 2) - (float)NPC.safeRangeY), NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
				if (((Rectangle)(ref rectangle)).Intersects(value))
				{
					return false;
				}
			}
		}
		Rectangle value2 = default(Rectangle);
		for (int l = 0; l < 200; l++)
		{
			if (Main.npc[l].active)
			{
				((Rectangle)(ref value2))._002Ector((int)Main.npc[l].position.X, (int)Main.npc[l].position.Y, Main.npc[l].width, Main.npc[l].height);
				if (((Rectangle)(ref rectangle)).Intersects(value2))
				{
					return false;
				}
			}
		}
		Tile tile;
		for (int m = i - num; m < i + num; m++)
		{
			for (int n = j - num; n < j + num; n++)
			{
				tile = Main.tile[m, n];
				if (!tile.active())
				{
					continue;
				}
				bool[] basicChest = TileID.Sets.BasicChest;
				tile = Main.tile[m, n];
				if (!basicChest[tile.type])
				{
					bool[] tileDungeon = Main.tileDungeon;
					tile = Main.tile[m, n];
					if (!tileDungeon[tile.type])
					{
						tile = Main.tile[m, n];
						_ = ref tile.type;
						bool[] avoidedByMeteorLanding = TileID.Sets.AvoidedByMeteorLanding;
						tile = Main.tile[m, n];
						if (avoidedByMeteorLanding[tile.type])
						{
							return false;
						}
						continue;
					}
				}
				return false;
			}
		}
		stopDrops = true;
		num = genRand.Next(17, 23);
		for (int num10 = i - num; num10 < i + num; num10++)
		{
			for (int num12 = j - num; num12 < j + num; num12++)
			{
				if (num12 <= j + Main.rand.Next(-2, 3) - 5)
				{
					continue;
				}
				double num17 = Math.Abs(i - num10);
				double num13 = Math.Abs(j - num12);
				if (Math.Sqrt(num17 * num17 + num13 * num13) < (double)num * 0.9 + (double)Main.rand.Next(-4, 5))
				{
					bool[] tileSolid = Main.tileSolid;
					tile = Main.tile[num10, num12];
					if (!tileSolid[tile.type])
					{
						tile = Main.tile[num10, num12];
						tile.active(active: false);
					}
					tile = Main.tile[num10, num12];
					tile.type = 37;
				}
			}
		}
		num = genRand.Next(8, 14);
		for (int num14 = i - num; num14 < i + num; num14++)
		{
			for (int num15 = j - num; num15 < j + num; num15++)
			{
				if (num15 > j + Main.rand.Next(-2, 3) - 4)
				{
					double num18 = Math.Abs(i - num14);
					double num16 = Math.Abs(j - num15);
					if (Math.Sqrt(num18 * num18 + num16 * num16) < (double)num * 0.8 + (double)Main.rand.Next(-3, 4))
					{
						tile = Main.tile[num14, num15];
						tile.active(active: false);
					}
				}
			}
		}
		num = genRand.Next(25, 35);
		for (int num2 = i - num; num2 < i + num; num2++)
		{
			for (int num3 = j - num; num3 < j + num; SquareTileFrame(num2, num3), SquareWallFrame(num2, num3), num3++)
			{
				double num19 = Math.Abs(i - num2);
				double num4 = Math.Abs(j - num3);
				if (Math.Sqrt(num19 * num19 + num4 * num4) < (double)num * 0.7)
				{
					bool[] getsDestroyedForMeteors = TileID.Sets.GetsDestroyedForMeteors;
					tile = Main.tile[num2, num3];
					if (getsDestroyedForMeteors[tile.type])
					{
						KillTile(num2, num3);
					}
					tile = Main.tile[num2, num3];
					tile.liquid = 0;
				}
				tile = Main.tile[num2, num3];
				if (tile.type != 37)
				{
					continue;
				}
				if (!SolidTile(num2 - 1, num3) && !SolidTile(num2 + 1, num3) && !SolidTile(num2, num3 - 1) && !SolidTile(num2, num3 + 1))
				{
					tile = Main.tile[num2, num3];
					tile.active(active: false);
					continue;
				}
				tile = Main.tile[num2, num3];
				if (!tile.halfBrick())
				{
					tile = Main.tile[num2 - 1, num3];
					if (!tile.topSlope())
					{
						continue;
					}
				}
				if (!SolidTile(num2, num3 + 1))
				{
					tile = Main.tile[num2, num3];
					tile.active(active: false);
				}
			}
		}
		num = genRand.Next(23, 32);
		for (int num5 = i - num; num5 < i + num; num5++)
		{
			for (int num6 = j - num; num6 < j + num; num6++)
			{
				if (num6 <= j + genRand.Next(-3, 4) - 3)
				{
					continue;
				}
				tile = Main.tile[num5, num6];
				if (!tile.active() || Main.rand.Next(10) != 0)
				{
					continue;
				}
				double num20 = Math.Abs(i - num5);
				double num7 = Math.Abs(j - num6);
				if (Math.Sqrt(num20 * num20 + num7 * num7) < (double)num * 0.8)
				{
					bool[] getsDestroyedForMeteors2 = TileID.Sets.GetsDestroyedForMeteors;
					tile = Main.tile[num5, num6];
					if (getsDestroyedForMeteors2[tile.type])
					{
						KillTile(num5, num6);
					}
					tile = Main.tile[num5, num6];
					tile.type = 37;
					SquareTileFrame(num5, num6);
				}
			}
		}
		num = genRand.Next(30, 38);
		for (int num8 = i - num; num8 < i + num; num8++)
		{
			for (int num9 = j - num; num9 < j + num; num9++)
			{
				if (num9 <= j + genRand.Next(-2, 3))
				{
					continue;
				}
				tile = Main.tile[num8, num9];
				if (!tile.active() || Main.rand.Next(20) != 0)
				{
					continue;
				}
				double num21 = Math.Abs(i - num8);
				double num11 = Math.Abs(j - num9);
				if (Math.Sqrt(num21 * num21 + num11 * num11) < (double)num * 0.85)
				{
					bool[] getsDestroyedForMeteors3 = TileID.Sets.GetsDestroyedForMeteors;
					tile = Main.tile[num8, num9];
					if (getsDestroyedForMeteors3[tile.type])
					{
						KillTile(num8, num9);
					}
					tile = Main.tile[num8, num9];
					tile.type = 37;
					SquareTileFrame(num8, num9);
				}
			}
		}
		stopDrops = false;
		if (Main.netMode == 0)
		{
			Main.NewText(Lang.gen[59].Value, 50, byte.MaxValue, 130);
		}
		else if (Main.netMode == 2)
		{
			ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.gen[59].Key), new Color(50, 255, 130));
		}
		if (Main.netMode != 1)
		{
			NetMessage.SendTileSquare(-1, i, j, 40);
		}
		return true;
	}

	public static void setWorldSize()
	{
		Main.bottomWorld = Main.maxTilesY * 16;
		Main.rightWorld = Main.maxTilesX * 16;
		Main.maxSectionsX = (Main.maxTilesX - 1) / 200 + 1;
		Main.maxSectionsY = (Main.maxTilesY - 1) / 150 + 1;
	}

	public static int GetWorldSize()
	{
		if (Main.maxTilesX <= 4200)
		{
			return 0;
		}
		if (Main.maxTilesX <= 6400)
		{
			return 1;
		}
		return 2;
	}

	public static void worldGenCallback(object threadContext)
	{
		try
		{
			do_worldGenCallBack(threadContext);
		}
		catch (Exception e)
		{
			Logging.Terraria.Error((object)Language.GetTextValue("tModLoader.WorldGenError"), e);
		}
	}

	public static void do_worldGenCallBack(object threadContext)
	{
		SoundEngine.PlaySound(10);
		clearWorld();
		GenerateWorld(Main.ActiveWorldFileData.Seed, threadContext as GenerationProgress);
		WorldFile.SaveWorld(Main.ActiveWorldFileData.IsCloudSave, resetTime: true);
		BackupIO.archiveLock = false;
		if (Main.menuMode == 10 || Main.menuMode == 888)
		{
			Main.menuMode = 6;
		}
		SoundEngine.PlaySound(10);
		generatingWorld = false;
	}

	public static Task CreateNewWorld(GenerationProgress progress = null)
	{
		generatingWorld = true;
		Main.rand = new UnifiedRandom(Main.ActiveWorldFileData.Seed);
		gen = true;
		Main.menuMode = 888;
		try
		{
			Main.MenuUI.SetState(new UIWorldLoad());
		}
		catch
		{
		}
		return Task.Factory.StartNew(worldGenCallback, progress);
	}

	public static void JustQuit()
	{
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		Main.ambientWaterfallStrength = 0f;
		Main.ambientLavafallStrength = 0f;
		Main.ambientLavaStrength = 0f;
		Main.invasionProgress = -1;
		Main.invasionProgressDisplayLeft = 0;
		Main.invasionProgressAlpha = 0f;
		Main.invasionProgressIcon = 0;
		Main.menuMode = 10;
		Main.gameMenu = true;
		SoundEngine.StopTrackedSounds();
		try
		{
			SoundEngine.PlaySound(11);
		}
		catch
		{
		}
		CaptureInterface.ResetFocus();
		Main.ActivePlayerFileData.StopPlayTimer();
		Main.fastForwardTimeToDawn = false;
		Main.fastForwardTimeToDusk = false;
		Main.UpdateTimeRate();
		if (Main.netMode == 0)
		{
			Main.GoToWorldSelect();
			Main.player[Main.myPlayer].position = new Vector2(0f, 0f);
		}
		else if (Main.netMode == 1)
		{
			Main.menuMode = 0;
			Netplay.Disconnect = true;
			Main.netMode = 0;
		}
	}

	public static void SaveAndQuitCallBack(object threadContext)
	{
		int netMode = Main.netMode;
		Main.ambientWaterfallStrength = 0f;
		Main.ambientLavafallStrength = 0f;
		if (netMode == 0)
		{
			WorldFile.CacheSaveTime();
		}
		Main.invasionProgress = -1;
		Main.invasionProgressDisplayLeft = 0;
		Main.invasionProgressAlpha = 0f;
		Main.invasionProgressIcon = 0;
		Main.menuMode = 10;
		Main.gameMenu = true;
		SoundEngine.StopTrackedSounds();
		try
		{
			SoundEngine.PlaySound(11);
		}
		catch
		{
		}
		CaptureInterface.ResetFocus();
		Main.ActivePlayerFileData.StopPlayTimer();
		Player.SavePlayer(Main.ActivePlayerFileData);
		Player.ClearPlayerTempInfo();
		Rain.ClearRain();
		if (netMode == 0)
		{
			WorldFile.SaveWorld();
			SoundEngine.PlaySound(10);
		}
		else
		{
			Netplay.Disconnect = true;
			Main.netMode = 0;
		}
		SystemLoader.OnWorldUnload();
		Main.fastForwardTimeToDawn = false;
		Main.fastForwardTimeToDusk = false;
		Main.UpdateTimeRate();
		Main.menuMode = 0;
		if (threadContext != null)
		{
			((Action)threadContext)();
		}
	}

	public static void SaveAndQuit(Action callback = null)
	{
		ThreadPool.QueueUserWorkItem(SaveAndQuitCallBack, callback);
	}

	public static void RenameWorld(WorldFileData data, string newName, Action<string> callback = null)
	{
		data.SetAsActive();
		ThreadPool.QueueUserWorkItem(RenameWorldCallBack, Tuple.Create(newName, callback));
	}

	public static void RenameWorldCallBack(object threadContext)
	{
		if (threadContext != null && threadContext is Tuple<string, Action<string>> { Item1: var item, Item2: var item2 })
		{
			noMapUpdate = true;
			Main.ToggleGameplayUpdates(state: false);
			WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
			noMapUpdate = false;
			if (loadFailed || !loadSuccess)
			{
				Main.LoadWorlds();
				Main.GoToWorldSelect();
				return;
			}
			Main.sectionManager.SetAllSectionsLoaded();
			double time = Main.time;
			bool dayTime = Main.dayTime;
			WorldFile.SetOngoingToTemps();
			WorldFile.CacheSaveTime();
			Main.time = time;
			Main.dayTime = dayTime;
			Main.worldName = item;
			WorldFile.SaveWorld();
			Rain.ClearRain();
			Main.fastForwardTimeToDawn = false;
			Main.fastForwardTimeToDusk = false;
			Main.UpdateTimeRate();
			item2?.Invoke(item);
		}
	}

	public static void playWorldCallBack(object threadContext)
	{
		Logging.Terraria.InfoFormat("Loading World: {0}, IsCloud={1}, Width: {2}, Height: {3}, Evil: {4}, GameMode: {5}", new object[6]
		{
			Main.ActiveWorldFileData.Name,
			Main.ActiveWorldFileData.IsCloudSave,
			Main.ActiveWorldFileData.WorldSizeX,
			Main.ActiveWorldFileData.WorldSizeY,
			Main.ActiveWorldFileData.HasCrimson.ToInt(),
			Main.ActiveWorldFileData.GameMode
		});
		if (Main.rand == null)
		{
			Main.rand = new UnifiedRandom((int)DateTime.Now.Ticks);
		}
		for (int i = 0; i < 255; i++)
		{
			if (i != Main.myPlayer)
			{
				Main.player[i].active = false;
			}
		}
		noMapUpdate = true;
		Main.ToggleGameplayUpdates(state: false);
		WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
		if (loadFailed || !loadSuccess)
		{
			WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
			if (loadFailed || !loadSuccess)
			{
				bool isCloudSave = Main.ActiveWorldFileData.IsCloudSave;
				if (FileUtilities.Exists(Main.worldPathName + ".bak", isCloudSave))
				{
					worldBackup = true;
				}
				else
				{
					worldBackup = false;
				}
				if (!Main.dedServ)
				{
					if (worldBackup)
					{
						Main.menuMode = 200;
					}
					else
					{
						Main.menuMode = 201;
					}
					return;
				}
				if (!worldBackup)
				{
					string message = Language.GetTextValue("Error.LoadFailedNoBackup");
					if (WorldIO.customDataFail != null)
					{
						message = WorldIO.customDataFail.modName + " " + message;
						message = message + "\n" + WorldIO.customDataFail.InnerException;
					}
					Console.WriteLine(message);
					return;
				}
				FileUtilities.Copy(Main.worldPathName, Main.worldPathName + ".bad", isCloudSave);
				FileUtilities.Copy(Main.worldPathName + ".bak", Main.worldPathName, isCloudSave);
				FileUtilities.Delete(Main.worldPathName + ".bak", isCloudSave);
				WorldIO.LoadDedServBackup(Main.worldPathName, isCloudSave);
				WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
				if (loadFailed || !loadSuccess)
				{
					WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
					if (loadFailed || !loadSuccess)
					{
						FileUtilities.Copy(Main.worldPathName, Main.worldPathName + ".bak", isCloudSave);
						FileUtilities.Copy(Main.worldPathName + ".bad", Main.worldPathName, isCloudSave);
						FileUtilities.Delete(Main.worldPathName + ".bad", isCloudSave);
						WorldIO.RevertDedServBackup(Main.worldPathName, isCloudSave);
						string message2 = Language.GetTextValue("Error.LoadFailed");
						if (WorldIO.customDataFail != null)
						{
							message2 = $"{WorldIO.customDataFail.modName} {message2}\r\n{WorldIO.customDataFail.InnerException}";
						}
						Console.WriteLine(message2);
						return;
					}
				}
			}
		}
		if (Main.mapEnabled)
		{
			Main.Map.Load();
		}
		if (Main.netMode != 2)
		{
			Main.sectionManager.SetAllSectionsLoaded();
		}
		while (Main.loadMapLock)
		{
			float num = (float)Main.loadMapLastX / (float)Main.maxTilesX;
			Main.statusText = Lang.gen[68].Value + " " + (int)(num * 100f + 1f) + "%";
			Thread.Sleep(0);
			if (!Main.mapEnabled)
			{
				break;
			}
		}
		if (Main.gameMenu)
		{
			Main.gameMenu = false;
		}
		if (Main.netMode == 0 && Main.anglerWhoFinishedToday.Contains(Main.player[Main.myPlayer].name))
		{
			Main.anglerQuestFinished = true;
		}
		Main.QueueMainThreadAction(FinishPlayWorld);
	}

	internal static void FinishPlayWorld()
	{
		Main.player[Main.myPlayer].Spawn(PlayerSpawnContext.SpawningIntoWorld);
		_lastSeed = Main.ActiveWorldFileData.Seed;
		WorldFile.SetOngoingToTemps();
		SoundEngine.PlaySound(11);
		Main.resetClouds = true;
		noMapUpdate = false;
	}

	public static void playWorld()
	{
		ThreadPool.QueueUserWorkItem(playWorldCallBack, 1);
	}

	public static void saveAndPlayCallBack(object threadContext)
	{
		WorldFile.SaveWorld();
	}

	public static void saveAndPlay()
	{
		ThreadPool.QueueUserWorkItem(saveAndPlayCallBack, 1);
	}

	public static void saveToonWhilePlayingCallBack(object threadContext)
	{
		Player.SavePlayer(Main.ActivePlayerFileData);
	}

	public static void saveToonWhilePlaying()
	{
		ThreadPool.QueueUserWorkItem(saveToonWhilePlayingCallBack, 1);
	}

	public static void serverLoadWorldCallBack()
	{
		Logging.Terraria.InfoFormat("Loading World: {0}, IsCloud={1}, Width: {2}, Height: {3}, Evil: {4}, GameMode: {5}", new object[6]
		{
			Main.ActiveWorldFileData.Name,
			Main.ActiveWorldFileData.IsCloudSave,
			Main.ActiveWorldFileData.WorldSizeX,
			Main.ActiveWorldFileData.WorldSizeY,
			Main.ActiveWorldFileData.HasCrimson.ToInt(),
			Main.ActiveWorldFileData.GameMode
		});
		Main.rand = new UnifiedRandom((int)DateTime.Now.Ticks);
		WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
		if (loadFailed || !loadSuccess)
		{
			WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
			if (loadFailed || !loadSuccess)
			{
				bool isCloudSave = Main.ActiveWorldFileData.IsCloudSave;
				if (FileUtilities.Exists(Main.worldPathName + ".bak", isCloudSave))
				{
					worldBackup = true;
				}
				else
				{
					worldBackup = false;
				}
				if (!Main.dedServ)
				{
					if (worldBackup)
					{
						Main.menuMode = 200;
					}
					else
					{
						Main.menuMode = 201;
					}
					return;
				}
				if (!worldBackup)
				{
					Console.WriteLine(Language.GetTextValue("Error.LoadFailedNoBackup"));
					return;
				}
				FileUtilities.Copy(Main.worldPathName + ".bak", Main.worldPathName, isCloudSave);
				FileUtilities.Delete(Main.worldPathName + ".bak", isCloudSave);
				WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
				if (loadFailed || !loadSuccess)
				{
					WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
					if (loadFailed || !loadSuccess)
					{
						Console.WriteLine(Language.GetTextValue("Error.LoadFailed"));
						return;
					}
				}
			}
		}
		_lastSeed = Main.ActiveWorldFileData.Seed;
		SoundEngine.PlaySound(10);
		WorldFile.SetOngoingToTemps();
		Hooks.WorldLoaded();
	}

	public static Task serverLoadWorld()
	{
		return Task.Factory.StartNew(serverLoadWorldCallBack);
	}

	public static void clearWorld()
	{
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		ResetTreeShakes();
		Main.ladyBugRainBoost = 0.0;
		Main.getGoodWorld = false;
		Main.drunkWorld = false;
		Main.tenthAnniversaryWorld = false;
		Main.dontStarveWorld = false;
		Main.notTheBeesWorld = false;
		Main.remixWorld = false;
		Main.noTrapsWorld = false;
		Main.zenithWorld = false;
		Main.afterPartyOfDoom = false;
		Main.shimmerAlpha = 0f;
		Main.shimmerDarken = 0f;
		Main.shimmerBrightenDelay = 0f;
		NPC.ResetBadgerHatTime();
		NPC.freeCake = false;
		NPC.mechQueen = -1;
		Main.mapDelay = 2;
		Main.waterStyle = 0;
		Main.ResetWindCounter(resetExtreme: true);
		TownManager = new TownRoomManager();
		PressurePlateHelper.Reset();
		TownManager.Clear();
		NPC.ResetKillCount();
		Main.instance.ClearCachedTileDraws();
		MapHelper.ResetMapData();
		TileEntity.Clear();
		Main.checkXMas();
		Main.checkHalloween();
		DontStarveDarknessDamageDealer.Reset();
		Wiring.ClearAll();
		Main.ParticleSystem_World_BehindPlayers.Particles.Clear();
		Main.ParticleSystem_World_OverPlayers.Particles.Clear();
		if (Main.mapReady)
		{
			for (int i = 0; i < lastMaxTilesX; i++)
			{
				_ = (float)i / (float)lastMaxTilesX;
				Main.statusText = Lang.gen[65].Value;
			}
			if (Main.Map != null)
			{
				Main.Map.Clear();
			}
		}
		NPC.MoonLordCountdown = 0;
		Main.forceHalloweenForToday = false;
		Main.forceXMasForToday = false;
		NPC.RevengeManager.Reset();
		Main.pumpkinMoon = false;
		Main.clearMap = true;
		Main.mapTime = 0;
		Main.updateMap = false;
		Main.mapReady = false;
		Main.refreshMap = false;
		Main.eclipse = false;
		Main.slimeRain = false;
		Main.slimeRainTime = 0.0;
		Main.slimeWarningTime = 0;
		Main.sundialCooldown = 0;
		Main.moondialCooldown = 0;
		Main.fastForwardTimeToDawn = false;
		Main.fastForwardTimeToDusk = false;
		BirthdayParty.WorldClear();
		LanternNight.WorldClear();
		mysticLogsEvent.WorldClear();
		CreditsRollEvent.Reset();
		Sandstorm.WorldClear();
		Main.DroneCameraTracker.WorldClear();
		Main.LocalGolfState.WorldClear();
		Main.CurrentPan = Vector2.Zero;
		Main.UpdateTimeRate();
		Main.wofNPCIndex = -1;
		NPC.waveKills = 0f;
		spawnHardBoss = 0;
		totalSolid2 = 0;
		totalGood2 = 0;
		totalEvil2 = 0;
		totalBlood2 = 0;
		totalSolid = 0;
		totalGood = 0;
		totalEvil = 0;
		totalBlood = 0;
		WorldFile.ResetTemps();
		Main.maxRaining = 0f;
		totalX = 0;
		totalD = 0;
		tEvil = 0;
		tBlood = 0;
		tGood = 0;
		spawnEye = false;
		prioritizedTownNPCType = 0;
		shadowOrbCount = 0;
		altarCount = 0;
		SavedOreTiers.Copper = -1;
		SavedOreTiers.Iron = -1;
		SavedOreTiers.Silver = -1;
		SavedOreTiers.Gold = -1;
		SavedOreTiers.Cobalt = -1;
		SavedOreTiers.Mythril = -1;
		SavedOreTiers.Adamantite = -1;
		GenVars.shimmerPosition = Vector2D.Zero;
		Main.cloudBGActive = 0f;
		Main.raining = false;
		Main.hardMode = false;
		Main.helpText = 0;
		Main.BartenderHelpTextIndex = 0;
		Main.dungeonX = 0;
		Main.dungeonY = 0;
		NPC.downedBoss1 = false;
		NPC.downedBoss2 = false;
		NPC.downedBoss3 = false;
		NPC.downedQueenBee = false;
		NPC.downedSlimeKing = false;
		NPC.downedMechBossAny = false;
		NPC.downedMechBoss1 = false;
		NPC.downedMechBoss2 = false;
		NPC.downedMechBoss3 = false;
		NPC.downedFishron = false;
		NPC.downedAncientCultist = false;
		NPC.downedMoonlord = false;
		NPC.downedHalloweenKing = false;
		NPC.downedHalloweenTree = false;
		NPC.downedChristmasIceQueen = false;
		NPC.downedChristmasSantank = false;
		NPC.downedChristmasTree = false;
		NPC.downedPlantBoss = false;
		NPC.downedGolemBoss = false;
		NPC.downedEmpressOfLight = false;
		NPC.downedQueenSlime = false;
		NPC.downedDeerclops = false;
		NPC.combatBookWasUsed = false;
		NPC.combatBookVolumeTwoWasUsed = false;
		NPC.peddlersSatchelWasUsed = false;
		NPC.savedStylist = false;
		NPC.savedGoblin = false;
		NPC.savedWizard = false;
		NPC.savedMech = false;
		NPC.savedTaxCollector = false;
		NPC.savedAngler = false;
		NPC.savedBartender = false;
		NPC.savedGolfer = false;
		NPC.boughtCat = false;
		NPC.boughtDog = false;
		NPC.boughtBunny = false;
		NPC.unlockedSlimeBlueSpawn = false;
		NPC.unlockedSlimeGreenSpawn = false;
		NPC.unlockedSlimeOldSpawn = false;
		NPC.unlockedSlimePurpleSpawn = false;
		NPC.unlockedSlimeRainbowSpawn = false;
		NPC.unlockedSlimeRedSpawn = false;
		NPC.unlockedSlimeYellowSpawn = false;
		NPC.unlockedSlimeCopperSpawn = false;
		NPC.unlockedMerchantSpawn = false;
		NPC.unlockedDemolitionistSpawn = false;
		NPC.unlockedPartyGirlSpawn = false;
		NPC.unlockedDyeTraderSpawn = false;
		NPC.unlockedTruffleSpawn = false;
		NPC.unlockedArmsDealerSpawn = false;
		NPC.unlockedNurseSpawn = false;
		NPC.unlockedPrincessSpawn = false;
		Array.Clear(NPC.ShimmeredTownNPCs, 0, NPC.ShimmeredTownNPCs.Length);
		NPC.downedGoblins = false;
		NPC.downedClown = false;
		NPC.downedFrost = false;
		NPC.downedPirates = false;
		NPC.downedMartians = false;
		NPC.downedTowerSolar = (NPC.downedTowerVortex = (NPC.downedTowerNebula = (NPC.downedTowerStardust = (NPC.LunarApocalypseIsUp = false))));
		NPC.TowerActiveSolar = (NPC.TowerActiveVortex = (NPC.TowerActiveNebula = (NPC.TowerActiveStardust = false)));
		DD2Event.ResetProgressEntirely();
		NPC.ClearFoundActiveNPCs();
		Main.BestiaryTracker.Reset();
		Main.PylonSystem.Reset();
		CreativePowerManager.Instance.Reset();
		Main.CreativeMenu.Reset();
		shadowOrbSmashed = false;
		spawnMeteor = false;
		stopDrops = false;
		Main.invasionDelay = 0;
		Main.invasionType = 0;
		Main.invasionSize = 0;
		Main.invasionWarn = 0;
		Main.invasionX = 0.0;
		Main.invasionSizeStart = 0;
		Main.treeX[0] = Main.maxTilesX;
		Main.treeX[1] = Main.maxTilesX;
		Main.treeX[2] = Main.maxTilesX;
		Main.treeStyle[0] = 0;
		Main.treeStyle[1] = 0;
		Main.treeStyle[2] = 0;
		Main.treeStyle[3] = 0;
		noLiquidCheck = false;
		Liquid.numLiquid = 0;
		LiquidBuffer.numLiquidBuffer = 0;
		lastMaxTilesX = Main.maxTilesX;
		lastMaxTilesY = Main.maxTilesY;
		if (Main.netMode != 2)
		{
			Main.sectionManager = new WorldSections((Main.maxTilesX - 1) / 200 + 1, (Main.maxTilesY - 1) / 150 + 1);
		}
		Main.tile.ClearEverything();
		for (int j = 0; j < Main.countsAsHostForGameplay.Length; j++)
		{
			Main.countsAsHostForGameplay[j] = false;
		}
		CombatText.clearAll();
		PopupText.ClearAll();
		for (int num12 = 0; num12 < 6000; num12++)
		{
			Main.dust[num12] = new Dust();
			Main.dust[num12].dustIndex = num12;
		}
		for (int num13 = 0; num13 < 600; num13++)
		{
			Main.gore[num13] = new Gore();
		}
		for (int num14 = 0; num14 < 400; num14++)
		{
			Main.item[num14] = new Item();
			Main.item[num14].whoAmI = num14;
			Main.timeItemSlotCannotBeReusedFor[num14] = 0;
		}
		for (int num15 = 0; num15 < 200; num15++)
		{
			Main.npc[num15] = new NPC();
			Main.npc[num15].whoAmI = num15;
		}
		for (int num16 = 0; num16 < 1000; num16++)
		{
			Main.projectile[num16] = new Projectile();
			Main.projectile[num16].whoAmI = num16;
		}
		for (int num17 = 0; num17 < 8000; num17++)
		{
			Main.chest[num17] = null;
		}
		for (int num18 = 0; num18 < 1000; num18++)
		{
			Main.sign[num18] = null;
		}
		for (int num10 = 0; num10 < Liquid.maxLiquid; num10++)
		{
			Main.liquid[num10] = new Liquid();
		}
		for (int num11 = 0; num11 < 50000; num11++)
		{
			Main.liquidBuffer[num11] = new LiquidBuffer();
		}
		setWorldSize();
		Star.SpawnStars();
		SystemLoader.ClearWorld();
		worldCleared = true;
	}

	public static void setBG(int bg, int style)
	{
		switch (bg)
		{
		case 0:
			treeBG1 = style;
			SetForestBGSet(style, Main.treeMntBGSet1, Main.treeBGSet1);
			break;
		case 10:
			treeBG2 = style;
			SetForestBGSet(style, Main.treeMntBGSet2, Main.treeBGSet2);
			break;
		case 11:
			treeBG3 = style;
			SetForestBGSet(style, Main.treeMntBGSet3, Main.treeBGSet3);
			break;
		case 12:
			treeBG4 = style;
			SetForestBGSet(style, Main.treeMntBGSet4, Main.treeBGSet4);
			break;
		case 1:
			corruptBG = style;
			switch (style)
			{
			default:
				Main.corruptBG[0] = 12;
				Main.corruptBG[1] = 13;
				Main.corruptBG[2] = 14;
				break;
			case 1:
				Main.corruptBG[0] = 56;
				Main.corruptBG[1] = 57;
				Main.corruptBG[2] = 58;
				break;
			case 2:
				Main.corruptBG[0] = 211;
				Main.corruptBG[1] = 212;
				Main.corruptBG[2] = 213;
				break;
			case 3:
				Main.corruptBG[0] = 225;
				Main.corruptBG[1] = 226;
				Main.corruptBG[2] = 227;
				break;
			case 4:
				Main.corruptBG[0] = 240;
				Main.corruptBG[1] = 241;
				Main.corruptBG[2] = 242;
				break;
			}
			break;
		case 2:
			jungleBG = style;
			switch (style)
			{
			default:
				Main.jungleBG[0] = 15;
				Main.jungleBG[1] = 16;
				Main.jungleBG[2] = 17;
				break;
			case 1:
				Main.jungleBG[0] = 59;
				Main.jungleBG[1] = 60;
				Main.jungleBG[2] = 61;
				break;
			case 2:
				Main.jungleBG[0] = 222;
				Main.jungleBG[1] = 223;
				Main.jungleBG[2] = 224;
				break;
			case 3:
				Main.jungleBG[0] = 237;
				Main.jungleBG[1] = 238;
				Main.jungleBG[2] = 239;
				break;
			case 4:
				Main.jungleBG[0] = 284;
				Main.jungleBG[1] = 285;
				Main.jungleBG[2] = 286;
				break;
			case 5:
				Main.jungleBG[0] = 271;
				Main.jungleBG[1] = 272;
				Main.jungleBG[2] = 273;
				break;
			}
			break;
		case 3:
			snowBG = style;
			Main.snowMntBG[0] = 35;
			Main.snowMntBG[1] = 36;
			switch (style)
			{
			default:
				Main.snowBG[0] = 37;
				Main.snowBG[1] = 38;
				Main.snowBG[2] = 39;
				break;
			case 1:
				Main.snowBG[0] = 97;
				Main.snowBG[1] = 96;
				Main.snowBG[2] = 95;
				break;
			case 2:
				Main.snowMntBG[0] = 98;
				Main.snowMntBG[1] = 99;
				Main.snowBG[0] = -1;
				Main.snowBG[1] = -1;
				Main.snowBG[2] = -1;
				break;
			case 21:
				Main.snowMntBG[0] = 98;
				Main.snowMntBG[1] = 99;
				Main.snowBG[0] = 95;
				Main.snowBG[1] = 96;
				Main.snowBG[2] = 97;
				break;
			case 22:
				Main.snowMntBG[0] = 98;
				Main.snowMntBG[1] = 99;
				Main.snowBG[0] = 37;
				Main.snowBG[1] = 38;
				Main.snowBG[2] = 39;
				break;
			case 3:
				Main.snowMntBG[0] = 98;
				Main.snowMntBG[1] = 100;
				Main.snowBG[0] = -1;
				Main.snowBG[1] = -1;
				Main.snowBG[2] = -1;
				break;
			case 31:
				Main.snowMntBG[0] = 98;
				Main.snowMntBG[1] = 100;
				Main.snowBG[0] = 95;
				Main.snowBG[1] = 96;
				Main.snowBG[2] = 97;
				break;
			case 32:
				Main.snowMntBG[0] = 98;
				Main.snowMntBG[1] = 100;
				Main.snowBG[0] = 37;
				Main.snowBG[1] = 38;
				Main.snowBG[2] = 39;
				break;
			case 4:
				Main.snowMntBG[0] = 98;
				Main.snowMntBG[1] = 101;
				Main.snowBG[0] = -1;
				Main.snowBG[1] = -1;
				Main.snowBG[2] = -1;
				break;
			case 41:
				Main.snowMntBG[0] = 98;
				Main.snowMntBG[1] = 101;
				Main.snowBG[0] = 95;
				Main.snowBG[1] = 96;
				Main.snowBG[2] = 97;
				break;
			case 42:
				Main.snowMntBG[0] = 98;
				Main.snowMntBG[1] = 101;
				Main.snowBG[0] = 37;
				Main.snowBG[1] = 38;
				Main.snowBG[2] = 39;
				break;
			case 5:
				Main.snowMntBG[0] = -1;
				Main.snowMntBG[1] = -1;
				Main.snowBG[0] = 258;
				Main.snowBG[1] = 259;
				Main.snowBG[2] = 260;
				break;
			case 6:
				Main.snowMntBG[0] = -1;
				Main.snowMntBG[1] = -1;
				Main.snowBG[0] = 263;
				Main.snowBG[1] = 264;
				Main.snowBG[2] = 265;
				break;
			case 7:
				Main.snowMntBG[0] = 269;
				Main.snowMntBG[1] = 270;
				Main.snowBG[0] = 267;
				Main.snowBG[1] = 266;
				Main.snowBG[2] = 268;
				break;
			}
			break;
		case 4:
			hallowBG = style;
			switch (style)
			{
			default:
				Main.hallowBG[0] = 29;
				Main.hallowBG[1] = 30;
				Main.hallowBG[2] = 31;
				break;
			case 1:
				Main.hallowBG[0] = 102;
				Main.hallowBG[1] = 103;
				Main.hallowBG[2] = 104;
				break;
			case 2:
				Main.hallowBG[0] = 219;
				Main.hallowBG[1] = 220;
				Main.hallowBG[2] = 221;
				break;
			case 3:
				Main.hallowBG[0] = 243;
				Main.hallowBG[1] = 244;
				Main.hallowBG[2] = 245;
				break;
			case 4:
				Main.hallowBG[0] = -1;
				Main.hallowBG[1] = 261;
				Main.hallowBG[2] = 262;
				break;
			}
			break;
		case 5:
			crimsonBG = style;
			switch (style)
			{
			default:
				Main.crimsonBG[0] = 43;
				Main.crimsonBG[1] = 44;
				Main.crimsonBG[2] = 45;
				break;
			case 1:
				Main.crimsonBG[0] = 105;
				Main.crimsonBG[1] = 106;
				Main.crimsonBG[2] = 107;
				break;
			case 2:
				Main.crimsonBG[0] = 174;
				Main.crimsonBG[1] = -1;
				Main.crimsonBG[2] = 175;
				break;
			case 3:
				Main.crimsonBG[0] = 214;
				Main.crimsonBG[1] = 215;
				Main.crimsonBG[2] = 216;
				break;
			case 4:
				Main.crimsonBG[0] = -1;
				Main.crimsonBG[1] = 229;
				Main.crimsonBG[2] = 230;
				break;
			case 5:
				Main.crimsonBG[0] = 255;
				Main.crimsonBG[1] = 256;
				Main.crimsonBG[2] = 257;
				break;
			}
			break;
		case 6:
			desertBG = style;
			switch (style)
			{
			default:
				Main.desertBG[0] = 21;
				Main.desertBG[1] = 20;
				Main.desertBG[2] = -1;
				break;
			case 1:
				Main.desertBG[0] = 108;
				Main.desertBG[1] = 109;
				Main.desertBG[2] = -1;
				break;
			case 2:
				Main.desertBG[0] = 207;
				Main.desertBG[1] = 208;
				Main.desertBG[2] = -1;
				break;
			case 3:
				Main.desertBG[0] = 217;
				Main.desertBG[1] = 218;
				Main.desertBG[2] = -1;
				break;
			case 4:
				Main.desertBG[0] = 248;
				Main.desertBG[1] = 249;
				Main.desertBG[2] = 250;
				break;
			}
			break;
		case 7:
			oceanBG = style;
			switch (style)
			{
			default:
				Main.oceanBG = 28;
				break;
			case 1:
				Main.oceanBG = 110;
				break;
			case 2:
				Main.oceanBG = 111;
				break;
			case 3:
				Main.oceanBG = 209;
				break;
			case 4:
				Main.oceanBG = 210;
				break;
			case 5:
				Main.oceanBG = 283;
				break;
			}
			break;
		case 8:
			mushroomBG = style;
			switch (style)
			{
			default:
				Main.mushroomBG[0] = 46;
				Main.mushroomBG[1] = 47;
				Main.mushroomBG[2] = 48;
				break;
			case 1:
				Main.mushroomBG[0] = 231;
				Main.mushroomBG[1] = 232;
				Main.mushroomBG[2] = 233;
				break;
			case 2:
				Main.mushroomBG[0] = 234;
				Main.mushroomBG[1] = 235;
				Main.mushroomBG[2] = 236;
				break;
			case 3:
				Main.mushroomBG[0] = 287;
				Main.mushroomBG[1] = 288;
				Main.mushroomBG[2] = 289;
				break;
			}
			break;
		case 9:
			underworldBG = style;
			switch (style)
			{
			default:
				Main.underworldBG[0] = 0;
				Main.underworldBG[1] = 1;
				Main.underworldBG[2] = 2;
				Main.underworldBG[3] = 3;
				Main.underworldBG[4] = 4;
				break;
			case 1:
				Main.underworldBG[0] = 5;
				Main.underworldBG[1] = 6;
				Main.underworldBG[2] = 7;
				Main.underworldBG[3] = 8;
				Main.underworldBG[4] = 9;
				break;
			case 2:
				Main.underworldBG[0] = 10;
				Main.underworldBG[1] = 11;
				Main.underworldBG[2] = 12;
				Main.underworldBG[3] = 13;
				Main.underworldBG[4] = 9;
				break;
			}
			break;
		}
	}

	private static void SetForestBGSet(int style, int[] mountainSet, int[] treeSet)
	{
		mountainSet[0] = 7;
		mountainSet[1] = 8;
		switch (style)
		{
		case 1:
			treeSet[0] = 50;
			treeSet[1] = 51;
			treeSet[2] = 52;
			break;
		case 2:
			treeSet[0] = 53;
			treeSet[1] = 54;
			treeSet[2] = 55;
			break;
		case 3:
			mountainSet[1] = 90;
			treeSet[0] = 91;
			treeSet[1] = -1;
			treeSet[2] = 92;
			break;
		case 31:
			mountainSet[1] = 90;
			treeSet[0] = 91;
			treeSet[1] = -1;
			treeSet[2] = 11;
			break;
		case 4:
			mountainSet[0] = 93;
			mountainSet[1] = 94;
			treeSet[0] = -1;
			treeSet[1] = -1;
			treeSet[2] = -1;
			break;
		case 5:
			mountainSet[0] = 93;
			mountainSet[1] = 94;
			treeSet[0] = -1;
			treeSet[1] = -1;
			treeSet[2] = 55;
			break;
		case 51:
			mountainSet[0] = 93;
			mountainSet[1] = 94;
			treeSet[0] = -1;
			treeSet[1] = -1;
			treeSet[2] = 11;
			break;
		case 6:
			mountainSet[0] = 171;
			mountainSet[1] = 172;
			treeSet[0] = 173;
			treeSet[1] = -1;
			treeSet[2] = -1;
			break;
		case 7:
			mountainSet[0] = 176;
			mountainSet[1] = 177;
			treeSet[0] = 178;
			treeSet[1] = -1;
			treeSet[2] = -1;
			break;
		case 71:
			mountainSet[0] = 176;
			mountainSet[1] = 177;
			treeSet[0] = 178;
			treeSet[1] = -1;
			treeSet[2] = 11;
			break;
		case 72:
			mountainSet[0] = 176;
			mountainSet[1] = 177;
			treeSet[0] = 178;
			treeSet[1] = -1;
			treeSet[2] = 52;
			break;
		case 73:
			mountainSet[0] = 176;
			mountainSet[1] = 177;
			treeSet[0] = 178;
			treeSet[1] = -1;
			treeSet[2] = 55;
			break;
		case 8:
			mountainSet[0] = 179;
			mountainSet[1] = 180;
			treeSet[0] = 184;
			treeSet[1] = -1;
			treeSet[2] = -1;
			break;
		case 9:
			mountainSet[0] = 277;
			mountainSet[1] = 278;
			treeSet[0] = 279;
			treeSet[1] = -1;
			treeSet[2] = -1;
			break;
		case 10:
			mountainSet[0] = 280;
			mountainSet[1] = 281;
			treeSet[0] = 282;
			treeSet[1] = -1;
			treeSet[2] = -1;
			break;
		default:
			treeSet[0] = 9;
			treeSet[1] = 10;
			treeSet[2] = 11;
			break;
		}
	}

	public static void RandomizeWeather()
	{
		Main.numClouds = genRand.Next(10, 200);
		Main.windSpeedCurrent = 0f;
		while (Main.windSpeedCurrent == 0f)
		{
			Main.windSpeedCurrent = (float)genRand.Next(-400, 401) * 0.001f;
			Main.windSpeedTarget = Main.windSpeedCurrent;
		}
		Cloud.resetClouds();
	}

	public static void RandomizeMoonState(UnifiedRandom random, bool garenteeNewStyle = false)
	{
		int moonType = Main.moonType;
		do
		{
			Main.moonType = random.Next(9);
		}
		while (garenteeNewStyle && moonType == Main.moonType);
	}

	public static void RandomizeBackgroundBasedOnPlayer(UnifiedRandom random, Player player)
	{
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		if (player.ZoneGlowshroom)
		{
			int num = mushroomBG;
			while (num == mushroomBG)
			{
				setBG(8, random.Next(4));
			}
		}
		else if (player.ZoneUnderworldHeight)
		{
			int num2 = underworldBG;
			while (num2 == underworldBG)
			{
				setBG(9, random.Next(3));
			}
		}
		else if (player.ZoneDesert)
		{
			int num3 = desertBG;
			while (num3 == desertBG)
			{
				setBG(6, random.Next(5));
			}
		}
		else if (player.ZoneHallow)
		{
			int num4 = hallowBG;
			while (num4 == hallowBG)
			{
				setBG(4, random.Next(5));
			}
		}
		else if (player.ZoneCorrupt)
		{
			int num5 = corruptBG;
			while (num5 == corruptBG)
			{
				setBG(1, random.Next(5));
			}
		}
		else if (player.ZoneCrimson)
		{
			int num6 = crimsonBG;
			while (num6 == crimsonBG)
			{
				setBG(5, random.Next(6));
			}
		}
		else if (player.ZoneJungle)
		{
			int num7 = jungleBG;
			while (num7 == jungleBG)
			{
				setBG(2, random.Next(6));
			}
		}
		else if (player.ZoneSnow)
		{
			int num8 = snowBG;
			while (num8 == snowBG)
			{
				snowBG = random.Next(8);
				if (snowBG == 2 && random.Next(2) == 0)
				{
					if (random.Next(2) == 0)
					{
						snowBG = 21;
					}
					else
					{
						snowBG = 22;
					}
				}
				if (snowBG == 3 && random.Next(2) == 0)
				{
					if (random.Next(2) == 0)
					{
						snowBG = 31;
					}
					else
					{
						snowBG = 32;
					}
				}
				if (snowBG == 4 && random.Next(2) == 0)
				{
					if (random.Next(2) == 0)
					{
						snowBG = 41;
					}
					else
					{
						snowBG = 42;
					}
				}
				setBG(3, snowBG);
			}
		}
		else if (player.ZoneBeach)
		{
			int num9 = oceanBG;
			while (num9 == oceanBG)
			{
				setBG(7, random.Next(6));
			}
		}
		else
		{
			int num14 = (int)(player.Center.X / 16f);
			if (num14 < Main.treeX[0])
			{
				int num10 = treeBG1;
				while (IsBackgroundConsideredTheSame(num10, treeBG1))
				{
					treeBG1 = RollRandomForestBGStyle(random);
				}
				setBG(0, treeBG1);
			}
			else if (num14 < Main.treeX[1])
			{
				int num11 = treeBG2;
				while (IsBackgroundConsideredTheSame(num11, treeBG2))
				{
					treeBG2 = RollRandomForestBGStyle(random);
				}
				setBG(10, treeBG2);
			}
			else if (num14 < Main.treeX[2])
			{
				int num12 = treeBG3;
				while (IsBackgroundConsideredTheSame(num12, treeBG3))
				{
					treeBG3 = RollRandomForestBGStyle(random);
				}
				setBG(11, treeBG3);
			}
			else
			{
				int num13 = treeBG4;
				while (IsBackgroundConsideredTheSame(num13, treeBG4))
				{
					treeBG4 = RollRandomForestBGStyle(random);
				}
				setBG(12, treeBG4);
			}
		}
		BackgroundsCache.UpdateCache();
	}

	public static void RandomizeBackgrounds(UnifiedRandom random)
	{
		treeBG1 = RollRandomForestBGStyle(random);
		for (treeBG2 = RollRandomForestBGStyle(random); treeBG2 == treeBG1; treeBG2 = RollRandomForestBGStyle(random))
		{
		}
		treeBG3 = RollRandomForestBGStyle(random);
		while (treeBG3 == treeBG1 || treeBG3 == treeBG2)
		{
			treeBG3 = RollRandomForestBGStyle(random);
		}
		treeBG4 = RollRandomForestBGStyle(random);
		while (treeBG4 == treeBG1 || treeBG4 == treeBG2 || treeBG4 == treeBG3)
		{
			treeBG4 = RollRandomForestBGStyle(random);
		}
		setBG(0, treeBG1);
		setBG(10, treeBG2);
		setBG(11, treeBG3);
		setBG(12, treeBG4);
		setBG(1, random.Next(5));
		setBG(2, random.Next(6));
		snowBG = random.Next(8);
		if (snowBG == 2 && random.Next(2) == 0)
		{
			if (random.Next(2) == 0)
			{
				snowBG = 21;
			}
			else
			{
				snowBG = 22;
			}
		}
		if (snowBG == 3 && random.Next(2) == 0)
		{
			if (random.Next(2) == 0)
			{
				snowBG = 31;
			}
			else
			{
				snowBG = 32;
			}
		}
		if (snowBG == 4 && random.Next(2) == 0)
		{
			if (random.Next(2) == 0)
			{
				snowBG = 41;
			}
			else
			{
				snowBG = 42;
			}
		}
		setBG(3, snowBG);
		setBG(4, random.Next(5));
		setBG(5, random.Next(6));
		setBG(6, random.Next(5));
		setBG(7, random.Next(6));
		setBG(8, random.Next(4));
		setBG(9, random.Next(3));
	}

	private static int RollRandomForestBGStyle(UnifiedRandom random)
	{
		int num = random.Next(11);
		if ((num == 1 || num == 2) && random.Next(2) == 0)
		{
			num = random.Next(11);
		}
		if (num == 0)
		{
			num = random.Next(11);
		}
		if (num == 3 && random.Next(3) == 0)
		{
			num = 31;
		}
		if (num == 5 && random.Next(2) == 0)
		{
			num = 51;
		}
		if (num == 7 && random.Next(4) == 0)
		{
			num = random.Next(71, 74);
		}
		return num;
	}

	public static bool IsBackgroundConsideredTheSame(int oldBG, int newBG)
	{
		switch (oldBG)
		{
		case 3:
		case 31:
			if (newBG != 3)
			{
				return newBG == 31;
			}
			return true;
		case 5:
		case 51:
			if (newBG != 5)
			{
				return newBG == 51;
			}
			return true;
		case 7:
		case 71:
		case 72:
		case 73:
			if (newBG != 7)
			{
				if (newBG >= 71)
				{
					return newBG <= 73;
				}
				return false;
			}
			return true;
		default:
			return oldBG == newBG;
		}
	}

	public static void RandomizeTreeStyle()
	{
		if (Main.maxTilesX == 4200)
		{
			Main.treeX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.5 - (double)Main.maxTilesX * 0.25), (int)((double)Main.maxTilesX * 0.5 + (double)Main.maxTilesX * 0.25));
			Main.treeStyle[0] = genRand.Next(6);
			Main.treeStyle[1] = genRand.Next(6);
			while (Main.treeStyle[1] == Main.treeStyle[0])
			{
				Main.treeStyle[1] = genRand.Next(6);
			}
			Main.treeX[1] = Main.maxTilesX;
			Main.treeX[2] = Main.maxTilesX;
			for (int i = 0; i < 2; i++)
			{
				if (Main.treeStyle[i] == 0 && genRand.Next(3) != 0)
				{
					Main.treeStyle[i] = 4;
				}
			}
			return;
		}
		if (Main.maxTilesX == 6400)
		{
			Main.treeX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.334 - (double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.334 + (double)Main.maxTilesX * 0.2));
			Main.treeX[1] = genRand.Next((int)((double)Main.maxTilesX * 0.667 - (double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.667 + (double)Main.maxTilesX * 0.2));
			Main.treeStyle[0] = genRand.Next(6);
			Main.treeStyle[1] = genRand.Next(6);
			Main.treeStyle[2] = genRand.Next(6);
			while (Main.treeStyle[1] == Main.treeStyle[0])
			{
				Main.treeStyle[1] = genRand.Next(6);
			}
			while (Main.treeStyle[2] == Main.treeStyle[0] || Main.treeStyle[2] == Main.treeStyle[1])
			{
				Main.treeStyle[2] = genRand.Next(6);
			}
			Main.treeX[2] = Main.maxTilesX;
			for (int j = 0; j < 3; j++)
			{
				if (Main.treeStyle[j] == 0 && genRand.Next(3) != 0)
				{
					Main.treeStyle[j] = 4;
				}
			}
			return;
		}
		Main.treeX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.25 - (double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.25 + (double)Main.maxTilesX * 0.15));
		Main.treeX[1] = genRand.Next((int)((double)Main.maxTilesX * 0.5 - (double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.5 + (double)Main.maxTilesX * 0.15));
		Main.treeX[2] = genRand.Next((int)((double)Main.maxTilesX * 0.75 - (double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.75 + (double)Main.maxTilesX * 0.15));
		Main.treeStyle[0] = genRand.Next(6);
		Main.treeStyle[1] = genRand.Next(6);
		Main.treeStyle[2] = genRand.Next(6);
		Main.treeStyle[3] = genRand.Next(6);
		while (Main.treeStyle[1] == Main.treeStyle[0])
		{
			Main.treeStyle[1] = genRand.Next(6);
		}
		while (Main.treeStyle[2] == Main.treeStyle[0] || Main.treeStyle[2] == Main.treeStyle[1])
		{
			Main.treeStyle[2] = genRand.Next(6);
		}
		while (Main.treeStyle[3] == Main.treeStyle[0] || Main.treeStyle[3] == Main.treeStyle[1] || Main.treeStyle[3] == Main.treeStyle[2])
		{
			Main.treeStyle[3] = genRand.Next(6);
		}
		for (int k = 0; k < 4; k++)
		{
			if (Main.treeStyle[k] == 0 && genRand.Next(3) != 0)
			{
				Main.treeStyle[k] = 4;
			}
		}
	}

	public static void RandomizeCaveBackgrounds()
	{
		int maxValue = 8;
		if (Main.maxTilesX == 4200)
		{
			Main.caveBackX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.5 - (double)Main.maxTilesX * 0.25), (int)((double)Main.maxTilesX * 0.5 + (double)Main.maxTilesX * 0.25));
			Main.caveBackX[1] = Main.maxTilesX;
			Main.caveBackX[2] = Main.maxTilesX;
			Main.caveBackStyle[0] = genRand.Next(maxValue);
			Main.caveBackStyle[1] = genRand.Next(maxValue);
			while (Main.caveBackStyle[1] == Main.caveBackStyle[0])
			{
				Main.caveBackStyle[1] = genRand.Next(maxValue);
			}
		}
		else if (Main.maxTilesX == 6400)
		{
			Main.caveBackX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.334 - (double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.334 + (double)Main.maxTilesX * 0.2));
			Main.caveBackX[1] = genRand.Next((int)((double)Main.maxTilesX * 0.667 - (double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.667 + (double)Main.maxTilesX * 0.2));
			Main.caveBackX[2] = Main.maxTilesX;
			Main.caveBackStyle[0] = genRand.Next(maxValue);
			Main.caveBackStyle[1] = genRand.Next(maxValue);
			Main.caveBackStyle[2] = genRand.Next(maxValue);
			while (Main.caveBackStyle[1] == Main.caveBackStyle[0])
			{
				Main.caveBackStyle[1] = genRand.Next(maxValue);
			}
			while (Main.caveBackStyle[2] == Main.caveBackStyle[0] || Main.caveBackStyle[2] == Main.caveBackStyle[1])
			{
				Main.caveBackStyle[2] = genRand.Next(maxValue);
			}
		}
		else
		{
			Main.caveBackX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.25 - (double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.25 + (double)Main.maxTilesX * 0.15));
			Main.caveBackX[1] = genRand.Next((int)((double)Main.maxTilesX * 0.5 - (double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.5 + (double)Main.maxTilesX * 0.15));
			Main.caveBackX[2] = genRand.Next((int)((double)Main.maxTilesX * 0.75 - (double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.75 + (double)Main.maxTilesX * 0.15));
			Main.caveBackStyle[0] = genRand.Next(maxValue);
			Main.caveBackStyle[1] = genRand.Next(maxValue);
			Main.caveBackStyle[2] = genRand.Next(maxValue);
			Main.caveBackStyle[3] = genRand.Next(maxValue);
			while (Main.caveBackStyle[1] == Main.caveBackStyle[0])
			{
				Main.caveBackStyle[1] = genRand.Next(maxValue);
			}
			while (Main.caveBackStyle[2] == Main.caveBackStyle[0] || Main.caveBackStyle[2] == Main.caveBackStyle[1])
			{
				Main.caveBackStyle[2] = genRand.Next(maxValue);
			}
			while (Main.caveBackStyle[3] == Main.caveBackStyle[0] || Main.caveBackStyle[3] == Main.caveBackStyle[1] || Main.caveBackStyle[3] == Main.caveBackStyle[2])
			{
				Main.caveBackStyle[3] = genRand.Next(maxValue);
			}
		}
		Main.iceBackStyle = genRand.Next(4);
		Main.hellBackStyle = genRand.Next(3);
		Main.jungleBackStyle = genRand.Next(2);
	}

	private static void ResetGenerator()
	{
		GenVars.numOrePatch = 0;
		GenVars.numTunnels = 0;
		GenVars.numLakes = 0;
		GenVars.numMushroomBiomes = 0;
		GenVars.numOceanCaveTreasure = 0;
		GenVars.numOasis = 0;
		GenVars.mudWall = false;
		GenVars.hellChest = 0;
		GenVars.JungleX = 0;
		GenVars.numMCaves = 0;
		GenVars.numIslandHouses = 0;
		GenVars.skyIslandHouseCount = 0;
		GenVars.dEnteranceX = 0;
		GenVars.numDRooms = 0;
		GenVars.numDDoors = 0;
		GenVars.generatedShadowKey = false;
		GenVars.numDungeonPlatforms = 0;
		GenVars.numJChests = 0;
		GenVars.JungleItemCount = 0;
		GenVars.lastDungeonHall = Vector2D.Zero;
	}

	public static bool mayanTrap(int x2, int y2)
	{
		int num = 1;
		if (genRand.Next(3) == 0)
		{
			num = 0;
		}
		int num12 = y2;
		while (!SolidOrSlopedTile(x2, num12))
		{
			num12++;
			if (num12 >= Main.maxTilesY - 300)
			{
				return false;
			}
		}
		Tile tile = Main.tile[x2, num12];
		if (tile.type != 232)
		{
			tile = Main.tile[x2, num12];
			if (tile.type != 10)
			{
				num12--;
				tile = Main.tile[x2, num12];
				if (tile.liquid > 0)
				{
					tile = Main.tile[x2, num12];
					if (tile.lava())
					{
						return false;
					}
				}
				if (num == -1 && genRand.Next(20) == 0)
				{
					num = 2;
				}
				else if (num == -1)
				{
					num = genRand.Next(2);
				}
				tile = Main.tile[x2, num12];
				if (!tile.nactive())
				{
					tile = Main.tile[x2 - 1, num12];
					if (!tile.nactive())
					{
						tile = Main.tile[x2 + 1, num12];
						if (!tile.nactive())
						{
							tile = Main.tile[x2, num12 - 1];
							if (!tile.nactive())
							{
								tile = Main.tile[x2 - 1, num12 - 1];
								if (!tile.nactive())
								{
									tile = Main.tile[x2 + 1, num12 - 1];
									if (!tile.nactive())
									{
										tile = Main.tile[x2, num12 - 2];
										if (!tile.nactive())
										{
											tile = Main.tile[x2 - 1, num12 - 2];
											if (!tile.nactive())
											{
												tile = Main.tile[x2 + 1, num12 - 2];
												if (!tile.nactive())
												{
													tile = Main.tile[x2, num12 + 1];
													if (tile.type == 10)
													{
														return false;
													}
													tile = Main.tile[x2, num12 + 1];
													if (tile.type == 48)
													{
														return false;
													}
													tile = Main.tile[x2, num12 + 1];
													if (tile.type == 232)
													{
														return false;
													}
													int num5;
													int num6;
													int num7;
													bool flag;
													bool flag2;
													int num10;
													int num4;
													int num11;
													int num23;
													int style2;
													int num13;
													int num14;
													int num15;
													int num16;
													switch (num)
													{
													case 0:
													{
														num4 = x2;
														num5 = num12;
														num5 -= genRand.Next(3);
														while (InWorld(num4, num5, 5) && !SolidOrSlopedTile(num4, num5))
														{
															num4--;
														}
														num6 = num4;
														for (num4 = x2; InWorld(num4, num5, 5) && !SolidOrSlopedTile(num4, num5); num4++)
														{
														}
														num7 = num4;
														int num8 = x2 - num6;
														int num9 = num7 - x2;
														flag = false;
														flag2 = false;
														if (num8 > 5 && num8 < 50)
														{
															flag = true;
														}
														if (num9 > 5 && num9 < 50)
														{
															flag2 = true;
														}
														if (flag && !SolidOrSlopedTile(num6, num5 + 1))
														{
															flag = false;
														}
														if (flag2 && !SolidOrSlopedTile(num7, num5 + 1))
														{
															flag2 = false;
														}
														if (flag)
														{
															tile = Main.tile[num6, num5];
															if (tile.type != 10)
															{
																tile = Main.tile[num6, num5];
																if (tile.type != 48)
																{
																	tile = Main.tile[num6, num5 + 1];
																	if (tile.type != 10)
																	{
																		tile = Main.tile[num6, num5 + 1];
																		if (tile.type != 48)
																		{
																			goto IL_0338;
																		}
																	}
																}
															}
															flag = false;
														}
														goto IL_0338;
													}
													case 1:
													{
														int num17 = num12;
														while (!SolidOrSlopedTile(x2, num17))
														{
															num17--;
															if ((double)num17 < Main.worldSurface)
															{
																return false;
															}
														}
														int num18 = Math.Abs(num17 - num12);
														if (num18 < 3)
														{
															return false;
														}
														int num19 = genRand.Next(3);
														tile = Main.tile[x2, num12];
														if (tile.wire())
														{
															num19 = 0;
														}
														tile = Main.tile[x2, num12];
														if (tile.wire2())
														{
															num19 = 1;
														}
														tile = Main.tile[x2, num12];
														if (tile.wire3())
														{
															num19 = 2;
														}
														int style = 3;
														if (num18 < 16 && genRand.Next(3) != 0)
														{
															style = 4;
														}
														tile = Main.tile[x2, num17];
														if (tile.type == 135)
														{
															return false;
														}
														tile = Main.tile[x2, num17];
														if (tile.type == 137)
														{
															return false;
														}
														tile = Main.tile[x2, num17];
														if (tile.type == 232)
														{
															return false;
														}
														tile = Main.tile[x2, num17];
														if (tile.type == 237)
														{
															return false;
														}
														tile = Main.tile[x2, num17];
														if (tile.type == 10)
														{
															return false;
														}
														tile = Main.tile[x2, num17];
														if (tile.wall != 87)
														{
															return false;
														}
														PlaceTile(x2, num12, 135, mute: true, forced: true, -1, 6);
														PlaceTile(x2, num17, 137, mute: true, forced: true, -1, style);
														for (int i = 0; i < 2; i++)
														{
															int num20 = genRand.Next(1, 5);
															int num21 = x2;
															int num22 = -1;
															if (i == 1)
															{
																num22 = 1;
															}
															while (num20 > 0)
															{
																num20--;
																num21 += num22;
																if (!SolidTile(num21, num17 - 1) || SolidOrSlopedTile(num21, num17 + 1))
																{
																	break;
																}
																PlaceTile(num21, num17, 137, mute: true, forced: true, -1, style);
																switch (num19)
																{
																case 0:
																	tile = Main.tile[num21, num17];
																	tile.wire(wire: true);
																	break;
																case 1:
																	tile = Main.tile[num21, num17];
																	tile.wire2(wire2: true);
																	break;
																case 2:
																	tile = Main.tile[num21, num17];
																	tile.wire3(wire3: true);
																	break;
																}
															}
														}
														int num2 = x2;
														int num3 = num12;
														while (num2 != x2 || num3 != num17)
														{
															switch (num19)
															{
															case 0:
																tile = Main.tile[num2, num3];
																tile.wire(wire: true);
																break;
															case 1:
																tile = Main.tile[num2, num3];
																tile.wire2(wire2: true);
																break;
															case 2:
																tile = Main.tile[num2, num3];
																tile.wire3(wire3: true);
																break;
															}
															if (num2 > x2)
															{
																num2--;
															}
															if (num2 < x2)
															{
																num2++;
															}
															switch (num19)
															{
															case 0:
																tile = Main.tile[num2, num3];
																tile.wire(wire: true);
																break;
															case 1:
																tile = Main.tile[num2, num3];
																tile.wire2(wire2: true);
																break;
															case 2:
																tile = Main.tile[num2, num3];
																tile.wire3(wire3: true);
																break;
															}
															if (num3 > num17)
															{
																num3--;
															}
															if (num3 < num17)
															{
																num3++;
															}
															switch (num19)
															{
															case 0:
																tile = Main.tile[num2, num3];
																tile.wire(wire: true);
																break;
															case 1:
																tile = Main.tile[num2, num3];
																tile.wire2(wire2: true);
																break;
															case 2:
																tile = Main.tile[num2, num3];
																tile.wire3(wire3: true);
																break;
															}
														}
														return true;
													}
													default:
														{
															return false;
														}
														IL_03af:
														num10 = 0;
														if (flag && flag2)
														{
															num10 = 1;
															num4 = num6;
															if (genRand.Next(2) == 0)
															{
																num4 = num7;
																num10 = -1;
															}
														}
														else if (flag2)
														{
															num4 = num7;
															num10 = -1;
														}
														else
														{
															if (!flag)
															{
																return false;
															}
															num4 = num6;
															num10 = 1;
														}
														tile = Main.tile[num4, num5];
														if (tile.wall != 87)
														{
															return false;
														}
														tile = Main.tile[num4, num5];
														if (tile.type == 190)
														{
															return false;
														}
														tile = Main.tile[num4, num5];
														if (tile.type == 135)
														{
															return false;
														}
														tile = Main.tile[num4, num5];
														if (tile.type == 137)
														{
															return false;
														}
														tile = Main.tile[num4, num5];
														if (tile.type == 232)
														{
															return false;
														}
														tile = Main.tile[num4, num5];
														if (tile.type == 237)
														{
															return false;
														}
														tile = Main.tile[num4, num5];
														if (tile.type == 10)
														{
															return false;
														}
														PlaceTile(x2, num12, 135, mute: true, forced: true, -1, 6);
														KillTile(num4, num5);
														num11 = genRand.Next(3);
														tile = Main.tile[x2, num12];
														if (tile.wire())
														{
															num11 = 0;
														}
														tile = Main.tile[x2, num12];
														if (tile.wire2())
														{
															num11 = 1;
														}
														tile = Main.tile[x2, num12];
														if (tile.wire3())
														{
															num11 = 2;
														}
														num23 = Math.Abs(num4 - x2);
														style2 = 1;
														if (num23 < 10 && genRand.Next(3) != 0)
														{
															style2 = 2;
														}
														PlaceTile(num4, num5, 137, mute: true, forced: true, -1, style2);
														if (num10 == 1)
														{
															tile = Main.tile[num4, num5];
															tile.frameX += 18;
														}
														num13 = genRand.Next(5);
														num14 = num5;
														while (num13 > 0)
														{
															num13--;
															num14--;
															if (!SolidTile(num4, num14) || !SolidTile(num4 - num10, num14) || SolidOrSlopedTile(num4 + num10, num14))
															{
																break;
															}
															PlaceTile(num4, num14, 137, mute: true, forced: true, -1, style2);
															if (num10 == 1)
															{
																tile = Main.tile[num4, num14];
																tile.frameX += 18;
															}
															switch (num11)
															{
															case 0:
																tile = Main.tile[num4, num14];
																tile.wire(wire: true);
																break;
															case 1:
																tile = Main.tile[num4, num14];
																tile.wire2(wire2: true);
																break;
															case 2:
																tile = Main.tile[num4, num14];
																tile.wire3(wire3: true);
																break;
															}
														}
														num15 = x2;
														num16 = num12;
														while (num15 != num4 || num16 != num5)
														{
															switch (num11)
															{
															case 0:
																tile = Main.tile[num15, num16];
																tile.wire(wire: true);
																break;
															case 1:
																tile = Main.tile[num15, num16];
																tile.wire2(wire2: true);
																break;
															case 2:
																tile = Main.tile[num15, num16];
																tile.wire3(wire3: true);
																break;
															}
															if (num15 > num4)
															{
																num15--;
															}
															if (num15 < num4)
															{
																num15++;
															}
															switch (num11)
															{
															case 0:
																tile = Main.tile[num15, num16];
																tile.wire(wire: true);
																break;
															case 1:
																tile = Main.tile[num15, num16];
																tile.wire2(wire2: true);
																break;
															case 2:
																tile = Main.tile[num15, num16];
																tile.wire3(wire3: true);
																break;
															}
															if (num16 > num5)
															{
																num16--;
															}
															if (num16 < num5)
															{
																num16++;
															}
															switch (num11)
															{
															case 0:
																tile = Main.tile[num15, num16];
																tile.wire(wire: true);
																break;
															case 1:
																tile = Main.tile[num15, num16];
																tile.wire2(wire2: true);
																break;
															case 2:
																tile = Main.tile[num15, num16];
																tile.wire3(wire3: true);
																break;
															}
														}
														return true;
														IL_0338:
														if (flag2)
														{
															tile = Main.tile[num7, num5];
															if (tile.type != 10)
															{
																tile = Main.tile[num7, num5];
																if (tile.type != 48)
																{
																	tile = Main.tile[num7, num5 + 1];
																	if (tile.type != 10)
																	{
																		tile = Main.tile[num7, num5 + 1];
																		if (tile.type != 48)
																		{
																			goto IL_03af;
																		}
																	}
																}
															}
															flag2 = false;
														}
														goto IL_03af;
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				return false;
			}
		}
		return false;
	}

	public static bool placeLavaTrap(int x, int y)
	{
		int num = 5;
		int num3 = 50;
		int num4 = 40;
		int num5 = 20;
		int num6 = 4;
		if (Main.tile[x, y].active() || Main.tile[x, y].liquid < byte.MaxValue || !Main.tile[x, y].lava())
		{
			return false;
		}
		int num7 = 0;
		for (int i = x - num; i <= x + num; i++)
		{
			for (int j = y - num; j <= y + num; j++)
			{
				if (Main.tile[i, j].lava() && !Main.tile[i, j].active() && Main.tile[i, j].liquid == byte.MaxValue)
				{
					num7++;
				}
			}
		}
		if (num7 < num3)
		{
			return false;
		}
		int num8 = y;
		while (!Main.tile[x, num8].active())
		{
			num8++;
			if (num8 > Main.maxTilesY - 200)
			{
				return false;
			}
		}
		if (!Main.tileSolid[Main.tile[x, num8].type] || Main.tileSolidTop[Main.tile[x, num8].type])
		{
			return false;
		}
		int num9 = num8;
		for (int k = x - num5; k <= x + num5; k++)
		{
			for (int l = num8 - num5; l <= num8 + num5; l++)
			{
				if (Main.tile[k, l].wire())
				{
					return false;
				}
			}
		}
		while (Main.tile[x, num8].active() && Main.tileSolid[Main.tile[x, num8].type] && !Main.tileSolidTop[Main.tile[x, num8].type])
		{
			num8++;
			if (num8 > Main.maxTilesY - 200)
			{
				return false;
			}
		}
		Tile tile = Main.tile[x, num8 - 1];
		if (Main.tileDungeon[tile.type] || tile.type == 225 || tile.type == 226)
		{
			return false;
		}
		int num10 = num8;
		while (!Main.tile[x, num8].active())
		{
			num8++;
			if (num8 > Main.maxTilesY - 200 || Main.tile[x, num8].liquid > 0)
			{
				return false;
			}
		}
		if (!Main.tileSolid[Main.tile[x, num8].type] || Main.tileSolidTop[Main.tile[x, num8].type] || Main.tile[x, num8].type == 162)
		{
			return false;
		}
		int num2 = num8 - 1;
		if (num2 - num9 > num4)
		{
			return false;
		}
		if (num2 - num10 < num6)
		{
			return false;
		}
		Main.tile[x, num8].slope(0);
		Main.tile[x, num8].halfBrick(halfBrick: false);
		PlaceTile(x, num2, 135, mute: false, forced: true, -1, 7);
		for (int m = num9; m <= num2; m++)
		{
			Main.tile[x, m].wire(wire: true);
			if (m < num10)
			{
				Main.tile[x, m].slope(0);
				Main.tile[x, m].halfBrick(halfBrick: false);
				Main.tile[x, m].actuator(actuator: true);
			}
		}
		return true;
	}

	public static bool IsTileNearby(int x, int y, int type, int distance)
	{
		for (int i = x - distance; i <= x + distance; i++)
		{
			for (int j = y - distance; j <= y + distance; j++)
			{
				if (InWorld(i, j) && Main.tile[i, j].active() && Main.tile[i, j].type == type)
				{
					return true;
				}
			}
		}
		return false;
	}

	private static bool placeTNTBarrel(int x, int y)
	{
		int num = y;
		while (!Main.tile[x, num].active())
		{
			num++;
			if (num > Main.maxTilesY - 350)
			{
				return false;
			}
		}
		num--;
		if (Main.tile[x, num].shimmer())
		{
			return false;
		}
		if (PlaceTile(x, num, 654))
		{
			return true;
		}
		return false;
	}

	public static bool placeTrap(int x2, int y2, int type = -1)
	{
		int num = y2;
		if (Vector2D.Distance(new Vector2D(x2, y2), GenVars.shimmerPosition) < 100.0)
		{
			return false;
		}
		bool flag = false;
		bool flag2 = false;
		if (noTrapsWorldGen)
		{
			Main.tileSolid[138] = false;
		}
		while (!SolidTile(x2, num))
		{
			num++;
			if (num > Main.maxTilesY - 10)
			{
				return false;
			}
			if (num >= Main.maxTilesY - 300)
			{
				flag2 = true;
			}
		}
		if (noTrapsWorldGen)
		{
			Main.tileSolid[138] = true;
		}
		num--;
		if (!noTrapsWorldGen && IsTileNearby(x2, num, 70, 20))
		{
			return false;
		}
		Tile tile = Main.tile[x2, num];
		if (tile.wall == 87)
		{
			return false;
		}
		tile = Main.tile[x2, num];
		if (tile.liquid > 0)
		{
			tile = Main.tile[x2, num];
			if (tile.lava())
			{
				flag = true;
			}
		}
		if (Main.remixWorld)
		{
			if (type == -1 && genRand.Next(20) == 0)
			{
				type = 2;
			}
			else if (type == -1 && (double)num < Main.rockLayer - 30.0 && genRand.Next(3) != 0)
			{
				type = 3;
			}
			else if (type == -1)
			{
				type = genRand.Next(2);
			}
		}
		else if (type == -1 && genRand.Next(20) == 0)
		{
			type = 2;
		}
		else if (type == -1 && num > GenVars.lavaLine + 30 && genRand.Next(6) != 0)
		{
			type = 3;
		}
		else if (type == -1)
		{
			type = genRand.Next(2);
		}
		if (!InWorld(x2, num, 3))
		{
			return false;
		}
		if (flag && type != 3)
		{
			return false;
		}
		if (flag2 && type != 3)
		{
			return false;
		}
		tile = Main.tile[x2, num];
		if (!tile.nactive())
		{
			tile = Main.tile[x2 - 1, num];
			if (!tile.nactive())
			{
				tile = Main.tile[x2 + 1, num];
				if (!tile.nactive())
				{
					tile = Main.tile[x2, num - 1];
					if (!tile.nactive())
					{
						tile = Main.tile[x2 - 1, num - 1];
						if (!tile.nactive())
						{
							tile = Main.tile[x2 + 1, num - 1];
							if (!tile.nactive())
							{
								tile = Main.tile[x2, num - 2];
								if (!tile.nactive())
								{
									tile = Main.tile[x2 - 1, num - 2];
									if (!tile.nactive())
									{
										tile = Main.tile[x2 + 1, num - 2];
										if (!tile.nactive())
										{
											tile = Main.tile[x2, num + 1];
											if (tile.type == 48)
											{
												return false;
											}
											tile = Main.tile[x2, num + 1];
											if (tile.type == 232)
											{
												return false;
											}
											if (type == 1)
											{
												for (int i = x2 - 3; i <= x2 + 3; i++)
												{
													for (int j = num - 3; j <= num + 3; j++)
													{
														tile = Main.tile[i, j];
														if (tile.type != 147)
														{
															tile = Main.tile[i, j];
															if (tile.type != 161)
															{
																continue;
															}
														}
														type = 0;
													}
												}
											}
											if (noTrapsWorldGen)
											{
												Main.tileSolid[138] = false;
											}
											int num14;
											int num15;
											int num16;
											bool flag5;
											bool flag6;
											int num19;
											int num13;
											int num20;
											int num21;
											switch (type)
											{
											case 0:
											{
												num13 = x2;
												num14 = num;
												num14 -= genRand.Next(3);
												while (!SolidTile(num13, num14))
												{
													bool[] tileCracked = Main.tileCracked;
													tile = Main.tile[num13, num14];
													if (tileCracked[tile.type])
													{
														break;
													}
													num13--;
													if (num13 < 0)
													{
														return false;
													}
												}
												num15 = num13;
												num13 = x2;
												while (!SolidTile(num13, num14))
												{
													bool[] tileCracked2 = Main.tileCracked;
													tile = Main.tile[num13, num14];
													if (tileCracked2[tile.type])
													{
														break;
													}
													num13++;
													if (num13 > Main.maxTilesX)
													{
														return false;
													}
												}
												num16 = num13;
												int num17 = x2 - num15;
												int num18 = num16 - x2;
												flag5 = false;
												flag6 = false;
												if (num17 > 5 && num17 < 50)
												{
													flag5 = true;
												}
												if (num18 > 5 && num18 < 50)
												{
													flag6 = true;
												}
												if (flag5 && !SolidTile(num15, num14 + 1))
												{
													flag5 = false;
												}
												if (flag6 && !SolidTile(num16, num14 + 1))
												{
													flag6 = false;
												}
												if (flag5)
												{
													tile = Main.tile[num15, num14];
													if (tile.type != 10)
													{
														tile = Main.tile[num15, num14];
														if (tile.type != 48)
														{
															tile = Main.tile[num15, num14 + 1];
															if (tile.type != 10)
															{
																tile = Main.tile[num15, num14 + 1];
																if (tile.type != 48)
																{
																	goto IL_04cc;
																}
															}
														}
													}
													flag5 = false;
												}
												goto IL_04cc;
											}
											case 1:
											{
												if (noTrapsWorldGen)
												{
													Main.tileSolid[138] = true;
												}
												int num22 = x2;
												int num23 = num - 8;
												num22 += genRand.Next(-1, 2);
												if (noTrapsWorldGen)
												{
													if (IsTileNearby(num22, num23, 138, 6))
													{
														return false;
													}
													if (IsTileNearby(num22, num23, 664, 6))
													{
														return false;
													}
												}
												else
												{
													if (IsTileNearby(num22, num23, 138, 10))
													{
														return false;
													}
													if (IsTileNearby(num22, num23, 664, 10))
													{
														return false;
													}
													if (IsTileNearby(num22, num23, 665, 10))
													{
														return false;
													}
												}
												bool flag3 = true;
												while (flag3)
												{
													bool flag4 = true;
													int num24 = 0;
													for (int m = num22 - 2; m <= num22 + 3; m++)
													{
														for (int n = num23; n <= num23 + 3; n++)
														{
															if (!SolidTile(m, n))
															{
																flag4 = false;
															}
															tile = Main.tile[m, n];
															if (!tile.active())
															{
																continue;
															}
															tile = Main.tile[m, n];
															if (tile.type == 226)
															{
																trapDiag[type, 0]++;
																return false;
															}
															tile = Main.tile[m, n];
															if (tile.type != 0)
															{
																tile = Main.tile[m, n];
																if (tile.type != 1)
																{
																	tile = Main.tile[m, n];
																	if (tile.type != 59)
																	{
																		continue;
																	}
																}
															}
															num24++;
														}
													}
													num23--;
													if ((double)num23 < Main.worldSurface)
													{
														trapDiag[type, 0]++;
														return false;
													}
													if (flag4 && num24 > 2)
													{
														flag3 = false;
													}
												}
												if (num - num23 <= 5 || num - num23 >= 40)
												{
													trapDiag[type, 0]++;
													return false;
												}
												for (int num25 = num22; num25 <= num22 + 1; num25++)
												{
													for (int num26 = num23; num26 <= num; num26++)
													{
														KillTile(num25, num26);
													}
												}
												for (int num27 = num22 - 2; num27 <= num22 + 3; num27++)
												{
													for (int num28 = num23 - 2; num28 <= num23 + 3; num28++)
													{
														if (SolidTile(num27, num28))
														{
															tile = Main.tile[num27, num28];
															tile.type = 1;
														}
													}
												}
												if (IsTileNearby(num22, num23, 21, 4) || IsTileNearby(num22, num23, 467, 4))
												{
													trapDiag[type, 0]++;
													return false;
												}
												PlaceTile(x2, num, 135, mute: true, forced: true, -1, 7);
												PlaceTile(num22, num23 + 2, 130, mute: true);
												PlaceTile(num22 + 1, num23 + 2, 130, mute: true);
												if ((tenthAnniversaryWorldGen || noTrapsWorldGen) && genRand.Next(3) == 0)
												{
													PlaceTile(num22 + 1, num23 + 1, 664, mute: true);
												}
												else
												{
													PlaceTile(num22 + 1, num23 + 1, 138, mute: true);
												}
												num23 += 2;
												tile = Main.tile[num22, num23];
												tile.wire(wire: true);
												tile = Main.tile[num22 + 1, num23];
												tile.wire(wire: true);
												num23++;
												PlaceTile(num22, num23, 130, mute: true);
												PlaceTile(num22 + 1, num23, 130, mute: true);
												tile = Main.tile[num22, num23];
												tile.wire(wire: true);
												tile = Main.tile[num22 + 1, num23];
												tile.wire(wire: true);
												PlaceTile(num22, num23 + 1, 130, mute: true);
												PlaceTile(num22 + 1, num23 + 1, 130, mute: true);
												tile = Main.tile[num22, num23 + 1];
												tile.wire(wire: true);
												tile = Main.tile[num22 + 1, num23 + 1];
												tile.wire(wire: true);
												int num2 = x2;
												int num3 = num;
												while (num2 != num22 || num3 != num23)
												{
													tile = Main.tile[num2, num3];
													tile.wire(wire: true);
													if (num2 > num22)
													{
														num2--;
													}
													if (num2 < num22)
													{
														num2++;
													}
													tile = Main.tile[num2, num3];
													tile.wire(wire: true);
													if (num3 > num23)
													{
														num3--;
													}
													if (num3 < num23)
													{
														num3++;
													}
													tile = Main.tile[num2, num3];
													tile.wire(wire: true);
												}
												trapDiag[type, 1]++;
												return true;
											}
											case 2:
											{
												int num4 = genRand.Next(4, 7);
												int num5 = x2;
												num5 += genRand.Next(-1, 2);
												int num6 = num;
												for (int num7 = 0; num7 < num4; num7++)
												{
													num6++;
													if (!SolidTile(num5, num6))
													{
														trapDiag[type, 0]++;
														return false;
													}
												}
												for (int num8 = num5 - 2; num8 <= num5 + 2; num8++)
												{
													for (int num9 = num6 - 2; num9 <= num6 + 2; num9++)
													{
														if (!SolidTile(num8, num9))
														{
															return false;
														}
													}
												}
												KillTile(num5, num6);
												tile = Main.tile[num5, num6];
												tile.active(active: true);
												tile = Main.tile[num5, num6];
												tile.type = 141;
												tile = Main.tile[num5, num6];
												tile.frameX = 0;
												tile = Main.tile[num5, num6];
												tile.frameY = (short)(18 * genRand.Next(2));
												PlaceTile(x2, num, 135, mute: true, forced: true, -1, genRand.Next(2, 4));
												int num10 = x2;
												int num11 = num;
												while (num10 != num5 || num11 != num6)
												{
													tile = Main.tile[num10, num11];
													tile.wire(wire: true);
													if (num10 > num5)
													{
														num10--;
													}
													if (num10 < num5)
													{
														num10++;
													}
													tile = Main.tile[num10, num11];
													tile.wire(wire: true);
													if (num11 > num6)
													{
														num11--;
													}
													if (num11 < num6)
													{
														num11++;
													}
													tile = Main.tile[num10, num11];
													tile.wire(wire: true);
												}
												trapDiag[type, 1]++;
												break;
											}
											case 3:
												{
													tile = Main.tile[x2 + 1, num];
													if (tile.active())
													{
														return false;
													}
													tile = Main.tile[x2, num];
													if (tile.liquid > 0)
													{
														tile = Main.tile[x2, num];
														if (!tile.lava())
														{
															return false;
														}
													}
													if (noTrapsWorldGen && (tenthAnniversaryWorldGen || notTheBees))
													{
														if (genRand.Next(3) != 0)
														{
															return false;
														}
														if (IsTileNearby(x2, num, 443, 30))
														{
															return false;
														}
													}
													for (int k = x2; k <= x2 + 1; k++)
													{
														int j2 = num + 1;
														if (!SolidTile(k, j2))
														{
															return false;
														}
													}
													int num12 = genRand.Next(2);
													for (int l = 0; l < 2; l++)
													{
														tile = Main.tile[x2 + l, num];
														tile.active(active: true);
														tile = Main.tile[x2 + l, num];
														tile.type = 443;
														tile = Main.tile[x2 + l, num];
														tile.frameX = (short)(18 * l + 36 * num12);
														tile = Main.tile[x2 + l, num];
														tile.frameY = 0;
													}
													return true;
												}
												IL_04cc:
												if (flag6)
												{
													tile = Main.tile[num16, num14];
													if (tile.type != 10)
													{
														tile = Main.tile[num16, num14];
														if (tile.type != 48)
														{
															tile = Main.tile[num16, num14 + 1];
															if (tile.type != 10)
															{
																tile = Main.tile[num16, num14 + 1];
																if (tile.type != 48)
																{
																	goto IL_0543;
																}
															}
														}
													}
													flag6 = false;
												}
												goto IL_0543;
												IL_0543:
												num19 = 0;
												if (flag5 && flag6)
												{
													num19 = 1;
													num13 = num15;
													if (genRand.Next(2) == 0)
													{
														num13 = num16;
														num19 = -1;
													}
												}
												else if (flag6)
												{
													num13 = num16;
													num19 = -1;
												}
												else
												{
													if (!flag5)
													{
														trapDiag[type, 0]++;
														return false;
													}
													num13 = num15;
													num19 = 1;
												}
												tile = Main.tile[num13, num14];
												if (tile.type == 190)
												{
													trapDiag[type, 0]++;
													return false;
												}
												tile = Main.tile[x2, num];
												if (tile.wall > 0)
												{
													PlaceTile(x2, num, 135, mute: true, forced: true, -1, 2);
												}
												else
												{
													PlaceTile(x2, num, 135, mute: true, forced: true, -1, genRand.Next(2, 4));
												}
												KillTile(num13, num14);
												PlaceTile(num13, num14, 137, mute: true, forced: true);
												if (num19 == 1)
												{
													tile = Main.tile[num13, num14];
													tile.frameX += 18;
												}
												num20 = x2;
												num21 = num;
												while (num20 != num13 || num21 != num14)
												{
													tile = Main.tile[num20, num21];
													tile.wire(wire: true);
													if (num20 > num13)
													{
														num20--;
													}
													if (num20 < num13)
													{
														num20++;
													}
													tile = Main.tile[num20, num21];
													tile.wire(wire: true);
													if (num21 > num14)
													{
														num21--;
													}
													if (num21 < num14)
													{
														num21++;
													}
													tile = Main.tile[num20, num21];
													tile.wire(wire: true);
												}
												trapDiag[type, 1]++;
												return true;
											}
											if (noTrapsWorldGen)
											{
												Main.tileSolid[138] = true;
											}
											return false;
										}
									}
								}
							}
						}
					}
				}
			}
		}
		return false;
	}

	public static int countWires(int x, int y, int size)
	{
		int num = 0;
		for (int i = x - size; i <= x + size; i++)
		{
			for (int j = y - size; j <= y + size; j++)
			{
				if (InWorld(i, j))
				{
					if (Main.tile[i, j].wire())
					{
						num++;
					}
					if (Main.tile[i, j].wire2())
					{
						num++;
					}
					if (Main.tile[i, j].wire3())
					{
						num++;
					}
					if (Main.tile[i, j].wire4())
					{
						num++;
					}
				}
			}
		}
		return num;
	}

	public static int countTiles(int x, int y, bool jungle = false, bool lavaOk = false)
	{
		numTileCount = 0;
		shroomCount = 0;
		lavaCount = 0;
		iceCount = 0;
		sandCount = 0;
		rockCount = 0;
		CountedTiles.Clear();
		nextCount(x, y, jungle, lavaOk);
		return numTileCount;
	}

	public static void nextCount(int x, int y, bool jungle = false, bool lavaOk = false)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		if (numTileCount >= maxTileCount)
		{
			return;
		}
		if (x <= 1 || x >= Main.maxTilesX - 1 || y <= 1 || y >= Main.maxTilesY - 1)
		{
			numTileCount = maxTileCount;
		}
		else
		{
			if (CountedTiles.ContainsKey(new Point(x, y)))
			{
				return;
			}
			if (Main.tile[x, y].wall == 244)
			{
				numTileCount = maxTileCount;
				return;
			}
			if (Main.tile[x, y].shimmer() && Main.tile[x, y].liquid > 0)
			{
				numTileCount = maxTileCount;
				return;
			}
			if (!jungle)
			{
				if (Main.tile[x, y].wall != 0)
				{
					numTileCount = maxTileCount;
					return;
				}
				if (!lavaOk)
				{
					if (Main.tile[x, y].lava() && Main.tile[x, y].liquid > 0)
					{
						lavaCount++;
						numTileCount = maxTileCount;
						return;
					}
				}
				else if (Main.tile[x, y].lava() && Main.tile[x, y].liquid > 0)
				{
					lavaCount++;
				}
			}
			if (Main.tile[x, y].active())
			{
				if (Main.tile[x, y].type == 70)
				{
					shroomCount++;
				}
				if (Main.tile[x, y].type == 1)
				{
					rockCount++;
				}
				if (Main.tile[x, y].type == 147 || Main.tile[x, y].type == 161)
				{
					iceCount++;
				}
				if (Main.tile[x, y].type == 53 || Main.tile[x, y].type == 396 || Main.tile[x, y].type == 397)
				{
					sandCount++;
				}
			}
			if (!SolidTile(x, y))
			{
				CountedTiles.Add(new Point(x, y), value: true);
				numTileCount++;
				nextCount(x - 1, y, jungle, lavaOk);
				nextCount(x + 1, y, jungle, lavaOk);
				nextCount(x, y - 1, jungle, lavaOk);
				nextCount(x, y + 1, jungle, lavaOk);
			}
		}
	}

	public static int countDirtTiles(int x, int y)
	{
		numTileCount = 0;
		CountedTiles.Clear();
		nextDirtCount(x, y);
		return numTileCount;
	}

	public static void nextDirtCount(int x, int y)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		if (numTileCount >= maxTileCount)
		{
			return;
		}
		if (x <= 1 || x >= Main.maxTilesX - 1 || y <= 1 || y >= Main.maxTilesY - 1)
		{
			numTileCount = maxTileCount;
		}
		else if (!CountedTiles.ContainsKey(new Point(x, y)))
		{
			if (Main.tile[x, y].active() && (Main.tile[x, y].type == 147 || Main.tile[x, y].type == 161))
			{
				numTileCount = maxTileCount;
			}
			else if (Main.tile[x, y].wall == 244 || Main.tile[x, y].wall == 83 || Main.tile[x, y].wall == 3 || Main.tile[x, y].wall == 187 || Main.tile[x, y].wall == 216)
			{
				numTileCount = maxTileCount;
			}
			else if (!SolidTile(x, y) && (Main.tile[x, y].wall == 2 || Main.tile[x, y].wall == 59))
			{
				CountedTiles.Add(new Point(x, y), value: true);
				numTileCount++;
				nextDirtCount(x - 1, y);
				nextDirtCount(x + 1, y);
				nextDirtCount(x, y - 1);
				nextDirtCount(x, y + 1);
				nextDirtCount(x - 1, y - 1);
				nextDirtCount(x - 1, y + 1);
				nextDirtCount(x + 1, y - 1);
				nextDirtCount(x + 1, y + 1);
				nextDirtCount(x - 2, y);
				nextDirtCount(x + 2, y);
			}
		}
	}

	public static bool InWorld(int x, int y, int fluff = 0)
	{
		if (x < fluff || x >= Main.maxTilesX - fluff || y < fluff || y >= Main.maxTilesY - fluff)
		{
			return false;
		}
		return true;
	}

	public static void gemCave(int x, int y)
	{
		countTiles(x, y);
		for (int i = 0; i < 6; i++)
		{
			gem[i] = false;
		}
		gem[genRand.Next(6)] = true;
		for (int j = 0; j < 6; j++)
		{
			if (genRand.Next(6) == 0)
			{
				gem[j] = true;
			}
		}
		Spread.Gem(x, y);
	}

	public static int randGem()
	{
		int num = genRand.Next(6);
		while (!gem[num])
		{
			num = genRand.Next(6);
		}
		return num;
	}

	public static ushort randGemTile()
	{
		if (genRand.Next(20) != 0)
		{
			return 1;
		}
		return (ushort)randGem() switch
		{
			0 => 67, 
			1 => 66, 
			2 => 63, 
			3 => 65, 
			4 => 64, 
			_ => 68, 
		};
	}

	public static void randMoss(bool justNeon = false)
	{
		neonMossType = genRand.NextFromList(new ushort[4] { 539, 536, 534, 625 });
		if (!justNeon)
		{
			mossType[0] = genRand.Next(5);
			mossType[1] = genRand.Next(5);
			while (mossType[1] == mossType[0])
			{
				mossType[1] = genRand.Next(5);
			}
			mossType[2] = genRand.Next(5);
			while (mossType[2] == mossType[0] || mossType[2] == mossType[1])
			{
				mossType[2] = genRand.Next(5);
			}
		}
	}

	public static void neonMossBiome(int i, int j, int maxY = 99999)
	{
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = genRand.NextDouble() * 4.0 - 2.0;
		vector2D2.Y = genRand.NextDouble() * 4.0 - 2.0;
		if (vector2D2.X == 0.0)
		{
			vector2D2.X = 1.0;
		}
		while (vector2D2.Length() < 4.0)
		{
			vector2D2 *= 1.5;
		}
		double num = genRand.Next(60, 80);
		double num2 = genRand.Next(30, 40);
		double num3 = (double)Main.maxTilesX / 4200.0;
		if (getGoodWorldGen)
		{
			num3 *= 1.5;
		}
		num *= num3;
		num2 *= num3;
		while (num2 > 0.0)
		{
			num *= 0.98;
			num2 -= 1.0;
			int num4 = (int)(vector2D.X - num);
			int num5 = (int)(vector2D.X + num);
			int num6 = (int)(vector2D.Y - num);
			int num7 = (int)(vector2D.Y + num);
			if (num4 < 1)
			{
				num4 = 1;
			}
			if (num5 > Main.maxTilesX - 1)
			{
				num5 = Main.maxTilesX - 1;
			}
			if (num6 < 1)
			{
				num6 = 1;
			}
			if (num7 > Main.maxTilesY - 1)
			{
				num7 = Main.maxTilesY - 1;
			}
			if (Main.remixWorld)
			{
				if ((double)num6 < Main.worldSurface)
				{
					num6 = (int)Main.worldSurface;
					if (vector2D2.Y < 5.0)
					{
						vector2D2.Y = 5.0;
					}
				}
			}
			else if ((double)num6 < Main.rockLayer)
			{
				num6 = (int)Main.rockLayer;
				if (vector2D2.Y < 5.0)
				{
					vector2D2.Y = 5.0;
				}
			}
			if (num7 > maxY)
			{
				num7 = maxY;
				if (vector2D2.Y > -5.0)
				{
					vector2D2.Y = -5.0;
				}
			}
			double num8 = num * (1.0 + genRand.NextDouble() * 0.4 - 0.2);
			for (int k = num4; k < num5; k++)
			{
				for (int l = num6; l < num7; l++)
				{
					if (new Vector2D(Math.Abs((double)k - vector2D.X), Math.Abs((double)l - vector2D.Y)).Length() < num8 * 0.8 && TileType(k, l) == 1 && (!Main.tile[k - 1, l].active() || !Main.tile[k + 1, l].active() || !Main.tile[k, l - 1].active() || !Main.tile[k, l + 1].active()))
					{
						SpreadGrass(k - 1, l, 1, neonMossType);
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += genRand.NextDouble() * 4.0 - 2.0;
			vector2D2.Y += genRand.NextDouble() * 4.0 - 2.0;
			vector2D2.Y = Utils.Clamp(vector2D2.Y, -10.0, 10.0);
			vector2D2.X = Utils.Clamp(vector2D2.X, -10.0, 10.0);
		}
	}

	public static void setMoss(int x, int y)
	{
		int num = 0;
		num = ((!((double)x < (double)Main.maxTilesX * 0.334)) ? (((double)x < (double)Main.maxTilesX * 0.667) ? 1 : 2) : 0);
		GenVars.mossWall = (ushort)(54 + mossType[num]);
		GenVars.mossTile = (ushort)(179 + mossType[num]);
	}

	public static void FillWallHolesInArea(Rectangle worldCoordsArea)
	{
		int num4 = Math.Max(((Rectangle)(ref worldCoordsArea)).Left, 0);
		int num2 = Math.Min(((Rectangle)(ref worldCoordsArea)).Right, Main.maxTilesX);
		int num3 = 0;
		for (int i = num4; i <= num2; i++)
		{
			if (i >= 0 && i < Main.maxTilesX)
			{
				num3 += FillWallHolesInColumn(i, ((Rectangle)(ref worldCoordsArea)).Top, ((Rectangle)(ref worldCoordsArea)).Bottom);
			}
		}
	}

	private static int FillWallHolesInColumn(int x, int startY, int endY)
	{
		int num = 0;
		x = Utils.Clamp(x, 2, Main.maxTilesX - 1 - 2);
		startY = Math.Max(startY, 2);
		endY = Math.Min(endY, Main.maxTilesY - 2);
		bool flag = false;
		for (int i = startY; i < endY; i++)
		{
			if (Main.tile[x, i].wall == 0)
			{
				if (flag)
				{
					flag = false;
					if (FillWallHolesInSpot(x, i, 150))
					{
						num++;
					}
				}
			}
			else
			{
				flag = true;
			}
		}
		return num;
	}

	private static bool FillWallHolesInSpot(int originX, int originY, int maxWallsThreshold)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		if (!InWorld(originX, originY, 2))
		{
			return false;
		}
		List<Point> list = new List<Point>();
		List<Point> list2 = new List<Point>();
		HashSet<Point> hashSet = new HashSet<Point>();
		Dictionary<ushort, int> dictionary = new Dictionary<ushort, int>();
		list2.Add(new Point(originX, originY));
		Point item2 = default(Point);
		while (list2.Count > 0)
		{
			list.Clear();
			list.AddRange(list2);
			list2.Clear();
			while (list.Count > 0)
			{
				if (hashSet.Count >= maxWallsThreshold)
				{
					return false;
				}
				Point item = list[0];
				if (hashSet.Contains(item))
				{
					list.Remove(item);
					continue;
				}
				if (!InWorld(item.X, item.Y, 1))
				{
					list.Remove(item);
					continue;
				}
				hashSet.Add(item);
				list.Remove(item);
				Tile tile = Main.tile[item.X, item.Y];
				if (tile.wall != 0)
				{
					if (dictionary.ContainsKey(tile.wall))
					{
						dictionary[tile.wall] = dictionary[tile.wall] + 1;
					}
					else
					{
						dictionary[tile.wall] = 1;
					}
					continue;
				}
				bool flag = false;
				if (!flag)
				{
					int y = item.Y;
					for (int i = item.X - 1; i <= item.X + 1; i++)
					{
						if (!Main.tile[i, y].active())
						{
							flag = true;
							break;
						}
					}
				}
				if (!flag)
				{
					int x = item.X;
					for (int j = item.Y - 1; j <= item.Y + 1; j++)
					{
						if (!Main.tile[x, j].active())
						{
							flag = true;
							break;
						}
					}
				}
				if (flag)
				{
					((Point)(ref item2))._002Ector(item.X - 1, item.Y);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					((Point)(ref item2))._002Ector(item.X + 1, item.Y);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					((Point)(ref item2))._002Ector(item.X, item.Y - 1);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
					((Point)(ref item2))._002Ector(item.X, item.Y + 1);
					if (!hashSet.Contains(item2))
					{
						list2.Add(item2);
					}
				}
			}
		}
		if (hashSet.Count == 1)
		{
			return false;
		}
		ushort wall = 0;
		int num = -1;
		foreach (KeyValuePair<ushort, int> item3 in dictionary)
		{
			if (item3.Value > num)
			{
				wall = item3.Key;
				num = item3.Value;
			}
		}
		if (num == -1)
		{
			wall = 2;
		}
		foreach (Point item4 in hashSet)
		{
			Tile tile2 = Main.tile[item4.X, item4.Y];
			if (tile2.wall == 0)
			{
				tile2.wall = wall;
			}
		}
		return true;
	}

	public static void tileCountAndDestroy()
	{
		for (int i = 10; i < Main.maxTilesX - 10; i++)
		{
			for (int j = 10; j < Main.maxTilesY - 10; j++)
			{
				if (Main.tile[i, j].active() && tileCounter(i, j) < tileCounterMax)
				{
					tileCounterKill();
				}
			}
		}
	}

	public static int tileCounter(int x, int y)
	{
		tileCounterNum = 0;
		tileCounterNext(x, y);
		return tileCounterNum;
	}

	public static void tileCounterNext(int x, int y)
	{
		if (tileCounterNum >= tileCounterMax || x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5 || !Main.tile[x, y].active() || !Main.tileSolid[Main.tile[x, y].type] || !TileID.Sets.CanBeClearedDuringGeneration[Main.tile[x, y].type])
		{
			return;
		}
		for (int i = 0; i < tileCounterNum; i++)
		{
			if (tileCounterX[i] == x && tileCounterY[i] == y)
			{
				return;
			}
		}
		tileCounterX[tileCounterNum] = x;
		tileCounterY[tileCounterNum] = y;
		tileCounterNum++;
		tileCounterNext(x - 1, y);
		tileCounterNext(x + 1, y);
		tileCounterNext(x, y - 1);
		tileCounterNext(x, y + 1);
	}

	public static void tileCounterKill()
	{
		for (int i = 0; i < tileCounterNum; i++)
		{
			int num = tileCounterX[i];
			int num2 = tileCounterY[i];
			Main.tile[num, num2].active(active: false);
		}
	}

	private static void AddGenerationPass(string name, WorldGenLegacyMethod method)
	{
		_vanillaGenPasses.Add(name, new PassLegacy(name, method));
	}

	private static void AddGenerationPass(GenPass pass)
	{
		_vanillaGenPasses.Add(pass.Name, pass);
	}

	private static void AddGenerationPass(string name, double weight, WorldGenLegacyMethod method)
	{
		_vanillaGenPasses.Add(name, new PassLegacy(name, method, weight));
	}

	public static bool checkUnderground(int x, int y)
	{
		try
		{
			int num = 120;
			int num2 = 80;
			int num3 = 3;
			if ((double)y > Main.worldSurface + (double)num2)
			{
				return true;
			}
			if ((double)y < Main.worldSurface / 2.0)
			{
				return false;
			}
			int num4 = y - num2;
			int num5 = x - num / 2;
			int num6 = 0;
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num5 >= Main.maxTilesX - num)
			{
				num5 = Main.maxTilesX - num - 1;
			}
			for (int i = num5; i < num5 + num; i++)
			{
				for (int j = num4; j < num4 + num3; j++)
				{
					if (SolidTile(i, j) || Main.tile[x, y].wall > 0)
					{
						num6++;
					}
				}
			}
			if ((double)num6 >= (double)(num * num3) * 0.8)
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static int GetNextJungleChestItem()
	{
		int result = 211;
		switch (GenVars.JungleItemCount % 4)
		{
		case 0:
			result = 211;
			break;
		case 1:
			result = 212;
			break;
		case 2:
			result = 213;
			break;
		case 3:
			result = 964;
			break;
		}
		if (genRand.Next(50) == 0)
		{
			result = 753;
		}
		else if (genRand.Next(15) == 0)
		{
			result = 2292;
		}
		else if (genRand.Next(20) == 0)
		{
			result = 3017;
		}
		GenVars.JungleItemCount++;
		return result;
	}

	private static void ScanTileColumnAndRemoveClumps(int x)
	{
		int num = 0;
		int y = 0;
		for (int i = 10; i < Main.maxTilesY - 10; i++)
		{
			if (Main.tile[x, i].active() && Main.tileSolid[Main.tile[x, i].type] && TileID.Sets.CanBeClearedDuringGeneration[Main.tile[x, i].type])
			{
				if (num == 0)
				{
					y = i;
				}
				num++;
				continue;
			}
			if (num > 0 && num < tileCounterMax)
			{
				SmallConsecutivesFound++;
				if (tileCounter(x, y) < tileCounterMax)
				{
					SmallConsecutivesEliminated++;
					tileCounterKill();
				}
			}
			num = 0;
		}
	}

	public static void OreHelper(int X, int Y)
	{
		for (int i = X - 1; i <= X + 1; i++)
		{
			for (int j = Y - 1; j <= Y + 1; j++)
			{
				if (Main.tile[i, j].type == 1 || Main.tile[i, j].type == 40)
				{
					Main.tile[i, j].type = 0;
				}
			}
		}
	}

	public static bool StonePatch(int X, int Y)
	{
		int num = Y;
		while (!SolidTile(X, num))
		{
			num++;
			if ((double)num > Main.worldSurface)
			{
				return false;
			}
		}
		if (!TileID.Sets.Conversion.Grass[Main.tile[X, num].type] || !TileID.Sets.Conversion.Grass[Main.tile[X - 1, num].type] || !TileID.Sets.Conversion.Grass[Main.tile[X + 1, num].type])
		{
			return false;
		}
		if (Main.tile[X, num].wall > 0)
		{
			return false;
		}
		for (int i = X - 10; i <= X + 10; i++)
		{
			for (int j = num + 7; j <= num + 30; j++)
			{
				if (!Main.tile[i, j].active() || Main.tileDungeon[Main.tile[i, j].type] || TileID.Sets.Clouds[Main.tile[i, j].type] || TileID.Sets.Conversion.Sand[Main.tile[i, j].type] || Main.tile[i, j].wall == 0 || Main.tile[i, j].type == 199 || Main.tile[i, j].type == 23)
				{
					return false;
				}
			}
		}
		Vector2D vector2D = new Vector2D(X, num);
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = genRand.NextDouble() * 0.6 - 0.3;
		vector2D2.Y = genRand.NextDouble() * 0.5 + 0.5;
		double num2 = genRand.Next(13, 18);
		int num3 = genRand.Next(13, 19);
		if (genRand.Next(3) == 0)
		{
			num2 += (double)genRand.Next(3);
		}
		if (genRand.Next(3) == 0)
		{
			num3 += genRand.Next(3);
		}
		while (num3 > 0)
		{
			num3--;
			for (int k = X - (int)num2 * 4; (double)k <= (double)X + num2 * 4.0; k++)
			{
				for (int l = num - (int)num2 * 4; (double)l <= (double)num + num2 * 4.0; l++)
				{
					double num4 = num2 * (0.7 + genRand.NextDouble() * 0.6) * 0.3;
					if (genRand.Next(8) == 0)
					{
						num4 *= 2.0;
					}
					Vector2D vector2D3 = vector2D - new Vector2D(k, l);
					if (vector2D3.Length() < num4 * 2.0 && !Main.tile[k, l].active() && Main.tile[k, l + 1].active() && Main.tile[k, l + 1].type == 1 && genRand.Next(7) == 0 && SolidTile(k - 1, l + 1) && SolidTile(k + 1, l + 1))
					{
						if (genRand.Next(3) != 0)
						{
							PlaceTile(k, l, 186, mute: true, forced: false, -1, genRand.Next(7, 13));
						}
						if (genRand.Next(3) != 0)
						{
							PlaceSmallPile(k, l, genRand.Next(6), 1, 185);
						}
						PlaceSmallPile(k, l, genRand.Next(6), 0, 185);
					}
					if (vector2D3.Length() < num4)
					{
						if (Main.tileSolid[Main.tile[k, l].type])
						{
							Main.tile[k, l].type = 1;
						}
						if (!gen)
						{
							SquareTileFrame(k, l);
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += genRand.NextDouble() * 0.2 - 0.1;
			vector2D2.Y += genRand.NextDouble() * 0.2 - 0.1;
			Utils.Clamp(vector2D2.X, -0.3, 0.3);
			Utils.Clamp(vector2D2.Y, 0.5, 1.0);
		}
		return true;
	}

	public static bool ShellPile(int X, int Y)
	{
		int num = Y;
		while (!SolidTile(X, num))
		{
			num++;
			if ((double)num > Main.worldSurface)
			{
				return false;
			}
		}
		if (Main.tile[X, num].type != 53)
		{
			return false;
		}
		if (Main.tile[X, num].wall > 0)
		{
			return false;
		}
		num--;
		Vector2D vector2D = new Vector2D(X, num);
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = genRand.NextDouble() * 0.6 - 0.3;
		vector2D2.Y = genRand.NextDouble() * 0.5 + 0.5;
		double num2 = genRand.Next(2, 4);
		if (genRand.Next(10) == 0)
		{
			num2 += 1.0;
		}
		int num3 = genRand.Next(3, 6);
		while (num3 > 0)
		{
			num3--;
			for (int i = X - (int)num2 * 4; (double)i <= (double)X + num2 * 4.0; i++)
			{
				int num4 = num + (int)num2 * 4;
				while ((double)num4 > (double)num - num2 * 4.0)
				{
					double num5 = num2 * (double)genRand.Next(70, 91) * 0.01;
					Vector2D vector2D3 = vector2D - new Vector2D(i, num4);
					vector2D3.X *= 0.6;
					if (vector2D3.Length() < num5)
					{
						if (num4 <= num + 1 || genRand.Next(6) == 0)
						{
							Main.tile[i, num4].type = 495;
							Main.tile[i, num4].active(active: true);
							Main.tile[i, num4].halfBrick(halfBrick: false);
							Main.tile[i, num4].slope(0);
							if (!Main.tile[i, num4 + 1].active())
							{
								Main.tile[i, num4 + 1].type = 495;
								Main.tile[i, num4 + 1].active(active: true);
								Main.tile[i, num4 + 1].halfBrick(halfBrick: false);
								Main.tile[i, num4 + 1].slope(0);
								if (!Main.tile[i, num4 + 2].active())
								{
									Main.tile[i, num4 + 2].type = 53;
									Main.tile[i, num4 + 2].active(active: true);
									Main.tile[i, num4 + 2].halfBrick(halfBrick: false);
									Main.tile[i, num4 + 2].slope(0);
									if (!Main.tile[i, num4 + 3].active())
									{
										Main.tile[i, num4 + 3].type = 397;
										Main.tile[i, num4 + 3].active(active: true);
										Main.tile[i, num4 + 3].halfBrick(halfBrick: false);
										Main.tile[i, num4 + 3].slope(0);
									}
								}
							}
							if (!gen)
							{
								SquareTileFrame(i, num4);
							}
						}
						else if (Main.tile[i, num4].type != 495)
						{
							Main.tile[i, num4].active(active: true);
							Main.tile[i, num4].halfBrick(halfBrick: false);
							Main.tile[i, num4].slope(0);
							Main.tile[i, num4].type = 53;
							if (!gen)
							{
								SquareTileFrame(i, num4);
							}
						}
					}
					num4--;
				}
			}
			vector2D += vector2D2;
			vector2D2.X += genRand.NextDouble() * 0.2 - 0.1;
			vector2D2.Y += genRand.NextDouble() * 0.2 - 0.1;
			Utils.Clamp(vector2D2.X, -0.3, 0.3);
			Utils.Clamp(vector2D2.Y, 0.5, 1.0);
		}
		return true;
	}

	public static bool MarblePileWithStatues(int X, int Y)
	{
		int num = Y;
		while (!SolidTile(X, num))
		{
			num++;
			if ((double)num > Main.worldSurface)
			{
				return false;
			}
		}
		if (Main.tile[X, num].type != 0 && Main.tile[X, num].type != 2)
		{
			return false;
		}
		if (Main.tile[X, num].wall > 0)
		{
			return false;
		}
		int num6 = 130;
		int num7 = 60;
		int num13 = (int)MathHelper.Clamp((float)(X - num6), 30f, (float)(Main.maxTilesX - 30));
		int num8 = (int)MathHelper.Clamp((float)(X + num6), 30f, (float)(Main.maxTilesX - 30));
		int num9 = (int)MathHelper.Clamp((float)(num - num7), 30f, (float)(Main.maxTilesY - 30));
		int num10 = (int)MathHelper.Clamp((float)(num + num7), 30f, (float)(Main.maxTilesY - 30));
		for (int i = num13; i <= num8; i++)
		{
			for (int j = num9; j <= num10; j++)
			{
				if (Main.tile[i, j].active() && (Main.tile[i, j].type == 367 || Main.tile[i, j].type == 191))
				{
					return false;
				}
			}
		}
		num--;
		Vector2D vector2D = new Vector2D(X, num);
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = genRand.NextDouble() * 0.6 - 0.3;
		vector2D2.Y = genRand.NextDouble() * 0.5 + 0.5;
		double num11 = genRand.Next(2, 4);
		if (genRand.Next(10) == 0)
		{
			num11 += 1.0;
		}
		int num12 = genRand.Next(3, 6);
		while (num12 > 0)
		{
			num12--;
			for (int k = X - (int)num11 * 5; (double)k <= (double)X + num11 * 5.0; k++)
			{
				int num2 = num + (int)num11 * 3;
				while ((double)num2 > (double)num - num11 * 3.0)
				{
					double num3 = num11 * (double)genRand.Next(70, 91) * 0.01 * 1.2;
					Vector2D vector2D3 = vector2D - new Vector2D(k, num2);
					if (vector2D3.Length() > 30.0)
					{
						vector2D = new Vector2D(X, num);
						vector2D2.X = genRand.NextDouble() * 0.6 - 0.3;
						vector2D2.Y = genRand.NextDouble() * 0.5 + 0.5;
					}
					else
					{
						vector2D3.X *= 0.25;
						vector2D3.Y *= 0.8;
						if (vector2D3.Length() < num3 && Main.tile[k, num2].active())
						{
							Main.tile[k, num2].active(active: true);
							Main.tile[k, num2].halfBrick(halfBrick: false);
							Main.tile[k, num2].slope(0);
							Main.tile[k, num2].type = 367;
							if (!gen)
							{
								SquareTileFrame(k, num2);
							}
						}
					}
					num2--;
				}
			}
			vector2D += vector2D2;
			vector2D2.X += genRand.NextDouble() * 0.2 - 0.1;
			vector2D2.Y += (0.1 + genRand.NextDouble() * 0.1) * 0.8;
			Utils.Clamp(vector2D2.X, -0.3, 0.3);
			Utils.Clamp(vector2D2.Y, 0.5, 1.0);
		}
		int num4 = 0;
		for (int l = X - (int)num11 * 5; (double)l <= (double)X + num11 * 5.0; l++)
		{
			if (num4 >= 3)
			{
				break;
			}
			if (l % 2 != 1 && (num4 <= 0 || genRand.Next(5) == 0))
			{
				int num5 = (int)vector2D.Y - 20;
				Tile tile = Main.tile[l, num5];
				while (tile != null && !tile.active())
				{
					num5++;
					tile = Main.tile[l, num5];
				}
				if (tile != null && tile.type == 367 && !Main.tile[l, num5 - 1].active() && Statue(l, num5 - 1, 26))
				{
					num4++;
				}
			}
		}
		return true;
	}

	public static bool Statue(int x, int y, byte paint)
	{
		int num = genRand.Next(2, GenVars.statueList.Length);
		int x2 = GenVars.statueList[num].X;
		int y2 = GenVars.statueList[num].Y;
		while (!Main.tile[x, y].active())
		{
			y++;
			if (y >= Main.maxTilesY)
			{
				break;
			}
		}
		if (y >= Main.maxTilesY)
		{
			return false;
		}
		y--;
		if (PlaceTile(x, y, x2, mute: true, forced: true, -1, y2))
		{
			for (int i = 0; i < 2; i++)
			{
				for (int j = 0; j < 3; j++)
				{
					Main.tile[x + i, y + j - 2].color(paint);
				}
			}
			return true;
		}
		return false;
	}

	public static bool OrePatch(int X, int Y)
	{
		ushort type = (ushort)SavedOreTiers.Copper;
		if (genRand.Next(3) == 0)
		{
			type = (ushort)SavedOreTiers.Iron;
		}
		int num = X;
		int num2 = Y;
		while (!SolidTile(num, num2))
		{
			num2++;
			if ((double)num2 > Main.worldSurface)
			{
				return false;
			}
		}
		if (!TileID.Sets.Conversion.Grass[Main.tile[num, num2].type] || !TileID.Sets.Conversion.Grass[Main.tile[num - 1, num2].type] || !TileID.Sets.Conversion.Grass[Main.tile[num + 1, num2].type])
		{
			return false;
		}
		if (Main.tile[num, num2].wall > 0)
		{
			return false;
		}
		for (int i = num - 10; i <= num + 10; i++)
		{
			for (int j = num2 + 7; j <= num2 + 30; j++)
			{
				if (!Main.tile[i, j].active() || Main.tileDungeon[Main.tile[i, j].type] || TileID.Sets.Clouds[Main.tile[i, j].type] || TileID.Sets.Conversion.Sand[Main.tile[i, j].type] || Main.tile[i, j].wall == 0)
				{
					return false;
				}
			}
		}
		num2 += genRand.Next(2);
		Main.tile[num, num2].type = type;
		Main.tile[num, num2].active(active: true);
		OreHelper(num, num2);
		if (!gen)
		{
			SquareTileFrame(num, num2);
		}
		int num3 = num2;
		while (num2 < num3 + genRand.Next(8, 13))
		{
			num += genRand.Next(-1, 2);
			num2 += genRand.Next(1, 3);
			if (genRand.Next(3) == 0)
			{
				num2++;
			}
			Main.tile[num, num2].type = type;
			Main.tile[num, num2].active(active: true);
			OreHelper(num, num2);
			if (!gen)
			{
				SquareTileFrame(num, num2);
			}
			if (genRand.Next(4) == 0)
			{
				int num4 = num + genRand.Next(-2, 3);
				int num5 = num2 + genRand.Next(2);
				Main.tile[num4, num5].type = type;
				Main.tile[num4, num5].active(active: true);
				OreHelper(num4, num5);
				if (!gen)
				{
					SquareTileFrame(num4, num5);
				}
			}
		}
		Vector2D vector2D = new Vector2D(num, num2);
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = genRand.NextDouble() * 0.6 - 0.3;
		vector2D2.Y = genRand.NextDouble() * 0.5 + 0.5;
		double num6 = genRand.Next(5, 9);
		int num7 = genRand.Next(9, 14);
		if (genRand.Next(3) == 0)
		{
			num6 += (double)genRand.Next(2);
		}
		if (genRand.Next(3) == 0)
		{
			num7 += genRand.Next(2);
		}
		while (num7 > 0)
		{
			num7--;
			for (int k = num - (int)num6 * 4; (double)k <= (double)num + num6 * 4.0; k++)
			{
				for (int l = num2 - (int)num6 * 4; (double)l <= (double)num2 + num6 * 4.0; l++)
				{
					double num8 = num6 * (0.5 + genRand.NextDouble() * 0.5) * 0.1;
					double num9 = num6 * (0.7 + genRand.NextDouble() * 0.6) * 0.3;
					if (genRand.Next(8) == 0)
					{
						num9 *= 2.0;
					}
					Vector2D vector2D3 = vector2D - new Vector2D(k, l);
					if (vector2D3.Length() < num8)
					{
						Main.tile[k, l].active(active: false);
					}
					else if (vector2D3.Length() < num9)
					{
						Main.tile[k, l].type = type;
						if (genRand.Next(4) == 0)
						{
							Main.tile[k, l].active(active: true);
						}
						OreHelper(k, l);
						if (!gen)
						{
							SquareTileFrame(k, l);
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += genRand.NextDouble() * 0.2 - 0.1;
			vector2D2.Y += genRand.NextDouble() * 0.2 - 0.1;
			Utils.Clamp(vector2D2.X, -0.3, 0.3);
			Utils.Clamp(vector2D2.Y, 0.5, 1.0);
		}
		return true;
	}

	public static bool PlaceOasis(int X, int Y)
	{
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_092e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0933: Unknown result type (might be due to invalid IL or missing references)
		int i = Y;
		if (!Main.tile[X, i].active() && Main.tile[X, i].wall == 0)
		{
			for (; !Main.tile[X, i].active() && Main.tile[X, i].wall == 0 && (double)i <= Main.worldSurface; i++)
			{
			}
			if ((double)i > Main.worldSurface - 10.0)
			{
				return false;
			}
			if (Main.tile[X, i].type != 53)
			{
				return false;
			}
			int num = 350;
			for (int j = 0; j < GenVars.numOasis; j++)
			{
				if (Vector2D.Distance(GenVars.oasisPosition[j].ToVector2D(), new Vector2D(X, i)) < (double)num)
				{
					return false;
				}
			}
			int num11 = genRand.Next(45, 61);
			int oasisHeight = GenVars.oasisHeight;
			int num20 = num11 + 50;
			int num21 = 4;
			for (int k = X - num20; k <= X + num20; k++)
			{
				for (int l = i - oasisHeight; l <= i + oasisHeight + num21; l++)
				{
					Tile tile = Main.tile[k, l];
					if (tile.active())
					{
						if (Main.tileSolid[tile.type])
						{
							if ((tile.type == 151 || tile.type == 397) && Math.Abs(k - X) < num11 && Math.Abs(l - i) < oasisHeight / 2)
							{
								return false;
							}
							if (tile.type != 53)
							{
								return false;
							}
						}
					}
					else if ((tile.liquid > 0 || tile.wall > 0) && Math.Abs(k - X) < num11 && Math.Abs(l - i) < oasisHeight / 2)
					{
						return false;
					}
				}
				if (k > X - num11 / 2 && k < X - num11 / 2)
				{
					if (Main.tile[k, i - 6].active())
					{
						return false;
					}
					if (!Main.tile[k, i + 1].active())
					{
						return false;
					}
				}
			}
			int num22 = 5;
			int num23 = i;
			while (!Main.tile[X - num11, i + num22].active() || Main.tile[X - num11, i + num22].wall != 0 || !Main.tile[X + num11, i + num22].active() || Main.tile[X + num11, i + num22].wall != 0)
			{
				i++;
				if (i - num23 > 20)
				{
					break;
				}
			}
			int num24 = num11 / 2;
			int num25 = X - num11 * 3;
			int num26 = X + num11 * 3;
			int num2 = i - oasisHeight * 4;
			int num3 = i + oasisHeight * 3;
			if (num25 < 0)
			{
				num25 = 0;
			}
			if (num26 > Main.maxTilesX)
			{
				num26 = Main.maxTilesX;
			}
			if (num2 < 0)
			{
				num2 = 0;
			}
			if (num3 > Main.maxTilesY)
			{
				num3 = Main.maxTilesY;
			}
			for (int m = num25; m < num26; m++)
			{
				for (int n = num2; n < num3; n++)
				{
					double num4 = (double)Math.Abs(m - X) * 0.7;
					double num5 = (double)Math.Abs(n - i) * 1.35;
					double num27 = Math.Sqrt(num4 * num4 + num5 * num5);
					double num6 = (double)num24 * (0.53 + genRand.NextDouble() * 0.04);
					double num7 = (double)Math.Abs(m - X) / (double)(num26 - X);
					num7 = 1.0 - num7;
					num7 *= 2.3;
					num7 *= num7;
					num7 *= num7;
					if (num27 < num6)
					{
						if (n == i + 1)
						{
							Main.tile[m, n].liquid = 127;
						}
						else if (n > i + 1)
						{
							Main.tile[m, n].liquid = byte.MaxValue;
						}
						Main.tile[m, n].lava(lava: false);
						Main.tile[m, n].active(active: false);
					}
					else if (n < i && num4 < num6 + (double)(Math.Abs(n - i) * 3) * num7)
					{
						if (Main.tile[m, n].type == 53)
						{
							Main.tile[m, n].active(active: false);
						}
					}
					else if (n >= i && num4 < num6 + (double)Math.Abs(n - i) * num7 && Main.tile[m, n].wall == 0)
					{
						if (Main.tile[m, n].active() && Main.tileSolid[Main.tile[m, n].type] && !Main.tileSolidTop[Main.tile[m, n].type])
						{
							Main.tile[m, n].slope(0);
							Main.tile[m, n].halfBrick(halfBrick: false);
							continue;
						}
						Main.tile[m, n].active(active: true);
						Main.tile[m, n].type = 53;
						Main.tile[m, n].slope(0);
						Main.tile[m, n].halfBrick(halfBrick: false);
					}
				}
			}
			int num8 = 50;
			num25 = X - num11 * 2;
			num26 = X + num11 * 2;
			num3 = i + oasisHeight * 2;
			for (int num9 = num25; num9 < num26; num9++)
			{
				for (int num10 = num3; num10 >= i; num10--)
				{
					double num28 = (double)Math.Abs(num9 - X) * 0.7;
					double num12 = (double)Math.Abs(num10 - i) * 1.35;
					double num29 = Math.Sqrt(num28 * num28 + num12 * num12);
					double num13 = (double)num24 * 0.5700000000000001;
					if (num29 > num13)
					{
						bool flag = false;
						if (!Main.tile[num9, num10].active() && Main.tile[num9, num10].wall == 0)
						{
							int num14 = -1;
							int num15 = -1;
							for (int num16 = num9; num16 <= num9 + num8 && Main.tile[num16, num10 + 1].active() && Main.tileSolid[Main.tile[num16, num10 + 1].type] && Main.tile[num16, num10].wall <= 0; num16++)
							{
								if (Main.tile[num16, num10].active() && Main.tileSolid[Main.tile[num16, num10].type])
								{
									if (Main.tile[num16, num10].type == 53)
									{
										flag = true;
									}
									num15 = num16;
									break;
								}
								if (Main.tile[num16, num10].active())
								{
									break;
								}
							}
							int num17 = num9;
							while (num17 >= num9 - num8 && Main.tile[num17, num10 + 1].active() && Main.tileSolid[Main.tile[num17, num10 + 1].type] && Main.tile[num17, num10].wall <= 0)
							{
								if (Main.tile[num17, num10].active() && Main.tileSolid[Main.tile[num17, num10].type])
								{
									if (Main.tile[num17, num10].type == 53)
									{
										flag = true;
									}
									num14 = num17;
									break;
								}
								if (Main.tile[num17, num10].active())
								{
									break;
								}
								num17--;
							}
							flag = true;
							if (num14 > -1 && num15 > -1 && flag)
							{
								int num18 = 0;
								for (int num19 = num14 + 1; num19 < num15; num19++)
								{
									if (num15 - num14 > 5 && genRand.Next(5) == 0)
									{
										num18 = genRand.Next(5, 10);
									}
									Main.tile[num19, num10].active(active: true);
									Main.tile[num19, num10].type = 53;
									if (num18 > 0)
									{
										num18--;
										Main.tile[num19, num10 - 1].active(active: true);
										Main.tile[num19, num10 - 1].type = 53;
									}
								}
							}
						}
					}
				}
			}
			if (GenVars.numOasis < GenVars.maxOasis)
			{
				GenVars.oasisPosition[GenVars.numOasis] = new Point(X, i);
				GenVars.oasisWidth[GenVars.numOasis] = num11;
				GenVars.numOasis++;
			}
			return true;
		}
		return false;
	}

	public static bool BiomeTileCheck(int x, int y)
	{
		int num = 50;
		for (int i = x - num; i <= x + num; i++)
		{
			for (int j = y - num; j <= y + num; j++)
			{
				if (!InWorld(i, j))
				{
					continue;
				}
				if (Main.tile[i, j].active())
				{
					int type = Main.tile[i, j].type;
					if (type == 368 || type == 367 || type == 147 || type == 161 || type == 162 || type == 70 || type == 72 || type == 396 || type == 397)
					{
						return true;
					}
				}
				int wall = Main.tile[i, j].wall;
				if (wall == 187 || wall == 216)
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool oceanDepths(int x, int y)
	{
		if ((double)y > oceanLevel)
		{
			return false;
		}
		if (x < beachDistance || x > Main.maxTilesX - beachDistance)
		{
			return true;
		}
		return false;
	}

	public static void UpdateDesertHiveBounds(int x, int y)
	{
		if (GenVars.desertHiveHigh > y)
		{
			GenVars.desertHiveHigh = y;
		}
		if (GenVars.desertHiveLow < y)
		{
			GenVars.desertHiveLow = y;
		}
		if (GenVars.desertHiveLeft > x)
		{
			GenVars.desertHiveLeft = x;
		}
		if (GenVars.desertHiveRight < x)
		{
			GenVars.desertHiveRight = x;
		}
	}

	public static void GenerateWorld(int seed, GenerationProgress customProgressObject = null)
	{
		Stopwatch generationStopwatch = Stopwatch.StartNew();
		remixWorldGen = tempRemixWorldGen;
		tenthAnniversaryWorldGen = tempTenthAnniversaryWorldGen;
		drunkWorldGen = false;
		drunkWorldGenText = false;
		Main.afterPartyOfDoom = false;
		if (seed == 5162020 || everythingWorldGen)
		{
			drunkWorldGen = true;
			drunkWorldGenText = true;
			Main.drunkWorld = true;
			Main.rand = new UnifiedRandom();
			seed = Main.rand.Next(999999999);
			if (!Main.dayTime)
			{
				Main.time = 0.0;
			}
		}
		else if (seed == 5162021 || seed == 5162011)
		{
			tenthAnniversaryWorldGen = true;
		}
		Main.notTheBeesWorld = notTheBees;
		if (notTheBees)
		{
			Main.rand = new UnifiedRandom();
			seed = Main.rand.Next(999999999);
		}
		Main.noTrapsWorld = noTrapsWorldGen;
		if (noTrapsWorldGen)
		{
			Main.rand = new UnifiedRandom();
			seed = Main.rand.Next(999999999);
		}
		if (getGoodWorldGen)
		{
			Main.getGoodWorld = true;
			Main.rand = new UnifiedRandom();
			seed = Main.rand.Next(999999999);
		}
		else
		{
			Main.getGoodWorld = false;
		}
		Main.tenthAnniversaryWorld = tenthAnniversaryWorldGen;
		if (tenthAnniversaryWorldGen)
		{
			Main.rand = new UnifiedRandom();
			seed = Main.rand.Next(999999999);
		}
		Main.dontStarveWorld = dontStarveWorldGen;
		if (dontStarveWorldGen)
		{
			Main.rand = new UnifiedRandom();
			seed = Main.rand.Next(999999999);
		}
		Main.remixWorld = remixWorldGen;
		if (remixWorldGen)
		{
			Main.rand = new UnifiedRandom();
			seed = Main.rand.Next(999999999);
		}
		Main.zenithWorld = everythingWorldGen;
		Utils.LogAndConsoleInfoMessageFormat("Creating world - Seed: {0}, Width: {1}, Height: {2}, Evil: {3}, IsExpert: {4}", seed, Main.maxTilesX, Main.maxTilesY, WorldGenParam_Evil, Main.expertMode);
		Main.lockMenuBGChange = true;
		GenVars.configuration = WorldGenConfiguration.FromEmbeddedPath("Terraria.GameContent.WorldBuilding.Configuration.json");
		Hooks.ProcessWorldGenConfig(ref GenVars.configuration);
		Logging.Terraria.InfoFormat("Generating World: {0}", (object)Main.ActiveWorldFileData.Name);
		_lastSeed = seed;
		_generator = new WorldGenerator(seed, GenVars.configuration);
		_genRand = new UnifiedRandom(seed);
		Main.rand = new UnifiedRandom(seed);
		GenVars.structures = new StructureMap();
		GenVars.desertHiveHigh = Main.maxTilesY;
		GenVars.desertHiveLow = 0;
		GenVars.desertHiveLeft = Main.maxTilesX;
		GenVars.desertHiveRight = 0;
		GenVars.worldSurfaceLow = 0.0;
		GenVars.worldSurface = 0.0;
		GenVars.worldSurfaceHigh = 0.0;
		GenVars.rockLayerLow = 0.0;
		GenVars.rockLayer = 0.0;
		GenVars.rockLayerHigh = 0.0;
		GenVars.copper = 7;
		GenVars.iron = 6;
		GenVars.silver = 9;
		GenVars.gold = 8;
		GenVars.dungeonSide = 0;
		GenVars.jungleHut = (ushort)genRand.Next(5);
		GenVars.shellStartXLeft = 0;
		GenVars.shellStartYLeft = 0;
		GenVars.shellStartXRight = 0;
		GenVars.shellStartYRight = 0;
		GenVars.PyrX = null;
		GenVars.PyrY = null;
		GenVars.numPyr = 0;
		GenVars.jungleMinX = -1;
		GenVars.jungleMaxX = -1;
		GenVars.snowMinX = new int[Main.maxTilesY];
		GenVars.snowMaxX = new int[Main.maxTilesY];
		GenVars.snowTop = 0;
		GenVars.snowBottom = 0;
		GenVars.skyLakes = 1;
		if (Main.maxTilesX > 8000)
		{
			GenVars.skyLakes++;
		}
		if (Main.maxTilesX > 6000)
		{
			GenVars.skyLakes++;
		}
		GenVars.beachBordersWidth = 275;
		GenVars.beachSandRandomCenter = GenVars.beachBordersWidth + 5 + 40;
		GenVars.beachSandRandomWidthRange = 20;
		GenVars.beachSandDungeonExtraWidth = 40;
		GenVars.beachSandJungleExtraWidth = 20;
		GenVars.oceanWaterStartRandomMin = 220;
		GenVars.oceanWaterStartRandomMax = GenVars.oceanWaterStartRandomMin + 40;
		GenVars.oceanWaterForcedJungleLength = 275;
		GenVars.leftBeachEnd = 0;
		GenVars.rightBeachStart = 0;
		GenVars.evilBiomeBeachAvoidance = GenVars.beachSandRandomCenter + 60;
		GenVars.evilBiomeAvoidanceMidFixer = 50;
		GenVars.lakesBeachAvoidance = GenVars.beachSandRandomCenter + 20;
		GenVars.smallHolesBeachAvoidance = GenVars.beachSandRandomCenter + 20;
		GenVars.surfaceCavesBeachAvoidance = GenVars.beachSandRandomCenter + 20;
		GenVars.surfaceCavesBeachAvoidance2 = GenVars.beachSandRandomCenter + 20;
		GenVars.jungleOriginX = 0;
		GenVars.snowOriginLeft = 0;
		GenVars.snowOriginRight = 0;
		GenVars.logX = -1;
		GenVars.logY = -1;
		GenVars.dungeonLocation = 0;
		SystemLoader.PreWorldGen();
		if (everythingWorldGen)
		{
			Main.starGame = true;
		}
		AddGenPassesFromLoadTime();
		GenerateWorld_RunTasksAndFinish(seed, generationStopwatch, customProgressObject);
	}

	internal static void AddGenPasses()
	{
		AddGenerationPass("Reset", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			if (genRand.Next(2) == 0)
			{
				GenVars.crimsonLeft = false;
			}
			else
			{
				GenVars.crimsonLeft = true;
			}
			GenVars.numOceanCaveTreasure = 0;
			GenVars.skipDesertTileCheck = false;
			growGrassUnderground = false;
			gen = true;
			Liquid.ReInit();
			noTileActions = true;
			progress.Message = "";
			SetupStatueList();
			RandomizeWeather();
			Main.cloudAlpha = 0f;
			Main.maxRaining = 0f;
			Main.raining = false;
			heartCount = 0;
			GenVars.extraBastStatueCount = 0;
			GenVars.extraBastStatueCountMax = 2;
			Main.checkXMas();
			Main.checkHalloween();
			ResetGenerator();
			GenVars.UndergroundDesertLocation = Rectangle.Empty;
			GenVars.UndergroundDesertHiveLocation = Rectangle.Empty;
			GenVars.numLarva = 0;
			List<int> list3 = new List<int> { 274, 220, 112, 218, 3019 };
			if (remixWorldGen)
			{
				list3 = new List<int> { 274, 220, 683, 218, 3019 };
			}
			List<int> list4 = new List<int>();
			while (list3.Count > 0)
			{
				int index = genRand.Next(list3.Count);
				int item = list3[index];
				list4.Add(item);
				list3.RemoveAt(index);
			}
			GenVars.hellChestItem = list4.ToArray();
			int num1064 = 86400;
			Main.slimeRainTime = -genRand.Next(num1064 * 2, num1064 * 3);
			Main.cloudBGActive = -genRand.Next(8640, 86400);
			skipFramingDuringGen = false;
			SavedOreTiers.Copper = 7;
			SavedOreTiers.Iron = 6;
			SavedOreTiers.Silver = 9;
			SavedOreTiers.Gold = 8;
			GenVars.copperBar = 20;
			GenVars.ironBar = 22;
			GenVars.silverBar = 21;
			GenVars.goldBar = 19;
			if (genRand.Next(2) == 0)
			{
				GenVars.copper = 166;
				GenVars.copperBar = 703;
				SavedOreTiers.Copper = 166;
			}
			if ((!dontStarveWorldGen || drunkWorldGen) && genRand.Next(2) == 0)
			{
				GenVars.iron = 167;
				GenVars.ironBar = 704;
				SavedOreTiers.Iron = 167;
			}
			if (genRand.Next(2) == 0)
			{
				GenVars.silver = 168;
				GenVars.silverBar = 705;
				SavedOreTiers.Silver = 168;
			}
			if ((!dontStarveWorldGen || drunkWorldGen) && genRand.Next(2) == 0)
			{
				GenVars.gold = 169;
				GenVars.goldBar = 706;
				SavedOreTiers.Gold = 169;
			}
			crimson = genRand.Next(2) == 0;
			if (WorldGenParam_Evil == 0)
			{
				crimson = false;
			}
			if (WorldGenParam_Evil == 1)
			{
				crimson = true;
			}
			if (GenVars.jungleHut == 0)
			{
				GenVars.jungleHut = 119;
			}
			else if (GenVars.jungleHut == 1)
			{
				GenVars.jungleHut = 120;
			}
			else if (GenVars.jungleHut == 2)
			{
				GenVars.jungleHut = 158;
			}
			else if (GenVars.jungleHut == 3)
			{
				GenVars.jungleHut = 175;
			}
			else if (GenVars.jungleHut == 4)
			{
				GenVars.jungleHut = 45;
			}
			Main.worldID = genRand.Next(int.MaxValue);
			RandomizeTreeStyle();
			RandomizeCaveBackgrounds();
			RandomizeBackgrounds(genRand);
			RandomizeMoonState(genRand);
			TreeTops.CopyExistingWorldInfoForWorldGeneration();
			GenVars.dungeonSide = ((genRand.Next(2) != 0) ? 1 : (-1));
			if (remixWorldGen)
			{
				if (GenVars.dungeonSide == -1)
				{
					double num1065 = 1.0 - (double)genRand.Next(20, 35) * 0.01;
					GenVars.jungleOriginX = (int)((double)Main.maxTilesX * num1065);
				}
				else
				{
					double num1066 = (double)genRand.Next(20, 35) * 0.01;
					GenVars.jungleOriginX = (int)((double)Main.maxTilesX * num1066);
				}
			}
			else
			{
				int minValue3 = 15;
				int maxValue12 = 30;
				if (tenthAnniversaryWorldGen && !remixWorldGen)
				{
					minValue3 = 25;
					maxValue12 = 35;
				}
				if (GenVars.dungeonSide == -1)
				{
					double num1067 = 1.0 - (double)genRand.Next(minValue3, maxValue12) * 0.01;
					GenVars.jungleOriginX = (int)((double)Main.maxTilesX * num1067);
				}
				else
				{
					double num1068 = (double)genRand.Next(minValue3, maxValue12) * 0.01;
					GenVars.jungleOriginX = (int)((double)Main.maxTilesX * num1068);
				}
			}
			int num1069 = genRand.Next(Main.maxTilesX);
			if (drunkWorldGen)
			{
				GenVars.dungeonSide *= -1;
			}
			if (GenVars.dungeonSide == 1)
			{
				while ((double)num1069 < (double)Main.maxTilesX * 0.6 || (double)num1069 > (double)Main.maxTilesX * 0.75)
				{
					num1069 = genRand.Next(Main.maxTilesX);
				}
			}
			else
			{
				while ((double)num1069 < (double)Main.maxTilesX * 0.25 || (double)num1069 > (double)Main.maxTilesX * 0.4)
				{
					num1069 = genRand.Next(Main.maxTilesX);
				}
			}
			if (drunkWorldGen)
			{
				GenVars.dungeonSide *= -1;
			}
			int num1070 = genRand.Next(50, 90);
			double num1071 = (double)Main.maxTilesX / 4200.0;
			num1070 += (int)((double)genRand.Next(20, 40) * num1071);
			num1070 += (int)((double)genRand.Next(20, 40) * num1071);
			int num1072 = num1069 - num1070;
			num1070 = genRand.Next(50, 90);
			num1070 += (int)((double)genRand.Next(20, 40) * num1071);
			num1070 += (int)((double)genRand.Next(20, 40) * num1071);
			int num1073 = num1069 + num1070;
			if (num1072 < 0)
			{
				num1072 = 0;
			}
			if (num1073 > Main.maxTilesX)
			{
				num1073 = Main.maxTilesX;
			}
			GenVars.snowOriginLeft = num1072;
			GenVars.snowOriginRight = num1073;
			GenVars.leftBeachEnd = genRand.Next(GenVars.beachSandRandomCenter - GenVars.beachSandRandomWidthRange, GenVars.beachSandRandomCenter + GenVars.beachSandRandomWidthRange);
			if (tenthAnniversaryWorldGen && !remixWorldGen)
			{
				GenVars.leftBeachEnd = GenVars.beachSandRandomCenter + GenVars.beachSandRandomWidthRange;
			}
			if (GenVars.dungeonSide == 1)
			{
				GenVars.leftBeachEnd += GenVars.beachSandDungeonExtraWidth;
			}
			else
			{
				GenVars.leftBeachEnd += GenVars.beachSandJungleExtraWidth;
			}
			GenVars.rightBeachStart = Main.maxTilesX - genRand.Next(GenVars.beachSandRandomCenter - GenVars.beachSandRandomWidthRange, GenVars.beachSandRandomCenter + GenVars.beachSandRandomWidthRange);
			if (tenthAnniversaryWorldGen && !remixWorldGen)
			{
				GenVars.rightBeachStart = Main.maxTilesX - (GenVars.beachSandRandomCenter + GenVars.beachSandRandomWidthRange);
			}
			if (GenVars.dungeonSide == -1)
			{
				GenVars.rightBeachStart -= GenVars.beachSandDungeonExtraWidth;
			}
			else
			{
				GenVars.rightBeachStart -= GenVars.beachSandJungleExtraWidth;
			}
			int num1074 = 50;
			if (GenVars.dungeonSide == -1)
			{
				GenVars.dungeonLocation = genRand.Next(GenVars.leftBeachEnd + num1074, (int)((double)Main.maxTilesX * 0.2));
			}
			else
			{
				GenVars.dungeonLocation = genRand.Next((int)((double)Main.maxTilesX * 0.8), GenVars.rightBeachStart - num1074);
			}
			int num1075 = 0;
			if (Main.maxTilesX >= 8400)
			{
				num1075 = 2;
			}
			else if (Main.maxTilesX >= 6400)
			{
				num1075 = 1;
			}
			GenVars.extraBastStatueCountMax = 2 + num1075;
			Main.tileSolid[659] = false;
		});
		AddGenerationPass(new TerrainPass());
		AddGenerationPass("Dunes", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0155: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			//IL_0174: Unknown result type (might be due to invalid IL or missing references)
			//IL_0181: Unknown result type (might be due to invalid IL or missing references)
			progress.Message = Lang.gen[1].Value;
			int random9 = passConfig.Get<WorldGenRange>("Count").GetRandom(genRand);
			double num1058 = passConfig.Get<double>("ChanceOfPyramid");
			if (drunkWorldGen)
			{
				num1058 = 1.0;
			}
			double num1059 = (double)Main.maxTilesX / 4200.0;
			GenVars.PyrX = new int[random9 + 3];
			GenVars.PyrY = new int[random9 + 3];
			DunesBiome dunesBiome = GenVars.configuration.CreateBiome<DunesBiome>();
			for (int num1060 = 0; num1060 < random9; num1060++)
			{
				progress.Set((double)num1060 / (double)random9);
				Point val7 = Point.Zero;
				bool flag62 = false;
				int num1061 = 0;
				while (!flag62)
				{
					val7 = RandomWorldPoint(0, 500, 0, 500);
					bool flag63 = Math.Abs(val7.X - GenVars.jungleOriginX) < (int)(600.0 * num1059);
					bool flag64 = Math.Abs(val7.X - Main.maxTilesX / 2) < 300;
					bool flag65 = val7.X > GenVars.snowOriginLeft - 300 && val7.X < GenVars.snowOriginRight + 300;
					num1061++;
					if (num1061 >= Main.maxTilesX)
					{
						flag63 = false;
					}
					if (num1061 >= Main.maxTilesX * 2)
					{
						flag65 = false;
					}
					flag62 = !(flag63 || flag64 || flag65);
				}
				dunesBiome.Place(val7, GenVars.structures);
				if (genRand.NextDouble() <= num1058)
				{
					int num1062 = genRand.Next(val7.X - 200, val7.X + 200);
					for (int num1063 = 0; num1063 < Main.maxTilesY; num1063++)
					{
						if (Main.tile[num1062, num1063].active())
						{
							GenVars.PyrX[GenVars.numPyr] = num1062;
							GenVars.PyrY[GenVars.numPyr] = num1063 + 20;
							GenVars.numPyr++;
							break;
						}
					}
				}
			}
		});
		AddGenerationPass("Ocean Sand", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Language.GetTextValue("WorldGeneration.OceanSand");
			for (int num1047 = 0; num1047 < 3; num1047++)
			{
				progress.Set((double)num1047 / 3.0);
				int num1048 = genRand.Next(Main.maxTilesX);
				while ((double)num1048 > (double)Main.maxTilesX * 0.4 && (double)num1048 < (double)Main.maxTilesX * 0.6)
				{
					num1048 = genRand.Next(Main.maxTilesX);
				}
				int num1049 = genRand.Next(35, 90);
				if (num1047 == 1)
				{
					double num1050 = (double)Main.maxTilesX / 4200.0;
					num1049 += (int)((double)genRand.Next(20, 40) * num1050);
				}
				if (genRand.Next(3) == 0)
				{
					num1049 *= 2;
				}
				if (num1047 == 1)
				{
					num1049 *= 2;
				}
				int num1051 = num1048 - num1049;
				num1049 = genRand.Next(35, 90);
				if (genRand.Next(3) == 0)
				{
					num1049 *= 2;
				}
				if (num1047 == 1)
				{
					num1049 *= 2;
				}
				int num1052 = num1048 + num1049;
				if (num1051 < 0)
				{
					num1051 = 0;
				}
				if (num1052 > Main.maxTilesX)
				{
					num1052 = Main.maxTilesX;
				}
				if (num1047 == 0)
				{
					num1051 = 0;
					num1052 = GenVars.leftBeachEnd;
				}
				else if (num1047 == 2)
				{
					num1051 = GenVars.rightBeachStart;
					num1052 = Main.maxTilesX;
				}
				else if (num1047 == 1)
				{
					continue;
				}
				int num1053 = genRand.Next(50, 100);
				for (int num1054 = num1051; num1054 < num1052; num1054++)
				{
					if (genRand.Next(2) == 0)
					{
						num1053 += genRand.Next(-1, 2);
						if (num1053 < 50)
						{
							num1053 = 50;
						}
						if (num1053 > 200)
						{
							num1053 = 200;
						}
					}
					for (int num1055 = 0; (double)num1055 < (Main.worldSurface + Main.rockLayer) / 2.0; num1055++)
					{
						if (Main.tile[num1054, num1055].active())
						{
							if (num1054 == (num1051 + num1052) / 2 && genRand.Next(6) == 0)
							{
								GenVars.PyrX[GenVars.numPyr] = num1054;
								GenVars.PyrY[GenVars.numPyr] = num1055;
								GenVars.numPyr++;
							}
							int num1056 = num1053;
							if (num1054 - num1051 < num1056)
							{
								num1056 = num1054 - num1051;
							}
							if (num1052 - num1054 < num1056)
							{
								num1056 = num1052 - num1054;
							}
							num1056 += genRand.Next(5);
							for (int num1057 = num1055; num1057 < num1055 + num1056; num1057++)
							{
								if (num1054 > num1051 + genRand.Next(5) && num1054 < num1052 - genRand.Next(5))
								{
									Main.tile[num1054, num1057].type = 53;
								}
							}
							break;
						}
					}
				}
			}
		});
		AddGenerationPass("Sand Patches", delegate
		{
			int num1042 = (int)((double)Main.maxTilesX * 0.013);
			if (remixWorldGen)
			{
				num1042 /= 4;
			}
			for (int num1043 = 0; num1043 < num1042; num1043++)
			{
				int num1044 = genRand.Next(0, Main.maxTilesX);
				int num1045 = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
				if (remixWorldGen)
				{
					num1045 = genRand.Next((int)Main.rockLayer - 100, Main.maxTilesY - 350);
				}
				while ((double)num1044 > (double)Main.maxTilesX * 0.46 && (double)num1044 < (double)Main.maxTilesX * 0.54 && (double)num1045 < Main.worldSurface + 150.0)
				{
					num1044 = genRand.Next(0, Main.maxTilesX);
					num1045 = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
				}
				int num1046 = genRand.Next(15, 70);
				int steps2 = genRand.Next(20, 130);
				TileRunner(num1044, num1045, num1046, steps2, 53);
			}
		});
		AddGenerationPass("Tunnels", delegate
		{
			int num1036 = (int)((double)Main.maxTilesX * 0.0015);
			if (remixWorldGen)
			{
				num1036 = (int)((double)num1036 * 1.5);
			}
			for (int num1037 = 0; num1037 < num1036; num1037++)
			{
				if (GenVars.numTunnels >= GenVars.maxTunnels - 1)
				{
					break;
				}
				int[] array = new int[10];
				int[] array2 = new int[10];
				int num1038 = genRand.Next(450, Main.maxTilesX - 450);
				if (!remixWorldGen)
				{
					if (tenthAnniversaryWorldGen)
					{
						num1038 = genRand.Next((int)((double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.8));
					}
					else
					{
						while ((double)num1038 > (double)Main.maxTilesX * 0.4 && (double)num1038 < (double)Main.maxTilesX * 0.6)
						{
							num1038 = genRand.Next(450, Main.maxTilesX - 450);
						}
					}
				}
				int num1039 = 0;
				bool flag61;
				do
				{
					flag61 = false;
					for (int num1040 = 0; num1040 < 10; num1040++)
					{
						for (num1038 %= Main.maxTilesX; !Main.tile[num1038, num1039].active(); num1039++)
						{
						}
						if (Main.tile[num1038, num1039].type == 53)
						{
							flag61 = true;
						}
						array[num1040] = num1038;
						array2[num1040] = num1039 - genRand.Next(11, 16);
						num1038 += genRand.Next(5, 11);
					}
				}
				while (flag61);
				GenVars.tunnelX[GenVars.numTunnels] = array[5];
				GenVars.numTunnels++;
				for (int num1041 = 0; num1041 < 10; num1041++)
				{
					TileRunner(array[num1041], array2[num1041], genRand.Next(5, 8), genRand.Next(6, 9), 0, addTile: true, -2.0, -0.3);
					TileRunner(array[num1041], array2[num1041], genRand.Next(5, 8), genRand.Next(6, 9), 0, addTile: true, 2.0, -0.3);
				}
			}
		});
		AddGenerationPass("Mount Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			GenVars.numMCaves = 0;
			progress.Message = Lang.gen[2].Value;
			int num1028 = (int)((double)Main.maxTilesX * 0.001);
			if (remixWorldGen)
			{
				num1028 = (int)((double)num1028 * 1.5);
			}
			for (int num1029 = 0; num1029 < num1028; num1029++)
			{
				progress.Set((double)num1029 / (double)num1028);
				int num1030 = 0;
				bool flag59 = false;
				bool flag60 = false;
				int num1031 = genRand.Next((int)((double)Main.maxTilesX * 0.25), (int)((double)Main.maxTilesX * 0.75));
				while (!flag60)
				{
					flag60 = true;
					if (!remixWorldGen)
					{
						while (num1031 > Main.maxTilesX / 2 - 90 && num1031 < Main.maxTilesX / 2 + 90)
						{
							num1031 = genRand.Next((int)((double)Main.maxTilesX * 0.25), (int)((double)Main.maxTilesX * 0.75));
						}
					}
					for (int num1032 = 0; num1032 < GenVars.numMCaves; num1032++)
					{
						if (Math.Abs(num1031 - GenVars.mCaveX[num1032]) < 100)
						{
							num1030++;
							flag60 = false;
							break;
						}
					}
					if (num1030 >= Main.maxTilesX / 5)
					{
						flag59 = true;
						break;
					}
				}
				if (!flag59)
				{
					for (int num1033 = 0; (double)num1033 < Main.worldSurface; num1033++)
					{
						if (Main.tile[num1031, num1033].active())
						{
							for (int num1034 = num1031 - 50; num1034 < num1031 + 50; num1034++)
							{
								for (int num1035 = num1033 - 25; num1035 < num1033 + 25; num1035++)
								{
									if (Main.tile[num1034, num1035].active() && (Main.tile[num1034, num1035].type == 53 || Main.tile[num1034, num1035].type == 151 || Main.tile[num1034, num1035].type == 274))
									{
										flag59 = true;
									}
								}
							}
							if (!flag59)
							{
								Mountinater(num1031, num1033);
								GenVars.mCaveX[GenVars.numMCaves] = num1031;
								GenVars.mCaveY[GenVars.numMCaves] = num1033;
								GenVars.numMCaves++;
								break;
							}
						}
					}
				}
			}
		});
		AddGenerationPass("Dirt Wall Backgrounds", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[3].Value;
			int num1024 = 0;
			for (int num1025 = 1; num1025 < Main.maxTilesX - 1; num1025++)
			{
				ushort num1026 = 2;
				double value20 = (double)num1025 / (double)Main.maxTilesX;
				progress.Set(value20);
				bool flag58 = false;
				num1024 += genRand.Next(-1, 2);
				if (num1024 < 0)
				{
					num1024 = 0;
				}
				if (num1024 > 10)
				{
					num1024 = 10;
				}
				for (int num1027 = 0; (double)num1027 < Main.worldSurface + 10.0 && !((double)num1027 > Main.worldSurface + (double)num1024); num1027++)
				{
					if (Main.tile[num1025, num1027].active())
					{
						num1026 = (ushort)((Main.tile[num1025, num1027].type != 147) ? 2u : 40u);
					}
					if (flag58 && Main.tile[num1025, num1027].wall != 64)
					{
						Main.tile[num1025, num1027].wall = num1026;
					}
					if (Main.tile[num1025, num1027].active() && Main.tile[num1025 - 1, num1027].active() && Main.tile[num1025 + 1, num1027].active() && Main.tile[num1025, num1027 + 1].active() && Main.tile[num1025 - 1, num1027 + 1].active() && Main.tile[num1025 + 1, num1027 + 1].active())
					{
						flag58 = true;
					}
				}
			}
		});
		AddGenerationPass("Rocks In Dirt", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[4].Value;
			double num1018 = (double)(Main.maxTilesX * Main.maxTilesY) * 0.00015;
			for (int num1019 = 0; (double)num1019 < num1018; num1019++)
			{
				TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)GenVars.worldSurfaceLow + 1), genRand.Next(4, 15), genRand.Next(5, 40), 1);
			}
			progress.Set(0.34);
			num1018 = (double)(Main.maxTilesX * Main.maxTilesY) * 0.0002;
			for (int num1020 = 0; (double)num1020 < num1018; num1020++)
			{
				int num1021 = genRand.Next(0, Main.maxTilesX);
				int num1022 = genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh + 1);
				if (!Main.tile[num1021, num1022 - 10].active())
				{
					num1022 = genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh + 1);
				}
				TileRunner(num1021, num1022, genRand.Next(4, 10), genRand.Next(5, 30), 1);
			}
			progress.Set(0.67);
			num1018 = (double)(Main.maxTilesX * Main.maxTilesY) * 0.0045;
			for (int num1023 = 0; (double)num1023 < num1018; num1023++)
			{
				TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceHigh, (int)GenVars.rockLayerHigh + 1), genRand.Next(2, 7), genRand.Next(2, 23), 1);
			}
		});
		AddGenerationPass("Dirt In Rocks", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[5].Value;
			double num1014 = (double)(Main.maxTilesX * Main.maxTilesY) * 0.005;
			for (int num1015 = 0; (double)num1015 < num1014; num1015++)
			{
				progress.Set((double)num1015 / num1014);
				TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(2, 6), genRand.Next(2, 40), 0);
			}
			if (remixWorldGen)
			{
				for (int num1016 = 0; num1016 < Main.maxTilesX; num1016++)
				{
					for (int num1017 = (int)Main.worldSurface + genRand.Next(-1, 3); num1017 < Main.maxTilesY; num1017++)
					{
						if (Main.tile[num1016, num1017].active())
						{
							if (Main.tile[num1016, num1017].type == 0)
							{
								Main.tile[num1016, num1017].type = 1;
							}
							else if (Main.tile[num1016, num1017].type == 1)
							{
								Main.tile[num1016, num1017].type = 0;
							}
						}
					}
				}
			}
		});
		AddGenerationPass("Clay", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[6].Value;
			for (int num1007 = 0; num1007 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2E-05); num1007++)
			{
				TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)GenVars.worldSurfaceLow), genRand.Next(4, 14), genRand.Next(10, 50), 40);
			}
			progress.Set(0.25);
			if (remixWorldGen)
			{
				for (int num1008 = 0; num1008 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 7E-05); num1008++)
				{
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayer - 25, Main.maxTilesY - 350), genRand.Next(8, 15), genRand.Next(5, 50), 40);
				}
			}
			else
			{
				for (int num1009 = 0; num1009 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 5E-05); num1009++)
				{
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh + 1), genRand.Next(8, 14), genRand.Next(15, 45), 40);
				}
				progress.Set(0.5);
				for (int num1010 = 0; num1010 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2E-05); num1010++)
				{
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceHigh, (int)GenVars.rockLayerHigh + 1), genRand.Next(8, 15), genRand.Next(5, 50), 40);
				}
			}
			progress.Set(0.75);
			for (int num1011 = 5; num1011 < Main.maxTilesX - 5; num1011++)
			{
				for (int num1012 = 1; (double)num1012 < Main.worldSurface - 1.0; num1012++)
				{
					if (Main.tile[num1011, num1012].active())
					{
						for (int num1013 = num1012; num1013 < num1012 + 5; num1013++)
						{
							if (Main.tile[num1011, num1013].type == 40)
							{
								Main.tile[num1011, num1013].type = 0;
							}
						}
						break;
					}
				}
			}
		});
		AddGenerationPass("Small Holes", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[7].Value;
			double worldSurfaceHigh2 = GenVars.worldSurfaceHigh;
			for (int num1002 = 0; num1002 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0015); num1002++)
			{
				double value19 = (double)num1002 / ((double)(Main.maxTilesX * Main.maxTilesY) * 0.0015);
				progress.Set(value19);
				int type13 = -1;
				if (genRand.Next(5) == 0)
				{
					type13 = -2;
				}
				int num1003 = genRand.Next(0, Main.maxTilesX);
				int num1004 = genRand.Next((int)GenVars.worldSurfaceHigh, Main.maxTilesY);
				if (!remixWorldGen && tenthAnniversaryWorldGen)
				{
					while ((double)num1003 < (double)Main.maxTilesX * 0.2 && (double)num1003 > (double)Main.maxTilesX * 0.8 && (double)num1004 < GenVars.worldSurface)
					{
						num1003 = genRand.Next(0, Main.maxTilesX);
						num1004 = genRand.Next((int)GenVars.worldSurfaceHigh, Main.maxTilesY);
					}
				}
				else
				{
					while (((num1003 < GenVars.smallHolesBeachAvoidance || num1003 > Main.maxTilesX - GenVars.smallHolesBeachAvoidance) && (double)num1004 < worldSurfaceHigh2) || ((double)num1003 > (double)Main.maxTilesX * 0.45 && (double)num1003 < (double)Main.maxTilesX * 0.55 && (double)num1004 < GenVars.worldSurface))
					{
						num1003 = genRand.Next(0, Main.maxTilesX);
						num1004 = genRand.Next((int)GenVars.worldSurfaceHigh, Main.maxTilesY);
					}
				}
				int num1005 = genRand.Next(2, 5);
				int num1006 = genRand.Next(2, 20);
				if (remixWorldGen && (double)num1004 > Main.rockLayer)
				{
					num1005 = (int)((double)num1005 * 0.8);
					num1006 = (int)((double)num1006 * 0.9);
				}
				TileRunner(num1003, num1004, num1005, num1006, type13);
				num1003 = genRand.Next(0, Main.maxTilesX);
				num1004 = genRand.Next((int)GenVars.worldSurfaceHigh, Main.maxTilesY);
				while (((num1003 < GenVars.smallHolesBeachAvoidance || num1003 > Main.maxTilesX - GenVars.smallHolesBeachAvoidance) && (double)num1004 < worldSurfaceHigh2) || ((double)num1003 > (double)Main.maxTilesX * 0.45 && (double)num1003 < (double)Main.maxTilesX * 0.55 && (double)num1004 < GenVars.worldSurface))
				{
					num1003 = genRand.Next(0, Main.maxTilesX);
					num1004 = genRand.Next((int)GenVars.worldSurfaceHigh, Main.maxTilesY);
				}
				num1005 = genRand.Next(8, 15);
				num1006 = genRand.Next(7, 30);
				if (remixWorldGen && (double)num1004 > Main.rockLayer)
				{
					num1005 = (int)((double)num1005 * 0.7);
					num1006 = (int)((double)num1006 * 0.9);
				}
				TileRunner(num1003, num1004, num1005, num1006, type13);
			}
		});
		AddGenerationPass("Dirt Layer Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[8].Value;
			double worldSurfaceHigh = GenVars.worldSurfaceHigh;
			int num996 = (int)((double)(Main.maxTilesX * Main.maxTilesY) * 3E-05);
			if (remixWorldGen)
			{
				num996 *= 2;
			}
			for (int num997 = 0; num997 < num996; num997++)
			{
				double value18 = (double)num997 / (double)num996;
				progress.Set(value18);
				if (GenVars.rockLayerHigh <= (double)Main.maxTilesY)
				{
					int type12 = -1;
					if (genRand.Next(6) == 0)
					{
						type12 = -2;
					}
					int num998 = genRand.Next(0, Main.maxTilesX);
					int num999 = genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.rockLayerHigh + 1);
					while (((num998 < GenVars.smallHolesBeachAvoidance || num998 > Main.maxTilesX - GenVars.smallHolesBeachAvoidance) && (double)num999 < worldSurfaceHigh) || ((double)num998 >= (double)Main.maxTilesX * 0.45 && (double)num998 <= (double)Main.maxTilesX * 0.55 && (double)num999 < Main.worldSurface))
					{
						num998 = genRand.Next(0, Main.maxTilesX);
						num999 = genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.rockLayerHigh + 1);
					}
					int num1000 = genRand.Next(5, 15);
					int num1001 = genRand.Next(30, 200);
					if (remixWorldGen)
					{
						num1000 = (int)((double)num1000 * 1.1);
						num1001 = (int)((double)num1001 * 1.9);
					}
					TileRunner(num998, num999, num1000, num1001, type12);
				}
			}
		});
		AddGenerationPass("Rock Layer Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[9].Value;
			int num988 = (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00013);
			if (remixWorldGen)
			{
				num988 = (int)((double)num988 * 1.1);
			}
			for (int num989 = 0; num989 < num988; num989++)
			{
				double value17 = (double)num989 / (double)num988;
				progress.Set(value17);
				if (GenVars.rockLayerHigh <= (double)Main.maxTilesY)
				{
					int type10 = -1;
					if (genRand.Next(10) == 0)
					{
						type10 = -2;
					}
					int num990 = genRand.Next(6, 20);
					int num991 = genRand.Next(50, 300);
					if (remixWorldGen)
					{
						num990 = (int)((double)num990 * 0.7);
						num991 = (int)((double)num991 * 0.7);
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerHigh, Main.maxTilesY), num990, num991, type10);
				}
			}
			if (remixWorldGen)
			{
				num988 = (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00013 * 0.4);
				for (int num992 = 0; num992 < num988; num992++)
				{
					if (GenVars.rockLayerHigh <= (double)Main.maxTilesY)
					{
						int type11 = -1;
						if (genRand.Next(10) == 0)
						{
							type11 = -2;
						}
						int num993 = genRand.Next(7, 26);
						int steps = genRand.Next(50, 200);
						double num994 = (double)genRand.Next(100, 221) * 0.1;
						double num995 = (double)genRand.Next(-10, 11) * 0.02;
						int i5 = genRand.Next(0, Main.maxTilesX);
						int j7 = genRand.Next((int)GenVars.rockLayerHigh, Main.maxTilesY);
						TileRunner(i5, j7, num993, steps, type11, addTile: false, num994, num995, noYChange: true);
						TileRunner(i5, j7, num993, steps, type11, addTile: false, 0.0 - num994, 0.0 - num995, noYChange: true);
					}
				}
			}
		});
		AddGenerationPass("Surface Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[10].Value;
			int num969 = (int)((double)Main.maxTilesX * 0.002);
			int num970 = (int)((double)Main.maxTilesX * 0.0007);
			int num971 = (int)((double)Main.maxTilesX * 0.0003);
			if (remixWorldGen)
			{
				num969 *= 3;
				num970 *= 3;
				num971 *= 3;
			}
			for (int num972 = 0; num972 < num969; num972++)
			{
				int num973 = genRand.Next(0, Main.maxTilesX);
				while (((double)num973 > (double)Main.maxTilesX * 0.45 && (double)num973 < (double)Main.maxTilesX * 0.55) || num973 < GenVars.leftBeachEnd + 20 || num973 > GenVars.rightBeachStart - 20)
				{
					num973 = genRand.Next(0, Main.maxTilesX);
				}
				for (int num974 = 0; (double)num974 < GenVars.worldSurfaceHigh; num974++)
				{
					if (Main.tile[num973, num974].active())
					{
						TileRunner(num973, num974, genRand.Next(3, 6), genRand.Next(5, 50), -1, addTile: false, (double)genRand.Next(-10, 11) * 0.1, 1.0);
						break;
					}
				}
			}
			progress.Set(0.2);
			for (int num975 = 0; num975 < num970; num975++)
			{
				int num976 = genRand.Next(0, Main.maxTilesX);
				while (((double)num976 > (double)Main.maxTilesX * 0.43 && (double)num976 < (double)Main.maxTilesX * 0.5700000000000001) || num976 < GenVars.leftBeachEnd + 20 || num976 > GenVars.rightBeachStart - 20)
				{
					num976 = genRand.Next(0, Main.maxTilesX);
				}
				for (int num977 = 0; (double)num977 < GenVars.worldSurfaceHigh; num977++)
				{
					if (Main.tile[num976, num977].active())
					{
						TileRunner(num976, num977, genRand.Next(10, 15), genRand.Next(50, 130), -1, addTile: false, (double)genRand.Next(-10, 11) * 0.1, 2.0);
						break;
					}
				}
			}
			progress.Set(0.4);
			for (int num978 = 0; num978 < num971; num978++)
			{
				int num979 = genRand.Next(0, Main.maxTilesX);
				while (((double)num979 > (double)Main.maxTilesX * 0.4 && (double)num979 < (double)Main.maxTilesX * 0.6) || num979 < GenVars.leftBeachEnd + 20 || num979 > GenVars.rightBeachStart - 20)
				{
					num979 = genRand.Next(0, Main.maxTilesX);
				}
				for (int num980 = 0; (double)num980 < GenVars.worldSurfaceHigh; num980++)
				{
					if (Main.tile[num979, num980].active())
					{
						TileRunner(num979, num980, genRand.Next(12, 25), genRand.Next(150, 500), -1, addTile: false, (double)genRand.Next(-10, 11) * 0.1, 4.0);
						TileRunner(num979, num980, genRand.Next(8, 17), genRand.Next(60, 200), -1, addTile: false, (double)genRand.Next(-10, 11) * 0.1, 2.0);
						TileRunner(num979, num980, genRand.Next(5, 13), genRand.Next(40, 170), -1, addTile: false, (double)genRand.Next(-10, 11) * 0.1, 2.0);
						break;
					}
				}
			}
			progress.Set(0.6);
			for (int num981 = 0; num981 < (int)((double)Main.maxTilesX * 0.0004); num981++)
			{
				int num982 = genRand.Next(0, Main.maxTilesX);
				while (((double)num982 > (double)Main.maxTilesX * 0.4 && (double)num982 < (double)Main.maxTilesX * 0.6) || num982 < GenVars.leftBeachEnd + 20 || num982 > GenVars.rightBeachStart - 20)
				{
					num982 = genRand.Next(0, Main.maxTilesX);
				}
				for (int num983 = 0; (double)num983 < GenVars.worldSurfaceHigh; num983++)
				{
					if (Main.tile[num982, num983].active())
					{
						TileRunner(num982, num983, genRand.Next(7, 12), genRand.Next(150, 250), -1, addTile: false, 0.0, 1.0, noYChange: true);
						break;
					}
				}
			}
			progress.Set(0.8);
			double num984 = (double)Main.maxTilesX / 4200.0;
			for (int num985 = 0; (double)num985 < 5.0 * num984; num985++)
			{
				try
				{
					int num986 = (int)Main.rockLayer;
					int num987 = Main.maxTilesY - 400;
					if (num986 >= num987)
					{
						num986 = num987 - 1;
					}
					Caverer(genRand.Next(GenVars.surfaceCavesBeachAvoidance2, Main.maxTilesX - GenVars.surfaceCavesBeachAvoidance2), genRand.Next(num986, num987));
				}
				catch
				{
				}
			}
		});
		AddGenerationPass("Wavy Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (dontStarveWorldGen)
			{
				progress.Message = Language.GetTextValue("WorldGeneration.WavyCaves");
				double num960 = (double)Main.maxTilesX / 4200.0;
				num960 *= num960;
				int num961 = (int)(35.0 * num960);
				if (Main.remixWorld)
				{
					num961 /= 3;
				}
				int num962 = 0;
				int num963 = 80;
				for (int num964 = 0; num964 < num961; num964++)
				{
					double num965 = (double)num964 / (double)(num961 - 1);
					progress.Set(num965);
					int num966 = genRand.Next((int)Main.worldSurface + 100, Main.UnderworldLayer - 100);
					int num967 = 0;
					while (Math.Abs(num966 - num962) < num963)
					{
						num967++;
						if (num967 > 100)
						{
							break;
						}
						num966 = genRand.Next((int)Main.worldSurface + 100, Main.UnderworldLayer - 100);
					}
					num962 = num966;
					int num968 = 80;
					int startX = num968 + (int)((double)(Main.maxTilesX - num968 * 2) * num965);
					try
					{
						WavyCaverer(startX, num966, 12 + genRand.Next(3, 6), 0.25 + genRand.NextDouble(), genRand.Next(300, 500), -1);
					}
					catch
					{
					}
				}
			}
		});
		AddGenerationPass("Generate Ice Biome", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[56].Value;
			GenVars.snowTop = (int)Main.worldSurface;
			int num952 = GenVars.lavaLine - genRand.Next(160, 200);
			int num953 = GenVars.lavaLine;
			if (remixWorldGen)
			{
				num953 = Main.maxTilesY - 250;
				num952 = num953 - genRand.Next(160, 200);
			}
			int num954 = GenVars.snowOriginLeft;
			int num955 = GenVars.snowOriginRight;
			int num956 = 10;
			for (int num957 = 0; num957 <= num953 - 140; num957++)
			{
				progress.Set((double)num957 / (double)(num953 - 140));
				num954 += genRand.Next(-4, 4);
				num955 += genRand.Next(-3, 5);
				if (num957 > 0)
				{
					num954 = (num954 + GenVars.snowMinX[num957 - 1]) / 2;
					num955 = (num955 + GenVars.snowMaxX[num957 - 1]) / 2;
				}
				if (GenVars.dungeonSide > 0)
				{
					if (genRand.Next(4) == 0)
					{
						num954++;
						num955++;
					}
				}
				else if (genRand.Next(4) == 0)
				{
					num954--;
					num955--;
				}
				GenVars.snowMinX[num957] = num954;
				GenVars.snowMaxX[num957] = num955;
				for (int num958 = num954; num958 < num955; num958++)
				{
					if (num957 < num952)
					{
						if (Main.tile[num958, num957].wall == 2)
						{
							Main.tile[num958, num957].wall = 40;
						}
						switch (Main.tile[num958, num957].type)
						{
						case 0:
						case 2:
						case 23:
						case 40:
						case 53:
							Main.tile[num958, num957].type = 147;
							break;
						case 1:
							Main.tile[num958, num957].type = 161;
							break;
						}
					}
					else
					{
						num956 += genRand.Next(-3, 4);
						if (genRand.Next(3) == 0)
						{
							num956 += genRand.Next(-4, 5);
							if (genRand.Next(3) == 0)
							{
								num956 += genRand.Next(-6, 7);
							}
						}
						if (num956 < 0)
						{
							num956 = genRand.Next(3);
						}
						else if (num956 > 50)
						{
							num956 = 50 - genRand.Next(3);
						}
						for (int num959 = num957; num959 < num957 + num956; num959++)
						{
							if (Main.tile[num958, num959].wall == 2)
							{
								Main.tile[num958, num959].wall = 40;
							}
							switch (Main.tile[num958, num959].type)
							{
							case 0:
							case 2:
							case 23:
							case 40:
							case 53:
								Main.tile[num958, num959].type = 147;
								break;
							case 1:
								Main.tile[num958, num959].type = 161;
								break;
							}
						}
					}
				}
				if (GenVars.snowBottom < num957)
				{
					GenVars.snowBottom = num957;
				}
			}
		});
		AddGenerationPass("Grass", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			double num948 = (double)(Main.maxTilesX * Main.maxTilesY) * 0.002;
			for (int num949 = 0; (double)num949 < num948; num949++)
			{
				progress.Set((double)num949 / num948);
				int num950 = genRand.Next(1, Main.maxTilesX - 1);
				int num951 = genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh);
				if (num951 >= Main.maxTilesY)
				{
					num951 = Main.maxTilesY - 2;
				}
				if (Main.tile[num950 - 1, num951].active() && Main.tile[num950 - 1, num951].type == 0 && Main.tile[num950 + 1, num951].active() && Main.tile[num950 + 1, num951].type == 0 && Main.tile[num950, num951 - 1].active() && Main.tile[num950, num951 - 1].type == 0 && Main.tile[num950, num951 + 1].active() && Main.tile[num950, num951 + 1].type == 0)
				{
					Main.tile[num950, num951].active(active: true);
					Main.tile[num950, num951].type = 2;
				}
				num950 = genRand.Next(1, Main.maxTilesX - 1);
				num951 = genRand.Next(0, (int)GenVars.worldSurfaceLow);
				if (num951 >= Main.maxTilesY)
				{
					num951 = Main.maxTilesY - 2;
				}
				if (Main.tile[num950 - 1, num951].active() && Main.tile[num950 - 1, num951].type == 0 && Main.tile[num950 + 1, num951].active() && Main.tile[num950 + 1, num951].type == 0 && Main.tile[num950, num951 - 1].active() && Main.tile[num950, num951 - 1].type == 0 && Main.tile[num950, num951 + 1].active() && Main.tile[num950, num951 + 1].type == 0)
				{
					Main.tile[num950, num951].active(active: true);
					Main.tile[num950, num951].type = 2;
				}
			}
		});
		AddGenerationPass(new JunglePass());
		AddGenerationPass("Mud Caves To Grass", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[77].Value;
			NotTheBees();
			for (int num943 = 0; num943 < Main.maxTilesX; num943++)
			{
				for (int num944 = 0; num944 < Main.maxTilesY; num944++)
				{
					if (Main.tile[num943, num944].active())
					{
						grassSpread = 0;
						SpreadGrass(num943, num944, 59, 60);
					}
					progress.Set(0.2 * ((double)(num943 * Main.maxTilesY + num944) / (double)(Main.maxTilesX * Main.maxTilesY)));
				}
			}
			SmallConsecutivesFound = 0;
			SmallConsecutivesEliminated = 0;
			double num945 = Main.maxTilesX - 20;
			for (int num946 = 10; num946 < Main.maxTilesX - 10; num946++)
			{
				ScanTileColumnAndRemoveClumps(num946);
				double num947 = (double)(num946 - 10) / num945;
				progress.Set(0.2 + num947 * 0.8);
			}
		});
		AddGenerationPass("Full Desert", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			progress.Message = Lang.gen[78].Value;
			Main.tileSolid[484] = false;
			int num934 = 0;
			int num935 = GenVars.dungeonSide;
			int num936 = Main.maxTilesX / 2;
			int num937 = genRand.Next(num936) / 8;
			num937 += num936 / 8;
			int num938 = num936 + num937 * -num935;
			int num939 = 0;
			DesertBiome desertBiome = GenVars.configuration.CreateBiome<DesertBiome>();
			while (!desertBiome.Place(new Point(num938, (int)GenVars.worldSurfaceHigh + 25), GenVars.structures))
			{
				num937 = genRand.Next(num936) / 2;
				num937 += num936 / 8;
				num937 += genRand.Next(num939 / 12);
				num938 = num936 + num937 * -num935;
				if (++num939 > Main.maxTilesX / 4)
				{
					num935 *= -1;
					num939 = 0;
					num934++;
					if (num934 >= 2)
					{
						GenVars.skipDesertTileCheck = true;
					}
				}
			}
			if (remixWorldGen)
			{
				for (int num940 = 50; num940 < Main.maxTilesX - 50; num940++)
				{
					for (int num941 = (int)Main.rockLayer + genRand.Next(-1, 2); num941 < Main.maxTilesY - 50; num941++)
					{
						if ((Main.tile[num940, num941].type == 396 || Main.tile[num940, num941].type == 397 || Main.tile[num940, num941].type == 53) && !SolidTile(num940, num941 - 1))
						{
							for (int num942 = num941; num942 < num941 + genRand.Next(4, 7) && Main.tile[num940, num942 + 1].active() && (Main.tile[num940, num942].type == 396 || Main.tile[num940, num942].type == 397); num942++)
							{
								Main.tile[num940, num942].type = 53;
							}
						}
					}
				}
			}
		});
		AddGenerationPass("Floating Islands", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			GenVars.numIslandHouses = 0;
			GenVars.skyIslandHouseCount = 0;
			progress.Message = Lang.gen[12].Value;
			int num924 = (int)((double)Main.maxTilesX * 0.0008);
			int num925 = 0;
			double num926 = num924 + GenVars.skyLakes;
			for (int num927 = 0; (double)num927 < num926; num927++)
			{
				progress.Set((double)num927 / num926);
				int num928 = Main.maxTilesX;
				while (--num928 > 0)
				{
					bool flag57 = true;
					int num929 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
					while (num929 > Main.maxTilesX / 2 - 150 && num929 < Main.maxTilesX / 2 + 150)
					{
						num929 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
					}
					for (int num930 = 0; num930 < GenVars.numIslandHouses; num930++)
					{
						if (num929 > GenVars.floatingIslandHouseX[num930] - 180 && num929 < GenVars.floatingIslandHouseX[num930] + 180)
						{
							flag57 = false;
							break;
						}
					}
					if (flag57)
					{
						flag57 = false;
						int num931 = 0;
						for (int num932 = 200; (double)num932 < Main.worldSurface; num932++)
						{
							if (Main.tile[num929, num932].active())
							{
								num931 = num932;
								flag57 = true;
								break;
							}
						}
						if (flag57)
						{
							int num933 = 0;
							num928 = -1;
							int val6 = genRand.Next(90, num931 - 100);
							val6 = Math.Min(val6, (int)GenVars.worldSurfaceLow - 50);
							if (num925 >= num924)
							{
								GenVars.skyLake[GenVars.numIslandHouses] = true;
								CloudLake(num929, val6);
							}
							else
							{
								GenVars.skyLake[GenVars.numIslandHouses] = false;
								if (drunkWorldGen && !remixWorldGen)
								{
									if (genRand.Next(2) == 0)
									{
										num933 = 3;
										SnowCloudIsland(num929, val6);
									}
									else
									{
										num933 = 1;
										DesertCloudIsland(num929, val6);
									}
								}
								else
								{
									if (remixWorldGen && drunkWorldGen)
									{
										num933 = ((GenVars.crimsonLeft && num929 < Main.maxTilesX / 2) ? 5 : ((GenVars.crimsonLeft || num929 <= Main.maxTilesX / 2) ? 4 : 5));
									}
									else if (getGoodWorldGen || remixWorldGen)
									{
										num933 = ((!crimson) ? 4 : 5);
									}
									else if (Main.tenthAnniversaryWorld)
									{
										num933 = 6;
									}
									CloudIsland(num929, val6);
								}
							}
							GenVars.floatingIslandHouseX[GenVars.numIslandHouses] = num929;
							GenVars.floatingIslandHouseY[GenVars.numIslandHouses] = val6;
							GenVars.floatingIslandStyle[GenVars.numIslandHouses] = num933;
							GenVars.numIslandHouses++;
							num925++;
						}
					}
				}
			}
		});
		AddGenerationPass("Mushroom Patches", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_025c: Unknown result type (might be due to invalid IL or missing references)
			progress.Message = Lang.gen[13].Value;
			if (remixWorldGen)
			{
				for (int num905 = 10; num905 < Main.maxTilesX - 10; num905++)
				{
					for (int num906 = Main.maxTilesY + genRand.Next(3) - 350; num906 < Main.maxTilesY - 10; num906++)
					{
						if (Main.tile[num905, num906].type == 0)
						{
							Main.tile[num905, num906].type = 59;
						}
					}
				}
			}
			double num907 = (double)Main.maxTilesX / 700.0;
			if (num907 > (double)GenVars.maxMushroomBiomes)
			{
				num907 = GenVars.maxMushroomBiomes;
			}
			for (int num908 = 0; (double)num908 < num907; num908++)
			{
				int num909 = 0;
				bool flag56 = true;
				while (flag56)
				{
					int num910 = genRand.Next((int)((double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.8));
					if (num909 > Main.maxTilesX / 4)
					{
						num910 = genRand.Next((int)((double)Main.maxTilesX * 0.25), (int)((double)Main.maxTilesX * 0.975));
					}
					int num911 = ((!remixWorldGen) ? genRand.Next((int)Main.rockLayer + 50, Main.maxTilesY - 300) : genRand.Next((int)Main.worldSurface + 50, (int)Main.rockLayer - 50));
					flag56 = false;
					int num912 = 100;
					int num913 = 500;
					for (int num914 = num910 - num912; num914 < num910 + num912; num914 += 3)
					{
						for (int num915 = num911 - num912; num915 < num911 + num912; num915 += 3)
						{
							if (InWorld(num914, num915))
							{
								if (Main.tile[num914, num915].type == 147 || Main.tile[num914, num915].type == 161 || Main.tile[num914, num915].type == 162 || Main.tile[num914, num915].type == 60 || Main.tile[num914, num915].type == 368 || Main.tile[num914, num915].type == 367)
								{
									flag56 = true;
									break;
								}
								if (((Rectangle)(ref GenVars.UndergroundDesertLocation)).Contains(new Point(num914, num915)))
								{
									flag56 = true;
									break;
								}
							}
							else
							{
								flag56 = true;
							}
						}
					}
					if (!flag56)
					{
						for (int num916 = 0; num916 < GenVars.numMushroomBiomes; num916++)
						{
							if (Vector2D.Distance(GenVars.mushroomBiomesPosition[num916].ToVector2D(), new Vector2D(num910, num911)) < (double)num913)
							{
								flag56 = true;
							}
						}
					}
					if (!flag56 && GenVars.numMushroomBiomes < GenVars.maxMushroomBiomes)
					{
						ShroomPatch(num910, num911);
						for (int num917 = 0; num917 < 5; num917++)
						{
							int i4 = num910 + genRand.Next(-40, 41);
							int j6 = num911 + genRand.Next(-40, 41);
							ShroomPatch(i4, j6);
						}
						GenVars.mushroomBiomesPosition[GenVars.numMushroomBiomes].X = num910;
						GenVars.mushroomBiomesPosition[GenVars.numMushroomBiomes].Y = num911;
						GenVars.numMushroomBiomes++;
					}
					num909++;
					if (num909 > Main.maxTilesX / 2)
					{
						break;
					}
				}
			}
			for (int num918 = 0; num918 < Main.maxTilesX; num918++)
			{
				progress.Set((double)num918 / (double)Main.maxTilesX);
				for (int num919 = (int)Main.worldSurface; num919 < Main.maxTilesY; num919++)
				{
					if (InWorld(num918, num919, 50) && Main.tile[num918, num919].active())
					{
						grassSpread = 0;
						SpreadGrass(num918, num919, 59, 70, repeat: false);
					}
				}
			}
			for (int num920 = 0; num920 < Main.maxTilesX; num920++)
			{
				for (int num921 = (int)Main.worldSurface; num921 < Main.maxTilesY; num921++)
				{
					if (Main.tile[num920, num921].active() && Main.tile[num920, num921].type == 70)
					{
						int type9 = 59;
						for (int num922 = num920 - 1; num922 <= num920 + 1; num922++)
						{
							for (int num923 = num921 - 1; num923 <= num921 + 1; num923++)
							{
								if (Main.tile[num922, num923].active())
								{
									if (!Main.tile[num922 - 1, num923].active() && !Main.tile[num922 + 1, num923].active())
									{
										KillTile(num922, num923);
									}
									else if (!Main.tile[num922, num923 - 1].active() && !Main.tile[num922, num923 + 1].active())
									{
										KillTile(num922, num923);
									}
								}
								else if (Main.tile[num922 - 1, num923].active() && Main.tile[num922 + 1, num923].active())
								{
									PlaceTile(num922, num923, type9);
									if (Main.tile[num922 - 1, num921].type == 70)
									{
										Main.tile[num922 - 1, num921].type = 59;
									}
									if (Main.tile[num922 + 1, num921].type == 70)
									{
										Main.tile[num922 + 1, num921].type = 59;
									}
								}
								else if (Main.tile[num922, num923 - 1].active() && Main.tile[num922, num923 + 1].active())
								{
									PlaceTile(num922, num923, type9);
									if (Main.tile[num922, num921 - 1].type == 70)
									{
										Main.tile[num922, num921 - 1].type = 59;
									}
									if (Main.tile[num922, num921 + 1].type == 70)
									{
										Main.tile[num922, num921 + 1].type = 59;
									}
								}
							}
						}
						if (genRand.Next(4) == 0)
						{
							int x29 = num920 + genRand.Next(-20, 21);
							int y24 = num921 + genRand.Next(-20, 21);
							if (InWorld(x29, y24) && Main.tile[x29, y24].type == 59)
							{
								Main.tile[x29, y24].type = 70;
							}
						}
					}
				}
			}
		});
		AddGenerationPass("Marble", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0096: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0130: Unknown result type (might be due to invalid IL or missing references)
			//IL_0111: Unknown result type (might be due to invalid IL or missing references)
			progress.Message = Lang.gen[80].Value;
			int num900 = passConfig.Get<WorldGenRange>("Count").GetRandom(genRand);
			double num901 = (double)(Main.maxTilesX - 160) / (double)num900;
			MarbleBiome marbleBiome = GenVars.configuration.CreateBiome<MarbleBiome>();
			int num902 = 0;
			int num903 = 0;
			while (num903 < num900)
			{
				double num904 = (double)num903 / (double)num900;
				progress.Set(num904);
				Point val5 = RandomRectanglePoint((int)(num904 * (double)(Main.maxTilesX - 160)) + 80, (int)GenVars.rockLayer + 20, (int)num901, Main.maxTilesY - ((int)GenVars.rockLayer + 40) - 200);
				if (remixWorldGen)
				{
					val5 = RandomRectanglePoint((int)(num904 * (double)(Main.maxTilesX - 160)) + 80, (int)GenVars.worldSurface + 100, (int)num901, (int)GenVars.rockLayer - (int)GenVars.worldSurface - 100);
				}
				while ((double)val5.X > (double)Main.maxTilesX * 0.45 && (double)val5.X < (double)Main.maxTilesX * 0.55)
				{
					val5.X = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
				}
				num902++;
				if (marbleBiome.Place(val5, GenVars.structures))
				{
					num903++;
					num902 = 0;
				}
				else if (num902 > Main.maxTilesX * 10)
				{
					num900 = num903;
					num903++;
					num902 = 0;
				}
			}
		});
		AddGenerationPass("Granite", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_012b: Unknown result type (might be due to invalid IL or missing references)
			//IL_010d: Unknown result type (might be due to invalid IL or missing references)
			//IL_017d: Unknown result type (might be due to invalid IL or missing references)
			//IL_013a: Unknown result type (might be due to invalid IL or missing references)
			progress.Message = Lang.gen[81].Value;
			int num894 = passConfig.Get<WorldGenRange>("Count").GetRandom(genRand);
			double num895 = (double)(Main.maxTilesX - 200) / (double)num894;
			List<Point> list2 = new List<Point>(num894);
			int num896 = 0;
			int num897 = 0;
			while (num897 < num894)
			{
				double num898 = (double)num897 / (double)num894;
				progress.Set(num898);
				Point val4 = RandomRectanglePoint((int)(num898 * (double)(Main.maxTilesX - 200)) + 100, (int)GenVars.rockLayer + 20, (int)num895, Main.maxTilesY - ((int)GenVars.rockLayer + 40) - 200);
				if (remixWorldGen)
				{
					val4 = RandomRectanglePoint((int)(num898 * (double)(Main.maxTilesX - 200)) + 100, (int)GenVars.worldSurface + 100, (int)num895, (int)GenVars.rockLayer - (int)GenVars.worldSurface - 100);
				}
				while ((double)val4.X > (double)Main.maxTilesX * 0.45 && (double)val4.X < (double)Main.maxTilesX * 0.55)
				{
					val4.X = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
				}
				num896++;
				if (GraniteBiome.CanPlace(val4, GenVars.structures))
				{
					list2.Add(val4);
					num897++;
				}
				else if (num896 > Main.maxTilesX * 10)
				{
					num894 = num897;
					num897++;
					num896 = 0;
				}
			}
			GraniteBiome graniteBiome = GenVars.configuration.CreateBiome<GraniteBiome>();
			for (int num899 = 0; num899 < num894; num899++)
			{
				graniteBiome.Place(list2[num899], GenVars.structures);
			}
		});
		AddGenerationPass("Dirt To Mud", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[14].Value;
			double num892 = (double)(Main.maxTilesX * Main.maxTilesY) * 0.001;
			for (int num893 = 0; (double)num893 < num892; num893++)
			{
				progress.Set((double)num893 / num892);
				if (remixWorldGen)
				{
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.worldSurface, (int)GenVars.rockLayerLow), genRand.Next(2, 6), genRand.Next(2, 40), 59, addTile: false, 0.0, 0.0, noYChange: false, overRide: true, 53);
				}
				else
				{
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(2, 6), genRand.Next(2, 40), 59, addTile: false, 0.0, 0.0, noYChange: false, overRide: true, 53);
				}
			}
		});
		AddGenerationPass("Silt", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[15].Value;
			for (int num886 = 0; num886 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0001); num886++)
			{
				int num887 = genRand.Next(0, Main.maxTilesX);
				int num888 = genRand.Next((int)GenVars.rockLayerHigh, Main.maxTilesY);
				if (remixWorldGen)
				{
					num888 = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
				}
				if (Main.tile[num887, num888].wall != 187 && Main.tile[num887, num888].wall != 216)
				{
					TileRunner(num887, num888, genRand.Next(5, 12), genRand.Next(15, 50), 123);
				}
			}
			for (int num889 = 0; num889 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0005); num889++)
			{
				int num890 = genRand.Next(0, Main.maxTilesX);
				int num891 = genRand.Next((int)GenVars.rockLayerHigh, Main.maxTilesY);
				if (remixWorldGen)
				{
					num891 = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
				}
				if (Main.tile[num890, num891].wall != 187 && Main.tile[num890, num891].wall != 216)
				{
					TileRunner(num890, num891, genRand.Next(2, 5), genRand.Next(2, 5), 123);
				}
			}
		});
		AddGenerationPass("Shinies", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[16].Value;
			if (remixWorldGen)
			{
				for (int num856 = 0; num856 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 6E-05); num856++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							GenVars.copper = 7;
						}
						else
						{
							GenVars.copper = 166;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh), genRand.Next(3, 6), genRand.Next(2, 6), GenVars.copper);
				}
				for (int num857 = 0; num857 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 8E-05); num857++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							GenVars.copper = 7;
						}
						else
						{
							GenVars.copper = 166;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceHigh, (int)GenVars.rockLayerHigh), genRand.Next(3, 7), genRand.Next(3, 7), GenVars.copper);
				}
				for (int num858 = 0; num858 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0002); num858++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							GenVars.copper = 7;
						}
						else
						{
							GenVars.copper = 166;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.copper);
				}
				for (int num859 = 0; num859 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 3E-05); num859++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							GenVars.iron = 6;
						}
						else
						{
							GenVars.iron = 167;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh), genRand.Next(3, 7), genRand.Next(2, 5), GenVars.iron);
				}
				for (int num860 = 0; num860 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 8E-05); num860++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							GenVars.iron = 6;
						}
						else
						{
							GenVars.iron = 167;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceHigh, (int)GenVars.rockLayerHigh), genRand.Next(3, 6), genRand.Next(3, 6), GenVars.iron);
				}
				for (int num861 = 0; num861 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0002); num861++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							GenVars.iron = 6;
						}
						else
						{
							GenVars.iron = 167;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.iron);
				}
				for (int num862 = 0; num862 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.6E-05); num862++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							GenVars.silver = 9;
						}
						else
						{
							GenVars.silver = 168;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer - 100, Main.maxTilesY - 250), genRand.Next(3, 6), genRand.Next(3, 6), GenVars.silver);
				}
				for (int num863 = 0; num863 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00015); num863++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							GenVars.silver = 9;
						}
						else
						{
							GenVars.silver = 168;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.worldSurface, (int)Main.rockLayer), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.silver);
				}
				for (int num864 = 0; num864 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00017); num864++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							GenVars.silver = 9;
						}
						else
						{
							GenVars.silver = 168;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)GenVars.worldSurfaceLow), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.silver);
				}
				for (int num865 = 0; num865 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00012); num865++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							GenVars.gold = 8;
						}
						else
						{
							GenVars.gold = 169;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.worldSurface, (int)Main.rockLayer), genRand.Next(4, 8), genRand.Next(4, 8), GenVars.gold);
				}
				for (int num866 = 0; num866 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00012); num866++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							GenVars.gold = 8;
						}
						else
						{
							GenVars.gold = 169;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)GenVars.worldSurfaceLow - 20), genRand.Next(4, 8), genRand.Next(4, 8), GenVars.gold);
				}
				if (drunkWorldGen)
				{
					for (int num867 = 0; num867 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.25E-05 / 2.0); num867++)
					{
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer, Main.maxTilesY), genRand.Next(3, 6), genRand.Next(4, 8), 204);
					}
					for (int num868 = 0; num868 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.25E-05 / 2.0); num868++)
					{
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer, Main.maxTilesY), genRand.Next(3, 6), genRand.Next(4, 8), 22);
					}
				}
				if (crimson)
				{
					for (int num869 = 0; num869 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 4.25E-05); num869++)
					{
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.worldSurface, (int)Main.rockLayer), genRand.Next(3, 6), genRand.Next(4, 8), 204);
					}
				}
				else
				{
					for (int num870 = 0; num870 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 4.25E-05); num870++)
					{
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.worldSurface, (int)Main.rockLayer), genRand.Next(3, 6), genRand.Next(4, 8), 22);
					}
				}
			}
			else
			{
				for (int num871 = 0; num871 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 6E-05); num871++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							GenVars.copper = 7;
						}
						else
						{
							GenVars.copper = 166;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh), genRand.Next(3, 6), genRand.Next(2, 6), GenVars.copper);
				}
				for (int num872 = 0; num872 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 8E-05); num872++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							GenVars.copper = 7;
						}
						else
						{
							GenVars.copper = 166;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceHigh, (int)GenVars.rockLayerHigh), genRand.Next(3, 7), genRand.Next(3, 7), GenVars.copper);
				}
				for (int num873 = 0; num873 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0002); num873++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							GenVars.copper = 7;
						}
						else
						{
							GenVars.copper = 166;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.copper);
				}
				for (int num874 = 0; num874 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 3E-05); num874++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							GenVars.iron = 6;
						}
						else
						{
							GenVars.iron = 167;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh), genRand.Next(3, 7), genRand.Next(2, 5), GenVars.iron);
				}
				for (int num875 = 0; num875 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 8E-05); num875++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							GenVars.iron = 6;
						}
						else
						{
							GenVars.iron = 167;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceHigh, (int)GenVars.rockLayerHigh), genRand.Next(3, 6), genRand.Next(3, 6), GenVars.iron);
				}
				for (int num876 = 0; num876 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0002); num876++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							GenVars.iron = 6;
						}
						else
						{
							GenVars.iron = 167;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.iron);
				}
				for (int num877 = 0; num877 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.6E-05); num877++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							GenVars.silver = 9;
						}
						else
						{
							GenVars.silver = 168;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceHigh, (int)GenVars.rockLayerHigh), genRand.Next(3, 6), genRand.Next(3, 6), GenVars.silver);
				}
				for (int num878 = 0; num878 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00015); num878++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							GenVars.silver = 9;
						}
						else
						{
							GenVars.silver = 168;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.silver);
				}
				for (int num879 = 0; num879 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00017); num879++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							GenVars.silver = 9;
						}
						else
						{
							GenVars.silver = 168;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)GenVars.worldSurfaceLow), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.silver);
				}
				for (int num880 = 0; num880 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00012); num880++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							GenVars.gold = 8;
						}
						else
						{
							GenVars.gold = 169;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(4, 8), genRand.Next(4, 8), GenVars.gold);
				}
				for (int num881 = 0; num881 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00012); num881++)
				{
					if (drunkWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							GenVars.gold = 8;
						}
						else
						{
							GenVars.gold = 169;
						}
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)GenVars.worldSurfaceLow - 20), genRand.Next(4, 8), genRand.Next(4, 8), GenVars.gold);
				}
				if (drunkWorldGen)
				{
					for (int num882 = 0; num882 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.25E-05 / 2.0); num882++)
					{
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer, Main.maxTilesY), genRand.Next(3, 6), genRand.Next(4, 8), 204);
					}
					for (int num883 = 0; num883 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.25E-05 / 2.0); num883++)
					{
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer, Main.maxTilesY), genRand.Next(3, 6), genRand.Next(4, 8), 22);
					}
				}
				if (crimson)
				{
					for (int num884 = 0; num884 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.25E-05); num884++)
					{
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer, Main.maxTilesY), genRand.Next(3, 6), genRand.Next(4, 8), 204);
					}
				}
				else
				{
					for (int num885 = 0; num885 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.25E-05); num885++)
					{
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer, Main.maxTilesY), genRand.Next(3, 6), genRand.Next(4, 8), 22);
					}
				}
			}
		});
		AddGenerationPass("Webs", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[17].Value;
			for (int num852 = 0; num852 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0006); num852++)
			{
				int num853 = genRand.Next(20, Main.maxTilesX - 20);
				int num854 = genRand.Next((int)GenVars.worldSurfaceHigh, Main.maxTilesY - 20);
				if (num852 < GenVars.numMCaves)
				{
					num853 = GenVars.mCaveX[num852];
					num854 = GenVars.mCaveY[num852];
				}
				if (!Main.tile[num853, num854].active() && ((double)num854 > Main.worldSurface || Main.tile[num853, num854].wall > 0))
				{
					while (!Main.tile[num853, num854].active() && num854 > (int)GenVars.worldSurfaceLow)
					{
						num854--;
					}
					num854++;
					int num855 = 1;
					if (genRand.Next(2) == 0)
					{
						num855 = -1;
					}
					for (; !Main.tile[num853, num854].active() && num853 > 10 && num853 < Main.maxTilesX - 10; num853 += num855)
					{
					}
					num853 -= num855;
					if ((double)num854 > Main.worldSurface || Main.tile[num853, num854].wall > 0)
					{
						TileRunner(num853, num854, genRand.Next(4, 11), genRand.Next(2, 4), 51, addTile: true, num855, -1.0, noYChange: false, overRide: false);
					}
				}
			}
		});
		AddGenerationPass("Underworld", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[18].Value;
			progress.Set(0.0);
			int num816 = Main.maxTilesY - genRand.Next(150, 190);
			for (int num817 = 0; num817 < Main.maxTilesX; num817++)
			{
				num816 += genRand.Next(-3, 4);
				if (num816 < Main.maxTilesY - 190)
				{
					num816 = Main.maxTilesY - 190;
				}
				if (num816 > Main.maxTilesY - 160)
				{
					num816 = Main.maxTilesY - 160;
				}
				for (int num818 = num816 - 20 - genRand.Next(3); num818 < Main.maxTilesY; num818++)
				{
					if (num818 >= num816)
					{
						Main.tile[num817, num818].active(active: false);
						Main.tile[num817, num818].lava(lava: false);
						Main.tile[num817, num818].liquid = 0;
					}
					else
					{
						Main.tile[num817, num818].type = 57;
					}
				}
			}
			int num819 = Main.maxTilesY - genRand.Next(40, 70);
			for (int num820 = 10; num820 < Main.maxTilesX - 10; num820++)
			{
				num819 += genRand.Next(-10, 11);
				if (num819 > Main.maxTilesY - 60)
				{
					num819 = Main.maxTilesY - 60;
				}
				if (num819 < Main.maxTilesY - 100)
				{
					num819 = Main.maxTilesY - 120;
				}
				for (int num821 = num819; num821 < Main.maxTilesY - 10; num821++)
				{
					if (!Main.tile[num820, num821].active())
					{
						Main.tile[num820, num821].lava(lava: true);
						Main.tile[num820, num821].liquid = byte.MaxValue;
					}
				}
			}
			for (int num822 = 0; num822 < Main.maxTilesX; num822++)
			{
				if (genRand.Next(50) == 0)
				{
					int num823 = Main.maxTilesY - 65;
					while (!Main.tile[num822, num823].active() && num823 > Main.maxTilesY - 135)
					{
						num823--;
					}
					TileRunner(genRand.Next(0, Main.maxTilesX), num823 + genRand.Next(20, 50), genRand.Next(15, 20), 1000, 57, addTile: true, 0.0, genRand.Next(1, 3), noYChange: true);
				}
			}
			Liquid.QuickWater(-2);
			for (int num824 = 0; num824 < Main.maxTilesX; num824++)
			{
				double num825 = (double)num824 / (double)(Main.maxTilesX - 1);
				progress.Set(num825 / 2.0 + 0.5);
				if (genRand.Next(13) == 0)
				{
					int num826 = Main.maxTilesY - 65;
					while ((Main.tile[num824, num826].liquid > 0 || Main.tile[num824, num826].active()) && num826 > Main.maxTilesY - 140)
					{
						num826--;
					}
					if ((!drunkWorldGen && !remixWorldGen) || genRand.Next(3) == 0 || !((double)num824 > (double)Main.maxTilesX * 0.4) || !((double)num824 < (double)Main.maxTilesX * 0.6))
					{
						TileRunner(num824, num826 - genRand.Next(2, 5), genRand.Next(5, 30), 1000, 57, addTile: true, 0.0, genRand.Next(1, 3), noYChange: true);
					}
					double num827 = genRand.Next(1, 3);
					if (genRand.Next(3) == 0)
					{
						num827 *= 0.5;
					}
					if ((!drunkWorldGen && !remixWorldGen) || genRand.Next(3) == 0 || !((double)num824 > (double)Main.maxTilesX * 0.4) || !((double)num824 < (double)Main.maxTilesX * 0.6))
					{
						if (genRand.Next(2) == 0)
						{
							TileRunner(num824, num826 - genRand.Next(2, 5), (int)((double)genRand.Next(5, 15) * num827), (int)((double)genRand.Next(10, 15) * num827), 57, addTile: true, 1.0, 0.3);
						}
						if (genRand.Next(2) == 0)
						{
							num827 = genRand.Next(1, 3);
							TileRunner(num824, num826 - genRand.Next(2, 5), (int)((double)genRand.Next(5, 15) * num827), (int)((double)genRand.Next(10, 15) * num827), 57, addTile: true, -1.0, 0.3);
						}
					}
					TileRunner(num824 + genRand.Next(-10, 10), num826 + genRand.Next(-10, 10), genRand.Next(5, 15), genRand.Next(5, 10), -2, addTile: false, genRand.Next(-1, 3), genRand.Next(-1, 3));
					if (genRand.Next(3) == 0)
					{
						TileRunner(num824 + genRand.Next(-10, 10), num826 + genRand.Next(-10, 10), genRand.Next(10, 30), genRand.Next(10, 20), -2, addTile: false, genRand.Next(-1, 3), genRand.Next(-1, 3));
					}
					if (genRand.Next(5) == 0)
					{
						TileRunner(num824 + genRand.Next(-15, 15), num826 + genRand.Next(-15, 10), genRand.Next(15, 30), genRand.Next(5, 20), -2, addTile: false, genRand.Next(-1, 3), genRand.Next(-1, 3));
					}
				}
			}
			for (int num828 = 0; num828 < Main.maxTilesX; num828++)
			{
				TileRunner(genRand.Next(20, Main.maxTilesX - 20), genRand.Next(Main.maxTilesY - 180, Main.maxTilesY - 10), genRand.Next(2, 7), genRand.Next(2, 7), -2);
			}
			if (drunkWorldGen || remixWorldGen)
			{
				for (int num829 = 0; num829 < Main.maxTilesX * 2; num829++)
				{
					TileRunner(genRand.Next((int)((double)Main.maxTilesX * 0.35), (int)((double)Main.maxTilesX * 0.65)), genRand.Next(Main.maxTilesY - 180, Main.maxTilesY - 10), genRand.Next(5, 20), genRand.Next(5, 10), -2);
				}
			}
			for (int num830 = 0; num830 < Main.maxTilesX; num830++)
			{
				if (!Main.tile[num830, Main.maxTilesY - 145].active())
				{
					Main.tile[num830, Main.maxTilesY - 145].liquid = byte.MaxValue;
					Main.tile[num830, Main.maxTilesY - 145].lava(lava: true);
				}
				if (!Main.tile[num830, Main.maxTilesY - 144].active())
				{
					Main.tile[num830, Main.maxTilesY - 144].liquid = byte.MaxValue;
					Main.tile[num830, Main.maxTilesY - 144].lava(lava: true);
				}
			}
			for (int num831 = 0; num831 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0008); num831++)
			{
				TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(Main.maxTilesY - 140, Main.maxTilesY), genRand.Next(2, 7), genRand.Next(3, 7), 58);
			}
			if (remixWorldGen)
			{
				int num832 = (int)((double)Main.maxTilesX * 0.38);
				int num833 = (int)((double)Main.maxTilesX * 0.62);
				int num834 = num832;
				int num835 = Main.maxTilesY - 1;
				int num836 = Main.maxTilesY - 135;
				int num837 = Main.maxTilesY - 160;
				bool flag55 = false;
				Liquid.QuickWater(-2);
				for (; num835 < Main.maxTilesY - 1 || num834 < num833; num834++)
				{
					if (!flag55)
					{
						num835 -= genRand.Next(1, 4);
						if (num835 < num836)
						{
							flag55 = true;
						}
					}
					else if (num834 >= num833)
					{
						num835 += genRand.Next(1, 4);
						if (num835 > Main.maxTilesY - 1)
						{
							num835 = Main.maxTilesY - 1;
						}
					}
					else
					{
						if ((num834 <= Main.maxTilesX / 2 - 5 || num834 >= Main.maxTilesX / 2 + 5) && genRand.Next(4) == 0)
						{
							if (genRand.Next(3) == 0)
							{
								num835 += genRand.Next(-1, 2);
							}
							else if (genRand.Next(6) == 0)
							{
								num835 += genRand.Next(-2, 3);
							}
							else if (genRand.Next(8) == 0)
							{
								num835 += genRand.Next(-4, 5);
							}
						}
						if (num835 < num837)
						{
							num835 = num837;
						}
						if (num835 > num836)
						{
							num835 = num836;
						}
					}
					for (int num838 = num835; num838 > num835 - 20; num838--)
					{
						Main.tile[num834, num838].liquid = 0;
					}
					for (int num839 = num835; num839 < Main.maxTilesY; num839++)
					{
						Main.tile[num834, num839].Clear(TileDataType.All);
						Main.tile[num834, num839].active(active: true);
						Main.tile[num834, num839].type = 57;
					}
				}
				Liquid.QuickWater(-2);
				for (int num840 = num832; num840 < num833 + 15; num840++)
				{
					for (int num841 = Main.maxTilesY - 300; num841 < num836 + 20; num841++)
					{
						Main.tile[num840, num841].liquid = 0;
						if (Main.tile[num840, num841].type == 57 && Main.tile[num840, num841].active() && (!Main.tile[num840 - 1, num841 - 1].active() || !Main.tile[num840, num841 - 1].active() || !Main.tile[num840 + 1, num841 - 1].active() || !Main.tile[num840 - 1, num841].active() || !Main.tile[num840 + 1, num841].active() || !Main.tile[num840 - 1, num841 + 1].active() || !Main.tile[num840, num841 + 1].active() || !Main.tile[num840 + 1, num841 + 1].active()))
						{
							Main.tile[num840, num841].type = 633;
						}
					}
				}
				for (int num842 = num832; num842 < num833 + 15; num842++)
				{
					for (int num843 = Main.maxTilesY - 200; num843 < num836 + 20; num843++)
					{
						if (Main.tile[num842, num843].type == 633 && Main.tile[num842, num843].active() && !Main.tile[num842, num843 - 1].active() && genRand.Next(3) == 0)
						{
							TryGrowingTreeByType(634, num842, num843);
						}
					}
				}
			}
			else if (!drunkWorldGen)
			{
				for (int num844 = 25; num844 < Main.maxTilesX - 25; num844++)
				{
					if ((double)num844 < (double)Main.maxTilesX * 0.17 || (double)num844 > (double)Main.maxTilesX * 0.83)
					{
						for (int num845 = Main.maxTilesY - 300; num845 < Main.maxTilesY - 100 + genRand.Next(-1, 2); num845++)
						{
							if (Main.tile[num844, num845].type == 57 && Main.tile[num844, num845].active() && (!Main.tile[num844 - 1, num845 - 1].active() || !Main.tile[num844, num845 - 1].active() || !Main.tile[num844 + 1, num845 - 1].active() || !Main.tile[num844 - 1, num845].active() || !Main.tile[num844 + 1, num845].active() || !Main.tile[num844 - 1, num845 + 1].active() || !Main.tile[num844, num845 + 1].active() || !Main.tile[num844 + 1, num845 + 1].active()))
							{
								Main.tile[num844, num845].type = 633;
							}
						}
					}
				}
				for (int num846 = 25; num846 < Main.maxTilesX - 25; num846++)
				{
					if ((double)num846 < (double)Main.maxTilesX * 0.17 || (double)num846 > (double)Main.maxTilesX * 0.83)
					{
						for (int num847 = Main.maxTilesY - 200; num847 < Main.maxTilesY - 50; num847++)
						{
							if (Main.tile[num846, num847].type == 633 && Main.tile[num846, num847].active() && !Main.tile[num846, num847 - 1].active() && genRand.Next(3) == 0)
							{
								TryGrowingTreeByType(634, num846, num847);
							}
						}
					}
				}
			}
			AddHellHouses();
			if (drunkWorldGen)
			{
				for (int num848 = 25; num848 < Main.maxTilesX - 25; num848++)
				{
					for (int num849 = Main.maxTilesY - 300; num849 < Main.maxTilesY - 100 + genRand.Next(-1, 2); num849++)
					{
						if (Main.tile[num848, num849].type == 57 && Main.tile[num848, num849].active() && (!Main.tile[num848 - 1, num849 - 1].active() || !Main.tile[num848, num849 - 1].active() || !Main.tile[num848 + 1, num849 - 1].active() || !Main.tile[num848 - 1, num849].active() || !Main.tile[num848 + 1, num849].active() || !Main.tile[num848 - 1, num849 + 1].active() || !Main.tile[num848, num849 + 1].active() || !Main.tile[num848 + 1, num849 + 1].active()))
						{
							Main.tile[num848, num849].type = 633;
						}
					}
				}
				for (int num850 = 25; num850 < Main.maxTilesX - 25; num850++)
				{
					for (int num851 = Main.maxTilesY - 200; num851 < Main.maxTilesY - 50; num851++)
					{
						if (Main.tile[num850, num851].type == 633 && Main.tile[num850, num851].active() && !Main.tile[num850, num851 - 1].active() && genRand.Next(3) == 0)
						{
							TryGrowingTreeByType(634, num850, num851);
						}
					}
				}
			}
		});
		AddGenerationPass("Corruption", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			int num757 = Main.maxTilesX;
			int num758 = 0;
			int num759 = Main.maxTilesX;
			int num760 = 0;
			for (int num761 = 0; num761 < Main.maxTilesX; num761++)
			{
				for (int num762 = 0; (double)num762 < Main.worldSurface; num762++)
				{
					if (Main.tile[num761, num762].active())
					{
						if (Main.tile[num761, num762].type == 60)
						{
							if (num761 < num757)
							{
								num757 = num761;
							}
							if (num761 > num758)
							{
								num758 = num761;
							}
						}
						else if (Main.tile[num761, num762].type == 147 || Main.tile[num761, num762].type == 161)
						{
							if (num761 < num759)
							{
								num759 = num761;
							}
							if (num761 > num760)
							{
								num760 = num761;
							}
						}
					}
				}
			}
			int num763 = 10;
			num757 -= num763;
			num758 += num763;
			num759 -= num763;
			num760 += num763;
			int num764 = 500;
			int num765 = 100;
			bool flag49 = crimson;
			double num766 = (double)Main.maxTilesX * 0.00045;
			if (remixWorldGen)
			{
				num766 *= 2.0;
			}
			else if (tenthAnniversaryWorldGen)
			{
				num764 *= 2;
				num765 *= 2;
			}
			if (drunkWorldGen)
			{
				flag49 = true;
				num766 /= 2.0;
			}
			if (flag49)
			{
				progress.Message = Lang.gen[72].Value;
				for (int num767 = 0; (double)num767 < num766; num767++)
				{
					int num768 = num759;
					int num769 = num760;
					int num770 = num757;
					int num771 = num758;
					double value15 = (double)num767 / num766;
					progress.Set(value15);
					bool flag50 = false;
					int num772 = 0;
					int num773 = 0;
					int num774 = 0;
					while (!flag50)
					{
						flag50 = true;
						int num775 = Main.maxTilesX / 2;
						int num776 = 200;
						if (drunkWorldGen)
						{
							num776 = 100;
							num772 = ((!GenVars.crimsonLeft) ? genRand.Next((int)((double)Main.maxTilesX * 0.5), Main.maxTilesX - num764) : genRand.Next(num764, (int)((double)Main.maxTilesX * 0.5)));
						}
						else
						{
							num772 = genRand.Next(num764, Main.maxTilesX - num764);
						}
						num773 = num772 - genRand.Next(200) - 100;
						num774 = num772 + genRand.Next(200) + 100;
						if (num773 < GenVars.evilBiomeBeachAvoidance)
						{
							num773 = GenVars.evilBiomeBeachAvoidance;
						}
						if (num774 > Main.maxTilesX - GenVars.evilBiomeBeachAvoidance)
						{
							num774 = Main.maxTilesX - GenVars.evilBiomeBeachAvoidance;
						}
						if (num772 < num773 + GenVars.evilBiomeAvoidanceMidFixer)
						{
							num772 = num773 + GenVars.evilBiomeAvoidanceMidFixer;
						}
						if (num772 > num774 - GenVars.evilBiomeAvoidanceMidFixer)
						{
							num772 = num774 - GenVars.evilBiomeAvoidanceMidFixer;
						}
						if (GenVars.dungeonSide < 0 && num773 < 400)
						{
							num773 = 400;
						}
						else if (GenVars.dungeonSide > 0 && num773 > Main.maxTilesX - 400)
						{
							num773 = Main.maxTilesX - 400;
						}
						if (num773 < GenVars.dungeonLocation + num765 && num774 > GenVars.dungeonLocation - num765)
						{
							flag50 = false;
						}
						if (!remixWorldGen)
						{
							if (!tenthAnniversaryWorldGen)
							{
								if (num772 > num775 - num776 && num772 < num775 + num776)
								{
									flag50 = false;
								}
								if (num773 > num775 - num776 && num773 < num775 + num776)
								{
									flag50 = false;
								}
								if (num774 > num775 - num776 && num774 < num775 + num776)
								{
									flag50 = false;
								}
							}
							if (num772 > GenVars.UndergroundDesertLocation.X && num772 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
							{
								flag50 = false;
							}
							if (num773 > GenVars.UndergroundDesertLocation.X && num773 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
							{
								flag50 = false;
							}
							if (num774 > GenVars.UndergroundDesertLocation.X && num774 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
							{
								flag50 = false;
							}
							if (num773 < num769 && num774 > num768)
							{
								num768++;
								num769--;
								flag50 = false;
							}
							if (num773 < num771 && num774 > num770)
							{
								num770++;
								num771--;
								flag50 = false;
							}
						}
					}
					CrimStart(num772, (int)GenVars.worldSurfaceLow - 10);
					for (int num777 = num773; num777 < num774; num777++)
					{
						for (int num778 = (int)GenVars.worldSurfaceLow; (double)num778 < Main.worldSurface - 1.0; num778++)
						{
							if (Main.tile[num777, num778].active())
							{
								int num779 = num778 + genRand.Next(10, 14);
								for (int num780 = num778; num780 < num779; num780++)
								{
									if (Main.tile[num777, num780].type == 60 && num777 >= num773 + genRand.Next(5) && num777 < num774 - genRand.Next(5))
									{
										Main.tile[num777, num780].type = 662;
									}
								}
								break;
							}
						}
					}
					double num781 = Main.worldSurface + 40.0;
					for (int num782 = num773; num782 < num774; num782++)
					{
						num781 += (double)genRand.Next(-2, 3);
						if (num781 < Main.worldSurface + 30.0)
						{
							num781 = Main.worldSurface + 30.0;
						}
						if (num781 > Main.worldSurface + 50.0)
						{
							num781 = Main.worldSurface + 50.0;
						}
						bool flag51 = false;
						for (int num783 = (int)GenVars.worldSurfaceLow; (double)num783 < num781; num783++)
						{
							if (Main.tile[num782, num783].active())
							{
								if (Main.tile[num782, num783].type == 53 && num782 >= num773 + genRand.Next(5) && num782 <= num774 - genRand.Next(5))
								{
									Main.tile[num782, num783].type = 234;
								}
								if ((double)num783 < Main.worldSurface - 1.0 && !flag51)
								{
									if (Main.tile[num782, num783].type == 0)
									{
										grassSpread = 0;
										SpreadGrass(num782, num783, 0, 199);
									}
									else if (Main.tile[num782, num783].type == 59)
									{
										grassSpread = 0;
										SpreadGrass(num782, num783, 59, 662);
									}
								}
								flag51 = true;
								if (Main.tile[num782, num783].wall == 216)
								{
									Main.tile[num782, num783].wall = 218;
								}
								else if (Main.tile[num782, num783].wall == 187)
								{
									Main.tile[num782, num783].wall = 221;
								}
								if (Main.tile[num782, num783].type == 1)
								{
									if (num782 >= num773 + genRand.Next(5) && num782 <= num774 - genRand.Next(5))
									{
										Main.tile[num782, num783].type = 203;
									}
								}
								else if (Main.tile[num782, num783].type == 2)
								{
									Main.tile[num782, num783].type = 199;
								}
								else if (Main.tile[num782, num783].type == 60)
								{
									Main.tile[num782, num783].type = 662;
								}
								else if (Main.tile[num782, num783].type == 161)
								{
									Main.tile[num782, num783].type = 200;
								}
								else if (Main.tile[num782, num783].type == 396)
								{
									Main.tile[num782, num783].type = 401;
								}
								else if (Main.tile[num782, num783].type == 397)
								{
									Main.tile[num782, num783].type = 399;
								}
							}
						}
					}
					int num784 = genRand.Next(10, 15);
					for (int num785 = 0; num785 < num784; num785++)
					{
						int num786 = 0;
						bool flag52 = false;
						int num787 = 0;
						while (!flag52)
						{
							num786++;
							int x28 = genRand.Next(num773 - num787, num774 + num787);
							int num788 = genRand.Next((int)(Main.worldSurface - (double)(num787 / 2)), (int)(Main.worldSurface + 100.0 + (double)num787));
							while (oceanDepths(x28, num788))
							{
								x28 = genRand.Next(num773 - num787, num774 + num787);
								num788 = genRand.Next((int)(Main.worldSurface - (double)(num787 / 2)), (int)(Main.worldSurface + 100.0 + (double)num787));
							}
							if (num786 > 100)
							{
								num787++;
								num786 = 0;
							}
							if (!Main.tile[x28, num788].active())
							{
								for (; !Main.tile[x28, num788].active(); num788++)
								{
								}
								num788--;
							}
							else
							{
								while (Main.tile[x28, num788].active() && (double)num788 > Main.worldSurface)
								{
									num788--;
								}
							}
							if ((num787 > 10 || (Main.tile[x28, num788 + 1].active() && Main.tile[x28, num788 + 1].type == 203)) && !IsTileNearby(x28, num788, 26, 3))
							{
								Place3x2(x28, num788, 26, 1);
								if (Main.tile[x28, num788].type == 26)
								{
									flag52 = true;
								}
							}
							if (num787 > 100)
							{
								flag52 = true;
							}
						}
					}
				}
				CrimPlaceHearts();
			}
			if (drunkWorldGen)
			{
				flag49 = false;
			}
			if (!flag49)
			{
				progress.Message = Lang.gen[20].Value;
				for (int num789 = 0; (double)num789 < num766; num789++)
				{
					int num790 = num759;
					int num791 = num760;
					int num792 = num757;
					int num793 = num758;
					double value16 = (double)num789 / num766;
					progress.Set(value16);
					bool flag53 = false;
					int num794 = 0;
					int num795 = 0;
					int num796 = 0;
					while (!flag53)
					{
						flag53 = true;
						int num797 = Main.maxTilesX / 2;
						int num798 = 200;
						num794 = ((!drunkWorldGen) ? genRand.Next(num764, Main.maxTilesX - num764) : (GenVars.crimsonLeft ? genRand.Next((int)((double)Main.maxTilesX * 0.5), Main.maxTilesX - num764) : genRand.Next(num764, (int)((double)Main.maxTilesX * 0.5))));
						num795 = num794 - genRand.Next(200) - 100;
						num796 = num794 + genRand.Next(200) + 100;
						if (num795 < GenVars.evilBiomeBeachAvoidance)
						{
							num795 = GenVars.evilBiomeBeachAvoidance;
						}
						if (num796 > Main.maxTilesX - GenVars.evilBiomeBeachAvoidance)
						{
							num796 = Main.maxTilesX - GenVars.evilBiomeBeachAvoidance;
						}
						if (num794 < num795 + GenVars.evilBiomeAvoidanceMidFixer)
						{
							num794 = num795 + GenVars.evilBiomeAvoidanceMidFixer;
						}
						if (num794 > num796 - GenVars.evilBiomeAvoidanceMidFixer)
						{
							num794 = num796 - GenVars.evilBiomeAvoidanceMidFixer;
						}
						if (num795 < GenVars.dungeonLocation + num765 && num796 > GenVars.dungeonLocation - num765)
						{
							flag53 = false;
						}
						if (!remixWorldGen)
						{
							if (!tenthAnniversaryWorldGen)
							{
								if (num794 > num797 - num798 && num794 < num797 + num798)
								{
									flag53 = false;
								}
								if (num795 > num797 - num798 && num795 < num797 + num798)
								{
									flag53 = false;
								}
								if (num796 > num797 - num798 && num796 < num797 + num798)
								{
									flag53 = false;
								}
							}
							if (num794 > GenVars.UndergroundDesertLocation.X && num794 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
							{
								flag53 = false;
							}
							if (num795 > GenVars.UndergroundDesertLocation.X && num795 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
							{
								flag53 = false;
							}
							if (num796 > GenVars.UndergroundDesertLocation.X && num796 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
							{
								flag53 = false;
							}
							if (num795 < num791 && num796 > num790)
							{
								num790++;
								num791--;
								flag53 = false;
							}
							if (num795 < num793 && num796 > num792)
							{
								num792++;
								num793--;
								flag53 = false;
							}
						}
					}
					int num799 = 0;
					for (int num800 = num795; num800 < num796; num800++)
					{
						if (num799 > 0)
						{
							num799--;
						}
						if (num800 == num794 || num799 == 0)
						{
							for (int num801 = (int)GenVars.worldSurfaceLow; (double)num801 < Main.worldSurface - 1.0; num801++)
							{
								if (Main.tile[num800, num801].active() || Main.tile[num800, num801].wall > 0)
								{
									if (num800 == num794)
									{
										num799 = 20;
										ChasmRunner(num800, num801, genRand.Next(150) + 150, makeOrb: true);
									}
									else if (genRand.Next(35) == 0 && num799 == 0)
									{
										num799 = 30;
										bool makeOrb = true;
										ChasmRunner(num800, num801, genRand.Next(50) + 50, makeOrb);
									}
									break;
								}
							}
						}
						for (int num802 = (int)GenVars.worldSurfaceLow; (double)num802 < Main.worldSurface - 1.0; num802++)
						{
							if (Main.tile[num800, num802].active())
							{
								int num803 = num802 + genRand.Next(10, 14);
								for (int num804 = num802; num804 < num803; num804++)
								{
									if (Main.tile[num800, num804].type == 60 && num800 >= num795 + genRand.Next(5) && num800 < num796 - genRand.Next(5))
									{
										Main.tile[num800, num804].type = 661;
									}
								}
								break;
							}
						}
					}
					double num805 = Main.worldSurface + 40.0;
					for (int num806 = num795; num806 < num796; num806++)
					{
						num805 += (double)genRand.Next(-2, 3);
						if (num805 < Main.worldSurface + 30.0)
						{
							num805 = Main.worldSurface + 30.0;
						}
						if (num805 > Main.worldSurface + 50.0)
						{
							num805 = Main.worldSurface + 50.0;
						}
						bool flag54 = false;
						for (int num807 = (int)GenVars.worldSurfaceLow; (double)num807 < num805; num807++)
						{
							if (Main.tile[num806, num807].active())
							{
								if (Main.tile[num806, num807].type == 53 && num806 >= num795 + genRand.Next(5) && num806 <= num796 - genRand.Next(5))
								{
									Main.tile[num806, num807].type = 112;
								}
								if ((double)num807 < Main.worldSurface - 1.0 && !flag54)
								{
									if (Main.tile[num806, num807].type == 0)
									{
										grassSpread = 0;
										SpreadGrass(num806, num807, 0, 23);
									}
									else if (Main.tile[num806, num807].type == 59)
									{
										grassSpread = 0;
										SpreadGrass(num806, num807, 59, 661);
									}
								}
								flag54 = true;
								if (Main.tile[num806, num807].wall == 216)
								{
									Main.tile[num806, num807].wall = 217;
								}
								else if (Main.tile[num806, num807].wall == 187)
								{
									Main.tile[num806, num807].wall = 220;
								}
								if (Main.tile[num806, num807].type == 1)
								{
									if (num806 >= num795 + genRand.Next(5) && num806 <= num796 - genRand.Next(5))
									{
										Main.tile[num806, num807].type = 25;
									}
								}
								else if (Main.tile[num806, num807].type == 2)
								{
									Main.tile[num806, num807].type = 23;
								}
								else if (Main.tile[num806, num807].type == 60)
								{
									Main.tile[num806, num807].type = 661;
								}
								else if (Main.tile[num806, num807].type == 161)
								{
									Main.tile[num806, num807].type = 163;
								}
								else if (Main.tile[num806, num807].type == 396)
								{
									Main.tile[num806, num807].type = 400;
								}
								else if (Main.tile[num806, num807].type == 397)
								{
									Main.tile[num806, num807].type = 398;
								}
							}
						}
					}
					for (int num808 = num795; num808 < num796; num808++)
					{
						for (int num809 = 0; num809 < Main.maxTilesY - 50; num809++)
						{
							if (Main.tile[num808, num809].active() && Main.tile[num808, num809].type == 31)
							{
								int num810 = num808 - 13;
								int num811 = num808 + 13;
								int num812 = num809 - 13;
								int num813 = num809 + 13;
								for (int num814 = num810; num814 < num811; num814++)
								{
									if (num814 > 10 && num814 < Main.maxTilesX - 10)
									{
										for (int num815 = num812; num815 < num813; num815++)
										{
											if (Math.Abs(num814 - num808) + Math.Abs(num815 - num809) < 9 + genRand.Next(11) && genRand.Next(3) != 0 && Main.tile[num814, num815].type != 31)
											{
												Main.tile[num814, num815].active(active: true);
												Main.tile[num814, num815].type = 25;
												if (Math.Abs(num814 - num808) <= 1 && Math.Abs(num815 - num809) <= 1)
												{
													Main.tile[num814, num815].active(active: false);
												}
											}
											if (Main.tile[num814, num815].type != 31 && Math.Abs(num814 - num808) <= 2 + genRand.Next(3) && Math.Abs(num815 - num809) <= 2 + genRand.Next(3))
											{
												Main.tile[num814, num815].active(active: false);
											}
										}
									}
								}
							}
						}
					}
				}
			}
		});
		AddGenerationPass("Lakes", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			//IL_03d2: Unknown result type (might be due to invalid IL or missing references)
			progress.Message = Lang.gen[19].Value;
			double num739 = (double)Main.maxTilesX / 4200.0;
			int num740 = genRand.Next((int)(num739 * 3.0), (int)(num739 * 6.0));
			for (int num741 = 0; num741 < num740; num741++)
			{
				int num742 = Main.maxTilesX / 4;
				if (GenVars.numLakes >= GenVars.maxLakes - 1)
				{
					break;
				}
				double value14 = (double)num741 / (double)num740;
				progress.Set(value14);
				while (num742 > 0)
				{
					bool flag48 = false;
					num742--;
					int num743 = genRand.Next(GenVars.lakesBeachAvoidance, Main.maxTilesX - GenVars.lakesBeachAvoidance);
					if (tenthAnniversaryWorldGen && !remixWorldGen)
					{
						num743 = genRand.Next((int)((double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.85));
					}
					else
					{
						while ((double)num743 > (double)Main.maxTilesX * 0.45 && (double)num743 < (double)Main.maxTilesX * 0.55)
						{
							num743 = genRand.Next(GenVars.lakesBeachAvoidance, Main.maxTilesX - GenVars.lakesBeachAvoidance);
						}
					}
					for (int num744 = 0; num744 < GenVars.numLakes; num744++)
					{
						if (Math.Abs(num743 - GenVars.LakeX[num744]) < 150)
						{
							flag48 = true;
							break;
						}
					}
					for (int num745 = 0; num745 < GenVars.numMCaves; num745++)
					{
						if (Math.Abs(num743 - GenVars.mCaveX[num745]) < 100)
						{
							flag48 = true;
							break;
						}
					}
					for (int num746 = 0; num746 < GenVars.numTunnels; num746++)
					{
						if (Math.Abs(num743 - GenVars.tunnelX[num746]) < 100)
						{
							flag48 = true;
							break;
						}
					}
					if (!flag48)
					{
						int num747 = (int)GenVars.worldSurfaceLow - 20;
						while (!Main.tile[num743, num747].active())
						{
							num747++;
							if ((double)num747 >= Main.worldSurface || Main.tile[num743, num747].wall > 0)
							{
								flag48 = true;
								break;
							}
						}
						if (Main.tile[num743, num747].type == 53)
						{
							flag48 = true;
						}
						if (!flag48)
						{
							int num748 = 50;
							for (int num749 = num743 - num748; num749 <= num743 + num748; num749++)
							{
								for (int num750 = num747 - num748; num750 <= num747 + num748; num750++)
								{
									if (Main.tile[num749, num750].type == 203 || Main.tile[num749, num750].type == 25)
									{
										flag48 = true;
										break;
									}
								}
							}
							if (!flag48)
							{
								int num751 = num747;
								num748 = 20;
								while (!SolidTile(num743 - num748, num747) || !SolidTile(num743 + num748, num747))
								{
									num747++;
									if ((double)num747 > Main.worldSurface - 50.0)
									{
										flag48 = true;
									}
								}
								if (num747 - num751 <= 10)
								{
									num748 = 60;
									for (int num752 = num743 - num748; num752 <= num743 + num748; num752++)
									{
										int y23 = num747 - 20;
										if (Main.tile[num752, y23].active() || Main.tile[num752, y23].wall > 0)
										{
											flag48 = true;
										}
									}
									if (!flag48)
									{
										int num753 = 0;
										for (int num754 = num743 - num748; num754 <= num743 + num748; num754++)
										{
											for (int num755 = num747; num755 <= num747 + num748 * 2; num755++)
											{
												if (SolidTile(num754, num755))
												{
													num753++;
												}
											}
										}
										int num756 = (num748 * 2 + 1) * (num748 * 2 + 1);
										if (!((double)num753 < (double)num756 * 0.8) && !((Rectangle)(ref GenVars.UndergroundDesertLocation)).Intersects(new Rectangle(num743 - 8, num747 - 8, 16, 16)))
										{
											SonOfLakinater(num743, num747);
											GenVars.LakeX[GenVars.numLakes] = num743;
											GenVars.numLakes++;
											break;
										}
									}
								}
							}
						}
					}
				}
			}
		});
		AddGenerationPass("Dungeon", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Set(1.0);
			int dungeonLocation = GenVars.dungeonLocation;
			int num735 = (int)((Main.worldSurface + Main.rockLayer) / 2.0) + genRand.Next(-200, 200);
			int num736 = (int)((Main.worldSurface + Main.rockLayer) / 2.0) + 200;
			int num737 = num735;
			bool flag47 = false;
			for (int num738 = 0; num738 < 10; num738++)
			{
				if (SolidTile(dungeonLocation, num737 + num738))
				{
					flag47 = true;
					break;
				}
			}
			if (!flag47)
			{
				for (; num737 < num736 && !SolidTile(dungeonLocation, num737 + 10); num737++)
				{
				}
			}
			if (drunkWorldGen)
			{
				num737 = (int)Main.worldSurface + 70;
			}
			MakeDungeon(dungeonLocation, num737);
		});
		AddGenerationPass("Slush", delegate
		{
			for (int num730 = GenVars.snowTop; num730 < GenVars.snowBottom; num730++)
			{
				for (int num731 = GenVars.snowMinX[num730]; num731 < GenVars.snowMaxX[num730]; num731++)
				{
					switch (Main.tile[num731, num730].type)
					{
					case 123:
						Main.tile[num731, num730].type = 224;
						break;
					case 59:
					{
						bool flag46 = true;
						int num732 = 3;
						for (int num733 = num731 - num732; num733 <= num731 + num732; num733++)
						{
							for (int num734 = num730 - num732; num734 <= num730 + num732; num734++)
							{
								if (Main.tile[num733, num734].type == 60 || Main.tile[num733, num734].type == 70 || Main.tile[num733, num734].type == 71 || Main.tile[num733, num734].type == 72)
								{
									flag46 = false;
									break;
								}
							}
						}
						if (flag46)
						{
							Main.tile[num731, num730].type = 224;
						}
						break;
					}
					case 1:
						Main.tile[num731, num730].type = 161;
						break;
					}
				}
			}
		});
		AddGenerationPass("Mountain Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[21].Value;
			for (int num729 = 0; num729 < GenVars.numMCaves; num729++)
			{
				int i3 = GenVars.mCaveX[num729];
				int j5 = GenVars.mCaveY[num729];
				CaveOpenater(i3, j5);
				Cavinator(i3, j5, genRand.Next(40, 50));
			}
		});
		AddGenerationPass("Beaches", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			int num711 = 50;
			progress.Message = Lang.gen[22].Value;
			bool floridaStyle = false;
			bool floridaStyle2 = false;
			if (genRand.Next(4) == 0)
			{
				if (genRand.Next(2) == 0)
				{
					floridaStyle = true;
				}
				else
				{
					floridaStyle2 = true;
				}
			}
			for (int num712 = 0; num712 < 2; num712++)
			{
				int num713 = 0;
				int num714 = 0;
				if (num712 == 0)
				{
					num713 = 0;
					num714 = genRand.Next(GenVars.oceanWaterStartRandomMin, GenVars.oceanWaterStartRandomMax);
					if (GenVars.dungeonSide == 1)
					{
						num714 = GenVars.oceanWaterForcedJungleLength;
					}
					int num715 = GenVars.leftBeachEnd - num711;
					if (num714 > num715)
					{
						num714 = num715;
					}
					int num716 = 0;
					double num717 = 1.0;
					int num718;
					for (num718 = 0; !Main.tile[num714 - 1, num718].active(); num718++)
					{
					}
					GenVars.shellStartYLeft = num718;
					num718 += genRand.Next(1, 5);
					for (int num719 = num714 - 1; num719 >= num713; num719--)
					{
						if (num719 > 30)
						{
							num716++;
							num717 = TuneOceanDepth(num716, num717, floridaStyle);
						}
						else
						{
							num717 += 1.0;
						}
						int num720 = genRand.Next(15, 20);
						for (int num721 = 0; (double)num721 < (double)num718 + num717 + (double)num720; num721++)
						{
							if ((double)num721 < (double)num718 + num717 * 0.75 - 3.0)
							{
								Main.tile[num719, num721].active(active: false);
								if (num721 > num718)
								{
									Main.tile[num719, num721].liquid = byte.MaxValue;
									Main.tile[num719, num721].lava(lava: false);
								}
								else if (num721 == num718)
								{
									Main.tile[num719, num721].liquid = 127;
									if (GenVars.shellStartXLeft == 0)
									{
										GenVars.shellStartXLeft = num719;
									}
								}
							}
							else if (num721 > num718)
							{
								Main.tile[num719, num721].type = 53;
								Main.tile[num719, num721].active(active: true);
							}
							Main.tile[num719, num721].wall = 0;
						}
					}
				}
				else
				{
					num713 = Main.maxTilesX - genRand.Next(GenVars.oceanWaterStartRandomMin, GenVars.oceanWaterStartRandomMax);
					num714 = Main.maxTilesX;
					if (GenVars.dungeonSide == -1)
					{
						num713 = Main.maxTilesX - GenVars.oceanWaterForcedJungleLength;
					}
					int num722 = GenVars.rightBeachStart + num711;
					if (num713 < num722)
					{
						num713 = num722;
					}
					double num723 = 1.0;
					int num724 = 0;
					int num725;
					for (num725 = 0; !Main.tile[num713, num725].active(); num725++)
					{
					}
					GenVars.shellStartXRight = 0;
					GenVars.shellStartYRight = num725;
					num725 += genRand.Next(1, 5);
					for (int num726 = num713; num726 < num714; num726++)
					{
						if (num726 < num714 - 30)
						{
							num724++;
							num723 = TuneOceanDepth(num724, num723, floridaStyle2);
						}
						else
						{
							num723 += 1.0;
						}
						int num727 = genRand.Next(15, 20);
						for (int num728 = 0; (double)num728 < (double)num725 + num723 + (double)num727; num728++)
						{
							if ((double)num728 < (double)num725 + num723 * 0.75 - 3.0)
							{
								Main.tile[num726, num728].active(active: false);
								if (num728 > num725)
								{
									Main.tile[num726, num728].liquid = byte.MaxValue;
									Main.tile[num726, num728].lava(lava: false);
								}
								else if (num728 == num725)
								{
									Main.tile[num726, num728].liquid = 127;
									if (GenVars.shellStartXRight == 0)
									{
										GenVars.shellStartXRight = num726;
									}
								}
							}
							else if (num728 > num725)
							{
								Main.tile[num726, num728].type = 53;
								Main.tile[num726, num728].active(active: true);
							}
							Main.tile[num726, num728].wall = 0;
						}
					}
				}
			}
		});
		AddGenerationPass("Gems", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[23].Value;
			Main.tileSolid[484] = false;
			for (int num699 = 63; num699 <= 68; num699++)
			{
				double value13 = (double)(num699 - 63) / 6.0;
				progress.Set(value13);
				double num700 = 0.0;
				switch (num699)
				{
				case 67:
					num700 = (double)Main.maxTilesX * 0.5;
					break;
				case 66:
					num700 = (double)Main.maxTilesX * 0.45;
					break;
				case 63:
					num700 = (double)Main.maxTilesX * 0.3;
					break;
				case 65:
					num700 = (double)Main.maxTilesX * 0.25;
					break;
				case 64:
					num700 = (double)Main.maxTilesX * 0.1;
					break;
				case 68:
					num700 = (double)Main.maxTilesX * 0.05;
					break;
				}
				num700 *= 0.2;
				for (int num701 = 0; (double)num701 < num700; num701++)
				{
					int num702 = genRand.Next(0, Main.maxTilesX);
					int num703 = genRand.Next((int)Main.worldSurface, Main.maxTilesY);
					while (Main.tile[num702, num703].type != 1)
					{
						num702 = genRand.Next(0, Main.maxTilesX);
						num703 = genRand.Next((int)Main.worldSurface, Main.maxTilesY);
					}
					TileRunner(num702, num703, genRand.Next(2, 6), genRand.Next(3, 7), num699);
				}
			}
			for (int num704 = 0; num704 < 2; num704++)
			{
				int num705 = 1;
				int num706 = 5;
				int num707 = Main.maxTilesX - 5;
				if (num704 == 1)
				{
					num705 = -1;
					num706 = Main.maxTilesX - 5;
					num707 = 5;
				}
				for (int num708 = num706; num708 != num707; num708 += num705)
				{
					if (num708 <= ((Rectangle)(ref GenVars.UndergroundDesertLocation)).Left || num708 >= ((Rectangle)(ref GenVars.UndergroundDesertLocation)).Right)
					{
						for (int num709 = 10; num709 < Main.maxTilesY - 10; num709++)
						{
							if (Main.tile[num708, num709].active() && Main.tile[num708, num709 + 1].active() && Main.tileSand[Main.tile[num708, num709].type] && Main.tileSand[Main.tile[num708, num709 + 1].type])
							{
								ushort type8 = Main.tile[num708, num709].type;
								int x27 = num708 + num705;
								int num710 = num709 + 1;
								if (!Main.tile[x27, num709].active() && !Main.tile[x27, num710].active())
								{
									for (; !Main.tile[x27, num710].active(); num710++)
									{
									}
									num710--;
									Main.tile[num708, num709].active(active: false);
									Main.tile[x27, num710].active(active: true);
									Main.tile[x27, num710].type = type8;
								}
							}
						}
					}
				}
			}
		});
		AddGenerationPass("Gravitating Sand", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[24].Value;
			for (int num695 = 0; num695 < Main.maxTilesX; num695++)
			{
				double value12 = (double)num695 / (double)(Main.maxTilesX - 1);
				progress.Set(value12);
				bool flag45 = false;
				int num696 = 0;
				for (int num697 = Main.maxTilesY - 1; num697 > 0; num697--)
				{
					if (SolidOrSlopedTile(num695, num697))
					{
						ushort type7 = Main.tile[num695, num697].type;
						if (flag45 && num697 < (int)Main.worldSurface && num697 != num696 - 1 && TileID.Sets.Falling[type7])
						{
							for (int num698 = num697; num698 < num696; num698++)
							{
								Main.tile[num695, num698].ResetToType(type7);
							}
						}
						flag45 = true;
						num696 = num697;
					}
				}
			}
		});
		AddGenerationPass("Create Ocean Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			int maxValue11 = 3;
			if (remixWorldGen)
			{
				maxValue11 = 2;
			}
			for (int num692 = 0; num692 < 2; num692++)
			{
				if ((num692 != 0 || GenVars.dungeonSide <= 0) && (num692 != 1 || GenVars.dungeonSide >= 0) && (genRand.Next(maxValue11) == 0 || drunkWorldGen || tenthAnniversaryWorldGen))
				{
					progress.Message = Lang.gen[90].Value;
					int num693 = genRand.Next(55, 95);
					if (num692 == 1)
					{
						num693 = genRand.Next(Main.maxTilesX - 95, Main.maxTilesX - 55);
					}
					int num694;
					for (num694 = 0; !Main.tile[num693, num694].active(); num694++)
					{
					}
					oceanCave(num693, num694);
				}
			}
		});
		AddGenerationPass("Shimmer", delegate
		{
			//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
			int num683 = 50;
			int num684 = (int)(Main.worldSurface + Main.rockLayer) / 2 + num683;
			int num685 = (int)((double)((Main.maxTilesY - 250) * 2) + Main.rockLayer) / 3;
			if (num685 > Main.maxTilesY - 330 - 100 - 30)
			{
				num685 = Main.maxTilesY - 330 - 100 - 30;
			}
			if (num685 <= num684)
			{
				num685 = num684 + 50;
			}
			int num686 = genRand.Next(num684, num685);
			int num687 = ((GenVars.dungeonSide < 0) ? genRand.Next((int)((double)Main.maxTilesX * 0.89), Main.maxTilesX - 200) : genRand.Next(200, (int)((double)Main.maxTilesX * 0.11)));
			int num688 = (int)Main.worldSurface + 150;
			int num689 = (int)(Main.rockLayer + Main.worldSurface + 200.0) / 2;
			if (num689 <= num688)
			{
				num689 = num688 + 50;
			}
			if (tenthAnniversaryWorldGen)
			{
				num686 = genRand.Next(num688, num689);
			}
			int num690 = 0;
			while (!ShimmerMakeBiome(num687, num686))
			{
				num690++;
				if (tenthAnniversaryWorldGen && num690 < 10000)
				{
					num686 = genRand.Next(num688, num689);
					num687 = ((GenVars.dungeonSide < 0) ? genRand.Next((int)((double)Main.maxTilesX * 0.89), Main.maxTilesX - 200) : genRand.Next(200, (int)((double)Main.maxTilesX * 0.11)));
				}
				else if (num690 > 20000)
				{
					num686 = genRand.Next((int)Main.worldSurface + 100 + 20, num685);
					num687 = ((GenVars.dungeonSide < 0) ? genRand.Next((int)((double)Main.maxTilesX * 0.8), Main.maxTilesX - 200) : genRand.Next(200, (int)((double)Main.maxTilesX * 0.2)));
				}
				else
				{
					num686 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2 + 20, num685);
					num687 = ((GenVars.dungeonSide < 0) ? genRand.Next((int)((double)Main.maxTilesX * 0.89), Main.maxTilesX - 200) : genRand.Next(200, (int)((double)Main.maxTilesX * 0.11)));
				}
			}
			GenVars.shimmerPosition = new Vector2D(num687, num686);
			int num691 = 200;
			GenVars.structures.AddProtectedStructure(new Rectangle(num687 - num691 / 2, num686 - num691 / 2, num691, num691));
		});
		AddGenerationPass("Clean Up Dirt", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[25].Value;
			for (int num677 = 3; num677 < Main.maxTilesX - 3; num677++)
			{
				double num678 = (double)num677 / (double)Main.maxTilesX;
				progress.Set(0.5 * num678);
				bool flag43 = true;
				for (int num679 = 0; (double)num679 < Main.worldSurface; num679++)
				{
					if (flag43)
					{
						if (Main.tile[num677, num679].wall == 2 || Main.tile[num677, num679].wall == 40 || Main.tile[num677, num679].wall == 64 || Main.tile[num677, num679].wall == 86)
						{
							Main.tile[num677, num679].wall = 0;
						}
						if (Main.tile[num677, num679].type != 53 && Main.tile[num677, num679].type != 112 && Main.tile[num677, num679].type != 234)
						{
							if (Main.tile[num677 - 1, num679].wall == 2 || Main.tile[num677 - 1, num679].wall == 40 || Main.tile[num677 - 1, num679].wall == 40)
							{
								Main.tile[num677 - 1, num679].wall = 0;
							}
							if ((Main.tile[num677 - 2, num679].wall == 2 || Main.tile[num677 - 2, num679].wall == 40 || Main.tile[num677 - 2, num679].wall == 40) && genRand.Next(2) == 0)
							{
								Main.tile[num677 - 2, num679].wall = 0;
							}
							if ((Main.tile[num677 - 3, num679].wall == 2 || Main.tile[num677 - 3, num679].wall == 40 || Main.tile[num677 - 3, num679].wall == 40) && genRand.Next(2) == 0)
							{
								Main.tile[num677 - 3, num679].wall = 0;
							}
							if (Main.tile[num677 + 1, num679].wall == 2 || Main.tile[num677 + 1, num679].wall == 40 || Main.tile[num677 + 1, num679].wall == 40)
							{
								Main.tile[num677 + 1, num679].wall = 0;
							}
							if ((Main.tile[num677 + 2, num679].wall == 2 || Main.tile[num677 + 2, num679].wall == 40 || Main.tile[num677 + 2, num679].wall == 40) && genRand.Next(2) == 0)
							{
								Main.tile[num677 + 2, num679].wall = 0;
							}
							if ((Main.tile[num677 + 3, num679].wall == 2 || Main.tile[num677 + 3, num679].wall == 40 || Main.tile[num677 + 3, num679].wall == 40) && genRand.Next(2) == 0)
							{
								Main.tile[num677 + 3, num679].wall = 0;
							}
							if (Main.tile[num677, num679].active())
							{
								flag43 = false;
							}
						}
					}
					else if (Main.tile[num677, num679].wall == 0 && Main.tile[num677, num679 + 1].wall == 0 && Main.tile[num677, num679 + 2].wall == 0 && Main.tile[num677, num679 + 3].wall == 0 && Main.tile[num677, num679 + 4].wall == 0 && Main.tile[num677 - 1, num679].wall == 0 && Main.tile[num677 + 1, num679].wall == 0 && Main.tile[num677 - 2, num679].wall == 0 && Main.tile[num677 + 2, num679].wall == 0 && !Main.tile[num677, num679].active() && !Main.tile[num677, num679 + 1].active() && !Main.tile[num677, num679 + 2].active() && !Main.tile[num677, num679 + 3].active())
					{
						flag43 = true;
					}
				}
			}
			for (int num680 = Main.maxTilesX - 5; num680 >= 5; num680--)
			{
				double num681 = (double)num680 / (double)Main.maxTilesX;
				progress.Set(1.0 - 0.5 * num681);
				bool flag44 = true;
				for (int num682 = 0; (double)num682 < Main.worldSurface; num682++)
				{
					if (flag44)
					{
						if (Main.tile[num680, num682].wall == 2 || Main.tile[num680, num682].wall == 40 || Main.tile[num680, num682].wall == 64)
						{
							Main.tile[num680, num682].wall = 0;
						}
						if (Main.tile[num680, num682].type != 53)
						{
							if (Main.tile[num680 - 1, num682].wall == 2 || Main.tile[num680 - 1, num682].wall == 40 || Main.tile[num680 - 1, num682].wall == 40)
							{
								Main.tile[num680 - 1, num682].wall = 0;
							}
							if ((Main.tile[num680 - 2, num682].wall == 2 || Main.tile[num680 - 2, num682].wall == 40 || Main.tile[num680 - 2, num682].wall == 40) && genRand.Next(2) == 0)
							{
								Main.tile[num680 - 2, num682].wall = 0;
							}
							if ((Main.tile[num680 - 3, num682].wall == 2 || Main.tile[num680 - 3, num682].wall == 40 || Main.tile[num680 - 3, num682].wall == 40) && genRand.Next(2) == 0)
							{
								Main.tile[num680 - 3, num682].wall = 0;
							}
							if (Main.tile[num680 + 1, num682].wall == 2 || Main.tile[num680 + 1, num682].wall == 40 || Main.tile[num680 + 1, num682].wall == 40)
							{
								Main.tile[num680 + 1, num682].wall = 0;
							}
							if ((Main.tile[num680 + 2, num682].wall == 2 || Main.tile[num680 + 2, num682].wall == 40 || Main.tile[num680 + 2, num682].wall == 40) && genRand.Next(2) == 0)
							{
								Main.tile[num680 + 2, num682].wall = 0;
							}
							if ((Main.tile[num680 + 3, num682].wall == 2 || Main.tile[num680 + 3, num682].wall == 40 || Main.tile[num680 + 3, num682].wall == 40) && genRand.Next(2) == 0)
							{
								Main.tile[num680 + 3, num682].wall = 0;
							}
							if (Main.tile[num680, num682].active())
							{
								flag44 = false;
							}
						}
					}
					else if (Main.tile[num680, num682].wall == 0 && Main.tile[num680, num682 + 1].wall == 0 && Main.tile[num680, num682 + 2].wall == 0 && Main.tile[num680, num682 + 3].wall == 0 && Main.tile[num680, num682 + 4].wall == 0 && Main.tile[num680 - 1, num682].wall == 0 && Main.tile[num680 + 1, num682].wall == 0 && Main.tile[num680 - 2, num682].wall == 0 && Main.tile[num680 + 2, num682].wall == 0 && !Main.tile[num680, num682].active() && !Main.tile[num680, num682 + 1].active() && !Main.tile[num680, num682 + 2].active() && !Main.tile[num680, num682 + 3].active())
					{
						flag44 = true;
					}
				}
			}
		});
		AddGenerationPass("Pyramids", delegate
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			Rectangle undergroundDesertLocation = GenVars.UndergroundDesertLocation;
			if (Main.tenthAnniversaryWorld)
			{
				int x26 = ((Rectangle)(ref undergroundDesertLocation)).Center.X;
				int j4 = ((Rectangle)(ref undergroundDesertLocation)).Top - 10;
				Pyramid(x26, j4);
			}
			for (int num670 = 0; num670 < GenVars.numPyr; num670++)
			{
				int num671 = GenVars.PyrX[num670];
				int num672 = GenVars.PyrY[num670];
				if (num671 > 300 && num671 < Main.maxTilesX - 300 && (GenVars.dungeonSide >= 0 || !((double)num671 < (double)GenVars.dungeonX + (double)Main.maxTilesX * 0.15)) && (GenVars.dungeonSide <= 0 || !((double)num671 > (double)GenVars.dungeonX - (double)Main.maxTilesX * 0.15)) && (!Main.tenthAnniversaryWorld || !((Rectangle)(ref undergroundDesertLocation)).Contains(num671, num672)))
				{
					for (; !Main.tile[num671, num672].active() && (double)num672 < Main.worldSurface; num672++)
					{
					}
					if (!((double)num672 >= Main.worldSurface) && Main.tile[num671, num672].type == 53)
					{
						int num673 = Main.maxTilesX;
						for (int num674 = 0; num674 < num670; num674++)
						{
							int num675 = Math.Abs(num671 - GenVars.PyrX[num674]);
							if (num675 < num673)
							{
								num673 = num675;
							}
						}
						int num676 = 220;
						if (drunkWorldGen)
						{
							num676 /= 2;
						}
						if (num673 >= num676)
						{
							num672--;
							Pyramid(num671, num672);
						}
					}
				}
			}
		});
		AddGenerationPass("Dirt Rock Wall Runner", delegate
		{
			for (int num667 = 0; num667 < Main.maxTilesX; num667++)
			{
				int num668 = genRand.Next(10, Main.maxTilesX - 10);
				int num669 = genRand.Next(10, (int)Main.worldSurface);
				if (Main.tile[num668, num669].wall == 2)
				{
					DirtyRockRunner(num668, num669);
				}
			}
		});
		AddGenerationPass("Living Trees", delegate
		{
			int num650 = 200;
			double num651 = (double)Main.maxTilesX / 4200.0;
			int num652 = genRand.Next(0, (int)(2.0 * num651) + 1);
			if (num652 == 0 && genRand.Next(2) == 0)
			{
				num652++;
			}
			if (drunkWorldGen)
			{
				num652 += (int)(2.0 * num651);
			}
			else if (Main.tenthAnniversaryWorld)
			{
				num652 += (int)(3.0 * num651);
			}
			else if (remixWorldGen)
			{
				num652 += (int)(2.0 * num651);
			}
			for (int num653 = 0; num653 < num652; num653++)
			{
				bool flag41 = false;
				int num654 = 0;
				while (!flag41)
				{
					num654++;
					if (num654 > Main.maxTilesX / 2)
					{
						flag41 = true;
					}
					int num655 = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
					if (tenthAnniversaryWorldGen && !remixWorldGen)
					{
						num655 = genRand.Next((int)((double)Main.maxTilesX * 0.15), (int)((float)Main.maxTilesX * 0.85f));
					}
					if (num655 <= Main.maxTilesX / 2 - num650 || num655 >= Main.maxTilesX / 2 + num650)
					{
						int num656;
						for (num656 = 0; !Main.tile[num655, num656].active() && (double)num656 < Main.worldSurface; num656++)
						{
						}
						if (Main.tile[num655, num656].type == 0)
						{
							num656--;
							if (num656 > 150)
							{
								bool flag42 = true;
								for (int num657 = num655 - 50; num657 < num655 + 50; num657++)
								{
									for (int num658 = num656 - 50; num658 < num656 + 50; num658++)
									{
										if (Main.tile[num657, num658].active())
										{
											switch (Main.tile[num657, num658].type)
											{
											case 41:
											case 43:
											case 44:
											case 189:
											case 196:
											case 460:
											case 481:
											case 482:
											case 483:
												flag42 = false;
												break;
											}
										}
									}
								}
								for (int num659 = 0; num659 < GenVars.numMCaves; num659++)
								{
									if (num655 > GenVars.mCaveX[num659] - 50 && num655 < GenVars.mCaveX[num659] + 50)
									{
										flag42 = false;
										break;
									}
								}
								if (flag42)
								{
									flag41 = GrowLivingTree(num655, num656);
									if (flag41)
									{
										for (int num660 = -1; num660 <= 1; num660++)
										{
											if (num660 != 0)
											{
												int num661 = num655;
												int num662 = genRand.Next(4);
												if (drunkWorldGen || Main.tenthAnniversaryWorld)
												{
													num662 += genRand.Next(2, 5);
												}
												else if (remixWorldGen)
												{
													num662 += genRand.Next(1, 6);
												}
												for (int num663 = 0; num663 < num662; num663++)
												{
													num661 += genRand.Next(13, 31) * num660;
													if (num661 <= Main.maxTilesX / 2 - num650 || num661 >= Main.maxTilesX / 2 + num650)
													{
														int num664 = num656;
														if (Main.tile[num661, num664].active())
														{
															while (Main.tile[num661, num664].active())
															{
																num664--;
															}
														}
														else
														{
															for (; !Main.tile[num661, num664].active(); num664++)
															{
															}
															num664--;
														}
														flag42 = true;
														for (int num665 = num655 - 50; num665 < num655 + 50; num665++)
														{
															for (int num666 = num656 - 50; num666 < num656 + 50; num666++)
															{
																if (Main.tile[num665, num666].active())
																{
																	switch (Main.tile[num665, num666].type)
																	{
																	case 41:
																	case 43:
																	case 44:
																	case 189:
																	case 196:
																	case 460:
																	case 481:
																	case 482:
																	case 483:
																		flag42 = false;
																		break;
																	}
																}
															}
														}
														if (flag42)
														{
															GrowLivingTree(num661, num664, patch: true);
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			Main.tileSolid[192] = false;
		});
		AddGenerationPass("Wood Tree Walls", delegate
		{
			for (int num646 = 25; num646 < Main.maxTilesX - 25; num646++)
			{
				for (int num647 = 25; (double)num647 < Main.worldSurface; num647++)
				{
					if (Main.tile[num646, num647].type == 191 || Main.tile[num646, num647 - 1].type == 191 || Main.tile[num646 - 1, num647].type == 191 || Main.tile[num646 + 1, num647].type == 191 || Main.tile[num646, num647 + 1].type == 191)
					{
						bool flag40 = true;
						for (int num648 = num646 - 1; num648 <= num646 + 1; num648++)
						{
							for (int num649 = num647 - 1; num649 <= num647 + 1; num649++)
							{
								if (num648 != num646 && num649 != num647 && Main.tile[num648, num649].type != 191 && Main.tile[num648, num649].wall != 244)
								{
									flag40 = false;
								}
							}
						}
						if (flag40)
						{
							Main.tile[num646, num647].wall = 244;
						}
					}
				}
			}
		});
		AddGenerationPass("Altars", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			Main.tileSolid[484] = false;
			progress.Message = Lang.gen[26].Value;
			int num641 = (int)((double)(Main.maxTilesX * Main.maxTilesY) * 3.3E-06);
			if (remixWorldGen)
			{
				num641 *= 3;
			}
			for (int num642 = 0; num642 < num641; num642++)
			{
				progress.Set((double)num642 / (double)num641);
				for (int num643 = 0; num643 < 10000; num643++)
				{
					int num644 = genRand.Next(281, Main.maxTilesX - 3 - 280);
					while ((double)num644 > (double)Main.maxTilesX * 0.45 && (double)num644 < (double)Main.maxTilesX * 0.55)
					{
						num644 = genRand.Next(281, Main.maxTilesX - 3 - 280);
					}
					int num645 = genRand.Next((int)(Main.worldSurface * 2.0 + Main.rockLayer) / 3, (int)(Main.rockLayer + (double)((Main.maxTilesY - 350) * 2)) / 3);
					if (remixWorldGen)
					{
						num645 = genRand.Next(100, (int)((double)Main.maxTilesY * 0.9));
					}
					while (oceanDepths(num644, num645) || Vector2D.Distance(new Vector2D(num644, num645), GenVars.shimmerPosition) < (double)shimmerSafetyDistance)
					{
						num644 = genRand.Next(281, Main.maxTilesX - 3 - 280);
						while ((double)num644 > (double)Main.maxTilesX * 0.45 && (double)num644 < (double)Main.maxTilesX * 0.55)
						{
							num644 = genRand.Next(281, Main.maxTilesX - 3 - 280);
						}
						num645 = genRand.Next((int)(Main.worldSurface * 2.0 + Main.rockLayer) / 3, (int)(Main.rockLayer + (double)((Main.maxTilesY - 350) * 2)) / 3);
						if (remixWorldGen)
						{
							num645 = genRand.Next(100, (int)((double)Main.maxTilesY * 0.9));
						}
					}
					int style2 = (crimson ? 1 : 0);
					if (drunkWorldGen)
					{
						style2 = ((!GenVars.crimsonLeft) ? ((num644 >= Main.maxTilesX / 2) ? 1 : 0) : ((num644 < Main.maxTilesX / 2) ? 1 : 0));
					}
					if (!IsTileNearby(num644, num645, 26, 3))
					{
						Place3x2(num644, num645, 26, style2);
					}
					if (Main.tile[num644, num645].type == 26)
					{
						break;
					}
				}
			}
		});
		AddGenerationPass("Wet Jungle", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Set(1.0);
			for (int num639 = 0; num639 < Main.maxTilesX; num639++)
			{
				for (int num640 = (int)GenVars.worldSurfaceLow; (double)num640 < Main.worldSurface - 1.0; num640++)
				{
					if (Main.tile[num639, num640].active())
					{
						if (Main.tile[num639, num640].type == 60)
						{
							Main.tile[num639, num640 - 1].liquid = byte.MaxValue;
							Main.tile[num639, num640 - 2].liquid = byte.MaxValue;
						}
						break;
					}
				}
			}
		});
		AddGenerationPass("Jungle Temple", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			int num630 = 0;
			progress.Message = Lang.gen[70].Value;
			long num631 = 0L;
			double num632 = 0.25;
			bool flag38 = false;
			while (true)
			{
				int num633 = (int)Main.rockLayer;
				int num634 = Main.maxTilesY - 500;
				if (num633 > num634 - 1)
				{
					num633 = num634 - 1;
				}
				int num635 = genRand.Next(num633, num634);
				int x24 = (int)(((genRand.NextDouble() * num632 + 0.1) * (double)(-GenVars.dungeonSide) + 0.5) * (double)Main.maxTilesX);
				if (remixWorldGen)
				{
					if (notTheBees)
					{
						x24 = ((GenVars.dungeonSide <= 0) ? genRand.Next((int)((double)Main.maxTilesX * 0.6), (int)((double)Main.maxTilesX * 0.8)) : genRand.Next((int)((double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.4)));
					}
					else
					{
						x24 = genRand.Next((int)((double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.8));
						while ((double)x24 > (double)Main.maxTilesX * 0.4 && (double)x24 < (double)Main.maxTilesX * 0.6)
						{
							x24 = genRand.Next((int)((double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.8));
						}
					}
					while (Main.tile[x24, num635].active() || Main.tile[x24, num635].wall > 0 || (double)num635 > Main.worldSurface - 5.0)
					{
						num635--;
					}
					num635++;
					if (Main.tile[x24, num635].active() && (Main.tile[x24, num635].type == 60 || Main.tile[x24, num635].type == 59))
					{
						int num636 = 10;
						bool flag39 = false;
						for (int num637 = x24 - num636; num637 <= num637 + num636; num637++)
						{
							for (int num638 = num635 - num636; num638 < num636; num638++)
							{
								if (Main.tile[num637, num638].type == 191 || Main.tileDungeon[Main.tile[num637, num638].type])
								{
									flag39 = true;
								}
							}
						}
						if (!flag39)
						{
							flag38 = true;
							num635 -= 10 + genRand.Next(10);
							makeTemple(x24, num635);
							break;
						}
					}
				}
				else if (Main.tile[x24, num635].active() && Main.tile[x24, num635].type == 60)
				{
					flag38 = true;
					makeTemple(x24, num635);
					break;
				}
				if (num631++ > 2000000)
				{
					if (num632 == 0.35)
					{
						num630++;
						if (num630 > 10)
						{
							break;
						}
					}
					num632 = Math.Min(0.35, num632 + 0.05);
					num631 = 0L;
				}
			}
			if (!flag38)
			{
				int x25 = Main.maxTilesX - GenVars.dungeonX;
				int y22 = (int)Main.rockLayer + 100;
				if (remixWorldGen)
				{
					x25 = (notTheBees ? ((GenVars.dungeonSide > 0) ? ((int)((double)Main.maxTilesX * 0.3)) : ((int)((double)Main.maxTilesX * 0.7))) : ((GenVars.dungeonSide > 0) ? ((int)((double)Main.maxTilesX * 0.4)) : ((int)((double)Main.maxTilesX * 0.6))));
				}
				makeTemple(x25, y22);
			}
		});
		AddGenerationPass("Hives", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0135: Unknown result type (might be due to invalid IL or missing references)
			//IL_0148: Unknown result type (might be due to invalid IL or missing references)
			//IL_0170: Unknown result type (might be due to invalid IL or missing references)
			progress.Message = Lang.gen[71].Value;
			double num620 = (double)Main.maxTilesX / 4200.0;
			double num621 = 1 + genRand.Next((int)(5.0 * num620), (int)(8.0 * num620));
			if (drunkWorldGen)
			{
				num621 *= 0.667;
			}
			int num622 = 10000;
			HiveBiome hiveBiome = GenVars.configuration.CreateBiome<HiveBiome>();
			HoneyPatchBiome honeyPatchBiome = GenVars.configuration.CreateBiome<HoneyPatchBiome>();
			while (num621 > 0.0 && num622 > 0)
			{
				num622--;
				Point val3 = RandomWorldPoint((int)(Main.worldSurface + Main.rockLayer) >> 1, 20, 300, 20);
				if (drunkWorldGen)
				{
					RandomWorldPoint((int)Main.worldSurface, 20, 300, 20);
				}
				if (hiveBiome.Place(val3, GenVars.structures))
				{
					num621 -= 1.0;
					int num623 = genRand.Next(5);
					int num624 = 0;
					int num625 = 10000;
					while (num624 < num623 && num625 > 0)
					{
						double num626 = genRand.NextDouble() * 60.0 + 30.0;
						double num627 = genRand.NextDouble() * 6.2831854820251465;
						int num628 = (int)(Math.Cos(num627) * num626) + val3.X;
						int num629 = (int)(Math.Sin(num627) * num626) + val3.Y;
						num625--;
						if (num628 > 50 && num628 < Main.maxTilesX - 50 && honeyPatchBiome.Place(new Point(num628, num629), GenVars.structures))
						{
							num624++;
						}
					}
				}
			}
		});
		AddGenerationPass("Jungle Chests", delegate
		{
			//IL_0245: Unknown result type (might be due to invalid IL or missing references)
			//IL_05e7: Unknown result type (might be due to invalid IL or missing references)
			int num593 = genRand.Next(40, Main.maxTilesX - 40);
			int num594 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 400);
			double num595 = genRand.Next(7, 12);
			num595 *= (double)Main.maxTilesX / 4200.0;
			int num596 = 0;
			Rectangle area = default(Rectangle);
			for (int num597 = 0; (double)num597 < num595; num597++)
			{
				bool flag36 = true;
				while (flag36)
				{
					num596++;
					num593 = genRand.Next(40, Main.maxTilesX / 2 - 40);
					if (GenVars.dungeonSide < 0)
					{
						num593 += Main.maxTilesX / 2;
					}
					num594 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 400);
					int num598 = genRand.Next(2, 4);
					int num599 = genRand.Next(2, 4);
					((Rectangle)(ref area))._002Ector(num593 - num598 - 1, num594 - num599 - 1, num598 + 1, num599 + 1);
					if (Main.tile[num593, num594].type == 60)
					{
						int num600 = 30;
						flag36 = false;
						for (int num601 = num593 - num600; num601 < num593 + num600; num601 += 3)
						{
							for (int num602 = num594 - num600; num602 < num594 + num600; num602 += 3)
							{
								if (Main.tile[num601, num602].active() && (Main.tile[num601, num602].type == 225 || Main.tile[num601, num602].type == 229 || Main.tile[num601, num602].type == 226 || Main.tile[num601, num602].type == 119 || Main.tile[num601, num602].type == 120))
								{
									flag36 = true;
								}
								if (Main.tile[num601, num602].wall == 86 || Main.tile[num601, num602].wall == 87)
								{
									flag36 = true;
								}
							}
						}
						if (!GenVars.structures.CanPlace(area, 1))
						{
							flag36 = true;
						}
					}
					if (!flag36)
					{
						ushort num603 = 0;
						if (GenVars.jungleHut == 119)
						{
							num603 = 23;
						}
						else if (GenVars.jungleHut == 120)
						{
							num603 = 24;
						}
						else if (GenVars.jungleHut == 158)
						{
							num603 = 42;
						}
						else if (GenVars.jungleHut == 175)
						{
							num603 = 45;
						}
						else if (GenVars.jungleHut == 45)
						{
							num603 = 10;
						}
						for (int num604 = num593 - num598 - 1; num604 <= num593 + num598 + 1; num604++)
						{
							for (int num605 = num594 - num599 - 1; num605 <= num594 + num599 + 1; num605++)
							{
								Main.tile[num604, num605].active(active: true);
								Main.tile[num604, num605].type = GenVars.jungleHut;
								Main.tile[num604, num605].liquid = 0;
								Main.tile[num604, num605].lava(lava: false);
							}
						}
						for (int num606 = num593 - num598; num606 <= num593 + num598; num606++)
						{
							for (int num607 = num594 - num599; num607 <= num594 + num599; num607++)
							{
								Main.tile[num606, num607].active(active: false);
								Main.tile[num606, num607].wall = num603;
							}
						}
						bool flag37 = false;
						int num608 = 0;
						while (!flag37 && num608 < 100)
						{
							num608++;
							int num609 = genRand.Next(num593 - num598, num593 + num598 + 1);
							int num610 = genRand.Next(num594 - num599, num594 + num599 - 2);
							PlaceTile(num609, num610, 4, mute: true, forced: false, -1, 3);
							if (TileID.Sets.Torch[Main.tile[num609, num610].type])
							{
								flag37 = true;
							}
						}
						for (int num611 = num593 - num598 - 1; num611 <= num593 + num598 + 1; num611++)
						{
							for (int num612 = num594 + num599 - 2; num612 <= num594 + num599; num612++)
							{
								Main.tile[num611, num612].active(active: false);
							}
						}
						for (int num613 = num593 - num598 - 1; num613 <= num593 + num598 + 1; num613++)
						{
							for (int num614 = num594 + num599 - 2; num614 <= num594 + num599 - 1; num614++)
							{
								Main.tile[num613, num614].active(active: false);
							}
						}
						for (int num615 = num593 - num598 - 1; num615 <= num593 + num598 + 1; num615++)
						{
							int num616 = 4;
							int num617 = num594 + num599 + 2;
							while (!Main.tile[num615, num617].active() && num617 < Main.maxTilesY && num616 > 0)
							{
								Main.tile[num615, num617].active(active: true);
								Main.tile[num615, num617].type = 59;
								num617++;
								num616--;
							}
						}
						num598 -= genRand.Next(1, 3);
						int num618 = num594 - num599 - 2;
						while (num598 > -1)
						{
							for (int num619 = num593 - num598 - 1; num619 <= num593 + num598 + 1; num619++)
							{
								Main.tile[num619, num618].active(active: true);
								Main.tile[num619, num618].type = GenVars.jungleHut;
							}
							num598 -= genRand.Next(1, 3);
							num618--;
						}
						GenVars.JChestX[GenVars.numJChests] = num593;
						GenVars.JChestY[GenVars.numJChests] = num594;
						GenVars.structures.AddProtectedStructure(area);
						GenVars.numJChests++;
						num596 = 0;
					}
					else if (num596 > Main.maxTilesX * 10)
					{
						num597++;
						num596 = 0;
						break;
					}
				}
			}
			Main.tileSolid[137] = false;
		});
		AddGenerationPass("Settle Liquids", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[27].Value;
			if (notTheBees)
			{
				NotTheBees();
			}
			Liquid.worldGenTilesIgnoreWater(ignoreSolids: true);
			Liquid.QuickWater(3);
			WaterCheck();
			int num586 = 0;
			Liquid.quickSettle = true;
			int num587 = 10;
			while (num586 < num587)
			{
				int num588 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
				num586++;
				double num589 = 0.0;
				int num590 = num588 * 5;
				while (Liquid.numLiquid > 0)
				{
					num590--;
					if (num590 < 0)
					{
						break;
					}
					double num591 = (double)(num588 - (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer)) / (double)num588;
					if (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer > num588)
					{
						num588 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
					}
					if (num591 > num589)
					{
						num589 = num591;
					}
					else
					{
						num591 = num589;
					}
					if (num586 == 1)
					{
						progress.Set(num591 / 3.0 + 0.33);
					}
					int num592 = 10;
					if (num586 > num592)
					{
						num592 = num586;
					}
					Liquid.UpdateLiquid();
				}
				WaterCheck();
				progress.Set((double)num586 * 0.1 / 3.0 + 0.66);
			}
			Liquid.quickSettle = false;
			Liquid.worldGenTilesIgnoreWater(ignoreSolids: false);
			Main.tileSolid[484] = false;
		});
		AddGenerationPass("Remove Water From Sand", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Set(1.0);
			for (int num583 = 400; num583 < Main.maxTilesX - 400; num583++)
			{
				for (int num584 = 100; (double)num584 < Main.worldSurface - 1.0; num584++)
				{
					if (Main.tile[num583, num584].active())
					{
						ushort type6 = Main.tile[num583, num584].type;
						if (type6 == 53 || type6 == 396 || type6 == 397 || type6 == 404 || type6 == 407 || type6 == 151)
						{
							int num585 = num584;
							while (num585 > 100)
							{
								num585--;
								if (Main.tile[num583, num585].active())
								{
									break;
								}
								Main.tile[num583, num585].liquid = 0;
							}
						}
						break;
					}
				}
			}
			Main.tileSolid[192] = true;
		});
		AddGenerationPass("Oasis", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!notTheBees)
			{
				progress.Set(1.0);
				int num579 = Main.maxTilesX / 2100;
				num579 += genRand.Next(2);
				for (int num580 = 0; num580 < num579; num580++)
				{
					int num581 = beachDistance + 300;
					int num582 = Main.maxTilesX * 2;
					while (num582 > 0)
					{
						num582--;
						int x23 = genRand.Next(num581, Main.maxTilesX - num581);
						int y21 = genRand.Next(100, (int)Main.worldSurface);
						if (PlaceOasis(x23, y21))
						{
							num582 = -1;
						}
					}
				}
			}
		});
		AddGenerationPass("Shell Piles", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (dontStarveWorldGen)
			{
				int num567 = (int)(5.0 * ((double)Main.maxTilesX / 4200.0));
				int num568 = 0;
				int num569 = 100;
				int num570 = Main.maxTilesX / 2;
				int num571 = num570 - num569;
				int num572 = num570 + num569;
				for (int num573 = 0; num573 < 80; num573++)
				{
					int num574 = genRand.Next(100, Main.maxTilesX - 100);
					if (num574 >= num571 && num574 <= num572)
					{
						num574 = genRand.Next(100, Main.maxTilesX - 100);
						if (num574 >= num571 && num574 <= num572)
						{
							continue;
						}
					}
					int y20 = (int)Main.worldSurface / 2;
					if (MarblePileWithStatues(num574, y20))
					{
						num568++;
						if (num568 >= num567)
						{
							break;
						}
					}
				}
			}
			if (!notTheBees)
			{
				progress.Set(1.0);
				if (genRand.Next(2) == 0)
				{
					int shellStartXLeft = GenVars.shellStartXLeft;
					int shellStartYLeft = GenVars.shellStartYLeft;
					for (int num575 = shellStartXLeft - 20; num575 <= shellStartXLeft + 20; num575++)
					{
						for (int num576 = shellStartYLeft - 10; num576 <= shellStartYLeft + 10; num576++)
						{
							if (Main.tile[num575, num576].active() && Main.tile[num575, num576].type == 53 && !Main.tile[num575, num576 - 1].active() && Main.tile[num575, num576 - 1].liquid == 0 && !Main.tile[num575 - 1, num576].active() && Main.tile[num575 - 1, num576].liquid > 0)
							{
								GenVars.shellStartXLeft = num575;
								GenVars.shellStartYLeft = num576;
							}
						}
					}
					GenVars.shellStartYLeft -= 50;
					GenVars.shellStartXLeft -= genRand.Next(5);
					if (genRand.Next(2) == 0)
					{
						GenVars.shellStartXLeft -= genRand.Next(10);
					}
					if (genRand.Next(3) == 0)
					{
						GenVars.shellStartXLeft -= genRand.Next(15);
					}
					if (genRand.Next(4) != 0)
					{
						ShellPile(GenVars.shellStartXLeft, GenVars.shellStartYLeft);
					}
					int maxValue9 = genRand.Next(2, 4);
					if (genRand.Next(maxValue9) == 0)
					{
						ShellPile(GenVars.shellStartXLeft - genRand.Next(10, 35), GenVars.shellStartYLeft);
					}
					if (genRand.Next(maxValue9) == 0)
					{
						ShellPile(GenVars.shellStartXLeft - genRand.Next(40, 65), GenVars.shellStartYLeft);
					}
					if (genRand.Next(maxValue9) == 0)
					{
						ShellPile(GenVars.shellStartXLeft - genRand.Next(70, 95), GenVars.shellStartYLeft);
					}
					if (genRand.Next(maxValue9) == 0)
					{
						ShellPile(GenVars.shellStartXLeft - genRand.Next(100, 125), GenVars.shellStartYLeft);
					}
					if (genRand.Next(maxValue9) == 0)
					{
						ShellPile(GenVars.shellStartXLeft + genRand.Next(10, 25), GenVars.shellStartYLeft);
					}
				}
				if (genRand.Next(2) == 0)
				{
					int shellStartXRight = GenVars.shellStartXRight;
					int shellStartYRight = GenVars.shellStartYRight;
					for (int num577 = shellStartXRight - 20; num577 <= shellStartXRight + 20; num577++)
					{
						for (int num578 = shellStartYRight - 10; num578 <= shellStartYRight + 10; num578++)
						{
							if (Main.tile[num577, num578].active() && Main.tile[num577, num578].type == 53 && !Main.tile[num577, num578 - 1].active() && Main.tile[num577, num578 - 1].liquid == 0 && !Main.tile[num577 + 1, num578].active() && Main.tile[num577 + 1, num578].liquid > 0)
							{
								GenVars.shellStartXRight = num577;
								GenVars.shellStartYRight = num578;
							}
						}
					}
					GenVars.shellStartYRight -= 50;
					GenVars.shellStartXRight += genRand.Next(5);
					if (genRand.Next(2) == 0)
					{
						GenVars.shellStartXLeft += genRand.Next(10);
					}
					if (genRand.Next(3) == 0)
					{
						GenVars.shellStartXLeft += genRand.Next(15);
					}
					if (genRand.Next(4) != 0)
					{
						ShellPile(GenVars.shellStartXRight, GenVars.shellStartYRight);
					}
					int maxValue10 = genRand.Next(2, 4);
					if (genRand.Next(maxValue10) == 0)
					{
						ShellPile(GenVars.shellStartXRight + genRand.Next(10, 35), GenVars.shellStartYRight);
					}
					if (genRand.Next(maxValue10) == 0)
					{
						ShellPile(GenVars.shellStartXRight + genRand.Next(40, 65), GenVars.shellStartYRight);
					}
					if (genRand.Next(maxValue10) == 0)
					{
						ShellPile(GenVars.shellStartXRight + genRand.Next(70, 95), GenVars.shellStartYRight);
					}
					if (genRand.Next(maxValue10) == 0)
					{
						ShellPile(GenVars.shellStartXRight + genRand.Next(100, 125), GenVars.shellStartYRight);
					}
					if (genRand.Next(maxValue10) == 0)
					{
						ShellPile(GenVars.shellStartXRight - genRand.Next(10, 25), GenVars.shellStartYRight);
					}
				}
			}
		});
		AddGenerationPass("Smooth World", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[60].Value;
			Main.tileSolid[GenVars.crackedType] = true;
			for (int num563 = 20; num563 < Main.maxTilesX - 20; num563++)
			{
				double value11 = (double)num563 / (double)Main.maxTilesX;
				progress.Set(value11);
				for (int num564 = 20; num564 < Main.maxTilesY - 20; num564++)
				{
					if (Main.tile[num563, num564].type != 48 && Main.tile[num563, num564].type != 137 && Main.tile[num563, num564].type != 232 && Main.tile[num563, num564].type != 191 && Main.tile[num563, num564].type != 151 && Main.tile[num563, num564].type != 274)
					{
						if (!Main.tile[num563, num564 - 1].active() && Main.tile[num563 - 1, num564].type != 136 && Main.tile[num563 + 1, num564].type != 136)
						{
							if (SolidTile(num563, num564) && TileID.Sets.CanBeClearedDuringGeneration[Main.tile[num563, num564].type])
							{
								if (!Main.tile[num563 - 1, num564].halfBrick() && !Main.tile[num563 + 1, num564].halfBrick() && Main.tile[num563 - 1, num564].slope() == 0 && Main.tile[num563 + 1, num564].slope() == 0)
								{
									if (SolidTile(num563, num564 + 1))
									{
										if (!SolidTile(num563 - 1, num564) && !Main.tile[num563 - 1, num564 + 1].halfBrick() && SolidTile(num563 - 1, num564 + 1) && SolidTile(num563 + 1, num564) && !Main.tile[num563 + 1, num564 - 1].active())
										{
											if (genRand.Next(2) == 0)
											{
												SlopeTile(num563, num564, 2);
											}
											else
											{
												PoundTile(num563, num564);
											}
										}
										else if (!SolidTile(num563 + 1, num564) && !Main.tile[num563 + 1, num564 + 1].halfBrick() && SolidTile(num563 + 1, num564 + 1) && SolidTile(num563 - 1, num564) && !Main.tile[num563 - 1, num564 - 1].active())
										{
											if (genRand.Next(2) == 0)
											{
												SlopeTile(num563, num564, 1);
											}
											else
											{
												PoundTile(num563, num564);
											}
										}
										else if (SolidTile(num563 + 1, num564 + 1) && SolidTile(num563 - 1, num564 + 1) && !Main.tile[num563 + 1, num564].active() && !Main.tile[num563 - 1, num564].active())
										{
											PoundTile(num563, num564);
										}
										if (SolidTile(num563, num564))
										{
											if (SolidTile(num563 - 1, num564) && SolidTile(num563 + 1, num564 + 2) && !Main.tile[num563 + 1, num564].active() && !Main.tile[num563 + 1, num564 + 1].active() && !Main.tile[num563 - 1, num564 - 1].active())
											{
												KillTile(num563, num564);
											}
											else if (SolidTile(num563 + 1, num564) && SolidTile(num563 - 1, num564 + 2) && !Main.tile[num563 - 1, num564].active() && !Main.tile[num563 - 1, num564 + 1].active() && !Main.tile[num563 + 1, num564 - 1].active())
											{
												KillTile(num563, num564);
											}
											else if (!Main.tile[num563 - 1, num564 + 1].active() && !Main.tile[num563 - 1, num564].active() && SolidTile(num563 + 1, num564) && SolidTile(num563, num564 + 2))
											{
												if (genRand.Next(5) == 0)
												{
													KillTile(num563, num564);
												}
												else if (genRand.Next(5) == 0)
												{
													PoundTile(num563, num564);
												}
												else
												{
													SlopeTile(num563, num564, 2);
												}
											}
											else if (!Main.tile[num563 + 1, num564 + 1].active() && !Main.tile[num563 + 1, num564].active() && SolidTile(num563 - 1, num564) && SolidTile(num563, num564 + 2))
											{
												if (genRand.Next(5) == 0)
												{
													KillTile(num563, num564);
												}
												else if (genRand.Next(5) == 0)
												{
													PoundTile(num563, num564);
												}
												else
												{
													SlopeTile(num563, num564, 1);
												}
											}
										}
									}
									if (SolidTile(num563, num564) && !Main.tile[num563 - 1, num564].active() && !Main.tile[num563 + 1, num564].active())
									{
										KillTile(num563, num564);
									}
								}
							}
							else if (!Main.tile[num563, num564].active() && Main.tile[num563, num564 + 1].type != 151 && Main.tile[num563, num564 + 1].type != 274)
							{
								if (Main.tile[num563 + 1, num564].type != 190 && Main.tile[num563 + 1, num564].type != 48 && Main.tile[num563 + 1, num564].type != 232 && SolidTile(num563 - 1, num564 + 1) && SolidTile(num563 + 1, num564) && !Main.tile[num563 - 1, num564].active() && !Main.tile[num563 + 1, num564 - 1].active())
								{
									if (Main.tile[num563 + 1, num564].type == 495)
									{
										PlaceTile(num563, num564, Main.tile[num563 + 1, num564].type);
									}
									else
									{
										PlaceTile(num563, num564, Main.tile[num563, num564 + 1].type);
									}
									if (genRand.Next(2) == 0)
									{
										SlopeTile(num563, num564, 2);
									}
									else
									{
										PoundTile(num563, num564);
									}
								}
								if (Main.tile[num563 - 1, num564].type != 190 && Main.tile[num563 - 1, num564].type != 48 && Main.tile[num563 - 1, num564].type != 232 && SolidTile(num563 + 1, num564 + 1) && SolidTile(num563 - 1, num564) && !Main.tile[num563 + 1, num564].active() && !Main.tile[num563 - 1, num564 - 1].active())
								{
									if (Main.tile[num563 - 1, num564].type == 495)
									{
										PlaceTile(num563, num564, Main.tile[num563 - 1, num564].type);
									}
									else
									{
										PlaceTile(num563, num564, Main.tile[num563, num564 + 1].type);
									}
									if (genRand.Next(2) == 0)
									{
										SlopeTile(num563, num564, 1);
									}
									else
									{
										PoundTile(num563, num564);
									}
								}
							}
						}
						else if (!Main.tile[num563, num564 + 1].active() && genRand.Next(2) == 0 && SolidTile(num563, num564) && !Main.tile[num563 - 1, num564].halfBrick() && !Main.tile[num563 + 1, num564].halfBrick() && Main.tile[num563 - 1, num564].slope() == 0 && Main.tile[num563 + 1, num564].slope() == 0 && SolidTile(num563, num564 - 1))
						{
							if (SolidTile(num563 - 1, num564) && !SolidTile(num563 + 1, num564) && SolidTile(num563 - 1, num564 - 1))
							{
								SlopeTile(num563, num564, 3);
							}
							else if (SolidTile(num563 + 1, num564) && !SolidTile(num563 - 1, num564) && SolidTile(num563 + 1, num564 - 1))
							{
								SlopeTile(num563, num564, 4);
							}
						}
						if (TileID.Sets.Conversion.Sand[Main.tile[num563, num564].type])
						{
							Tile.SmoothSlope(num563, num564, applyToNeighbors: false);
						}
					}
				}
			}
			for (int num565 = 20; num565 < Main.maxTilesX - 20; num565++)
			{
				for (int num566 = 20; num566 < Main.maxTilesY - 20; num566++)
				{
					if (genRand.Next(2) == 0 && !Main.tile[num565, num566 - 1].active() && Main.tile[num565, num566].type != 137 && Main.tile[num565, num566].type != 48 && Main.tile[num565, num566].type != 232 && Main.tile[num565, num566].type != 191 && Main.tile[num565, num566].type != 151 && Main.tile[num565, num566].type != 274 && Main.tile[num565, num566].type != 75 && Main.tile[num565, num566].type != 76 && SolidTile(num565, num566) && Main.tile[num565 - 1, num566].type != 137 && Main.tile[num565 + 1, num566].type != 137)
					{
						if (SolidTile(num565, num566 + 1) && SolidTile(num565 + 1, num566) && !Main.tile[num565 - 1, num566].active())
						{
							SlopeTile(num565, num566, 2);
						}
						if (SolidTile(num565, num566 + 1) && SolidTile(num565 - 1, num566) && !Main.tile[num565 + 1, num566].active())
						{
							SlopeTile(num565, num566, 1);
						}
					}
					if (Main.tile[num565, num566].slope() == 1 && !SolidTile(num565 - 1, num566))
					{
						SlopeTile(num565, num566);
						PoundTile(num565, num566);
					}
					if (Main.tile[num565, num566].slope() == 2 && !SolidTile(num565 + 1, num566))
					{
						SlopeTile(num565, num566);
						PoundTile(num565, num566);
					}
				}
			}
			Main.tileSolid[137] = true;
			Main.tileSolid[190] = false;
			Main.tileSolid[192] = false;
			Main.tileSolid[GenVars.crackedType] = false;
		});
		AddGenerationPass("Waterfalls", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[69].Value;
			Main.tileSolid[191] = false;
			for (int num554 = 20; num554 < Main.maxTilesX - 20; num554++)
			{
				double num555 = (double)num554 / (double)Main.maxTilesX;
				progress.Set(num555 * 0.5);
				for (int num556 = 20; num556 < Main.maxTilesY - 20; num556++)
				{
					if (SolidTile(num554, num556) && !Main.tile[num554 - 1, num556].active() && SolidTile(num554, num556 + 1) && !Main.tile[num554 + 1, num556].active() && (Main.tile[num554 - 1, num556].liquid > 0 || Main.tile[num554 + 1, num556].liquid > 0))
					{
						bool flag35 = true;
						int num557 = genRand.Next(8, 20);
						int num558 = genRand.Next(8, 20);
						num557 = num556 - num557;
						num558 += num556;
						for (int num559 = num557; num559 <= num558; num559++)
						{
							if (Main.tile[num554, num559].halfBrick())
							{
								flag35 = false;
							}
						}
						if ((Main.tile[num554, num556].type == 75 || Main.tile[num554, num556].type == 76) && genRand.Next(10) != 0)
						{
							flag35 = false;
						}
						if (flag35)
						{
							PoundTile(num554, num556);
						}
					}
				}
			}
			for (int num560 = 20; num560 < Main.maxTilesX - 20; num560++)
			{
				double num561 = (double)num560 / (double)Main.maxTilesX;
				progress.Set(num561 * 0.5 + 0.5);
				for (int num562 = 20; num562 < Main.maxTilesY - 20; num562++)
				{
					if (Main.tile[num560, num562].type != 48 && Main.tile[num560, num562].type != 232 && SolidTile(num560, num562) && SolidTile(num560, num562 + 1))
					{
						if (!SolidTile(num560 + 1, num562) && Main.tile[num560 - 1, num562].halfBrick() && Main.tile[num560 - 2, num562].liquid > 0)
						{
							PoundTile(num560, num562);
						}
						if (!SolidTile(num560 - 1, num562) && Main.tile[num560 + 1, num562].halfBrick() && Main.tile[num560 + 2, num562].liquid > 0)
						{
							PoundTile(num560, num562);
						}
					}
				}
			}
			Main.tileSolid[191] = true;
		});
		AddGenerationPass("Ice", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (notTheBees)
			{
				NotTheBees();
			}
			progress.Set(1.0);
			for (int num552 = 10; num552 < Main.maxTilesX - 10; num552++)
			{
				for (int num553 = (int)Main.worldSurface; num553 < Main.maxTilesY - 100; num553++)
				{
					if (Main.tile[num552, num553].liquid > 0 && (!Main.tile[num552, num553].lava() || remixWorldGen))
					{
						MakeWateryIceThing(num552, num553);
					}
				}
			}
			Main.tileSolid[226] = false;
			Main.tileSolid[162] = false;
		});
		AddGenerationPass("Wall Variety", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0083: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			//IL_00af: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0186: Unknown result type (might be due to invalid IL or missing references)
			//IL_012a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0195: Unknown result type (might be due to invalid IL or missing references)
			//IL_0139: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_0229: Unknown result type (might be due to invalid IL or missing references)
			//IL_0230: Unknown result type (might be due to invalid IL or missing references)
			//IL_0239: Unknown result type (might be due to invalid IL or missing references)
			//IL_0370: Unknown result type (might be due to invalid IL or missing references)
			//IL_0377: Unknown result type (might be due to invalid IL or missing references)
			//IL_037e: Unknown result type (might be due to invalid IL or missing references)
			progress.Message = Lang.gen[79].Value;
			double num548 = (double)(Main.maxTilesX * Main.maxTilesY) / 5040000.0;
			int num549 = (int)(300.0 * num548);
			int num550 = num549;
			ShapeData shapeData = new ShapeData();
			while (num549 > 0)
			{
				progress.Set(1.0 - (double)num549 / (double)num550);
				Point val2 = RandomWorldPoint((int)GenVars.worldSurface, 2, 190, 2);
				while (Vector2D.Distance(new Vector2D(val2.X, val2.Y), GenVars.shimmerPosition) < (double)shimmerSafetyDistance)
				{
					val2 = RandomWorldPoint((int)GenVars.worldSurface, 2, 190, 2);
				}
				Tile tile7 = Main.tile[val2.X, val2.Y];
				Tile tile8 = Main.tile[val2.X, val2.Y - 1];
				ushort num551 = 0;
				if (tile7.type == 60)
				{
					num551 = (ushort)(204 + genRand.Next(4));
				}
				else if (tile7.type == 1 && tile8.wall == 0)
				{
					num551 = ((!remixWorldGen) ? (((double)val2.Y < GenVars.rockLayer) ? ((ushort)(196 + genRand.Next(4))) : ((val2.Y >= GenVars.lavaLine) ? ((ushort)(208 + genRand.Next(4))) : ((ushort)(212 + genRand.Next(4))))) : (((double)val2.Y > GenVars.rockLayer) ? ((ushort)(196 + genRand.Next(4))) : ((val2.Y <= GenVars.lavaLine || genRand.Next(2) != 0) ? ((ushort)(212 + genRand.Next(4))) : ((ushort)(208 + genRand.Next(4))))));
				}
				if (tile7.active() && num551 != 0 && !tile8.active())
				{
					bool foundInvalidTile = false;
					bool flag34 = ((tile7.type != 60) ? WorldUtils.Gen(new Point(val2.X, val2.Y - 1), new ShapeFloodFill(1000), Actions.Chain(new Modifiers.IsNotSolid(), new Actions.Blank().Output(shapeData), new Actions.ContinueWrapper(Actions.Chain(new Modifiers.IsTouching(true, 60, 147, 161, 396, 397, 70, 191), new Modifiers.IsTouching(true, 147, 161, 396, 397, 70, 191), new Actions.Custom(delegate
					{
						foundInvalidTile = true;
						return true;
					}))))) : WorldUtils.Gen(new Point(val2.X, val2.Y - 1), new ShapeFloodFill(1000), Actions.Chain(new Modifiers.IsNotSolid(), new Actions.Blank().Output(shapeData), new Actions.ContinueWrapper(Actions.Chain(new Modifiers.IsTouching(true, 147, 161, 396, 397, 70, 191), new Actions.Custom(delegate
					{
						foundInvalidTile = true;
						return true;
					}))))));
					if (shapeData.Count > 50 && flag34 && !foundInvalidTile)
					{
						WorldUtils.Gen(new Point(val2.X, val2.Y), new ModShapes.OuterOutline(shapeData, useDiagonals: true, useInterior: true), Actions.Chain(new Modifiers.SkipWalls(87), new Actions.PlaceWall(num551)));
						num549--;
					}
					shapeData.Clear();
				}
			}
		});
		AddGenerationPass("Life Crystals", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (getGoodWorldGen)
			{
				Main.tileSolid[56] = false;
			}
			if (notTheBees)
			{
				NotTheBees();
			}
			progress.Message = Lang.gen[28].Value;
			double num545 = (double)(Main.maxTilesX * Main.maxTilesY) * 2E-05;
			if (tenthAnniversaryWorldGen)
			{
				num545 *= 1.2;
			}
			if (Main.starGame)
			{
				num545 *= Main.starGameMath(0.2);
			}
			for (int num546 = 0; num546 < (int)num545; num546++)
			{
				double value10 = (double)num546 / ((double)(Main.maxTilesX * Main.maxTilesY) * 2E-05);
				progress.Set(value10);
				bool flag33 = false;
				int num547 = 0;
				while (!flag33)
				{
					int j3 = genRand.Next((int)(Main.worldSurface * 2.0 + Main.rockLayer) / 3, Main.maxTilesY - 300);
					if (remixWorldGen)
					{
						j3 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 400);
					}
					if (AddLifeCrystal(genRand.Next(Main.offLimitBorderTiles, Main.maxTilesX - Main.offLimitBorderTiles), j3))
					{
						flag33 = true;
					}
					else
					{
						num547++;
						if (num547 >= 10000)
						{
							flag33 = true;
						}
					}
				}
			}
			Main.tileSolid[225] = false;
		});
		AddGenerationPass("Statues", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[29].Value;
			int num538 = 0;
			double num539 = (double)Main.maxTilesX / 4200.0;
			int num540 = (int)((double)(GenVars.statueList.Length * 2) * num539);
			if (noTrapsWorldGen)
			{
				num540 *= 15;
				if (tenthAnniversaryWorldGen || notTheBees)
				{
					num540 /= 5;
				}
			}
			if (Main.starGame)
			{
				num540 = (int)((double)num540 * Main.starGameMath(0.2));
			}
			for (int num541 = 0; num541 < num540; num541++)
			{
				if (num538 >= GenVars.statueList.Length)
				{
					num538 = 0;
				}
				int x22 = GenVars.statueList[num538].X;
				int y19 = GenVars.statueList[num538].Y;
				double value9 = num541 / num540;
				progress.Set(value9);
				bool flag32 = false;
				int num542 = 0;
				while (!flag32)
				{
					int num543 = genRand.Next(20, Main.maxTilesX - 20);
					int num544 = genRand.Next((int)(Main.worldSurface * 2.0 + Main.rockLayer) / 3, Main.maxTilesY - 300);
					if (remixWorldGen)
					{
						genRand.Next((int)Main.worldSurface, Main.maxTilesY - 400);
					}
					while (oceanDepths(num543, num544))
					{
						num543 = genRand.Next(20, Main.maxTilesX - 20);
						num544 = genRand.Next((int)(Main.worldSurface * 2.0 + Main.rockLayer) / 3, Main.maxTilesY - 300);
						if (remixWorldGen)
						{
							genRand.Next((int)Main.worldSurface, Main.maxTilesY - 400);
						}
					}
					while (!Main.tile[num543, num544].active())
					{
						num544++;
						if (num544 >= Main.maxTilesY)
						{
							break;
						}
					}
					if (num544 < Main.maxTilesY)
					{
						num544--;
						if (!Main.tile[num543, num544].shimmer())
						{
							PlaceTile(num543, num544, x22, mute: true, forced: true, -1, y19);
						}
						if (Main.tile[num543, num544].active() && Main.tile[num543, num544].type == x22)
						{
							flag32 = true;
							if (GenVars.StatuesWithTraps.Contains(num538))
							{
								PlaceStatueTrap(num543, num544);
							}
							num538++;
						}
						else
						{
							num542++;
							if (num542 >= 10000)
							{
								flag32 = true;
							}
						}
					}
				}
			}
		});
		AddGenerationPass("Buried Chests", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			//IL_031d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0322: Unknown result type (might be due to invalid IL or missing references)
			//IL_0324: Unknown result type (might be due to invalid IL or missing references)
			//IL_0346: Unknown result type (might be due to invalid IL or missing references)
			//IL_02eb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0388: Unknown result type (might be due to invalid IL or missing references)
			//IL_038a: Unknown result type (might be due to invalid IL or missing references)
			progress.Message = Lang.gen[30].Value;
			Main.tileSolid[226] = true;
			Main.tileSolid[162] = true;
			Main.tileSolid[225] = true;
			CaveHouseBiome caveHouseBiome = GenVars.configuration.CreateBiome<CaveHouseBiome>();
			int random6 = passConfig.Get<WorldGenRange>("CaveHouseCount").GetRandom(genRand);
			int random7 = passConfig.Get<WorldGenRange>("UnderworldChestCount").GetRandom(genRand);
			int num524 = passConfig.Get<WorldGenRange>("CaveChestCount").GetRandom(genRand);
			int random8 = passConfig.Get<WorldGenRange>("AdditionalDesertHouseCount").GetRandom(genRand);
			if (Main.starGame)
			{
				num524 = (int)((double)num524 * Main.starGameMath(0.2));
			}
			int num525 = random6 + random7 + num524 + random8;
			int num526 = 10000;
			for (int num527 = 0; num527 < num524; num527++)
			{
				if (num526 <= 0)
				{
					break;
				}
				progress.Set((double)num527 / (double)num525);
				int num528 = genRand.Next(20, Main.maxTilesX - 20);
				int num529 = genRand.Next((int)((GenVars.worldSurfaceHigh + 20.0 + Main.rockLayer) / 2.0), Main.maxTilesY - 230);
				if (remixWorldGen)
				{
					num529 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 400);
				}
				ushort wall = Main.tile[num528, num529].wall;
				if (Main.wallDungeon[wall] || wall == 87 || oceanDepths(num528, num529) || !AddBuriedChest(num528, num529, 0, notNearOtherChests: false, -1, trySlope: false, 0))
				{
					num526--;
					num527--;
				}
			}
			num526 = 10000;
			for (int num530 = 0; num530 < random7; num530++)
			{
				if (num526 <= 0)
				{
					break;
				}
				progress.Set((double)(num530 + num524) / (double)num525);
				int num531 = genRand.Next(20, Main.maxTilesX - 20);
				int num532 = genRand.Next(Main.UnderworldLayer, Main.maxTilesY - 50);
				if (Main.wallDungeon[Main.tile[num531, num532].wall] || !AddBuriedChest(num531, num532, 0, notNearOtherChests: false, -1, trySlope: false, 0))
				{
					num526--;
					num530--;
				}
			}
			num526 = 10000;
			for (int num533 = 0; num533 < random6; num533++)
			{
				if (num526 <= 0)
				{
					break;
				}
				progress.Set((double)(num533 + num524 + random7) / (double)num525);
				int num534 = genRand.Next(80, Main.maxTilesX - 80);
				int num535 = genRand.Next((int)(GenVars.worldSurfaceHigh + 20.0), Main.maxTilesY - 230);
				if (remixWorldGen)
				{
					num535 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 400);
				}
				if (oceanDepths(num534, num535) || !caveHouseBiome.Place(new Point(num534, num535), GenVars.structures))
				{
					num526--;
					num533--;
				}
			}
			num526 = 10000;
			Rectangle undergroundDesertHiveLocation = GenVars.UndergroundDesertHiveLocation;
			if ((double)undergroundDesertHiveLocation.Y < Main.worldSurface + 26.0)
			{
				int num536 = (int)Main.worldSurface + 26 - undergroundDesertHiveLocation.Y;
				undergroundDesertHiveLocation.Y += num536;
				undergroundDesertHiveLocation.Height -= num536;
			}
			for (int num537 = 0; num537 < random8; num537++)
			{
				if (num526 <= 0)
				{
					break;
				}
				progress.Set((double)(num537 + num524 + random7 + random6) / (double)num525);
				if (!caveHouseBiome.Place(RandomRectanglePoint(undergroundDesertHiveLocation), GenVars.structures))
				{
					num526--;
					num537--;
				}
			}
			Main.tileSolid[226] = false;
			Main.tileSolid[162] = false;
			Main.tileSolid[225] = false;
		});
		AddGenerationPass("Surface Chests", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[31].Value;
			for (int num514 = 0; num514 < (int)((double)Main.maxTilesX * 0.005); num514++)
			{
				double value8 = (double)num514 / ((double)Main.maxTilesX * 0.005);
				progress.Set(value8);
				bool flag30 = false;
				int num515 = 0;
				while (!flag30)
				{
					int num516 = genRand.Next(200, Main.maxTilesX - 200);
					int num517 = genRand.Next((int)GenVars.worldSurfaceLow, (int)Main.worldSurface);
					if (remixWorldGen)
					{
						num517 = genRand.Next(Main.maxTilesY - 400, Main.maxTilesY - 150);
					}
					else
					{
						while (oceanDepths(num516, num517))
						{
							num516 = genRand.Next(300, Main.maxTilesX - 300);
							num517 = genRand.Next((int)GenVars.worldSurfaceLow, (int)Main.worldSurface);
						}
					}
					bool flag31 = false;
					if (!Main.tile[num516, num517].active())
					{
						if (Main.tile[num516, num517].wall == 2 || Main.tile[num516, num517].wall == 59 || Main.tile[num516, num517].wall == 244 || remixWorldGen)
						{
							flag31 = true;
						}
					}
					else
					{
						int num518 = 50;
						int num519 = num516;
						int num520 = num517;
						int num521 = 1;
						for (int num522 = num519 - num518; num522 <= num519 + num518; num522 += 2)
						{
							for (int num523 = num520 - num518; num523 <= num520 + num518; num523 += 2)
							{
								if ((double)num523 < Main.worldSurface && !Main.tile[num522, num523].active() && Main.tile[num522, num523].wall == 244 && genRand.Next(num521) == 0)
								{
									num521++;
									flag31 = true;
									num516 = num522;
									num517 = num523;
								}
							}
						}
					}
					if (flag31 && AddBuriedChest(num516, num517, 0, notNearOtherChests: true, -1, trySlope: false, 0))
					{
						flag30 = true;
					}
					else
					{
						num515++;
						if (num515 >= 2000)
						{
							flag30 = true;
						}
					}
				}
			}
		});
		AddGenerationPass("Jungle Chests Placement", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[32].Value;
			for (int num509 = 0; num509 < GenVars.numJChests; num509++)
			{
				double value7 = (double)num509 / (double)GenVars.numJChests;
				progress.Set(value7);
				int nextJungleChestItem = GetNextJungleChestItem();
				if (!AddBuriedChest(GenVars.JChestX[num509] + genRand.Next(2), GenVars.JChestY[num509], nextJungleChestItem, notNearOtherChests: false, 10, trySlope: false, 0))
				{
					for (int num510 = GenVars.JChestX[num509] - 1; num510 <= GenVars.JChestX[num509] + 1; num510++)
					{
						for (int num511 = GenVars.JChestY[num509]; num511 <= GenVars.JChestY[num509] + 2; num511++)
						{
							KillTile(num510, num511);
						}
					}
					for (int num512 = GenVars.JChestX[num509] - 1; num512 <= GenVars.JChestX[num509] + 1; num512++)
					{
						for (int num513 = GenVars.JChestY[num509]; num513 <= GenVars.JChestY[num509] + 3; num513++)
						{
							if (num513 < Main.maxTilesY)
							{
								Main.tile[num512, num513].slope(0);
								Main.tile[num512, num513].halfBrick(halfBrick: false);
							}
						}
					}
					AddBuriedChest(GenVars.JChestX[num509], GenVars.JChestY[num509], nextJungleChestItem, notNearOtherChests: false, 10, trySlope: false, 0);
				}
			}
		});
		AddGenerationPass("Water Chests", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[33].Value;
			for (int num496 = 0; num496 < GenVars.numOceanCaveTreasure; num496++)
			{
				int contain = genRand.NextFromList(new short[5] { 863, 186, 277, 187, 4404 });
				bool flag28 = false;
				double num497 = 2.0;
				while (!flag28 && num497 < 50.0)
				{
					num497 += 0.1;
					int num498 = genRand.Next(GenVars.oceanCaveTreasure[num496].X - (int)num497, GenVars.oceanCaveTreasure[num496].X + (int)num497 + 1);
					int num499 = genRand.Next(GenVars.oceanCaveTreasure[num496].Y - (int)num497 / 2, GenVars.oceanCaveTreasure[num496].Y + (int)num497 / 2 + 1);
					num498 = ((num498 >= Main.maxTilesX) ? ((int)((double)num498 + num497 / 2.0)) : ((int)((double)num498 - num497 / 2.0)));
					if (Main.tile[num498, num499].liquid > 250 && (Main.tile[num498, num499].liquidType() == 0 || notTheBees || remixWorldGen))
					{
						flag28 = AddBuriedChest(num498, num499, contain, notNearOtherChests: false, 17, trySlope: true, 0);
					}
				}
			}
			int num500 = 0;
			double num501 = (double)Main.maxTilesX / 4200.0;
			for (int num502 = 0; (double)num502 < 9.0 * num501; num502++)
			{
				double value6 = (double)num502 / (9.0 * num501);
				progress.Set(value6);
				int num503 = 0;
				num500++;
				int maxValue8 = 10;
				if (tenthAnniversaryWorldGen)
				{
					maxValue8 = 7;
				}
				if (genRand.Next(maxValue8) == 0)
				{
					num503 = 863;
				}
				else
				{
					switch (num500)
					{
					case 1:
						num503 = 186;
						break;
					case 2:
						num503 = 4404;
						break;
					case 3:
						num503 = 277;
						break;
					default:
						num503 = 187;
						num500 = 0;
						break;
					}
				}
				bool flag29 = false;
				int num504 = 0;
				while (!flag29)
				{
					int num505 = genRand.Next(50, Main.maxTilesX - 50);
					int num506 = genRand.Next(1, Main.UnderworldLayer);
					while (Main.tile[num505, num506].liquid < 250 || (Main.tile[num505, num506].liquidType() != 0 && !notTheBees && !remixWorldGen))
					{
						num505 = genRand.Next(50, Main.maxTilesX - 50);
						num506 = genRand.Next(50, Main.UnderworldLayer);
					}
					flag29 = AddBuriedChest(num505, num506, num503, notNearOtherChests: false, 17, num505 < beachDistance || num505 > Main.maxTilesX - beachDistance, 0);
					num504++;
					if (num504 > 10000)
					{
						break;
					}
				}
				flag29 = false;
				num504 = 0;
				while (!flag29)
				{
					int num507 = genRand.Next(50, Main.maxTilesX - 50);
					int num508 = genRand.Next((int)Main.worldSurface, Main.UnderworldLayer);
					while (Main.tile[num507, num508].liquid < 250 || (Main.tile[num507, num508].liquidType() != 0 && !notTheBees))
					{
						num507 = genRand.Next(50, Main.maxTilesX - 50);
						num508 = genRand.Next((int)Main.worldSurface, Main.UnderworldLayer);
					}
					flag29 = AddBuriedChest(num507, num508, num503, notNearOtherChests: false, 17, num507 < beachDistance || num507 > Main.maxTilesX - beachDistance, 0);
					num504++;
					if (num504 > 10000)
					{
						break;
					}
				}
			}
		});
		AddGenerationPass("Spider Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[64].Value;
			maxTileCount = 3500;
			int num491 = Main.maxTilesX / 2;
			int num492 = (int)((double)Main.maxTilesX * 0.005);
			if (getGoodWorldGen)
			{
				num492 *= 3;
			}
			if (notTheBees)
			{
				Main.tileSolid[225] = true;
			}
			for (int num493 = 0; num493 < num492; num493++)
			{
				double value5 = (double)num493 / ((double)Main.maxTilesX * 0.005);
				progress.Set(value5);
				int num494 = 0;
				int x21 = genRand.Next(200, Main.maxTilesX - 200);
				int y18 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 230);
				if (remixWorldGen)
				{
					y18 = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
				}
				int num495 = countTiles(x21, y18, jungle: false, lavaOk: true);
				while ((num495 >= 3500 || num495 < 500) && num494 < num491)
				{
					num494++;
					x21 = genRand.Next(200, Main.maxTilesX - 200);
					y18 = genRand.Next((int)Main.rockLayer + 30, Main.maxTilesY - 230);
					if (remixWorldGen)
					{
						y18 = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
					}
					num495 = countTiles(x21, y18, jungle: false, lavaOk: true);
					if (shroomCount > 1)
					{
						num495 = 0;
					}
				}
				if (num494 < num491)
				{
					Spread.Spider(x21, y18);
				}
			}
			if (notTheBees)
			{
				Main.tileSolid[225] = false;
			}
			Main.tileSolid[162] = true;
		});
		AddGenerationPass("Gem Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!notTheBees)
			{
				progress.Message = Lang.gen[64].Value;
				maxTileCount = 300;
				double num487 = (double)Main.maxTilesX * 0.003;
				if (tenthAnniversaryWorldGen)
				{
					num487 *= 1.5;
				}
				if (Main.starGame)
				{
					num487 *= Main.starGameMath(0.2);
				}
				for (int num488 = 0; (double)num488 < num487; num488++)
				{
					double value4 = (double)num488 / num487;
					progress.Set(value4);
					int num489 = 0;
					int x20 = genRand.Next(200, Main.maxTilesX - 200);
					int y17 = genRand.Next((int)Main.rockLayer + 30, Main.maxTilesY - 230);
					if (remixWorldGen)
					{
						y17 = genRand.Next((int)Main.worldSurface + 30, (int)Main.rockLayer - 30);
					}
					int num490 = countTiles(x20, y17);
					while ((num490 >= 300 || num490 < 50 || lavaCount > 0 || iceCount > 0 || rockCount == 0) && num489 < 1000)
					{
						num489++;
						x20 = genRand.Next(200, Main.maxTilesX - 200);
						y17 = genRand.Next((int)Main.rockLayer + 30, Main.maxTilesY - 230);
						if (remixWorldGen)
						{
							y17 = genRand.Next((int)Main.worldSurface + 30, (int)Main.rockLayer - 30);
						}
						num490 = countTiles(x20, y17);
					}
					if (num489 < 1000)
					{
						gemCave(x20, y17);
					}
				}
			}
		});
		AddGenerationPass("Moss", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!notTheBees || remixWorldGen)
			{
				progress.Message = Lang.gen[61].Value;
				randMoss();
				int num457 = Main.maxTilesX / 2100;
				if (remixWorldGen)
				{
					num457 = (int)((double)num457 * 1.5);
				}
				else if (tenthAnniversaryWorldGen)
				{
					num457 *= 2;
				}
				int num458 = 0;
				int num459 = 0;
				while (num459 < num457)
				{
					int num460 = genRand.Next(100, Main.maxTilesX - 100);
					if (remixWorldGen)
					{
						num460 = genRand.Next((int)((double)Main.maxTilesX * 0.3), (int)((double)Main.maxTilesX * 0.7));
					}
					else if (tenthAnniversaryWorldGen)
					{
						if (genRand.Next(2) == 0)
						{
							randMoss(justNeon: true);
						}
					}
					else if (getGoodWorldGen)
					{
						while ((double)num460 > (double)Main.maxTilesX * 0.42 && (double)num460 < (double)Main.maxTilesX * 0.48)
						{
							num460 = genRand.Next(100, Main.maxTilesX - 100);
						}
					}
					else if (!drunkWorldGen)
					{
						while ((double)num460 > (double)Main.maxTilesX * 0.38 && (double)num460 < (double)Main.maxTilesX * 0.62)
						{
							num460 = genRand.Next(100, Main.maxTilesX - 100);
						}
					}
					int num461 = ((!remixWorldGen) ? genRand.Next((int)Main.rockLayer + 40, GenVars.lavaLine - 40) : genRand.Next((int)Main.worldSurface + 50, (int)Main.rockLayer - 50));
					bool flag27 = false;
					int num462 = 50;
					for (int num463 = num460 - num462; num463 <= num460 + num462; num463++)
					{
						for (int num464 = num461 - num462; num464 <= num461 + num462; num464++)
						{
							if (Main.tile[num463, num464].active())
							{
								int type5 = Main.tile[num463, num464].type;
								if (remixWorldGen)
								{
									if (type5 == 60 || type5 == 161 || type5 == 147 || Main.tileDungeon[type5] || type5 == 25 || type5 == 203)
									{
										flag27 = true;
										num463 = num460 + num462 + 1;
										break;
									}
								}
								else if (type5 == 70 || type5 == 60 || type5 == 367 || type5 == 368 || type5 == 161 || type5 == 147 || type5 == 396 || type5 == 397 || Main.tileDungeon[type5])
								{
									flag27 = true;
									num463 = num460 + num462 + 1;
									break;
								}
							}
						}
					}
					if (flag27)
					{
						num458++;
						if (num458 > Main.maxTilesX)
						{
							num459++;
						}
					}
					else
					{
						num458 = 0;
						num459++;
						int maxY = GenVars.lavaLine;
						if (remixWorldGen)
						{
							maxY = (int)Main.rockLayer + 50;
						}
						neonMossBiome(num460, num461, maxY);
					}
				}
				maxTileCount = 2500;
				for (int num465 = 0; num465 < (int)((double)Main.maxTilesX * 0.01); num465++)
				{
					double value3 = (double)num465 / ((double)Main.maxTilesX * 0.01);
					progress.Set(value3);
					int num466 = 0;
					int num467 = genRand.Next(200, Main.maxTilesX - 200);
					int num468 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, GenVars.waterLine);
					if (remixWorldGen)
					{
						num468 = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
					}
					if (!(Vector2D.Distance(new Vector2D(num467, num468), GenVars.shimmerPosition) < (double)shimmerSafetyDistance))
					{
						int num469 = countTiles(num467, num468);
						while ((num469 >= 2500 || num469 < 10 || lavaCount > 0 || iceCount > 0 || rockCount == 0 || shroomCount > 0) && num466 < 1000)
						{
							num466++;
							num467 = genRand.Next(200, Main.maxTilesX - 200);
							num468 = genRand.Next((int)Main.rockLayer + 30, Main.maxTilesY - 230);
							num469 = countTiles(num467, num468);
						}
						if (num466 < 1000)
						{
							setMoss(num467, num468);
							Spread.Moss(num467, num468);
						}
					}
				}
				for (int num470 = 0; num470 < Main.maxTilesX; num470++)
				{
					int num471 = genRand.Next(50, Main.maxTilesX - 50);
					int num472 = ((!remixWorldGen) ? genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, GenVars.lavaLine) : genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300));
					if (!(Vector2D.Distance(new Vector2D(num471, num472), GenVars.shimmerPosition) < (double)shimmerSafetyDistance) && Main.tile[num471, num472].type == 1)
					{
						setMoss(num471, num472);
						Main.tile[num471, num472].type = GenVars.mossTile;
					}
				}
				double num473 = (double)Main.maxTilesX * 0.05;
				while (num473 > 0.0)
				{
					int num474 = genRand.Next(50, Main.maxTilesX - 50);
					int num475 = ((!remixWorldGen) ? genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, GenVars.lavaLine) : genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300));
					if (!(Vector2D.Distance(new Vector2D(num474, num475), GenVars.shimmerPosition) < (double)shimmerSafetyDistance) && Main.tile[num474, num475].type == 1 && (!Main.tile[num474 - 1, num475].active() || !Main.tile[num474 + 1, num475].active() || !Main.tile[num474, num475 - 1].active() || !Main.tile[num474, num475 + 1].active()))
					{
						setMoss(num474, num475);
						Main.tile[num474, num475].type = GenVars.mossTile;
						num473 -= 1.0;
					}
				}
				num473 = (double)Main.maxTilesX * 0.065;
				if (remixWorldGen)
				{
					num473 *= 2.0;
				}
				while (num473 > 0.0)
				{
					int num476 = genRand.Next(50, Main.maxTilesX - 50);
					int num477 = ((!remixWorldGen) ? genRand.Next(GenVars.waterLine, Main.UnderworldLayer) : genRand.Next(GenVars.lavaLine, (int)Main.rockLayer + 50));
					if (Main.tile[num476, num477].type == 1 && (!Main.tile[num476 - 1, num477].active() || !Main.tile[num476 + 1, num477].active() || !Main.tile[num476, num477 - 1].active() || !Main.tile[num476, num477 + 1].active()))
					{
						int num478 = 25;
						int num479 = 0;
						for (int num480 = num476 - num478; num480 < num476 + num478; num480++)
						{
							for (int num481 = num477 - num478; num481 < num477 + num478; num481++)
							{
								if (Main.tile[num480, num481].liquid > 0 && Main.tile[num480, num481].lava())
								{
									num479++;
								}
							}
						}
						if (num479 > 20)
						{
							Main.tile[num476, num477].type = 381;
							num473 -= 1.0;
						}
						else
						{
							num473 -= 0.002;
						}
					}
					num473 -= 0.001;
				}
				for (int num482 = 0; num482 < Main.maxTilesX; num482++)
				{
					for (int num483 = 0; num483 < Main.maxTilesY; num483++)
					{
						if (Main.tile[num482, num483].active() && Main.tileMoss[Main.tile[num482, num483].type])
						{
							for (int num484 = 0; num484 < 4; num484++)
							{
								int num485 = num482;
								int num486 = num483;
								if (num484 == 0)
								{
									num485--;
								}
								if (num484 == 1)
								{
									num485++;
								}
								if (num484 == 2)
								{
									num486--;
								}
								if (num484 == 3)
								{
									num486++;
								}
								try
								{
									grassSpread = 0;
									SpreadGrass(num485, num486, 1, Main.tile[num482, num483].type);
								}
								catch
								{
									grassSpread = 0;
									SpreadGrass(num485, num486, 1, Main.tile[num482, num483].type, repeat: false);
								}
							}
						}
					}
				}
			}
		});
		AddGenerationPass("Temple", delegate
		{
			Main.tileSolid[162] = false;
			Main.tileSolid[226] = true;
			templePart2();
			Main.tileSolid[232] = false;
		});
		AddGenerationPass("Cave Walls", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[63].Value;
			maxTileCount = 1500;
			for (int num443 = 0; num443 < (int)((double)Main.maxTilesX * 0.04); num443++)
			{
				double num444 = (double)num443 / ((double)Main.maxTilesX * 0.04);
				progress.Set(num444 * 0.66);
				int num445 = 0;
				int x17 = genRand.Next(200, Main.maxTilesX - 200);
				int y14 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 220);
				if (remixWorldGen)
				{
					y14 = genRand.Next((int)Main.worldSurface + 25, (int)Main.rockLayer);
				}
				int num446 = countTiles(x17, y14, jungle: false, lavaOk: true);
				while ((num446 >= maxTileCount || num446 < 10) && num445 < 500)
				{
					num445++;
					x17 = genRand.Next(200, Main.maxTilesX - 200);
					y14 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 220);
					if (remixWorldGen)
					{
						y14 = genRand.Next((int)Main.worldSurface + 25, (int)Main.rockLayer);
					}
					num446 = countTiles(x17, y14, jungle: false, lavaOk: true);
				}
				if (num445 < 500)
				{
					int num447 = genRand.Next(2);
					if ((double)shroomCount > (double)rockCount * 0.75)
					{
						num447 = 80;
					}
					else if (iceCount > 0)
					{
						switch (num447)
						{
						case 0:
							num447 = 40;
							break;
						case 1:
							num447 = 71;
							break;
						}
					}
					else if (lavaCount > 0)
					{
						num447 = 79;
					}
					else
					{
						num447 = genRand.Next(4);
						switch (num447)
						{
						case 0:
							num447 = 59;
							break;
						case 1:
							num447 = 61;
							break;
						case 2:
							num447 = 170;
							break;
						case 3:
							num447 = 171;
							break;
						}
					}
					Spread.Wall(x17, y14, num447);
				}
			}
			if (remixWorldGen)
			{
				maxTileCount = 1500;
				for (int num448 = 0; num448 < (int)((double)Main.maxTilesX * 0.04); num448++)
				{
					double num449 = (double)num448 / ((double)Main.maxTilesX * 0.04);
					progress.Set(num449 * 0.66);
					int num450 = 0;
					int x18 = genRand.Next(200, Main.maxTilesX - 200);
					int y15 = genRand.Next((int)Main.rockLayer, Main.maxTilesY - 350);
					int num451 = countTiles(x18, y15, jungle: false, lavaOk: true);
					while ((num451 >= maxTileCount || num451 < 10) && num450 < 500)
					{
						num450++;
						x18 = genRand.Next(200, Main.maxTilesX - 200);
						y15 = genRand.Next((int)Main.rockLayer, Main.maxTilesY - 350);
						num451 = countTiles(x18, y15, jungle: false, lavaOk: true);
					}
					if (num450 < 500 && iceCount == 0 && lavaCount == 0 && sandCount == 0)
					{
						int wallType2 = ((genRand.Next(2) != 0) ? 63 : 2);
						Spread.Wall(x18, y15, wallType2);
					}
				}
			}
			maxTileCount = 1500;
			double num452 = (double)Main.maxTilesX * 0.02;
			for (int num453 = 0; (double)num453 < num452; num453++)
			{
				double num454 = (double)num453 / ((double)Main.maxTilesX * 0.02);
				progress.Set(num454 * 0.33 + 0.66);
				int num455 = 0;
				int x19 = genRand.Next(200, Main.maxTilesX - 200);
				int y16 = genRand.Next((int)Main.worldSurface, GenVars.lavaLine);
				int num456 = 0;
				if (Main.tile[x19, y16].wall == 64)
				{
					num456 = countTiles(x19, y16, jungle: true);
				}
				while ((num456 >= maxTileCount || num456 < 10) && num455 < 1000)
				{
					num455++;
					x19 = genRand.Next(200, Main.maxTilesX - 200);
					y16 = genRand.Next((int)Main.worldSurface, GenVars.lavaLine);
					if (!Main.wallHouse[Main.tile[x19, y16].wall] && Main.tile[x19, y16].wall != 244)
					{
						num456 = ((Main.tile[x19, y16].wall == 64) ? countTiles(x19, y16, jungle: true) : 0);
					}
				}
				if (num455 < 1000)
				{
					Spread.Wall2(x19, y16, 15);
				}
			}
		});
		AddGenerationPass("Jungle Trees", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[83].Value;
			for (int num441 = 0; num441 < Main.maxTilesX; num441++)
			{
				progress.Set((double)num441 / (double)Main.maxTilesX);
				for (int num442 = (int)Main.worldSurface - 1; num442 < Main.maxTilesY - 350; num442++)
				{
					if (genRand.Next(10) == 0 || drunkWorldGen)
					{
						GrowUndergroundTree(num441, num442);
					}
				}
			}
		});
		AddGenerationPass("Floating Island Houses", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Set(1.0);
			for (int num440 = 0; num440 < GenVars.numIslandHouses; num440++)
			{
				if (!GenVars.skyLake[num440])
				{
					IslandHouse(GenVars.floatingIslandHouseX[num440], GenVars.floatingIslandHouseY[num440], GenVars.floatingIslandStyle[num440]);
				}
			}
		});
		AddGenerationPass("Quick Cleanup", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Set(1.0);
			if (notTheBees)
			{
				NotTheBees();
			}
			Main.tileSolid[137] = false;
			Main.tileSolid[130] = false;
			for (int num433 = 20; num433 < Main.maxTilesX - 20; num433++)
			{
				for (int num434 = 20; num434 < Main.maxTilesY - 20; num434++)
				{
					if ((double)num434 < Main.worldSurface && oceanDepths(num433, num434) && Main.tile[num433, num434].type == 53 && Main.tile[num433, num434].active())
					{
						if (Main.tile[num433, num434].bottomSlope())
						{
							Main.tile[num433, num434].slope(0);
						}
						for (int num435 = num434 + 1; num435 < num434 + genRand.Next(4, 7) && (!Main.tile[num433, num435].active() || (Main.tile[num433, num435].type != 397 && Main.tile[num433, num435].type != 53)) && (!Main.tile[num433, num435 + 1].active() || (Main.tile[num433, num435 + 1].type != 397 && Main.tile[num433, num435 + 1].type != 53 && Main.tile[num433, num435 + 1].type != 495)) && (!Main.tile[num433, num435 + 2].active() || (Main.tile[num433, num435 + 2].type != 397 && Main.tile[num433, num435 + 2].type != 53 && Main.tile[num433, num435 + 2].type != 495)); num435++)
						{
							Main.tile[num433, num435].type = 0;
							Main.tile[num433, num435].active(active: true);
							Main.tile[num433, num435].halfBrick(halfBrick: false);
							Main.tile[num433, num435].slope(0);
						}
					}
					if (Main.tile[num433, num434].wall == 187 || Main.tile[num433, num434].wall == 216)
					{
						if (Main.tile[num433, num434].type == 59 || Main.tile[num433, num434].type == 123 || Main.tile[num433, num434].type == 224)
						{
							Main.tile[num433, num434].type = 397;
						}
						if (Main.tile[num433, num434].type == 368 || Main.tile[num433, num434].type == 367)
						{
							Main.tile[num433, num434].type = 397;
						}
						if ((double)num434 <= Main.rockLayer)
						{
							Main.tile[num433, num434].liquid = 0;
						}
						else if (Main.tile[num433, num434].liquid > 0)
						{
							Main.tile[num433, num434].liquid = byte.MaxValue;
							Main.tile[num433, num434].lava(lava: true);
						}
					}
					if ((double)num434 < Main.worldSurface && Main.tile[num433, num434].active() && Main.tile[num433, num434].type == 53 && Main.tile[num433, num434 + 1].wall == 0 && !SolidTile(num433, num434 + 1))
					{
						ushort num436 = 0;
						int num437 = 3;
						for (int num438 = num433 - num437; num438 <= num433 + num437; num438++)
						{
							for (int num439 = num434 - num437; num439 <= num434 + num437; num439++)
							{
								if (Main.tile[num438, num439].wall > 0)
								{
									num436 = Main.tile[num438, num439].wall;
									break;
								}
							}
						}
						if (num436 > 0)
						{
							Main.tile[num433, num434 + 1].wall = num436;
							if (Main.tile[num433, num434].wall == 0)
							{
								Main.tile[num433, num434].wall = num436;
							}
						}
					}
					if (Main.tile[num433, num434].type != 19 && TileID.Sets.CanBeClearedDuringGeneration[Main.tile[num433, num434].type])
					{
						if (Main.tile[num433, num434].topSlope() || Main.tile[num433, num434].halfBrick())
						{
							if (Main.tile[num433, num434].type != 225 || !Main.tile[num433, num434].halfBrick())
							{
								if (!SolidTile(num433, num434 + 1))
								{
									Main.tile[num433, num434].active(active: false);
								}
								if (Main.tile[num433 + 1, num434].type == 137 || Main.tile[num433 - 1, num434].type == 137)
								{
									Main.tile[num433, num434].active(active: false);
								}
							}
						}
						else if (Main.tile[num433, num434].bottomSlope())
						{
							if (!SolidTile(num433, num434 - 1))
							{
								Main.tile[num433, num434].active(active: false);
							}
							if (Main.tile[num433 + 1, num434].type == 137 || Main.tile[num433 - 1, num434].type == 137)
							{
								Main.tile[num433, num434].active(active: false);
							}
						}
					}
				}
			}
		});
		AddGenerationPass("Pots", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			Main.tileSolid[137] = true;
			Main.tileSolid[130] = true;
			progress.Message = Lang.gen[35].Value;
			if (noTrapsWorldGen)
			{
				Main.tileSolid[138] = true;
				int num421 = (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0004);
				if (remixWorldGen)
				{
					num421 /= 2;
				}
				for (int num422 = 0; num422 < num421; num422++)
				{
					int num423 = genRand.Next(50, Main.maxTilesX - 50);
					int num424;
					for (num424 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 250); !Main.tile[num423, num424].active() && num424 < Main.maxTilesY - 250; num424++)
					{
					}
					num424--;
					if (!Main.tile[num423, num424].shimmer())
					{
						PlaceTile(num423, num424, 138, mute: true);
						PlaceTile(num423 + 2, num424, 138, mute: true);
						PlaceTile(num423 + 1, num424 - 2, 138, mute: true);
					}
				}
				Main.tileSolid[138] = false;
			}
			double num425 = (double)(Main.maxTilesX * Main.maxTilesY) * 0.0008;
			if (Main.starGame)
			{
				num425 *= Main.starGameMath(0.2);
			}
			for (int num426 = 0; (double)num426 < num425; num426++)
			{
				double num427 = (double)num426 / num425;
				progress.Set(num427);
				bool flag25 = false;
				int num428 = 0;
				while (!flag25)
				{
					int num429 = genRand.Next((int)GenVars.worldSurfaceHigh, Main.maxTilesY - 10);
					if (num427 > 0.93)
					{
						num429 = Main.maxTilesY - 150;
					}
					else if (num427 > 0.75)
					{
						num429 = (int)GenVars.worldSurfaceLow;
					}
					int x16 = genRand.Next(20, Main.maxTilesX - 20);
					bool flag26 = false;
					for (int num430 = num429; num430 < Main.maxTilesY - 20; num430++)
					{
						if (!flag26)
						{
							if (Main.tile[x16, num430].active() && Main.tileSolid[Main.tile[x16, num430].type] && !Main.tile[x16, num430 - 1].lava() && !Main.tile[x16, num430 - 1].shimmer())
							{
								flag26 = true;
							}
						}
						else if (!((double)num430 < Main.worldSurface) || Main.tile[x16, num430].wall != 0)
						{
							int style = genRand.Next(0, 4);
							int num431 = 0;
							int num432 = 0;
							if (num430 < Main.maxTilesY - 5)
							{
								num431 = Main.tile[x16, num430 + 1].type;
								num432 = Main.tile[x16, num430].wall;
							}
							if (num431 == 147 || num431 == 161 || num431 == 162)
							{
								style = genRand.Next(4, 7);
							}
							if (num431 == 60)
							{
								style = genRand.Next(7, 10);
							}
							if (Main.wallDungeon[Main.tile[x16, num430].wall])
							{
								style = genRand.Next(10, 13);
							}
							if (num431 == 41 || num431 == 43 || num431 == 44 || num431 == 481 || num431 == 482 || num431 == 483)
							{
								style = genRand.Next(10, 13);
							}
							if (num431 == 22 || num431 == 23 || num431 == 25)
							{
								style = genRand.Next(16, 19);
							}
							if (num431 == 199 || num431 == 203 || num431 == 204 || num431 == 200)
							{
								style = genRand.Next(22, 25);
							}
							if (num431 == 367)
							{
								style = genRand.Next(31, 34);
							}
							if (num431 == 226)
							{
								style = genRand.Next(28, 31);
							}
							if (num432 == 187 || num432 == 216)
							{
								style = genRand.Next(34, 37);
							}
							if (num430 > Main.UnderworldLayer)
							{
								style = genRand.Next(13, 16);
							}
							if (!oceanDepths(x16, num430) && !Main.tile[x16, num430].shimmer() && PlacePot(x16, num430, 28, style))
							{
								flag25 = true;
								break;
							}
							num428++;
							if (num428 >= 10000)
							{
								flag25 = true;
								break;
							}
						}
					}
				}
			}
		});
		AddGenerationPass("Hellforge", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[36].Value;
			for (int num417 = 0; num417 < Main.maxTilesX / 200; num417++)
			{
				double value2 = (double)num417 / (double)(Main.maxTilesX / 200);
				progress.Set(value2);
				bool flag24 = false;
				int num418 = 0;
				while (!flag24)
				{
					int num419 = genRand.Next(1, Main.maxTilesX);
					int num420 = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 30);
					try
					{
						if (Main.tile[num419, num420].wall == 13 || Main.tile[num419, num420].wall == 14)
						{
							for (; !Main.tile[num419, num420].active() && num420 < Main.maxTilesY - 20; num420++)
							{
							}
							num420--;
							PlaceTile(num419, num420, 77);
							if (Main.tile[num419, num420].type == 77)
							{
								flag24 = true;
							}
							else
							{
								num418++;
								if (num418 >= 10000)
								{
									flag24 = true;
								}
							}
						}
					}
					catch
					{
						num418++;
						if (num418 >= 10000)
						{
							flag24 = true;
						}
					}
				}
			}
		});
		AddGenerationPass("Spreading Grass", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!notTheBees || remixWorldGen)
			{
				progress.Message = Lang.gen[37].Value;
				for (int num395 = 50; num395 < Main.maxTilesX - 50; num395++)
				{
					for (int num396 = 50; (double)num396 <= Main.worldSurface; num396++)
					{
						if (Main.tile[num395, num396].active())
						{
							int type4 = Main.tile[num395, num396].type;
							if (Main.tile[num395, num396].active() && type4 == 60)
							{
								for (int num397 = num395 - 1; num397 <= num395 + 1; num397++)
								{
									for (int num398 = num396 - 1; num398 <= num396 + 1; num398++)
									{
										if (Main.tile[num397, num398].active() && Main.tile[num397, num398].type == 0)
										{
											if (!Main.tile[num397, num398 - 1].active())
											{
												Main.tile[num397, num398].type = 60;
											}
											else
											{
												Main.tile[num397, num398].type = 59;
											}
										}
									}
								}
							}
							else if (type4 == 1 || type4 == 40 || TileID.Sets.Ore[type4])
							{
								int num399 = 3;
								bool flag22 = false;
								ushort num400 = 0;
								for (int num401 = num395 - num399; num401 <= num395 + num399; num401++)
								{
									for (int num402 = num396 - num399; num402 <= num396 + num399; num402++)
									{
										if (Main.tile[num401, num402].active())
										{
											if (Main.tile[num401, num402].type == 53 || num400 == 53)
											{
												num400 = 53;
											}
											else if (Main.tile[num401, num402].type == 59 || Main.tile[num401, num402].type == 60 || Main.tile[num401, num402].type == 147 || Main.tile[num401, num402].type == 161 || Main.tile[num401, num402].type == 199 || Main.tile[num401, num402].type == 23)
											{
												num400 = Main.tile[num401, num402].type;
											}
										}
										else if (num402 < num396 && Main.tile[num401, num402].wall == 0)
										{
											flag22 = true;
										}
									}
								}
								if (flag22)
								{
									switch (num400)
									{
									case 23:
									case 199:
										if (Main.tile[num395, num396 - 1].active())
										{
											num400 = 0;
										}
										break;
									case 59:
									case 60:
										if (num395 >= GenVars.jungleMinX && num395 <= GenVars.jungleMaxX)
										{
											num400 = (ushort)(Main.tile[num395, num396 - 1].active() ? 59u : 60u);
										}
										break;
									}
									Main.tile[num395, num396].type = num400;
								}
							}
						}
					}
				}
				for (int num403 = 10; num403 < Main.maxTilesX - 10; num403++)
				{
					bool flag23 = true;
					for (int num404 = 0; (double)num404 < Main.worldSurface - 1.0; num404++)
					{
						if (Main.tile[num403, num404].active())
						{
							if (flag23 && Main.tile[num403, num404].type == 0)
							{
								try
								{
									grassSpread = 0;
									SpreadGrass(num403, num404);
								}
								catch
								{
									grassSpread = 0;
									SpreadGrass(num403, num404, 0, 2, repeat: false);
								}
							}
							if ((double)num404 > GenVars.worldSurfaceHigh)
							{
								break;
							}
							flag23 = false;
						}
						else if (Main.tile[num403, num404].wall == 0)
						{
							flag23 = true;
						}
					}
				}
				if (remixWorldGen)
				{
					for (int num405 = 5; num405 < Main.maxTilesX - 5; num405++)
					{
						for (int num406 = (int)GenVars.rockLayerLow + genRand.Next(-1, 2); num406 < Main.maxTilesY - 200; num406++)
						{
							if (Main.tile[num405, num406].type == 0 && Main.tile[num405, num406].active() && (!Main.tile[num405 - 1, num406 - 1].active() || !Main.tile[num405, num406 - 1].active() || !Main.tile[num405 + 1, num406 - 1].active() || !Main.tile[num405 - 1, num406].active() || !Main.tile[num405 + 1, num406].active() || !Main.tile[num405 - 1, num406 + 1].active() || !Main.tile[num405, num406 + 1].active() || !Main.tile[num405 + 1, num406 + 1].active()))
							{
								Main.tile[num405, num406].type = 2;
							}
						}
					}
					for (int num407 = 5; num407 < Main.maxTilesX - 5; num407++)
					{
						for (int num408 = (int)GenVars.rockLayerLow + genRand.Next(-1, 2); num408 < Main.maxTilesY - 200; num408++)
						{
							if (Main.tile[num407, num408].type == 2 && !Main.tile[num407, num408 - 1].active() && genRand.Next(20) == 0)
							{
								PlaceTile(num407, num408 - 1, 27, mute: true);
							}
						}
					}
					int conversionType = 1;
					if (crimson)
					{
						conversionType = 4;
					}
					int num409 = Main.maxTilesX / 7;
					for (int num410 = 10; num410 < Main.maxTilesX - 10; num410++)
					{
						for (int num411 = 10; num411 < Main.maxTilesY - 10; num411++)
						{
							if ((double)num411 < Main.worldSurface + (double)genRand.Next(3) || num410 < num409 + genRand.Next(3) || num410 >= Main.maxTilesX - num409 - genRand.Next(3))
							{
								if (drunkWorldGen)
								{
									if (GenVars.crimsonLeft)
									{
										if (num410 < Main.maxTilesX / 2 + genRand.Next(-2, 3))
										{
											Convert(num410, num411, 4, 1);
										}
										else
										{
											Convert(num410, num411, 1, 1);
										}
									}
									else if (num410 < Main.maxTilesX / 2 + genRand.Next(-2, 3))
									{
										Convert(num410, num411, 1, 1);
									}
									else
									{
										Convert(num410, num411, 4, 1);
									}
								}
								else
								{
									Convert(num410, num411, conversionType, 1);
								}
								Main.tile[num410, num411].color(0);
								Main.tile[num410, num411].wallColor(0);
							}
						}
					}
					if (remixWorldGen)
					{
						Main.tileSolid[225] = true;
						int num412 = (int)((double)Main.maxTilesX * 0.31);
						int num413 = (int)((double)Main.maxTilesX * 0.69);
						_ = Main.maxTilesY;
						int num414 = Main.maxTilesY - 135;
						_ = Main.maxTilesY;
						Liquid.QuickWater(-2);
						for (int num415 = num412; num415 < num413 + 15; num415++)
						{
							for (int num416 = Main.maxTilesY - 200; num416 < num414; num416++)
							{
								Main.tile[num415, num416].liquid = 0;
							}
						}
						Main.tileSolid[225] = false;
						Main.tileSolid[484] = false;
					}
				}
			}
		});
		AddGenerationPass("Surface Ore and Stone", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Set(1.0);
			int num386 = genRand.Next(Main.maxTilesX * 5 / 4200, Main.maxTilesX * 10 / 4200);
			for (int num387 = 0; num387 < num386; num387++)
			{
				int num388 = Main.maxTilesX / 420;
				while (num388 > 0)
				{
					num388--;
					int num389 = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
					while ((double)num389 >= (double)Main.maxTilesX * 0.48 && (double)num389 <= (double)Main.maxTilesX * 0.52)
					{
						num389 = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
					}
					int y12 = genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurface);
					bool flag20 = false;
					for (int num390 = 0; num390 < GenVars.numOrePatch; num390++)
					{
						if (Math.Abs(num389 - GenVars.orePatchX[num390]) < 200)
						{
							flag20 = true;
						}
					}
					if (!flag20 && OrePatch(num389, y12))
					{
						if (GenVars.numOrePatch < GenVars.maxOrePatch - 1)
						{
							GenVars.orePatchX[GenVars.numOrePatch] = num389;
							GenVars.numOrePatch++;
						}
						break;
					}
				}
			}
			num386 = genRand.Next(1, Main.maxTilesX * 7 / 4200);
			for (int num391 = 0; num391 < num386; num391++)
			{
				int num392 = Main.maxTilesX / 420;
				while (num392 > 0)
				{
					num392--;
					int num393 = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
					while ((double)num393 >= (double)Main.maxTilesX * 0.47 && (double)num393 <= (double)Main.maxTilesX * 0.53)
					{
						num393 = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
					}
					int y13 = genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurface);
					bool flag21 = false;
					for (int num394 = 0; num394 < GenVars.numOrePatch; num394++)
					{
						if (Math.Abs(num393 - GenVars.orePatchX[num394]) < 100)
						{
							flag21 = true;
						}
					}
					if (!flag21 && StonePatch(num393, y13))
					{
						break;
					}
				}
			}
		});
		AddGenerationPass("Place Fallen Log", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[85].Value;
			int num372 = Main.maxTilesX / 2100;
			num372 = ((!remixWorldGen) ? (num372 + genRand.Next(-1, 2)) : (num372 + genRand.Next(0, 2)));
			for (int num373 = 0; num373 < num372; num373++)
			{
				progress.Set((double)num373 / (double)num372);
				int num374 = beachDistance + 20;
				int num375 = 50000;
				int num376 = 5000;
				while (num375 > 0)
				{
					num375--;
					int num377 = genRand.Next(num374, Main.maxTilesX - num374);
					int num378 = genRand.Next(10, (int)Main.worldSurface);
					if (remixWorldGen)
					{
						num378 = genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY - 350);
					}
					bool flag18 = false;
					if (num375 < num376)
					{
						flag18 = true;
					}
					if (num375 > num376 / 2)
					{
						while ((double)num377 > (double)Main.maxTilesX * 0.4 && (double)num377 < (double)Main.maxTilesX * 0.6)
						{
							num377 = genRand.Next(num374, Main.maxTilesX - num374);
						}
					}
					if (!Main.tile[num377, num378].active() && Main.tile[num377, num378].wall == 0)
					{
						bool flag19 = true;
						if (remixWorldGen)
						{
							for (; !Main.tile[num377, num378].active() && Main.tile[num377, num378].wall == 0 && num378 <= Main.maxTilesY - 350; num378++)
							{
							}
						}
						else
						{
							for (; !Main.tile[num377, num378].active() && Main.tile[num377, num378].wall == 0 && (double)num378 <= Main.worldSurface; num378++)
							{
							}
						}
						if ((double)num378 > Main.worldSurface - 10.0 && !remixWorldGen)
						{
							flag19 = false;
						}
						else if (!flag18)
						{
							int num379 = 50;
							for (int num380 = num377 - num379; num380 < num377 + num379; num380++)
							{
								if (num380 > 10 && num380 < Main.maxTilesX - 10)
								{
									for (int num381 = num378 - num379; num381 < num378 + num379; num381++)
									{
										if (num381 > 10 && num381 < Main.maxTilesY - 10)
										{
											int type3 = Main.tile[num380, num381].type;
											switch (type3)
											{
											case 189:
												flag19 = false;
												break;
											case 53:
												flag19 = false;
												break;
											default:
												if (Main.tileDungeon[type3])
												{
													flag19 = false;
												}
												else if (TileID.Sets.Crimson[type3])
												{
													flag19 = false;
												}
												else if (TileID.Sets.Corrupt[type3])
												{
													flag19 = false;
												}
												break;
											}
										}
									}
								}
							}
							if (flag19)
							{
								int num382 = 10;
								int num383 = 10;
								for (int num384 = num377 - num382; num384 < num377 + num382; num384++)
								{
									for (int num385 = num378 - num383; num385 < num378 - 1; num385++)
									{
										if (Main.tile[num384, num385].active() && Main.tileSolid[Main.tile[num384, num385].type])
										{
											flag19 = false;
										}
										if (Main.tile[num384, num385].wall != 0)
										{
											flag19 = false;
										}
									}
								}
							}
						}
						if (flag19 && (Main.tile[num377, num378 - 1].liquid == 0 || num375 < num376 / 5) && (Main.tile[num377, num378].type == 2 || (notTheBees && Main.tile[num377, num378].type == 60)) && (Main.tile[num377 - 1, num378].type == 2 || (notTheBees && Main.tile[num377 - 1, num378].type == 60)) && (Main.tile[num377 + 1, num378].type == 2 || (notTheBees && Main.tile[num377 + 1, num378].type == 60)))
						{
							num378--;
							PlaceTile(num377, num378, 488);
							if (Main.tile[num377, num378].active() && Main.tile[num377, num378].type == 488)
							{
								if (genRand.Next(2) == 0)
								{
									GenVars.logX = num377;
									GenVars.logY = num378;
								}
								num375 = -1;
							}
						}
					}
				}
			}
		});
		AddGenerationPass("Traps", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (!notTheBees || noTrapsWorldGen || remixWorldGen)
			{
				placingTraps = true;
				progress.Message = Lang.gen[34].Value;
				if (noTrapsWorldGen)
				{
					progress.Message = Lang.gen[91].Value;
				}
				double num358 = (double)Main.maxTilesX * 0.05;
				if (noTrapsWorldGen)
				{
					num358 = ((!tenthAnniversaryWorldGen && !notTheBees) ? (num358 * 100.0) : (num358 * 5.0));
				}
				else if (getGoodWorldGen)
				{
					num358 *= 1.5;
				}
				if (Main.starGame)
				{
					num358 *= Main.starGameMath(0.2);
				}
				for (int num359 = 0; (double)num359 < num358; num359++)
				{
					progress.Set((double)num359 / num358 / 2.0);
					for (int num360 = 0; num360 < 1150; num360++)
					{
						if (noTrapsWorldGen)
						{
							int num361 = genRand.Next(50, Main.maxTilesX - 50);
							int num362 = genRand.Next(50, Main.maxTilesY - 50);
							if (remixWorldGen)
							{
								num362 = genRand.Next(50, Main.maxTilesY - 210);
							}
							if (((double)num362 > Main.worldSurface || Main.tile[num361, num362].wall > 0) && placeTrap(num361, num362))
							{
								break;
							}
						}
						else
						{
							int num363 = genRand.Next(200, Main.maxTilesX - 200);
							int num364 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 210);
							while (oceanDepths(num363, num364))
							{
								num363 = genRand.Next(200, Main.maxTilesX - 200);
								num364 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 210);
							}
							if (Main.tile[num363, num364].wall == 0 && placeTrap(num363, num364))
							{
								break;
							}
						}
					}
				}
				if (noTrapsWorldGen)
				{
					num358 = Main.maxTilesX * 3;
					if (Main.remixWorld)
					{
						num358 = Main.maxTilesX / 3;
					}
					if (Main.starGame)
					{
						num358 *= Main.starGameMath(0.2);
					}
					for (int num365 = 0; (double)num365 < num358; num365++)
					{
						if (Main.remixWorld)
						{
							placeTNTBarrel(genRand.Next(50, Main.maxTilesX - 50), genRand.Next((int)Main.worldSurface, (int)((double)(Main.maxTilesY - 350) + Main.rockLayer) / 2));
						}
						else
						{
							placeTNTBarrel(genRand.Next(50, Main.maxTilesX - 50), genRand.Next((int)Main.rockLayer, Main.maxTilesY - 200));
						}
					}
				}
				num358 = (double)Main.maxTilesX * 0.003;
				if (noTrapsWorldGen)
				{
					num358 *= 5.0;
				}
				else if (getGoodWorldGen)
				{
					num358 *= 1.5;
				}
				for (int num366 = 0; (double)num366 < num358; num366++)
				{
					progress.Set((double)num366 / num358 / 2.0 + 0.5);
					for (int num367 = 0; num367 < 20000; num367++)
					{
						int num368 = genRand.Next((int)((double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.85));
						int num369 = genRand.Next((int)Main.worldSurface + 20, Main.maxTilesY - 210);
						if (Main.tile[num368, num369].wall == 187 && PlaceSandTrap(num368, num369))
						{
							break;
						}
					}
				}
				if (drunkWorldGen && !noTrapsWorldGen && !notTheBees)
				{
					for (int num370 = 0; num370 < 8; num370++)
					{
						progress.Message = Lang.gen[34].Value;
						num358 = 100.0;
						for (int num371 = 0; (double)num371 < num358; num371++)
						{
							progress.Set((double)num371 / num358);
							Thread.Sleep(10);
						}
					}
				}
				if (noTrapsWorldGen)
				{
					Main.tileSolid[138] = true;
				}
				placingTraps = false;
			}
		});
		AddGenerationPass("Piles", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[89].Value;
			Main.tileSolid[229] = false;
			Main.tileSolid[190] = false;
			Main.tileSolid[196] = false;
			Main.tileSolid[189] = false;
			Main.tileSolid[202] = false;
			Main.tileSolid[460] = false;
			Main.tileSolid[484] = false;
			if (noTrapsWorldGen)
			{
				Main.tileSolid[138] = false;
			}
			for (int num300 = 0; (double)num300 < (double)Main.maxTilesX * 0.06; num300++)
			{
				int num301 = Main.maxTilesX / 2;
				bool flag11 = false;
				while (!flag11 && num301 > 0)
				{
					num301--;
					int num302 = genRand.Next(25, Main.maxTilesX - 25);
					int num303 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300);
					while (oceanDepths(num302, num303))
					{
						num302 = genRand.Next(25, Main.maxTilesX - 25);
						num303 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300);
					}
					if (!Main.tile[num302, num303].active())
					{
						int num304 = 186;
						for (; !Main.tile[num302, num303 + 1].active() && num303 < Main.maxTilesY - 5; num303++)
						{
						}
						int num305 = genRand.Next(22);
						if (num305 >= 16 && num305 <= 22)
						{
							num305 = genRand.Next(22);
						}
						if ((Main.tile[num302, num303 + 1].type == 0 || Main.tile[num302, num303 + 1].type == 1 || Main.tileMoss[Main.tile[num302, num303 + 1].type]) && genRand.Next(5) == 0)
						{
							num305 = genRand.Next(23, 29);
							num304 = 187;
						}
						if (num303 > Main.maxTilesY - 300 || Main.wallDungeon[Main.tile[num302, num303].wall] || Main.tile[num302, num303 + 1].type == 30 || Main.tile[num302, num303 + 1].type == 19 || Main.tile[num302, num303 + 1].type == 25 || Main.tile[num302, num303 + 1].type == 203)
						{
							num305 = genRand.Next(7);
							num304 = 186;
						}
						if (Main.tile[num302, num303 + 1].type == 147 || Main.tile[num302, num303 + 1].type == 161 || Main.tile[num302, num303 + 1].type == 162)
						{
							num305 = genRand.Next(26, 32);
							num304 = 186;
						}
						if (Main.tile[num302, num303 + 1].type == 60)
						{
							num304 = 187;
							num305 = genRand.Next(6);
						}
						if ((Main.tile[num302, num303 + 1].type == 57 || Main.tile[num302, num303 + 1].type == 58) && genRand.Next(3) < 2)
						{
							num304 = 187;
							num305 = genRand.Next(6, 9);
						}
						if (Main.tile[num302, num303 + 1].type == 226)
						{
							num304 = 187;
							num305 = genRand.Next(18, 23);
						}
						if (Main.tile[num302, num303 + 1].type == 70)
						{
							num305 = genRand.Next(32, 35);
							num304 = 186;
						}
						if (Main.tile[num302, num303 + 1].type == 396 || Main.tile[num302, num303 + 1].type == 397 || Main.tile[num302, num303 + 1].type == 404)
						{
							num305 = genRand.Next(29, 35);
							num304 = 187;
						}
						if (Main.tile[num302, num303 + 1].type == 368)
						{
							num305 = genRand.Next(35, 41);
							num304 = 187;
						}
						if (Main.tile[num302, num303 + 1].type == 367)
						{
							num305 = genRand.Next(41, 47);
							num304 = 187;
						}
						if (num304 == 186 && num305 >= 7 && num305 <= 15 && genRand.Next(75) == 0)
						{
							num304 = 187;
							num305 = 17;
						}
						if (Main.wallDungeon[Main.tile[num302, num303].wall] && genRand.Next(3) != 0)
						{
							flag11 = true;
						}
						else
						{
							if (!Main.tile[num302, num303].shimmer())
							{
								PlaceTile(num302, num303, num304, mute: true, forced: false, -1, num305);
							}
							if (Main.tile[num302, num303].type == 186 || Main.tile[num302, num303].type == 187)
							{
								flag11 = true;
							}
							if (flag11 && num304 == 186 && num305 <= 7)
							{
								int num306 = genRand.Next(1, 5);
								for (int num307 = 0; num307 < num306; num307++)
								{
									int num308 = num302 + genRand.Next(-10, 11);
									int num309 = num303 - genRand.Next(5);
									if (!Main.tile[num308, num309].active())
									{
										for (; !Main.tile[num308, num309 + 1].active() && num309 < Main.maxTilesY - 5; num309++)
										{
										}
										int x12 = genRand.Next(12, 36);
										PlaceSmallPile(num308, num309, x12, 0, 185);
									}
								}
							}
						}
					}
				}
			}
			for (int num310 = 0; (double)num310 < (double)Main.maxTilesX * 0.01; num310++)
			{
				int num311 = Main.maxTilesX / 2;
				bool flag12 = false;
				while (!flag12 && num311 > 0)
				{
					num311--;
					int num312 = genRand.Next(25, Main.maxTilesX - 25);
					int num313 = genRand.Next(Main.maxTilesY - 300, Main.maxTilesY - 10);
					if (!Main.tile[num312, num313].active())
					{
						int num314 = 186;
						for (; !Main.tile[num312, num313 + 1].active() && num313 < Main.maxTilesY - 5; num313++)
						{
						}
						int num315 = genRand.Next(22);
						if (num315 >= 16 && num315 <= 22)
						{
							num315 = genRand.Next(22);
						}
						if (num313 > Main.maxTilesY - 300 || Main.wallDungeon[Main.tile[num312, num313].wall] || Main.tile[num312, num313 + 1].type == 30 || Main.tile[num312, num313 + 1].type == 19)
						{
							num315 = genRand.Next(7);
						}
						if ((Main.tile[num312, num313 + 1].type == 57 || Main.tile[num312, num313 + 1].type == 58) && genRand.Next(3) < 2)
						{
							num314 = 187;
							num315 = genRand.Next(6, 9);
						}
						if (Main.tile[num312, num313 + 1].type == 147 || Main.tile[num312, num313 + 1].type == 161 || Main.tile[num312, num313 + 1].type == 162)
						{
							num315 = genRand.Next(26, 32);
						}
						PlaceTile(num312, num313, num314, mute: true, forced: false, -1, num315);
						if (Main.tile[num312, num313].type == 186 || Main.tile[num312, num313].type == 187)
						{
							flag12 = true;
						}
						if (flag12 && num314 == 186 && num315 <= 7)
						{
							int num316 = genRand.Next(1, 5);
							for (int num317 = 0; num317 < num316; num317++)
							{
								int num318 = num312 + genRand.Next(-10, 11);
								int num319 = num313 - genRand.Next(5);
								if (!Main.tile[num318, num319].active())
								{
									for (; !Main.tile[num318, num319 + 1].active() && num319 < Main.maxTilesY - 5; num319++)
									{
									}
									int x13 = genRand.Next(12, 36);
									PlaceSmallPile(num318, num319, x13, 0, 185);
								}
							}
						}
					}
				}
			}
			for (int num320 = 0; (double)num320 < (double)Main.maxTilesX * 0.003; num320++)
			{
				int num321 = Main.maxTilesX / 2;
				bool flag13 = false;
				while (!flag13 && num321 > 0)
				{
					num321--;
					int num322 = 186;
					int num323 = genRand.Next(25, Main.maxTilesX - 25);
					int num324 = genRand.Next(10, (int)Main.worldSurface);
					while (oceanDepths(num323, num324))
					{
						num323 = genRand.Next(25, Main.maxTilesX - 25);
						num324 = genRand.Next(10, (int)Main.worldSurface);
					}
					if (!Main.tile[num323, num324].active())
					{
						for (; !Main.tile[num323, num324 + 1].active() && num324 < Main.maxTilesY - 5; num324++)
						{
						}
						int num325 = genRand.Next(7, 13);
						if (num324 > Main.maxTilesY - 300 || Main.wallDungeon[Main.tile[num323, num324].wall] || Main.tile[num323, num324 + 1].type == 30 || Main.tile[num323, num324 + 1].type == 19 || Main.tile[num323, num324 + 1].type == 25 || Main.tile[num323, num324 + 1].type == 203 || Main.tile[num323, num324 + 1].type == 234 || Main.tile[num323, num324 + 1].type == 112)
						{
							num325 = -1;
						}
						if (Main.tile[num323, num324 + 1].type == 147 || Main.tile[num323, num324 + 1].type == 161 || Main.tile[num323, num324 + 1].type == 162)
						{
							num325 = genRand.Next(26, 32);
						}
						if (Main.tile[num323, num324 + 1].type == 53)
						{
							num322 = 187;
							num325 = genRand.Next(52, 55);
						}
						if (Main.tile[num323, num324 + 1].type == 2 || Main.tile[num323 - 1, num324 + 1].type == 2 || Main.tile[num323 + 1, num324 + 1].type == 2)
						{
							num322 = 187;
							num325 = genRand.Next(14, 17);
						}
						if (Main.tile[num323, num324 + 1].type == 151 || Main.tile[num323, num324 + 1].type == 274)
						{
							num322 = 186;
							num325 = genRand.Next(7);
						}
						if (num325 >= 0)
						{
							PlaceTile(num323, num324, num322, mute: true, forced: false, -1, num325);
						}
						if (Main.tile[num323, num324].type == num322)
						{
							flag13 = true;
						}
					}
				}
			}
			for (int num326 = 0; (double)num326 < (double)Main.maxTilesX * 0.0035; num326++)
			{
				int num327 = Main.maxTilesX / 2;
				bool flag14 = false;
				while (!flag14 && num327 > 0)
				{
					num327--;
					int num328 = genRand.Next(25, Main.maxTilesX - 25);
					int num329 = genRand.Next(10, (int)Main.worldSurface);
					if (!Main.tile[num328, num329].active() && Main.tile[num328, num329].wall > 0)
					{
						int num330 = 186;
						for (; !Main.tile[num328, num329 + 1].active() && num329 < Main.maxTilesY - 5; num329++)
						{
						}
						int num331 = genRand.Next(7, 13);
						if (num329 > Main.maxTilesY - 300 || Main.wallDungeon[Main.tile[num328, num329].wall] || Main.tile[num328, num329 + 1].type == 30 || Main.tile[num328, num329 + 1].type == 19)
						{
							num331 = -1;
						}
						if (Main.tile[num328, num329 + 1].type == 25)
						{
							num331 = genRand.Next(7);
						}
						if (Main.tile[num328, num329 + 1].type == 147 || Main.tile[num328, num329 + 1].type == 161 || Main.tile[num328, num329 + 1].type == 162)
						{
							num331 = genRand.Next(26, 32);
						}
						if (Main.tile[num328, num329 + 1].type == 2 || Main.tile[num328 - 1, num329 + 1].type == 2 || Main.tile[num328 + 1, num329 + 1].type == 2)
						{
							num330 = 187;
							num331 = genRand.Next(14, 17);
						}
						if (Main.tile[num328, num329 + 1].type == 151 || Main.tile[num328, num329 + 1].type == 274)
						{
							num330 = 186;
							num331 = genRand.Next(7);
						}
						if (num331 >= 0)
						{
							PlaceTile(num328, num329, num330, mute: true, forced: false, -1, num331);
						}
						if (Main.tile[num328, num329].type == num330)
						{
							flag14 = true;
						}
						if (flag14 && num331 <= 7)
						{
							int num332 = genRand.Next(1, 5);
							for (int num333 = 0; num333 < num332; num333++)
							{
								int num334 = num328 + genRand.Next(-10, 11);
								int num335 = num329 - genRand.Next(5);
								if (!Main.tile[num334, num335].active())
								{
									for (; !Main.tile[num334, num335 + 1].active() && num335 < Main.maxTilesY - 5; num335++)
									{
									}
									int x14 = genRand.Next(12, 36);
									PlaceSmallPile(num334, num335, x14, 0, 185);
								}
							}
						}
					}
				}
			}
			for (int num336 = 0; (double)num336 < (double)Main.maxTilesX * 0.6; num336++)
			{
				int num337 = Main.maxTilesX / 2;
				bool flag15 = false;
				while (!flag15 && num337 > 0)
				{
					num337--;
					int num338 = genRand.Next(25, Main.maxTilesX - 25);
					int num339 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 20);
					if (Main.tile[num338, num339].wall == 87 && genRand.Next(2) == 0)
					{
						num338 = genRand.Next(25, Main.maxTilesX - 25);
						num339 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 20);
					}
					while (oceanDepths(num338, num339))
					{
						num338 = genRand.Next(25, Main.maxTilesX - 25);
						num339 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 20);
					}
					if (!Main.tile[num338, num339].active())
					{
						for (; !Main.tile[num338, num339 + 1].active() && num339 < Main.maxTilesY - 5; num339++)
						{
						}
						int num340 = genRand.Next(2);
						int num341 = genRand.Next(36);
						if (num341 >= 28 && num341 <= 35)
						{
							num341 = genRand.Next(36);
						}
						if (num340 == 1)
						{
							num341 = genRand.Next(25);
							if (num341 >= 16 && num341 <= 24)
							{
								num341 = genRand.Next(25);
							}
						}
						if (num339 > Main.maxTilesY - 300)
						{
							if (num340 == 0)
							{
								num341 = genRand.Next(12, 28);
							}
							if (num340 == 1)
							{
								num341 = genRand.Next(6, 16);
							}
						}
						if (Main.wallDungeon[Main.tile[num338, num339].wall] || Main.tile[num338, num339 + 1].type == 30 || Main.tile[num338, num339 + 1].type == 19 || Main.tile[num338, num339 + 1].type == 25 || Main.tile[num338, num339 + 1].type == 203 || Main.tile[num338, num339].wall == 87)
						{
							if (num340 == 0 && num341 < 12)
							{
								num341 += 12;
							}
							if (num340 == 1 && num341 < 6)
							{
								num341 += 6;
							}
							if (num340 == 1 && num341 >= 17)
							{
								num341 -= 10;
							}
						}
						if (Main.tile[num338, num339 + 1].type == 147 || Main.tile[num338, num339 + 1].type == 161 || Main.tile[num338, num339 + 1].type == 162)
						{
							if (num340 == 0 && num341 < 12)
							{
								num341 += 36;
							}
							if (num340 == 1 && num341 >= 20)
							{
								num341 += 6;
							}
							if (num340 == 1 && num341 < 6)
							{
								num341 += 25;
							}
						}
						if (Main.tile[num338, num339 + 1].type == 151 || Main.tile[num338, num339 + 1].type == 274)
						{
							if (num340 == 0)
							{
								num341 = genRand.Next(12, 28);
							}
							if (num340 == 1)
							{
								num341 = genRand.Next(12, 19);
							}
						}
						if (Main.tile[num338, num339 + 1].type == 368)
						{
							if (num340 == 0)
							{
								num341 = genRand.Next(60, 66);
							}
							if (num340 == 1)
							{
								num341 = genRand.Next(47, 53);
							}
						}
						if (Main.tile[num338, num339 + 1].type == 367)
						{
							if (num340 == 0)
							{
								num341 = genRand.Next(66, 72);
							}
							if (num340 == 1)
							{
								num341 = genRand.Next(53, 59);
							}
						}
						if (Main.wallDungeon[Main.tile[num338, num339].wall] && genRand.Next(3) != 0)
						{
							flag15 = true;
						}
						else if (!Main.tile[num338, num339].shimmer())
						{
							flag15 = PlaceSmallPile(num338, num339, num341, num340, 185);
						}
						if (flag15 && num340 == 1 && num341 >= 6 && num341 <= 15)
						{
							int num342 = genRand.Next(1, 5);
							for (int num343 = 0; num343 < num342; num343++)
							{
								int num344 = num338 + genRand.Next(-10, 11);
								int num345 = num339 - genRand.Next(5);
								if (!Main.tile[num344, num345].active())
								{
									for (; !Main.tile[num344, num345 + 1].active() && num345 < Main.maxTilesY - 5; num345++)
									{
									}
									int x15 = genRand.Next(12, 36);
									PlaceSmallPile(num344, num345, x15, 0, 185);
								}
							}
						}
					}
				}
			}
			for (int num346 = 0; (double)num346 < (double)Main.maxTilesX * 0.02; num346++)
			{
				int num347 = Main.maxTilesX / 2;
				bool flag16 = false;
				while (!flag16 && num347 > 0)
				{
					num347--;
					int num348 = genRand.Next(25, Main.maxTilesX - 25);
					int num349 = genRand.Next(15, (int)Main.worldSurface);
					while (oceanDepths(num348, num349))
					{
						num348 = genRand.Next(25, Main.maxTilesX - 25);
						num349 = genRand.Next(15, (int)Main.worldSurface);
					}
					if (!Main.tile[num348, num349].active())
					{
						for (; !Main.tile[num348, num349 + 1].active() && num349 < Main.maxTilesY - 5; num349++)
						{
						}
						int num350 = genRand.Next(2);
						int num351 = genRand.Next(11);
						if (num350 == 1)
						{
							num351 = genRand.Next(5);
						}
						if (Main.tile[num348, num349 + 1].type == 147 || Main.tile[num348, num349 + 1].type == 161 || Main.tile[num348, num349 + 1].type == 162)
						{
							if (num350 == 0 && num351 < 12)
							{
								num351 += 36;
							}
							if (num350 == 1 && num351 >= 20)
							{
								num351 += 6;
							}
							if (num350 == 1 && num351 < 6)
							{
								num351 += 25;
							}
						}
						if (Main.tile[num348, num349 + 1].type == 2 && num350 == 1)
						{
							num351 = genRand.Next(38, 41);
						}
						if (Main.tile[num348, num349 + 1].type == 151 || Main.tile[num348, num349 + 1].type == 274)
						{
							if (num350 == 0)
							{
								num351 = genRand.Next(12, 28);
							}
							if (num350 == 1)
							{
								num351 = genRand.Next(12, 19);
							}
						}
						if (!Main.wallDungeon[Main.tile[num348, num349].wall] && Main.tile[num348, num349 + 1].type != 30 && Main.tile[num348, num349 + 1].type != 19 && Main.tile[num348, num349 + 1].type != 41 && Main.tile[num348, num349 + 1].type != 43 && Main.tile[num348, num349 + 1].type != 44 && Main.tile[num348, num349 + 1].type != 481 && Main.tile[num348, num349 + 1].type != 482 && Main.tile[num348, num349 + 1].type != 483 && Main.tile[num348, num349 + 1].type != 45 && Main.tile[num348, num349 + 1].type != 46 && Main.tile[num348, num349 + 1].type != 47 && Main.tile[num348, num349 + 1].type != 175 && Main.tile[num348, num349 + 1].type != 176 && Main.tile[num348, num349 + 1].type != 177 && Main.tile[num348, num349 + 1].type != 53 && Main.tile[num348, num349 + 1].type != 25 && Main.tile[num348, num349 + 1].type != 203)
						{
							flag16 = PlaceSmallPile(num348, num349, num351, num350, 185);
						}
					}
				}
			}
			for (int num352 = 0; (double)num352 < (double)Main.maxTilesX * 0.15; num352++)
			{
				int num353 = Main.maxTilesX / 2;
				bool flag17 = false;
				while (!flag17 && num353 > 0)
				{
					num353--;
					int num354 = genRand.Next(25, Main.maxTilesX - 25);
					int num355 = genRand.Next(15, (int)Main.worldSurface);
					if (!Main.tile[num354, num355].active() && (Main.tile[num354, num355].wall == 2 || Main.tile[num354, num355].wall == 40))
					{
						for (; !Main.tile[num354, num355 + 1].active() && num355 < Main.maxTilesY - 5; num355++)
						{
						}
						int num356 = genRand.Next(2);
						int num357 = genRand.Next(11);
						if (num356 == 1)
						{
							num357 = genRand.Next(5);
						}
						if (Main.tile[num354, num355 + 1].type == 147 || Main.tile[num354, num355 + 1].type == 161 || Main.tile[num354, num355 + 1].type == 162)
						{
							if (num356 == 0 && num357 < 12)
							{
								num357 += 36;
							}
							if (num356 == 1 && num357 >= 20)
							{
								num357 += 6;
							}
							if (num356 == 1 && num357 < 6)
							{
								num357 += 25;
							}
						}
						if (Main.tile[num354, num355 + 1].type == 2 && num356 == 1)
						{
							num357 = genRand.Next(38, 41);
						}
						if (Main.tile[num354, num355 + 1].type == 151 || Main.tile[num354, num355 + 1].type == 274)
						{
							if (num356 == 0)
							{
								num357 = genRand.Next(12, 28);
							}
							if (num356 == 1)
							{
								num357 = genRand.Next(12, 19);
							}
						}
						if ((Main.tile[num354, num355].liquid != byte.MaxValue || Main.tile[num354, num355 + 1].type != 53 || Main.tile[num354, num355].wall != 0) && !Main.wallDungeon[Main.tile[num354, num355].wall] && Main.tile[num354, num355 + 1].type != 30 && Main.tile[num354, num355 + 1].type != 19 && Main.tile[num354, num355 + 1].type != 41 && Main.tile[num354, num355 + 1].type != 43 && Main.tile[num354, num355 + 1].type != 44 && Main.tile[num354, num355 + 1].type != 481 && Main.tile[num354, num355 + 1].type != 482 && Main.tile[num354, num355 + 1].type != 483 && Main.tile[num354, num355 + 1].type != 45 && Main.tile[num354, num355 + 1].type != 46 && Main.tile[num354, num355 + 1].type != 47 && Main.tile[num354, num355 + 1].type != 175 && Main.tile[num354, num355 + 1].type != 176 && Main.tile[num354, num355 + 1].type != 177 && Main.tile[num354, num355 + 1].type != 25 && Main.tile[num354, num355 + 1].type != 203)
						{
							flag17 = PlaceSmallPile(num354, num355, num357, num356, 185);
						}
					}
				}
			}
			Main.tileSolid[190] = true;
			Main.tileSolid[192] = true;
			Main.tileSolid[196] = true;
			Main.tileSolid[189] = true;
			Main.tileSolid[202] = true;
			Main.tileSolid[225] = true;
			Main.tileSolid[460] = true;
			Main.tileSolid[138] = true;
		});
		AddGenerationPass("Spawn Point", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Set(1.0);
			int num291 = 5;
			bool flag10 = true;
			int num292 = Main.maxTilesX / 2;
			if (Main.tenthAnniversaryWorld && !remixWorldGen)
			{
				int num293 = GenVars.beachBordersWidth + 15;
				num292 = ((genRand.Next(2) != 0) ? (Main.maxTilesX - num293) : num293);
			}
			while (flag10)
			{
				int num294 = num292 + genRand.Next(-num291, num291 + 1);
				for (int num295 = 0; num295 < Main.maxTilesY; num295++)
				{
					if (Main.tile[num294, num295].active())
					{
						Main.spawnTileX = num294;
						Main.spawnTileY = num295;
						break;
					}
				}
				flag10 = false;
				num291++;
				if ((double)Main.spawnTileY > Main.worldSurface)
				{
					flag10 = true;
				}
				if (Main.tile[Main.spawnTileX, Main.spawnTileY - 1].liquid > 0)
				{
					flag10 = true;
				}
			}
			int num296 = 10;
			while ((double)Main.spawnTileY > Main.worldSurface)
			{
				int num297 = genRand.Next(num292 - num296, num292 + num296);
				for (int num298 = 0; num298 < Main.maxTilesY; num298++)
				{
					if (Main.tile[num297, num298].active())
					{
						Main.spawnTileX = num297;
						Main.spawnTileY = num298;
						break;
					}
				}
				num296++;
			}
			if (remixWorldGen)
			{
				int num299 = Main.maxTilesY - 10;
				while (SolidTile(Main.spawnTileX, num299))
				{
					num299--;
				}
				Main.spawnTileY = num299 + 1;
			}
		});
		AddGenerationPass("Grass Wall", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			maxTileCount = 3500;
			progress.Set(1.0);
			for (int num279 = 50; num279 < Main.maxTilesX - 50; num279++)
			{
				for (int num280 = 0; (double)num280 < Main.worldSurface - 10.0; num280++)
				{
					if (genRand.Next(4) == 0)
					{
						bool flag8 = false;
						int num281 = -1;
						int num282 = -1;
						if (Main.tile[num279, num280].active() && Main.tile[num279, num280].type == 2 && (Main.tile[num279, num280].wall == 2 || Main.tile[num279, num280].wall == 63))
						{
							for (int num283 = num279 - 1; num283 <= num279 + 1; num283++)
							{
								for (int num284 = num280 - 1; num284 <= num280 + 1; num284++)
								{
									if (Main.tile[num283, num284].wall == 0 && !SolidTile(num283, num284))
									{
										flag8 = true;
									}
								}
							}
							if (flag8)
							{
								for (int num285 = num279 - 1; num285 <= num279 + 1; num285++)
								{
									for (int num286 = num280 - 1; num286 <= num280 + 1; num286++)
									{
										if ((Main.tile[num285, num286].wall == 2 || Main.tile[num285, num286].wall == 15) && !SolidTile(num285, num286))
										{
											num281 = num285;
											num282 = num286;
										}
									}
								}
							}
						}
						if (flag8 && num281 > -1 && num282 > -1 && countDirtTiles(num281, num282) < maxTileCount)
						{
							try
							{
								ushort wallType = 63;
								if (dontStarveWorldGen && genRand.Next(3) != 0)
								{
									wallType = 62;
								}
								Spread.Wall2(num281, num282, wallType);
							}
							catch
							{
							}
						}
					}
				}
			}
			for (int num287 = 5; num287 < Main.maxTilesX - 5; num287++)
			{
				for (int num288 = 10; (double)num288 < Main.worldSurface - 1.0; num288++)
				{
					if (Main.tile[num287, num288].wall == 63 && genRand.Next(10) == 0)
					{
						Main.tile[num287, num288].wall = 65;
					}
					if (Main.tile[num287, num288].active() && Main.tile[num287, num288].type == 0)
					{
						bool flag9 = false;
						for (int num289 = num287 - 1; num289 <= num287 + 1; num289++)
						{
							for (int num290 = num288 - 1; num290 <= num288 + 1; num290++)
							{
								if (Main.tile[num289, num290].wall == 63 || Main.tile[num289, num290].wall == 65)
								{
									flag9 = true;
									break;
								}
							}
						}
						if (flag9)
						{
							SpreadGrass(num287, num288);
						}
					}
				}
			}
		});
		AddGenerationPass("Guide", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			//IL_011d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0122: Unknown result type (might be due to invalid IL or missing references)
			//IL_0129: Unknown result type (might be due to invalid IL or missing references)
			//IL_0132: Unknown result type (might be due to invalid IL or missing references)
			//IL_0167: Unknown result type (might be due to invalid IL or missing references)
			//IL_0179: Unknown result type (might be due to invalid IL or missing references)
			//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0215: Unknown result type (might be due to invalid IL or missing references)
			//IL_0227: Unknown result type (might be due to invalid IL or missing references)
			//IL_027f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0284: Unknown result type (might be due to invalid IL or missing references)
			//IL_028b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0294: Unknown result type (might be due to invalid IL or missing references)
			//IL_02c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_02db: Unknown result type (might be due to invalid IL or missing references)
			//IL_0333: Unknown result type (might be due to invalid IL or missing references)
			//IL_0338: Unknown result type (might be due to invalid IL or missing references)
			//IL_03a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_03aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_0346: Unknown result type (might be due to invalid IL or missing references)
			//IL_034f: Unknown result type (might be due to invalid IL or missing references)
			//IL_03f2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0404: Unknown result type (might be due to invalid IL or missing references)
			progress.Set(1.0);
			if (Main.tenthAnniversaryWorld)
			{
				BirthdayParty.GenuineParty = true;
				BirthdayParty.PartyDaysOnCooldown = 5;
				if (getGoodWorldGen)
				{
					Main.afterPartyOfDoom = true;
				}
				int num273;
				if (remixWorldGen)
				{
					num273 = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 441);
					NPC.savedTaxCollector = true;
				}
				else
				{
					num273 = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 22);
				}
				Main.npc[num273].homeTileX = Main.spawnTileX;
				Main.npc[num273].homeTileY = Main.spawnTileY;
				Main.npc[num273].direction = 1;
				Main.npc[num273].homeless = true;
				Main.npc[num273].GivenName = Language.GetTextValue("GuideNames.Andrew");
				BirthdayParty.CelebratingNPCs.Add(num273);
				Point adjustedFloorPosition = GetAdjustedFloorPosition(Main.spawnTileX + 2, Main.spawnTileY);
				num273 = NPC.NewNPC(new EntitySource_WorldGen(), adjustedFloorPosition.X * 16, adjustedFloorPosition.Y * 16, 178);
				Main.npc[num273].homeTileX = adjustedFloorPosition.X;
				Main.npc[num273].homeTileY = adjustedFloorPosition.Y;
				Main.npc[num273].direction = -1;
				Main.npc[num273].homeless = true;
				Main.npc[num273].GivenName = Language.GetTextValue("SteampunkerNames.Whitney");
				BirthdayParty.CelebratingNPCs.Add(num273);
				adjustedFloorPosition = GetAdjustedFloorPosition(Main.spawnTileX - 2, Main.spawnTileY);
				num273 = NPC.NewNPC(new EntitySource_WorldGen(), adjustedFloorPosition.X * 16, adjustedFloorPosition.Y * 16, 663);
				Main.npc[num273].homeTileX = adjustedFloorPosition.X;
				Main.npc[num273].homeTileY = adjustedFloorPosition.Y;
				Main.npc[num273].direction = 1;
				Main.npc[num273].homeless = true;
				Main.npc[num273].GivenName = Language.GetTextValue("PrincessNames.Yorai");
				BirthdayParty.CelebratingNPCs.Add(num273);
				NPC.unlockedPrincessSpawn = true;
				adjustedFloorPosition = GetAdjustedFloorPosition(Main.spawnTileX + 4, Main.spawnTileY);
				num273 = NPC.NewNPC(new EntitySource_WorldGen(), adjustedFloorPosition.X * 16, adjustedFloorPosition.Y * 16, 208);
				Main.npc[num273].homeTileX = adjustedFloorPosition.X;
				Main.npc[num273].homeTileY = adjustedFloorPosition.Y;
				Main.npc[num273].direction = -1;
				Main.npc[num273].homeless = true;
				Main.npc[num273].GivenName = Language.GetTextValue("PartyGirlNames.Amanda");
				BirthdayParty.CelebratingNPCs.Add(num273);
				NPC.unlockedPartyGirlSpawn = true;
				adjustedFloorPosition = GetAdjustedFloorPosition(Main.spawnTileX - 4, Main.spawnTileY);
				if (Main.remixWorld)
				{
					num273 = NPC.NewNPC(new EntitySource_WorldGen(), adjustedFloorPosition.X * 16, adjustedFloorPosition.Y * 16, 681);
					Main.npc[num273].GivenName = Language.GetTextValue("SlimeNames_Rainbow.Slimestar");
					NPC.unlockedSlimeRainbowSpawn = true;
				}
				else
				{
					num273 = NPC.NewNPC(new EntitySource_WorldGen(), adjustedFloorPosition.X * 16, adjustedFloorPosition.Y * 16, 656);
					NPC.boughtBunny = true;
					Main.npc[num273].townNpcVariationIndex = 1;
				}
				Main.npc[num273].homeTileX = adjustedFloorPosition.X;
				Main.npc[num273].homeTileY = adjustedFloorPosition.Y;
				Main.npc[num273].direction = 1;
				Main.npc[num273].homeless = true;
			}
			else if (remixWorldGen)
			{
				int num274 = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 441);
				Main.npc[num274].homeTileX = Main.spawnTileX;
				Main.npc[num274].homeTileY = Main.spawnTileY;
				Main.npc[num274].direction = 1;
				Main.npc[num274].homeless = true;
				NPC.savedTaxCollector = true;
			}
			else if (notTheBees)
			{
				int num275 = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 17);
				Main.npc[num275].homeTileX = Main.spawnTileX;
				Main.npc[num275].homeTileY = Main.spawnTileY;
				Main.npc[num275].direction = 1;
				Main.npc[num275].homeless = true;
				NPC.unlockedMerchantSpawn = true;
			}
			else if (drunkWorldGen)
			{
				int num276 = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 208);
				Main.npc[num276].homeTileX = Main.spawnTileX;
				Main.npc[num276].homeTileY = Main.spawnTileY;
				Main.npc[num276].direction = 1;
				Main.npc[num276].homeless = true;
				NPC.unlockedPartyGirlSpawn = true;
			}
			else if (getGoodWorldGen)
			{
				int num277 = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 38);
				Main.npc[num277].homeTileX = Main.spawnTileX;
				Main.npc[num277].homeTileY = Main.spawnTileY;
				Main.npc[num277].direction = 1;
				Main.npc[num277].homeless = true;
				NPC.unlockedDemolitionistSpawn = true;
			}
			else
			{
				int num278 = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 22);
				Main.npc[num278].homeTileX = Main.spawnTileX;
				Main.npc[num278].homeTileY = Main.spawnTileY;
				Main.npc[num278].direction = 1;
				Main.npc[num278].homeless = true;
			}
		});
		AddGenerationPass("Sunflowers", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[39].Value;
			double num264 = (double)Main.maxTilesX * 0.002;
			for (int num265 = 0; (double)num265 < num264; num265++)
			{
				progress.Set((double)num265 / num264);
				int num266 = 0;
				int num267 = 0;
				_ = Main.maxTilesX / 2;
				int num268 = genRand.Next(Main.maxTilesX);
				num266 = num268 - genRand.Next(10) - 7;
				num267 = num268 + genRand.Next(10) + 7;
				if (num266 < 0)
				{
					num266 = 0;
				}
				if (num267 > Main.maxTilesX - 1)
				{
					num267 = Main.maxTilesX - 1;
				}
				int num269 = 1;
				int num270 = (int)Main.worldSurface - 1;
				for (int num271 = num266; num271 < num267; num271++)
				{
					for (int num272 = num269; num272 < num270; num272++)
					{
						if (Main.tile[num271, num272].type == 2 && Main.tile[num271, num272].active() && !Main.tile[num271, num272 - 1].active())
						{
							PlaceTile(num271, num272 - 1, 27, mute: true);
						}
						if (Main.tile[num271, num272].active())
						{
							break;
						}
					}
				}
			}
		});
		AddGenerationPass("Planting Trees", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[40].Value;
			if (!drunkWorldGen && !Main.tenthAnniversaryWorld)
			{
				for (int num259 = 0; (double)num259 < (double)Main.maxTilesX * 0.003; num259++)
				{
					progress.Set((double)num259 / ((double)Main.maxTilesX * 0.003));
					int num260 = genRand.Next(50, Main.maxTilesX - 50);
					int num261 = genRand.Next(25, 50);
					for (int num262 = num260 - num261; num262 < num260 + num261; num262++)
					{
						for (int num263 = 20; (double)num263 < Main.worldSurface; num263++)
						{
							GrowEpicTree(num262, num263);
						}
					}
				}
			}
			AddTrees();
		});
		AddGenerationPass("Herbs", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			double num257 = (double)Main.maxTilesX * 1.7;
			if (remixWorldGen)
			{
				num257 *= 5.0;
			}
			progress.Message = Lang.gen[41].Value;
			for (int num258 = 0; (double)num258 < num257; num258++)
			{
				progress.Set((double)num258 / num257);
				PlantAlch();
			}
		});
		AddGenerationPass("Dye Plants", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Set(1.0);
			for (int num256 = 0; num256 < Main.maxTilesX; num256++)
			{
				plantDye(genRand.Next(100, Main.maxTilesX - 100), genRand.Next(100, Main.UnderworldLayer));
			}
			MatureTheHerbPlants();
			GrowGlowTulips();
		});
		AddGenerationPass("Webs And Honey", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Set(1.0);
			for (int num246 = 100; num246 < Main.maxTilesX - 100; num246++)
			{
				int num247 = (int)Main.worldSurface;
				if (dontStarveWorldGen)
				{
					num247 = 50;
				}
				for (int num248 = num247; num248 < Main.maxTilesY - 100; num248++)
				{
					if (Main.tile[num246, num248].wall == 86)
					{
						if (Main.tile[num246, num248].liquid > 0)
						{
							Main.tile[num246, num248].honey(honey: true);
						}
						if (genRand.Next(3) == 0)
						{
							PlaceTight(num246, num248);
						}
					}
					if (Main.tile[num246, num248].wall == 62)
					{
						Main.tile[num246, num248].liquid = 0;
						Main.tile[num246, num248].lava(lava: false);
					}
					if (Main.tile[num246, num248].wall == 62 && !Main.tile[num246, num248].active() && genRand.Next(10) != 0)
					{
						int num249 = genRand.Next(2, 5);
						int num250 = num246 - num249;
						int num251 = num246 + num249;
						int num252 = num248 - num249;
						int num253 = num248 + num249;
						bool flag7 = false;
						for (int num254 = num250; num254 <= num251; num254++)
						{
							for (int num255 = num252; num255 <= num253; num255++)
							{
								if (SolidTile(num254, num255))
								{
									flag7 = true;
									break;
								}
							}
						}
						if (flag7)
						{
							PlaceTile(num246, num248, 51, mute: true);
							TileFrame(num246, num248);
						}
					}
				}
			}
		});
		AddGenerationPass("Weeds", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[42].Value;
			if (Main.halloween)
			{
				for (int num240 = 40; num240 < Main.maxTilesX - 40; num240++)
				{
					for (int num241 = 50; (double)num241 < Main.worldSurface; num241++)
					{
						if (Main.tile[num240, num241].active() && Main.tile[num240, num241].type == 2 && genRand.Next(15) == 0)
						{
							PlacePumpkin(num240, num241 - 1);
							int num242 = genRand.Next(5);
							for (int num243 = 0; num243 < num242; num243++)
							{
								GrowPumpkin(num240, num241 - 1, 254);
							}
						}
					}
				}
			}
			for (int num244 = 0; num244 < Main.maxTilesX; num244++)
			{
				progress.Set((double)num244 / (double)Main.maxTilesX);
				for (int num245 = 1; num245 < Main.maxTilesY; num245++)
				{
					if (Main.tile[num244, num245].type == 2 && Main.tile[num244, num245].nactive())
					{
						if (!Main.tile[num244, num245 - 1].active())
						{
							PlaceTile(num244, num245 - 1, 3, mute: true);
							Main.tile[num244, num245 - 1].CopyPaintAndCoating(Main.tile[num244, num245]);
						}
					}
					else if (Main.tile[num244, num245].type == 23 && Main.tile[num244, num245].nactive())
					{
						if (!Main.tile[num244, num245 - 1].active())
						{
							PlaceTile(num244, num245 - 1, 24, mute: true);
						}
					}
					else if (Main.tile[num244, num245].type == 199 && Main.tile[num244, num245].nactive())
					{
						if (!Main.tile[num244, num245 - 1].active())
						{
							PlaceTile(num244, num245 - 1, 201, mute: true);
						}
					}
					else if (Main.tile[num244, num245].type == 633 && Main.tile[num244, num245].nactive() && !Main.tile[num244, num245 - 1].active())
					{
						PlaceTile(num244, num245 - 1, 637, mute: true);
					}
				}
			}
		});
		AddGenerationPass("Glowing Mushrooms and Jungle Plants", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Set(1.0);
			for (int num238 = 0; num238 < Main.maxTilesX; num238++)
			{
				for (int num239 = 0; num239 < Main.maxTilesY; num239++)
				{
					if (Main.tile[num238, num239].active())
					{
						if (num239 >= (int)Main.worldSurface && Main.tile[num238, num239].type == 70 && !Main.tile[num238, num239 - 1].active())
						{
							GrowTree(num238, num239);
							if (!Main.tile[num238, num239 - 1].active())
							{
								GrowTree(num238, num239);
								if (!Main.tile[num238, num239 - 1].active())
								{
									GrowTree(num238, num239);
									if (!Main.tile[num238, num239 - 1].active())
									{
										PlaceTile(num238, num239 - 1, 71, mute: true);
									}
								}
							}
						}
						if (Main.tile[num238, num239].type == 60 && !Main.tile[num238, num239 - 1].active())
						{
							PlaceTile(num238, num239 - 1, 61, mute: true);
						}
					}
				}
			}
		});
		AddGenerationPass("Jungle Plants", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Set(1.0);
			for (int num235 = 0; num235 < Main.maxTilesX * 100; num235++)
			{
				int num236 = genRand.Next(40, Main.maxTilesX / 2 - 40);
				if (GenVars.dungeonSide < 0)
				{
					num236 += Main.maxTilesX / 2;
				}
				int num237;
				for (num237 = genRand.Next(Main.maxTilesY - 300); !Main.tile[num236, num237].active() && num237 < Main.maxTilesY - 300; num237++)
				{
				}
				if (Main.tile[num236, num237].active() && Main.tile[num236, num237].type == 60)
				{
					num237--;
					PlaceJunglePlant(num236, num237, 233, genRand.Next(8), 0);
					if (Main.tile[num236, num237].type != 233)
					{
						PlaceJunglePlant(num236, num237, 233, genRand.Next(12), 1);
					}
				}
			}
		});
		AddGenerationPass("Vines", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[43].Value;
			for (int num213 = 5; num213 < Main.maxTilesX - 5; num213++)
			{
				progress.Set((double)num213 / (double)Main.maxTilesX);
				int num214 = 0;
				ushort num215 = 52;
				int num216 = (int)Main.worldSurface;
				if (remixWorldGen)
				{
					num216 = Main.maxTilesY - 200;
				}
				for (int num217 = 0; num217 < num216; num217++)
				{
					if (num214 > 0 && !Main.tile[num213, num217].active())
					{
						Main.tile[num213, num217].active(active: true);
						Main.tile[num213, num217].type = num215;
						Main.tile[num213, num217].CopyPaintAndCoating(Main.tile[num213, num217 - 1]);
						num214--;
					}
					else
					{
						num214 = 0;
					}
					if (Main.tile[num213, num217].active() && !Main.tile[num213, num217].bottomSlope() && (Main.tile[num213, num217].type == 2 || (Main.tile[num213, num217].type == 192 && genRand.Next(4) == 0)) && GrowMoreVines(num213, num217))
					{
						num215 = 52;
						if (Main.tile[num213, num217].wall == 68 || Main.tile[num213, num217].wall == 65 || Main.tile[num213, num217].wall == 66 || Main.tile[num213, num217].wall == 63)
						{
							num215 = 382;
						}
						else if (Main.tile[num213, num217 + 1].wall == 68 || Main.tile[num213, num217 + 1].wall == 65 || Main.tile[num213, num217 + 1].wall == 66 || Main.tile[num213, num217 + 1].wall == 63)
						{
							num215 = 382;
						}
						if (remixWorldGen && genRand.Next(5) == 0)
						{
							num215 = 382;
						}
						if (genRand.Next(5) < 3)
						{
							num214 = genRand.Next(1, 10);
						}
					}
				}
				num214 = 0;
				for (int num218 = 5; num218 < Main.maxTilesY - 5; num218++)
				{
					if (num214 > 0 && !Main.tile[num213, num218].active())
					{
						Main.tile[num213, num218].active(active: true);
						Main.tile[num213, num218].type = 62;
						num214--;
					}
					else
					{
						num214 = 0;
					}
					if (Main.tile[num213, num218].active() && Main.tile[num213, num218].type == 60 && !Main.tile[num213, num218].bottomSlope() && GrowMoreVines(num213, num218))
					{
						if (notTheBees && num218 < Main.maxTilesY - 10 && Main.tile[num213, num218 - 1].active() && !Main.tile[num213, num218 - 1].bottomSlope() && Main.tile[num213 + 1, num218 - 1].active() && !Main.tile[num213 + 1, num218 - 1].bottomSlope() && (Main.tile[num213, num218 - 1].type == 60 || Main.tile[num213, num218 - 1].type == 444 || Main.tile[num213, num218 - 1].type == 230))
						{
							bool flag5 = true;
							for (int num219 = num213; num219 < num213 + 2; num219++)
							{
								for (int num220 = num218 + 1; num220 < num218 + 3; num220++)
								{
									if (Main.tile[num219, num220].active() && (!Main.tileCut[Main.tile[num219, num220].type] || Main.tile[num219, num220].type == 444))
									{
										flag5 = false;
										break;
									}
									if (Main.tile[num219, num220].liquid > 0 || Main.wallHouse[Main.tile[num219, num220].wall])
									{
										flag5 = false;
										break;
									}
								}
								if (!flag5)
								{
									break;
								}
							}
							if (flag5 && CountNearBlocksTypes(num213, num218, genRand.Next(3, 10), 1, 444) > 0)
							{
								flag5 = false;
							}
							if (flag5)
							{
								for (int num221 = num213; num221 < num213 + 2; num221++)
								{
									for (int num222 = num218 + 1; num222 < num218 + 3; num222++)
									{
										KillTile(num221, num222);
									}
								}
								for (int num223 = num213; num223 < num213 + 2; num223++)
								{
									for (int num224 = num218 + 1; num224 < num218 + 3; num224++)
									{
										Main.tile[num223, num224].active(active: true);
										Main.tile[num223, num224].type = 444;
										Main.tile[num223, num224].frameX = (short)((num223 - num213) * 18);
										Main.tile[num223, num224].frameY = (short)((num224 - num218 - 1) * 18);
									}
								}
								continue;
							}
						}
						else if (num213 < Main.maxTilesX - 1 && num218 < Main.maxTilesY - 2 && Main.tile[num213 + 1, num218].active() && Main.tile[num213 + 1, num218].type == 60 && !Main.tile[num213 + 1, num218].bottomSlope() && genRand.Next(40) == 0)
						{
							bool flag6 = true;
							for (int num225 = num213; num225 < num213 + 2; num225++)
							{
								for (int num226 = num218 + 1; num226 < num218 + 3; num226++)
								{
									if (Main.tile[num225, num226].active() && (!Main.tileCut[Main.tile[num225, num226].type] || Main.tile[num225, num226].type == 444))
									{
										flag6 = false;
										break;
									}
									if (Main.tile[num225, num226].liquid > 0 || Main.wallHouse[Main.tile[num225, num226].wall])
									{
										flag6 = false;
										break;
									}
								}
								if (!flag6)
								{
									break;
								}
							}
							if (flag6 && CountNearBlocksTypes(num213, num218, 20, 1, 444) > 0)
							{
								flag6 = false;
							}
							if (flag6)
							{
								for (int num227 = num213; num227 < num213 + 2; num227++)
								{
									for (int num228 = num218 + 1; num228 < num218 + 3; num228++)
									{
										KillTile(num227, num228);
									}
								}
								for (int num229 = num213; num229 < num213 + 2; num229++)
								{
									for (int num230 = num218 + 1; num230 < num218 + 3; num230++)
									{
										Main.tile[num229, num230].active(active: true);
										Main.tile[num229, num230].type = 444;
										Main.tile[num229, num230].frameX = (short)((num229 - num213) * 18);
										Main.tile[num229, num230].frameY = (short)((num230 - num218 - 1) * 18);
									}
								}
								continue;
							}
						}
						if (genRand.Next(5) < 3)
						{
							num214 = genRand.Next(1, 10);
						}
					}
				}
				num214 = 0;
				for (int num231 = 0; num231 < Main.maxTilesY; num231++)
				{
					if (num214 > 0 && !Main.tile[num213, num231].active())
					{
						Main.tile[num213, num231].active(active: true);
						Main.tile[num213, num231].type = 528;
						num214--;
					}
					else
					{
						num214 = 0;
					}
					if (Main.tile[num213, num231].active() && Main.tile[num213, num231].type == 70 && genRand.Next(5) == 0 && !Main.tile[num213, num231].bottomSlope() && GrowMoreVines(num213, num231) && genRand.Next(5) < 3)
					{
						num214 = genRand.Next(1, 10);
					}
				}
				num214 = 0;
				for (int num232 = 0; num232 < Main.maxTilesY; num232++)
				{
					if (num214 > 0 && !Main.tile[num213, num232].active())
					{
						Main.tile[num213, num232].active(active: true);
						Main.tile[num213, num232].type = 636;
						num214--;
					}
					else
					{
						num214 = 0;
					}
					if (Main.tile[num213, num232].active() && !Main.tile[num213, num232].bottomSlope() && Main.tile[num213, num232].type == 23 && GrowMoreVines(num213, num232) && genRand.Next(5) < 3)
					{
						num214 = genRand.Next(1, 10);
					}
				}
				num214 = 0;
				for (int num233 = 0; num233 < Main.maxTilesY; num233++)
				{
					if (num214 > 0 && !Main.tile[num213, num233].active())
					{
						Main.tile[num213, num233].active(active: true);
						Main.tile[num213, num233].type = 205;
						num214--;
					}
					else
					{
						num214 = 0;
					}
					if (Main.tile[num213, num233].active() && !Main.tile[num213, num233].bottomSlope() && Main.tile[num213, num233].type == 199 && GrowMoreVines(num213, num233) && genRand.Next(5) < 3)
					{
						num214 = genRand.Next(1, 10);
					}
				}
				num214 = 0;
				for (int num234 = 0; num234 < Main.maxTilesY; num234++)
				{
					if (num214 > 0 && !Main.tile[num213, num234].active())
					{
						Main.tile[num213, num234].active(active: true);
						Main.tile[num213, num234].type = 638;
						num214--;
					}
					else
					{
						num214 = 0;
					}
					if (Main.tile[num213, num234].active() && !Main.tile[num213, num234].bottomSlope() && Main.tile[num213, num234].type == 633 && GrowMoreVines(num213, num234) && genRand.Next(5) < 3)
					{
						num214 = genRand.Next(1, 10);
					}
				}
			}
		});
		AddGenerationPass("Flowers", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[44].Value;
			int num200 = (int)((double)Main.maxTilesX * 0.004);
			if (remixWorldGen)
			{
				num200 *= 6;
			}
			for (int num201 = 0; num201 < num200; num201++)
			{
				progress.Set((double)num201 / (double)num200);
				int num202 = genRand.Next(100, Main.maxTilesX - 100);
				int num203 = genRand.Next(15, 30);
				int num204 = genRand.Next(15, 30);
				if (remixWorldGen)
				{
					num203 = genRand.Next(15, 45);
					num204 = genRand.Next(15, 45);
					int num205 = genRand.Next((int)Main.rockLayer, Main.maxTilesY - 350);
					if (GenVars.logX >= 0)
					{
						num202 = GenVars.logX;
						num205 = GenVars.logY;
						GenVars.logX = -1;
					}
					int num206 = genRand.NextFromList<int>(21, 24, 27, 30, 33, 36, 39, 42);
					for (int num207 = num202 - num203; num207 < num202 + num203; num207++)
					{
						for (int num208 = num205 - num204; num208 < num205 + num204; num208++)
						{
							if (Main.tile[num207, num208].type != 488 && !Main.tileSolid[Main.tile[num207, num208].type])
							{
								if (Main.tile[num207, num208].type == 3)
								{
									Main.tile[num207, num208].frameX = (short)((num206 + genRand.Next(3)) * 18);
									if (genRand.Next(3) != 0)
									{
										Main.tile[num207, num208].type = 73;
									}
								}
								else if (Main.tile[num207, num208 + 1].wall == 0 && (Main.tile[num207, num208 + 1].type == 2 || ((Main.tile[num207, num208 + 1].type == 40 || Main.tile[num207, num208 + 1].type == 1 || TileID.Sets.Ore[Main.tile[num207, num208 + 1].type]) && !Main.tile[num207, num208].active())) && (!Main.tile[num207, num208].active() || Main.tile[num207, num208].type == 185 || Main.tile[num207, num208].type == 186 || Main.tile[num207, num208].type == 187 || (Main.tile[num207, num208].type == 5 && (double)num207 < (double)Main.maxTilesX * 0.48) || (double)num207 > (double)Main.maxTilesX * 0.52))
								{
									if (Main.tile[num207, num208 + 1].type == 40 || Main.tile[num207, num208 + 1].type == 1 || TileID.Sets.Ore[Main.tile[num207, num208 + 1].type])
									{
										Main.tile[num207, num208 + 1].type = 2;
										if (Main.tile[num207, num208 + 2].type == 40 || Main.tile[num207, num208 + 2].type == 1 || TileID.Sets.Ore[Main.tile[num207, num208 + 2].type])
										{
											Main.tile[num207, num208 + 2].type = 2;
										}
									}
									KillTile(num207, num208);
									if (genRand.Next(2) == 0)
									{
										Main.tile[num207, num208 + 1].slope(0);
										Main.tile[num207, num208 + 1].halfBrick(halfBrick: false);
									}
									PlaceTile(num207, num208, 3);
									if (Main.tile[num207, num208].active() && Main.tile[num207, num208].type == 3)
									{
										Main.tile[num207, num208].frameX = (short)((num206 + genRand.Next(3)) * 18);
										if (genRand.Next(3) != 0)
										{
											Main.tile[num207, num208].type = 73;
										}
									}
									if (Main.tile[num207, num208 + 2].type == 40 || Main.tile[num207, num208 + 2].type == 1 || TileID.Sets.Ore[Main.tile[num207, num208 + 2].type])
									{
										Main.tile[num207, num208 + 2].type = 0;
									}
								}
							}
						}
					}
				}
				else
				{
					for (int num209 = num204; (double)num209 < Main.worldSurface - (double)num204 - 1.0; num209++)
					{
						if (Main.tile[num202, num209].active())
						{
							if (GenVars.logX >= 0)
							{
								num202 = GenVars.logX;
								num209 = GenVars.logY;
								GenVars.logX = -1;
							}
							int num210 = genRand.NextFromList<int>(21, 24, 27, 30, 33, 36, 39, 42);
							for (int num211 = num202 - num203; num211 < num202 + num203; num211++)
							{
								for (int num212 = num209 - num204; num212 < num209 + num204; num212++)
								{
									if (Main.tile[num211, num212].type != 488 && !Main.tileSolid[Main.tile[num211, num212].type])
									{
										if (Main.tile[num211, num212].type == 3)
										{
											Main.tile[num211, num212].frameX = (short)((num210 + genRand.Next(3)) * 18);
											if (genRand.Next(3) != 0)
											{
												Main.tile[num211, num212].type = 73;
											}
										}
										else if (Main.tile[num211, num212 + 1].wall == 0 && (Main.tile[num211, num212 + 1].type == 2 || ((Main.tile[num211, num212 + 1].type == 40 || Main.tile[num211, num212 + 1].type == 1 || TileID.Sets.Ore[Main.tile[num211, num212 + 1].type]) && !Main.tile[num211, num212].active())) && (!Main.tile[num211, num212].active() || Main.tile[num211, num212].type == 185 || Main.tile[num211, num212].type == 186 || Main.tile[num211, num212].type == 187 || (Main.tile[num211, num212].type == 5 && (double)num211 < (double)Main.maxTilesX * 0.48) || (double)num211 > (double)Main.maxTilesX * 0.52))
										{
											if (Main.tile[num211, num212 + 1].type == 40 || Main.tile[num211, num212 + 1].type == 1 || TileID.Sets.Ore[Main.tile[num211, num212 + 1].type])
											{
												Main.tile[num211, num212 + 1].type = 2;
												if (Main.tile[num211, num212 + 2].type == 40 || Main.tile[num211, num212 + 2].type == 1 || TileID.Sets.Ore[Main.tile[num211, num212 + 2].type])
												{
													Main.tile[num211, num212 + 2].type = 2;
												}
											}
											KillTile(num211, num212);
											if (genRand.Next(2) == 0)
											{
												Main.tile[num211, num212 + 1].slope(0);
												Main.tile[num211, num212 + 1].halfBrick(halfBrick: false);
											}
											PlaceTile(num211, num212, 3);
											if (Main.tile[num211, num212].active() && Main.tile[num211, num212].type == 3)
											{
												Main.tile[num211, num212].frameX = (short)((num210 + genRand.Next(3)) * 18);
												if (genRand.Next(3) != 0)
												{
													Main.tile[num211, num212].type = 73;
												}
											}
											if (Main.tile[num211, num212 + 2].type == 40 || Main.tile[num211, num212 + 2].type == 1 || TileID.Sets.Ore[Main.tile[num211, num212 + 2].type])
											{
												Main.tile[num211, num212 + 2].type = 0;
											}
										}
									}
								}
							}
							break;
						}
					}
				}
			}
		});
		AddGenerationPass("Mushrooms", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[45].Value;
			int num189 = (int)((double)Main.maxTilesX * 0.002);
			if (remixWorldGen)
			{
				num189 *= 9;
			}
			for (int num190 = 0; num190 < num189; num190++)
			{
				progress.Set((double)num190 / (double)num189);
				int num191 = genRand.Next(20, Main.maxTilesX - 20);
				int num192 = genRand.Next(4, 10);
				int num193 = genRand.Next(15, 30);
				if (remixWorldGen)
				{
					num192 = genRand.Next(8, 17);
					num193 = genRand.Next(8, 17);
					int num194 = genRand.Next((int)Main.rockLayer, Main.maxTilesY - 350);
					if (Main.tile[num191, num194].active())
					{
						for (int num195 = num191 - num192; num195 < num191 + num192; num195++)
						{
							for (int num196 = num194 - num193; num196 < num194 + num193; num196++)
							{
								if (num195 < 10)
								{
									break;
								}
								if (num196 < 0)
								{
									break;
								}
								if (num195 > Main.maxTilesX - 10)
								{
									break;
								}
								if (num196 > Main.maxTilesY - 10)
								{
									break;
								}
								if (Main.tile[num195, num196].type == 3 || Main.tile[num195, num196].type == 24)
								{
									Main.tile[num195, num196].frameX = 144;
								}
								else if (Main.tile[num195, num196].type == 201)
								{
									Main.tile[num195, num196].frameX = 270;
								}
							}
						}
					}
				}
				else
				{
					for (int num197 = 1; (double)num197 < Main.worldSurface - 1.0; num197++)
					{
						if (Main.tile[num191, num197].active())
						{
							for (int num198 = num191 - num192; num198 < num191 + num192; num198++)
							{
								for (int num199 = num197 - num193; num199 < num197 + num193; num199++)
								{
									if (num198 < 10)
									{
										break;
									}
									if (num199 < 0)
									{
										break;
									}
									if (num198 > Main.maxTilesX - 10)
									{
										break;
									}
									if (num199 > Main.maxTilesY - 10)
									{
										break;
									}
									if (Main.tile[num198, num199].type == 3 || Main.tile[num198, num199].type == 24)
									{
										Main.tile[num198, num199].frameX = 144;
									}
									else if (Main.tile[num198, num199].type == 201)
									{
										Main.tile[num198, num199].frameX = 270;
									}
								}
							}
							break;
						}
					}
				}
			}
		});
		AddGenerationPass("Gems In Ice Biome", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Set(1.0);
			for (int num178 = 0; (double)num178 < (double)Main.maxTilesX * 0.25; num178++)
			{
				int num179 = ((!remixWorldGen) ? genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, GenVars.lavaLine) : genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300));
				int num180 = genRand.Next(GenVars.snowMinX[num179], GenVars.snowMaxX[num179]);
				if (Main.tile[num180, num179].active() && (Main.tile[num180, num179].type == 147 || Main.tile[num180, num179].type == 161 || Main.tile[num180, num179].type == 162 || Main.tile[num180, num179].type == 224))
				{
					int num181 = genRand.Next(1, 4);
					int num182 = genRand.Next(1, 4);
					int num183 = genRand.Next(1, 4);
					int num184 = genRand.Next(1, 4);
					int num185 = genRand.Next(12);
					int num186 = 0;
					num186 = ((num185 >= 3) ? ((num185 < 6) ? 1 : ((num185 < 8) ? 2 : ((num185 < 10) ? 3 : ((num185 >= 11) ? 5 : 4)))) : 0);
					for (int num187 = num180 - num181; num187 < num180 + num182; num187++)
					{
						for (int num188 = num179 - num183; num188 < num179 + num184; num188++)
						{
							if (!Main.tile[num187, num188].active())
							{
								PlaceTile(num187, num188, 178, mute: true, forced: false, -1, num186);
							}
						}
					}
				}
			}
		});
		AddGenerationPass("Random Gems", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Set(1.0);
			for (int num164 = 0; num164 < Main.maxTilesX; num164++)
			{
				int num165 = genRand.Next(20, Main.maxTilesX - 20);
				int num166 = genRand.Next((int)Main.rockLayer, Main.maxTilesY - 300);
				if (!Main.tile[num165, num166].active() && !Main.tile[num165, num166].lava() && !Main.wallDungeon[Main.tile[num165, num166].wall] && Main.tile[num165, num166].wall != 27)
				{
					int num167 = genRand.Next(12);
					int num168 = 0;
					num168 = ((num167 >= 3) ? ((num167 < 6) ? 1 : ((num167 < 8) ? 2 : ((num167 < 10) ? 3 : ((num167 >= 11) ? 5 : 4)))) : 0);
					PlaceTile(num165, num166, 178, mute: true, forced: false, -1, num168);
				}
			}
			for (int num169 = 0; num169 < Main.maxTilesX; num169++)
			{
				int num170 = genRand.Next(20, Main.maxTilesX - 20);
				int num171 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300);
				if (!Main.tile[num170, num171].active() && !Main.tile[num170, num171].lava() && (Main.tile[num170, num171].wall == 216 || Main.tile[num170, num171].wall == 187))
				{
					int num172 = genRand.Next(1, 4);
					int num173 = genRand.Next(1, 4);
					int num174 = genRand.Next(1, 4);
					int num175 = genRand.Next(1, 4);
					for (int num176 = num170 - num172; num176 < num170 + num173; num176++)
					{
						for (int num177 = num171 - num174; num177 < num171 + num175; num177++)
						{
							if (!Main.tile[num176, num177].active())
							{
								PlaceTile(num176, num177, 178, mute: true, forced: false, -1, 6);
							}
						}
					}
				}
			}
		});
		AddGenerationPass("Moss Grass", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Set(1.0);
			for (int num159 = 5; num159 < Main.maxTilesX - 5; num159++)
			{
				for (int num160 = 5; num160 < Main.maxTilesY - 5; num160++)
				{
					if (Main.tile[num159, num160].active() && Main.tileMoss[Main.tile[num159, num160].type])
					{
						for (int num161 = 0; num161 < 4; num161++)
						{
							int num162 = num159;
							int num163 = num160;
							if (num161 == 0)
							{
								num162--;
							}
							if (num161 == 1)
							{
								num162++;
							}
							if (num161 == 2)
							{
								num163--;
							}
							if (num161 == 3)
							{
								num163++;
							}
							if (!Main.tile[num162, num163].active())
							{
								PlaceTile(num162, num163, 184, mute: true);
							}
						}
					}
				}
			}
		});
		AddGenerationPass("Muds Walls In Jungle", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Set(1.0);
			int num151 = 0;
			int num152 = 0;
			bool flag4 = false;
			for (int num153 = 5; num153 < Main.maxTilesX - 5; num153++)
			{
				for (int num154 = 0; (double)num154 < Main.worldSurface + 20.0; num154++)
				{
					if (Main.tile[num153, num154].active() && Main.tile[num153, num154].type == 60)
					{
						num151 = num153;
						flag4 = true;
						break;
					}
				}
				if (flag4)
				{
					break;
				}
			}
			flag4 = false;
			for (int num155 = Main.maxTilesX - 5; num155 > 5; num155--)
			{
				for (int num156 = 0; (double)num156 < Main.worldSurface + 20.0; num156++)
				{
					if (Main.tile[num155, num156].active() && Main.tile[num155, num156].type == 60)
					{
						num152 = num155;
						flag4 = true;
						break;
					}
				}
				if (flag4)
				{
					break;
				}
			}
			GenVars.jungleMinX = num151;
			GenVars.jungleMaxX = num152;
			for (int num157 = num151; num157 <= num152; num157++)
			{
				for (int num158 = 0; (double)num158 < Main.worldSurface + 20.0; num158++)
				{
					if (((num157 >= num151 + 2 && num157 <= num152 - 2) || genRand.Next(2) != 0) && ((num157 >= num151 + 3 && num157 <= num152 - 3) || genRand.Next(3) != 0) && (Main.tile[num157, num158].wall == 2 || Main.tile[num157, num158].wall == 59))
					{
						Main.tile[num157, num158].wall = 15;
					}
				}
			}
		});
		AddGenerationPass("Larva", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			Main.tileSolid[229] = true;
			progress.Set(1.0);
			for (int num146 = 0; num146 < GenVars.numLarva; num146++)
			{
				int num147 = GenVars.larvaX[num146];
				int num148 = GenVars.larvaY[num146];
				for (int num149 = num147 - 1; num149 <= num147 + 1; num149++)
				{
					for (int num150 = num148 - 2; num150 <= num148 + 1; num150++)
					{
						if (num150 != num148 + 1)
						{
							Main.tile[num149, num150].active(active: false);
						}
						else
						{
							Main.tile[num149, num150].active(active: true);
							Main.tile[num149, num150].type = 225;
							Main.tile[num149, num150].slope(0);
							Main.tile[num149, num150].halfBrick(halfBrick: false);
						}
					}
				}
				PlaceTile(num147, num148, 231, mute: true);
			}
			Main.tileSolid[232] = true;
			Main.tileSolid[162] = true;
		});
		AddGenerationPass("Settle Liquids Again", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			if (getGoodWorldGen)
			{
				Main.tileSolid[56] = true;
			}
			progress.Message = Lang.gen[27].Value;
			if (notTheBees)
			{
				NotTheBees();
			}
			Liquid.worldGenTilesIgnoreWater(ignoreSolids: true);
			Liquid.QuickWater(3);
			WaterCheck();
			int num140 = 0;
			Liquid.quickSettle = true;
			int num141 = 10;
			while (num140 < num141)
			{
				int num142 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
				num140++;
				double num143 = 0.0;
				int num144 = num142 * 5;
				while (Liquid.numLiquid > 0)
				{
					num144--;
					if (num144 < 0)
					{
						break;
					}
					double num145 = (double)(num142 - (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer)) / (double)num142;
					if (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer > num142)
					{
						num142 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
					}
					if (num145 > num143)
					{
						num143 = num145;
					}
					else
					{
						num145 = num143;
					}
					if (num140 == 1)
					{
						progress.Set(num145 / 3.0 + 0.33);
					}
					Liquid.UpdateLiquid();
				}
				WaterCheck();
				progress.Set((double)num140 / (double)num141 / 3.0 + 0.66);
			}
			Liquid.quickSettle = false;
			Liquid.worldGenTilesIgnoreWater(ignoreSolids: false);
			Main.tileSolid[484] = false;
		});
		AddGenerationPass("Cactus, Palm Trees, & Coral", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[38].Value;
			int num114 = 8;
			if (remixWorldGen)
			{
				num114 = 2;
			}
			int num115 = 400;
			int num116 = genRand.Next(3, 13);
			int num117 = genRand.Next(3, 13);
			genRand.Next(2, 6);
			genRand.Next(2, 6);
			int num118 = 380;
			for (int num119 = 0; num119 < GenVars.numOasis; num119++)
			{
				int num120 = (int)((double)GenVars.oasisWidth[num119] * 1.5);
				for (int num121 = GenVars.oasisPosition[num119].X - num120; num121 <= GenVars.oasisPosition[num119].X + num120; num121++)
				{
					for (int num122 = GenVars.oasisPosition[num119].Y - GenVars.oasisHeight; num122 <= GenVars.oasisPosition[num119].Y + GenVars.oasisHeight; num122++)
					{
						double num123 = 1.0;
						int num124 = 8;
						for (int num125 = num121 - num124; num125 <= num121 + num124; num125++)
						{
							for (int num126 = num122 - num124; num126 <= num122 + num124; num126++)
							{
								if (InWorld(num125, num126) && Main.tile[num125, num126] != null && Main.tile[num125, num126].active() && Main.tile[num125, num126].type == 323)
								{
									num123 = 0.13;
								}
							}
						}
						if (genRand.NextDouble() < num123)
						{
							GrowPalmTree(num121, num122);
						}
						if (PlantSeaOat(num121, num122))
						{
							if (genRand.Next(2) == 0)
							{
								GrowSeaOat(num121, num122);
							}
							if (genRand.Next(2) == 0)
							{
								GrowSeaOat(num121, num122);
							}
						}
						PlaceOasisPlant(num121, num122, 530);
					}
				}
			}
			for (int num127 = 0; num127 < 3; num127++)
			{
				progress.Set((double)num127 / 3.0);
				int num128;
				int num129;
				bool flag3;
				int maxValue4;
				switch (num127)
				{
				default:
					num128 = 5;
					num129 = num118;
					flag3 = false;
					maxValue4 = num116;
					break;
				case 1:
					num128 = num115;
					num129 = Main.maxTilesX - num115;
					flag3 = true;
					maxValue4 = num114;
					break;
				case 2:
					num128 = Main.maxTilesX - num118;
					num129 = Main.maxTilesX - 5;
					flag3 = false;
					maxValue4 = num117;
					break;
				}
				double num130 = Main.worldSurface - 1.0;
				if (remixWorldGen)
				{
					num130 = Main.maxTilesY - 50;
				}
				for (int num131 = num128; num131 < num129; num131++)
				{
					if (genRand.Next(maxValue4) == 0)
					{
						for (int num132 = 0; (double)num132 < num130; num132++)
						{
							Tile tile5 = Main.tile[num131, num132];
							if (tile5.active() && (tile5.type == 53 || tile5.type == 112 || tile5.type == 234))
							{
								Tile tile6 = Main.tile[num131, num132 - 1];
								if (!tile6.active() && tile6.wall == 0)
								{
									if (flag3)
									{
										if (remixWorldGen)
										{
											if ((double)num132 > Main.worldSurface)
											{
												if (SolidTile(num131, num132) && Main.tile[num131, num132 + 1].type == 53 && Main.tile[num131, num132 + 2].type == 53)
												{
													int maxValue5 = 3;
													GrowPalmTree(num131, num132);
													if (!Main.tile[num131, num132 - 1].active() && genRand.Next(maxValue5) == 0)
													{
														PlantCactus(num131, num132);
													}
												}
											}
											else
											{
												int num133 = 0;
												for (int num134 = num131 - cactusWaterWidth; num134 < num131 + cactusWaterWidth; num134++)
												{
													for (int num135 = num132 - cactusWaterHeight; num135 < num132 + cactusWaterHeight; num135++)
													{
														num133 += Main.tile[num134, num135].liquid;
													}
												}
												if (num133 / 255 > cactusWaterLimit)
												{
													int maxValue6 = 4;
													if (genRand.Next(maxValue6) == 0)
													{
														GrowPalmTree(num131, num132);
													}
												}
												else
												{
													PlantCactus(num131, num132);
												}
											}
										}
										else
										{
											int num136 = 0;
											for (int num137 = num131 - cactusWaterWidth; num137 < num131 + cactusWaterWidth; num137++)
											{
												for (int num138 = num132 - cactusWaterHeight; num138 < num132 + cactusWaterHeight; num138++)
												{
													num136 += Main.tile[num137, num138].liquid;
												}
											}
											if (num136 / 255 > cactusWaterLimit)
											{
												int maxValue7 = 4;
												if (genRand.Next(maxValue7) == 0)
												{
													GrowPalmTree(num131, num132);
												}
											}
											else
											{
												PlantCactus(num131, num132);
											}
										}
									}
									else
									{
										if (Main.tile[num131, num132 - 2].liquid == byte.MaxValue && Main.tile[num131, num132 - 3].liquid == byte.MaxValue && Main.tile[num131, num132 - 4].liquid == byte.MaxValue)
										{
											if (genRand.Next(2) == 0)
											{
												PlaceTile(num131, num132 - 1, 81, mute: true);
											}
											else
											{
												PlaceTile(num131, num132 - 1, 324, mute: true, forced: false, -1, RollRandomSeaShellStyle());
											}
											break;
										}
										if (Main.tile[num131, num132 - 2].liquid == 0 && (double)num132 < Main.worldSurface)
										{
											PlaceTile(num131, num132 - 1, 324, mute: true, forced: false, -1, RollRandomSeaShellStyle());
											break;
										}
									}
								}
							}
						}
					}
					else
					{
						for (int num139 = 0; (double)num139 < num130; num139++)
						{
							if (PlantSeaOat(num131, num139))
							{
								if (genRand.Next(2) == 0)
								{
									GrowSeaOat(num131, num139);
								}
								if (genRand.Next(2) == 0)
								{
									GrowSeaOat(num131, num139);
								}
							}
							PlaceOasisPlant(num131, num139, 530);
						}
					}
				}
			}
		});
		AddGenerationPass("Tile Cleanup", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Message = Lang.gen[84].Value;
			for (int num57 = 40; num57 < Main.maxTilesX - 40; num57++)
			{
				progress.Set((double)(num57 - 40) / (double)(Main.maxTilesX - 80));
				for (int num58 = 40; num58 < Main.maxTilesY - 40; num58++)
				{
					if (Main.tile[num57, num58].active() && Main.tile[num57, num58].topSlope() && ((Main.tile[num57, num58].leftSlope() && Main.tile[num57 + 1, num58].halfBrick()) || (Main.tile[num57, num58].rightSlope() && Main.tile[num57 - 1, num58].halfBrick())))
					{
						Main.tile[num57, num58].slope(0);
						Main.tile[num57, num58].halfBrick(halfBrick: true);
					}
					if (Main.tile[num57, num58].active() && Main.tile[num57, num58].liquid > 0 && TileID.Sets.SlowlyDiesInWater[Main.tile[num57, num58].type])
					{
						KillTile(num57, num58);
					}
					if (!Main.tile[num57, num58].active() && Main.tile[num57, num58].liquid == 0 && genRand.Next(3) != 0 && SolidTile(num57, num58 - 1))
					{
						int num59 = genRand.Next(15, 21);
						for (int num60 = num58 - 2; num60 >= num58 - num59; num60--)
						{
							if (Main.tile[num57, num60].liquid >= 128 && !Main.tile[num57, num60].shimmer())
							{
								int num61 = 373;
								if (Main.tile[num57, num60].lava())
								{
									num61 = 374;
								}
								else if (Main.tile[num57, num60].honey())
								{
									num61 = 375;
								}
								int maxValue3 = num58 - num60;
								if (genRand.Next(maxValue3) <= 1)
								{
									if (Main.tile[num57, num58].wall == 86)
									{
										num61 = 375;
									}
									Main.tile[num57, num58].type = (ushort)num61;
									Main.tile[num57, num58].frameX = 0;
									Main.tile[num57, num58].frameY = 0;
									Main.tile[num57, num58].active(active: true);
									break;
								}
							}
						}
						if (!Main.tile[num57, num58].active())
						{
							num59 = genRand.Next(3, 11);
							for (int num62 = num58 + 1; num62 <= num58 + num59; num62++)
							{
								if (Main.tile[num57, num62].liquid >= 200 && !Main.tile[num57, num62].shimmer())
								{
									int num63 = 373;
									if (Main.tile[num57, num62].lava())
									{
										num63 = 374;
									}
									else if (Main.tile[num57, num62].honey())
									{
										num63 = 375;
									}
									int num64 = num62 - num58;
									if (genRand.Next(num64 * 3) <= 1)
									{
										Main.tile[num57, num58].type = (ushort)num63;
										Main.tile[num57, num58].frameX = 0;
										Main.tile[num57, num58].frameY = 0;
										Main.tile[num57, num58].active(active: true);
										break;
									}
								}
							}
						}
						if (!Main.tile[num57, num58].active() && genRand.Next(4) == 0)
						{
							Tile tile4 = Main.tile[num57, num58 - 1];
							if (TileID.Sets.Conversion.Sandstone[tile4.type] || TileID.Sets.Conversion.HardenedSand[tile4.type])
							{
								Main.tile[num57, num58].type = 461;
								Main.tile[num57, num58].frameX = 0;
								Main.tile[num57, num58].frameY = 0;
								Main.tile[num57, num58].active(active: true);
							}
						}
					}
					if (Main.tile[num57, num58].type == 137)
					{
						int num65 = Main.tile[num57, num58].frameY / 18;
						if (num65 <= 2 || num65 == 5)
						{
							int num66 = -1;
							if (Main.tile[num57, num58].frameX >= 18)
							{
								num66 = 1;
							}
							if (Main.tile[num57 + num66, num58].halfBrick() || Main.tile[num57 + num66, num58].slope() != 0)
							{
								Main.tile[num57 + num66, num58].active(active: false);
							}
						}
					}
					else if (Main.tile[num57, num58].type == 162 && Main.tile[num57, num58 + 1].liquid == 0 && CanKillTile(num57, num58))
					{
						Main.tile[num57, num58].active(active: false);
					}
					if (Main.tile[num57, num58].wall == 13 || Main.tile[num57, num58].wall == 14)
					{
						Main.tile[num57, num58].liquid = 0;
					}
					if (Main.tile[num57, num58].type == 31)
					{
						int num67 = Main.tile[num57, num58].frameX / 18;
						int num68 = 0;
						int num69 = num57;
						num68 += num67 / 2;
						num68 = (drunkWorldGen ? ((Main.tile[num57, num58].wall == 83) ? 1 : 0) : (crimson ? 1 : 0));
						num67 %= 2;
						num69 -= num67;
						int num70 = Main.tile[num57, num58].frameY / 18;
						int num71 = 0;
						int num72 = num58;
						num71 += num70 / 2;
						num70 %= 2;
						num72 -= num70;
						for (int num73 = 0; num73 < 2; num73++)
						{
							for (int num74 = 0; num74 < 2; num74++)
							{
								int x6 = num69 + num73;
								int y6 = num72 + num74;
								Main.tile[x6, y6].active(active: true);
								Main.tile[x6, y6].slope(0);
								Main.tile[x6, y6].halfBrick(halfBrick: false);
								Main.tile[x6, y6].type = 31;
								Main.tile[x6, y6].frameX = (short)(num73 * 18 + 36 * num68);
								Main.tile[x6, y6].frameY = (short)(num74 * 18 + 36 * num71);
							}
						}
					}
					if (Main.tile[num57, num58].type == 12)
					{
						int num75 = Main.tile[num57, num58].frameX / 18;
						int num76 = 0;
						int num77 = num57;
						num76 += num75 / 2;
						num75 %= 2;
						num77 -= num75;
						int num78 = Main.tile[num57, num58].frameY / 18;
						int num79 = 0;
						int num80 = num58;
						num79 += num78 / 2;
						num78 %= 2;
						num80 -= num78;
						for (int num81 = 0; num81 < 2; num81++)
						{
							for (int num82 = 0; num82 < 2; num82++)
							{
								int x7 = num77 + num81;
								int y7 = num80 + num82;
								Main.tile[x7, y7].active(active: true);
								Main.tile[x7, y7].slope(0);
								Main.tile[x7, y7].halfBrick(halfBrick: false);
								Main.tile[x7, y7].type = 12;
								Main.tile[x7, y7].frameX = (short)(num81 * 18 + 36 * num76);
								Main.tile[x7, y7].frameY = (short)(num82 * 18 + 36 * num79);
							}
							if (!Main.tile[num81, num58 + 2].active())
							{
								Main.tile[num81, num58 + 2].active(active: true);
								if (!Main.tileSolid[Main.tile[num81, num58 + 2].type] || Main.tileSolidTop[Main.tile[num81, num58 + 2].type])
								{
									Main.tile[num81, num58 + 2].type = 0;
								}
							}
							Main.tile[num81, num58 + 2].slope(0);
							Main.tile[num81, num58 + 2].halfBrick(halfBrick: false);
						}
					}
					if (Main.tile[num57, num58].type == 639)
					{
						int num83 = Main.tile[num57, num58].frameX / 18;
						int num84 = 0;
						int num85 = num57;
						num84 += num83 / 2;
						num83 %= 2;
						num85 -= num83;
						int num86 = Main.tile[num57, num58].frameY / 18;
						int num87 = 0;
						int num88 = num58;
						num87 += num86 / 2;
						num86 %= 2;
						num88 -= num86;
						for (int num89 = 0; num89 < 2; num89++)
						{
							for (int num90 = 0; num90 < 2; num90++)
							{
								int x8 = num85 + num89;
								int y8 = num88 + num90;
								Main.tile[x8, y8].active(active: true);
								Main.tile[x8, y8].slope(0);
								Main.tile[x8, y8].halfBrick(halfBrick: false);
								Main.tile[x8, y8].type = 639;
								Main.tile[x8, y8].frameX = (short)(num89 * 18 + 36 * num84);
								Main.tile[x8, y8].frameY = (short)(num90 * 18 + 36 * num87);
							}
							if (!Main.tile[num89, num58 + 2].active())
							{
								Main.tile[num89, num58 + 2].active(active: true);
								if (!Main.tileSolid[Main.tile[num89, num58 + 2].type] || Main.tileSolidTop[Main.tile[num89, num58 + 2].type])
								{
									Main.tile[num89, num58 + 2].type = 0;
								}
							}
							Main.tile[num89, num58 + 2].slope(0);
							Main.tile[num89, num58 + 2].halfBrick(halfBrick: false);
						}
					}
					if (TileID.Sets.BasicChest[Main.tile[num57, num58].type])
					{
						int num91 = Main.tile[num57, num58].frameX / 18;
						int num92 = 0;
						ushort num93 = 21;
						int num94 = num57;
						int num95 = num58 - Main.tile[num57, num58].frameY / 18;
						if (Main.tile[num57, num58].type == 467)
						{
							num93 = 467;
						}
						if (TileID.Sets.BasicChest[Main.tile[num57, num58].type])
						{
							num93 = Main.tile[num57, num58].type;
						}
						while (num91 >= 2)
						{
							num92++;
							num91 -= 2;
						}
						num94 -= num91;
						int num96 = Chest.FindChest(num94, num95);
						if (num96 != -1)
						{
							switch (Main.chest[num96].item[0].type)
							{
							case 1156:
								num92 = 23;
								break;
							case 1571:
								num92 = 24;
								break;
							case 1569:
								num92 = 25;
								break;
							case 1260:
								num92 = 26;
								break;
							case 1572:
								num92 = 27;
								break;
							}
						}
						for (int num97 = 0; num97 < 2; num97++)
						{
							for (int num98 = 0; num98 < 2; num98++)
							{
								int x9 = num94 + num97;
								int y9 = num95 + num98;
								Main.tile[x9, y9].active(active: true);
								Main.tile[x9, y9].slope(0);
								Main.tile[x9, y9].halfBrick(halfBrick: false);
								Main.tile[x9, y9].type = num93;
								Main.tile[x9, y9].frameX = (short)(num97 * 18 + 36 * num92);
								Main.tile[x9, y9].frameY = (short)(num98 * 18);
							}
							if (!Main.tile[num97, num58 + 2].active())
							{
								Main.tile[num97, num58 + 2].active(active: true);
								if (!Main.tileSolid[Main.tile[num97, num58 + 2].type] || Main.tileSolidTop[Main.tile[num97, num58 + 2].type])
								{
									Main.tile[num97, num58 + 2].type = 0;
								}
							}
							Main.tile[num97, num58 + 2].slope(0);
							Main.tile[num97, num58 + 2].halfBrick(halfBrick: false);
						}
					}
					if (Main.tile[num57, num58].type == 28)
					{
						int num99 = Main.tile[num57, num58].frameX / 18;
						int num100 = 0;
						int num101 = num57;
						while (num99 >= 2)
						{
							num100++;
							num99 -= 2;
						}
						num101 -= num99;
						int num102 = Main.tile[num57, num58].frameY / 18;
						int num103 = 0;
						int num104 = num58;
						while (num102 >= 2)
						{
							num103++;
							num102 -= 2;
						}
						num104 -= num102;
						for (int num105 = 0; num105 < 2; num105++)
						{
							for (int num106 = 0; num106 < 2; num106++)
							{
								int x10 = num101 + num105;
								int y10 = num104 + num106;
								Main.tile[x10, y10].active(active: true);
								Main.tile[x10, y10].slope(0);
								Main.tile[x10, y10].halfBrick(halfBrick: false);
								Main.tile[x10, y10].type = 28;
								Main.tile[x10, y10].frameX = (short)(num105 * 18 + 36 * num100);
								Main.tile[x10, y10].frameY = (short)(num106 * 18 + 36 * num103);
							}
							if (!Main.tile[num105, num58 + 2].active())
							{
								Main.tile[num105, num58 + 2].active(active: true);
								if (!Main.tileSolid[Main.tile[num105, num58 + 2].type] || Main.tileSolidTop[Main.tile[num105, num58 + 2].type])
								{
									Main.tile[num105, num58 + 2].type = 0;
								}
							}
							Main.tile[num105, num58 + 2].slope(0);
							Main.tile[num105, num58 + 2].halfBrick(halfBrick: false);
						}
					}
					if (Main.tile[num57, num58].type == 26)
					{
						int num107 = Main.tile[num57, num58].frameX / 18;
						int num108 = 0;
						int num109 = num57;
						int num110 = num58 - Main.tile[num57, num58].frameY / 18;
						while (num107 >= 3)
						{
							num108++;
							num107 -= 3;
						}
						num109 -= num107;
						num108 = ((!drunkWorldGen) ? (crimson ? 1 : 0) : ((Main.tile[num57, num58].wall == 83) ? 1 : 0));
						for (int num111 = 0; num111 < 3; num111++)
						{
							for (int num112 = 0; num112 < 2; num112++)
							{
								int x11 = num109 + num111;
								int y11 = num110 + num112;
								Main.tile[x11, y11].active(active: true);
								Main.tile[x11, y11].slope(0);
								Main.tile[x11, y11].halfBrick(halfBrick: false);
								Main.tile[x11, y11].type = 26;
								Main.tile[x11, y11].frameX = (short)(num111 * 18 + 54 * num108);
								Main.tile[x11, y11].frameY = (short)(num112 * 18);
							}
							if (!Main.tile[num109 + num111, num110 + 2].active() || !Main.tileSolid[Main.tile[num109 + num111, num110 + 2].type] || Main.tileSolidTop[Main.tile[num109 + num111, num110 + 2].type])
							{
								Main.tile[num109 + num111, num110 + 2].active(active: true);
								if (!TileID.Sets.Platforms[Main.tile[num109 + num111, num110 + 2].type])
								{
									if (Main.tile[num109 + num111, num110 + 2].type == 484)
									{
										Main.tile[num109 + num111, num110 + 2].type = 397;
									}
									else if (TileID.Sets.Boulders[Main.tile[num109 + num111, num110 + 2].type] || !Main.tileSolid[Main.tile[num109 + num111, num110 + 2].type] || Main.tileSolidTop[Main.tile[num109 + num111, num110 + 2].type])
									{
										Main.tile[num109 + num111, num110 + 2].type = 0;
									}
								}
							}
							Main.tile[num109 + num111, num110 + 2].slope(0);
							Main.tile[num109 + num111, num110 + 2].halfBrick(halfBrick: false);
							if (Main.tile[num109 + num111, num110 + 3].type == 28 && Main.tile[num109 + num111, num110 + 3].frameY % 36 >= 18)
							{
								Main.tile[num109 + num111, num110 + 3].type = 0;
								Main.tile[num109 + num111, num110 + 3].active(active: false);
							}
						}
						for (int num113 = 0; num113 < 3; num113++)
						{
							if ((Main.tile[num109 - 1, num110 + num113].type == 28 || Main.tile[num109 - 1, num110 + num113].type == 12 || Main.tile[num109 - 1, num110 + num113].type == 639) && Main.tile[num109 - 1, num110 + num113].frameX % 36 < 18)
							{
								Main.tile[num109 - 1, num110 + num113].type = 0;
								Main.tile[num109 - 1, num110 + num113].active(active: false);
							}
							if ((Main.tile[num109 + 3, num110 + num113].type == 28 || Main.tile[num109 + 3, num110 + num113].type == 12 || Main.tile[num109 - 1, num110 + num113].type == 639) && Main.tile[num109 + 3, num110 + num113].frameX % 36 >= 18)
							{
								Main.tile[num109 + 3, num110 + num113].type = 0;
								Main.tile[num109 + 3, num110 + num113].active(active: false);
							}
						}
					}
					if (Main.tile[num57, num58].type == 237 && Main.tile[num57, num58 + 1].type == 232)
					{
						Main.tile[num57, num58 + 1].type = 226;
					}
					if (Main.tile[num57, num58].wall == 87)
					{
						Main.tile[num57, num58].liquid = 0;
					}
				}
			}
		});
		AddGenerationPass("Lihzahrd Altars", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Set(1.0);
			for (int num53 = 0; num53 < 3; num53++)
			{
				for (int num54 = 0; num54 < 2; num54++)
				{
					int x5 = GenVars.lAltarX + num53;
					int y5 = GenVars.lAltarY + num54;
					Main.tile[x5, y5].active(active: true);
					Main.tile[x5, y5].type = 237;
					Main.tile[x5, y5].frameX = (short)(num53 * 18);
					Main.tile[x5, y5].frameY = (short)(num54 * 18);
				}
				Main.tile[GenVars.lAltarX + num53, GenVars.lAltarY + 2].active(active: true);
				Main.tile[GenVars.lAltarX + num53, GenVars.lAltarY + 2].slope(0);
				Main.tile[GenVars.lAltarX + num53, GenVars.lAltarY + 2].halfBrick(halfBrick: false);
				Main.tile[GenVars.lAltarX + num53, GenVars.lAltarY + 2].type = 226;
			}
			for (int num55 = 0; num55 < 3; num55++)
			{
				for (int num56 = 0; num56 < 2; num56++)
				{
					int i2 = GenVars.lAltarX + num55;
					int j2 = GenVars.lAltarY + num56;
					SquareTileFrame(i2, j2);
				}
			}
		});
		AddGenerationPass("Micro Biomes", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_0182: Unknown result type (might be due to invalid IL or missing references)
			//IL_0243: Unknown result type (might be due to invalid IL or missing references)
			//IL_03ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_055d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0622: Unknown result type (might be due to invalid IL or missing references)
			//IL_04c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0494: Unknown result type (might be due to invalid IL or missing references)
			//IL_06cd: Unknown result type (might be due to invalid IL or missing references)
			progress.Message = Lang.gen[76].Value + "..Dead Man's Chests";
			_ = (double)(Main.maxTilesX * Main.maxTilesY) / 5040000.0;
			double num31 = 10.0;
			if (getGoodWorldGen || noTrapsWorldGen)
			{
				num31 *= 3.0;
			}
			DeadMansChestBiome deadMansChestBiome = GenVars.configuration.CreateBiome<DeadMansChestBiome>();
			List<int> possibleChestsToTrapify = deadMansChestBiome.GetPossibleChestsToTrapify(GenVars.structures);
			int random = passConfig.Get<WorldGenRange>("DeadManChests").GetRandom(genRand);
			int num32 = 0;
			int num33 = 3000;
			Point origin = default(Point);
			while (num32 < random && possibleChestsToTrapify.Count > 0)
			{
				num33--;
				if (num33 <= 0)
				{
					break;
				}
				int num34 = possibleChestsToTrapify[genRand.Next(possibleChestsToTrapify.Count)];
				((Point)(ref origin))._002Ector(Main.chest[num34].x, Main.chest[num34].y);
				deadMansChestBiome.Place(origin, GenVars.structures);
				num32++;
				possibleChestsToTrapify.Remove(num34);
			}
			progress.Message = Lang.gen[76].Value + "..Thin Ice";
			progress.Set(1.0 / num31);
			if (!notTheBees || remixWorldGen)
			{
				ThinIceBiome thinIceBiome = GenVars.configuration.CreateBiome<ThinIceBiome>();
				int random2 = passConfig.Get<WorldGenRange>("ThinIcePatchCount").GetRandom(genRand);
				int num35 = 0;
				int num36 = 1000;
				int num37 = 0;
				while (num37 < random2)
				{
					if (thinIceBiome.Place(RandomWorldPoint((int)Main.worldSurface + 20, 50, 200, 50), GenVars.structures))
					{
						num37++;
						num35 = 0;
					}
					else
					{
						num35++;
						if (num35 > num36)
						{
							num37++;
							num35 = 0;
						}
					}
				}
			}
			progress.Message = Lang.gen[76].Value + "..Sword Shrines";
			progress.Set(0.1);
			progress.Set(2.0 / num31);
			EnchantedSwordBiome enchantedSwordBiome = GenVars.configuration.CreateBiome<EnchantedSwordBiome>();
			int num38 = passConfig.Get<WorldGenRange>("SwordShrineAttempts").GetRandom(genRand);
			double num39 = passConfig.Get<double>("SwordShrinePlacementChance");
			if (tenthAnniversaryWorldGen)
			{
				num38 *= 2;
				num39 /= 2.0;
			}
			Point origin2 = default(Point);
			for (int num40 = 0; num40 < num38; num40++)
			{
				if ((num40 == 0 && tenthAnniversaryWorldGen) || !(genRand.NextDouble() > num39))
				{
					int num41 = 0;
					while (num41++ <= Main.maxTilesX)
					{
						origin2.Y = (int)GenVars.worldSurface + genRand.Next(50, 100);
						if (genRand.Next(2) == 0)
						{
							origin2.X = genRand.Next(50, (int)((double)Main.maxTilesX * 0.3));
						}
						else
						{
							origin2.X = genRand.Next((int)((double)Main.maxTilesX * 0.7), Main.maxTilesX - 50);
						}
						if (enchantedSwordBiome.Place(origin2, GenVars.structures))
						{
							break;
						}
					}
				}
			}
			progress.Message = Lang.gen[76].Value + "..Campsites";
			progress.Set(0.2);
			progress.Set(3.0 / num31);
			if (!notTheBees || remixWorldGen)
			{
				CampsiteBiome campsiteBiome = GenVars.configuration.CreateBiome<CampsiteBiome>();
				int random3 = passConfig.Get<WorldGenRange>("CampsiteCount").GetRandom(genRand);
				num33 = 1000;
				int num42 = 0;
				while (num42 < random3)
				{
					num33--;
					if (num33 <= 0)
					{
						break;
					}
					if (campsiteBiome.Place(RandomWorldPoint((int)Main.worldSurface, beachDistance, 200, beachDistance), GenVars.structures))
					{
						num42++;
					}
				}
			}
			progress.Message = Lang.gen[76].Value + "..Explosive Traps";
			progress.Set(4.0 / num31);
			if (!notTheBees || remixWorldGen)
			{
				MiningExplosivesBiome miningExplosivesBiome = GenVars.configuration.CreateBiome<MiningExplosivesBiome>();
				int num43 = passConfig.Get<WorldGenRange>("ExplosiveTrapCount").GetRandom(genRand);
				if ((getGoodWorldGen || noTrapsWorldGen) && !notTheBees)
				{
					num43 = (int)((double)num43 * 1.5);
				}
				num33 = 3000;
				int num44 = 0;
				while (num44 < num43)
				{
					num33--;
					if (num33 <= 0)
					{
						break;
					}
					if (remixWorldGen)
					{
						if (miningExplosivesBiome.Place(RandomWorldPoint((int)Main.worldSurface, beachDistance, (int)GenVars.rockLayer, beachDistance), GenVars.structures))
						{
							num44++;
						}
					}
					else if (miningExplosivesBiome.Place(RandomWorldPoint((int)GenVars.rockLayer, beachDistance, 200, beachDistance), GenVars.structures))
					{
						num44++;
					}
				}
			}
			progress.Message = Lang.gen[76].Value + "..Living Trees";
			progress.Set(0.3);
			progress.Set(5.0 / num31);
			MahoganyTreeBiome mahoganyTreeBiome = GenVars.configuration.CreateBiome<MahoganyTreeBiome>();
			int random4 = passConfig.Get<WorldGenRange>("LivingTreeCount").GetRandom(genRand);
			int num45 = 0;
			int num46 = 0;
			while (num45 < random4 && num46 < 20000)
			{
				if (mahoganyTreeBiome.Place(RandomWorldPoint((int)Main.worldSurface + 50, 50, 500, 50), GenVars.structures))
				{
					num45++;
				}
				num46++;
			}
			progress.Message = Lang.gen[76].Value + "..Long Minecart Tracks";
			progress.Set(0.4);
			progress.Set(6.0 / num31);
			progress.Set(7.0 / num31);
			TrackGenerator trackGenerator = new TrackGenerator();
			int random5 = passConfig.Get<WorldGenRange>("LongTrackCount").GetRandom(genRand);
			WorldGenRange worldGenRange = passConfig.Get<WorldGenRange>("LongTrackLength");
			int maxTilesX = Main.maxTilesX;
			int num47 = 0;
			int num48 = 0;
			while (num48 < random5)
			{
				if (trackGenerator.Place(RandomWorldPoint((int)Main.worldSurface, 10, 200, 10), worldGenRange.ScaledMinimum, worldGenRange.ScaledMaximum))
				{
					num48++;
					num47 = 0;
				}
				else
				{
					num47++;
					if (num47 > maxTilesX)
					{
						num48++;
						num47 = 0;
					}
				}
			}
			progress.Message = Lang.gen[76].Value + "..Standard Minecart Tracks";
			progress.Set(8.0 / num31);
			random5 = passConfig.Get<WorldGenRange>("StandardTrackCount").GetRandom(genRand);
			worldGenRange = passConfig.Get<WorldGenRange>("StandardTrackLength");
			num47 = 0;
			int num49 = 0;
			while (num49 < random5)
			{
				if (trackGenerator.Place(RandomWorldPoint((int)Main.worldSurface, 10, 200, 10), worldGenRange.ScaledMinimum, worldGenRange.ScaledMaximum))
				{
					num49++;
					num47 = 0;
				}
				else
				{
					num47++;
					if (num47 > maxTilesX)
					{
						num49++;
						num47 = 0;
					}
				}
			}
			progress.Message = Lang.gen[76].Value + "..Lava Traps";
			progress.Set(9.0 / num31);
			if (!notTheBees)
			{
				double num50 = (double)Main.maxTilesX * 0.02;
				if (noTrapsWorldGen)
				{
					num31 *= 5.0;
				}
				else if (getGoodWorldGen)
				{
					num31 *= 2.0;
				}
				for (int num51 = 0; (double)num51 < num50; num51++)
				{
					for (int num52 = 0; num52 < 10150; num52++)
					{
						int x4 = genRand.Next(200, Main.maxTilesX - 200);
						int y4 = genRand.Next(GenVars.lavaLine - 100, Main.maxTilesY - 210);
						if (placeLavaTrap(x4, y4))
						{
							break;
						}
					}
				}
			}
			progress.Set(1.0);
		});
		AddGenerationPass("Water Plants", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00de: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
			progress.Message = Lang.gen[88].Value;
			int num23 = (int)Main.worldSurface;
			if (remixWorldGen)
			{
				num23 = Main.maxTilesY - 200;
			}
			for (int num24 = 20; num24 < Main.maxTilesX - 20; num24++)
			{
				progress.Set((double)num24 / (double)Main.maxTilesX);
				for (int num25 = 1; num25 < num23; num25++)
				{
					if (genRand.Next(5) == 0 && Main.tile[num24, num25].liquid > 0)
					{
						if (!Main.tile[num24, num25].active())
						{
							if (genRand.Next(2) == 0)
							{
								PlaceLilyPad(num24, num25);
							}
							else
							{
								Point val = PlaceCatTail(num24, num25);
								if (InWorld(val.X, val.Y))
								{
									int num26 = genRand.Next(14);
									for (int num27 = 0; num27 < num26; num27++)
									{
										GrowCatTail(val.X, val.Y);
									}
									SquareTileFrame(val.X, val.Y);
								}
							}
						}
						if ((!Main.tile[num24, num25].active() || Main.tile[num24, num25].type == 61 || Main.tile[num24, num25].type == 74) && PlaceBamboo(num24, num25))
						{
							int num28 = genRand.Next(10, 20);
							for (int num29 = 0; num29 < num28 && PlaceBamboo(num24, num25 - num29); num29++)
							{
							}
						}
					}
				}
				int num30 = Main.UnderworldLayer;
				while ((double)num30 > Main.worldSurface)
				{
					if (Main.tile[num24, num30].type == 53 && genRand.Next(3) != 0)
					{
						GrowCheckSeaweed(num24, num30);
					}
					else if (Main.tile[num24, num30].type == 549)
					{
						GrowCheckSeaweed(num24, num30);
					}
					num30--;
				}
			}
		});
		AddGenerationPass("Stalac", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			progress.Set(1.0);
			for (int num19 = 20; num19 < Main.maxTilesX - 20; num19++)
			{
				for (int num20 = (int)Main.worldSurface; num20 < Main.maxTilesY - 20; num20++)
				{
					if ((Main.tenthAnniversaryWorld || drunkWorldGen || genRand.Next(5) == 0) && Main.tile[num19, num20 - 1].liquid == 0)
					{
						int num21 = genRand.Next(7);
						int treeTileType = 0;
						switch (num21)
						{
						case 0:
							treeTileType = 583;
							break;
						case 1:
							treeTileType = 584;
							break;
						case 2:
							treeTileType = 585;
							break;
						case 3:
							treeTileType = 586;
							break;
						case 4:
							treeTileType = 587;
							break;
						case 5:
							treeTileType = 588;
							break;
						case 6:
							treeTileType = 589;
							break;
						}
						TryGrowingTreeByType(treeTileType, num19, num20);
					}
					if (!oceanDepths(num19, num20) && !Main.tile[num19, num20].active() && genRand.Next(5) == 0)
					{
						if ((Main.tile[num19, num20 - 1].type == 1 || Main.tile[num19, num20 - 1].type == 147 || Main.tile[num19, num20 - 1].type == 161 || Main.tile[num19, num20 - 1].type == 25 || Main.tile[num19, num20 - 1].type == 203 || Main.tileStone[Main.tile[num19, num20 - 1].type] || Main.tileMoss[Main.tile[num19, num20 - 1].type]) && !Main.tile[num19, num20].active() && !Main.tile[num19, num20 + 1].active())
						{
							Main.tile[num19, num20 - 1].slope(0);
						}
						if ((Main.tile[num19, num20 + 1].type == 1 || Main.tile[num19, num20 + 1].type == 147 || Main.tile[num19, num20 + 1].type == 161 || Main.tile[num19, num20 + 1].type == 25 || Main.tile[num19, num20 + 1].type == 203 || Main.tileStone[Main.tile[num19, num20 + 1].type] || Main.tileMoss[Main.tile[num19, num20 + 1].type]) && !Main.tile[num19, num20].active() && !Main.tile[num19, num20 - 1].active())
						{
							Main.tile[num19, num20 + 1].slope(0);
						}
						PlaceTight(num19, num20);
					}
				}
				for (int num22 = 5; num22 < (int)Main.worldSurface; num22++)
				{
					if ((Main.tile[num19, num22 - 1].type == 147 || Main.tile[num19, num22 - 1].type == 161) && genRand.Next(5) == 0)
					{
						if (!Main.tile[num19, num22].active() && !Main.tile[num19, num22 + 1].active())
						{
							Main.tile[num19, num22 - 1].slope(0);
						}
						PlaceTight(num19, num22);
					}
					if ((Main.tile[num19, num22 - 1].type == 25 || Main.tile[num19, num22 - 1].type == 203) && genRand.Next(5) == 0)
					{
						if (!Main.tile[num19, num22].active() && !Main.tile[num19, num22 + 1].active())
						{
							Main.tile[num19, num22 - 1].slope(0);
						}
						PlaceTight(num19, num22);
					}
					if ((Main.tile[num19, num22 + 1].type == 25 || Main.tile[num19, num22 + 1].type == 203) && genRand.Next(5) == 0)
					{
						if (!Main.tile[num19, num22].active() && !Main.tile[num19, num22 - 1].active())
						{
							Main.tile[num19, num22 + 1].slope(0);
						}
						PlaceTight(num19, num22);
					}
				}
			}
		});
		AddGenerationPass("Remove Broken Traps", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			if (!noTrapsWorldGen || tenthAnniversaryWorldGen || notTheBees)
			{
				progress.Message = Lang.gen[82].Value;
				List<Point> list = new List<Point>();
				int num16 = 50;
				for (int num17 = num16; num17 < Main.maxTilesX - num16; num17++)
				{
					double value = (double)(num17 - num16) / (double)(Main.maxTilesX - num16 * 2);
					progress.Set(value);
					for (int num18 = 50; num18 < Main.maxTilesY - 50; num18++)
					{
						if (Main.tile[num17, num18].wire() && !list.Contains(new Point(num17, num18)))
						{
							ClearBrokenTraps(new Point(num17, num18), list);
						}
					}
				}
			}
		});
		AddGenerationPass("Final Cleanup", delegate(GenerationProgress progress, GameConfiguration passConfig)
		{
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			Main.tileSolid[484] = false;
			FillWallHolesInArea(new Rectangle(0, 0, Main.maxTilesX, (int)Main.worldSurface));
			progress.Message = Lang.gen[86].Value;
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				progress.Set((double)i / (double)Main.maxTilesX);
				int num = 0;
				while (num < Main.maxTilesY)
				{
					Tile tile = Main.tile[i, num];
					if (tile.active() && !SolidTile(i, num + 1))
					{
						tile = Main.tile[i, num];
						if (tile.type != 53)
						{
							tile = Main.tile[i, num];
							if (tile.type != 112)
							{
								tile = Main.tile[i, num];
								if (tile.type != 234)
								{
									tile = Main.tile[i, num];
									if (tile.type != 224)
									{
										tile = Main.tile[i, num];
										if (tile.type != 123)
										{
											goto IL_06be;
										}
									}
								}
							}
						}
						if ((double)num < Main.worldSurface + 10.0)
						{
							tile = Main.tile[i, num + 1];
							if (!tile.active())
							{
								tile = Main.tile[i, num + 1];
								if (tile.wall != 191 && !oceanDepths(i, num))
								{
									int num2 = 10;
									int num3 = num + 1;
									for (int j = num3; j < num3 + 10; j++)
									{
										tile = Main.tile[i, j];
										if (tile.active())
										{
											tile = Main.tile[i, j];
											if (tile.type == 314)
											{
												num2 = 0;
												break;
											}
										}
									}
									while (true)
									{
										tile = Main.tile[i, num3];
										if (tile.active() || num2 <= 0 || num3 >= Main.maxTilesY - 50)
										{
											break;
										}
										tile = Main.tile[i, num3 - 1];
										tile.slope(0);
										tile = Main.tile[i, num3 - 1];
										tile.halfBrick(halfBrick: false);
										tile = Main.tile[i, num3];
										tile.active(active: true);
										tile = Main.tile[i, num3];
										ref ushort type = ref tile.type;
										tile = Main.tile[i, num];
										type = tile.type;
										tile = Main.tile[i, num3];
										tile.slope(0);
										tile = Main.tile[i, num3];
										tile.halfBrick(halfBrick: false);
										num3++;
										num2--;
									}
									if (num2 == 0)
									{
										tile = Main.tile[i, num3];
										if (!tile.active())
										{
											tile = Main.tile[i, num];
											switch (tile.type)
											{
											case 53:
												tile = Main.tile[i, num3];
												tile.type = 397;
												tile = Main.tile[i, num3];
												tile.active(active: true);
												break;
											case 112:
												tile = Main.tile[i, num3];
												tile.type = 398;
												tile = Main.tile[i, num3];
												tile.active(active: true);
												break;
											case 234:
												tile = Main.tile[i, num3];
												tile.type = 399;
												tile = Main.tile[i, num3];
												tile.active(active: true);
												break;
											case 224:
												tile = Main.tile[i, num3];
												tile.type = 147;
												tile = Main.tile[i, num3];
												tile.active(active: true);
												break;
											case 123:
												tile = Main.tile[i, num3];
												tile.type = 1;
												tile = Main.tile[i, num3];
												tile.active(active: true);
												break;
											}
											goto IL_0690;
										}
									}
									tile = Main.tile[i, num3];
									if (tile.active())
									{
										bool[] tileSolid = Main.tileSolid;
										tile = Main.tile[i, num3];
										if (tileSolid[tile.type])
										{
											bool[] tileSolidTop = Main.tileSolidTop;
											tile = Main.tile[i, num3];
											if (!tileSolidTop[tile.type])
											{
												tile = Main.tile[i, num3];
												tile.slope(0);
												tile = Main.tile[i, num3];
												tile.halfBrick(halfBrick: false);
											}
										}
									}
									goto IL_0690;
								}
							}
						}
						bool[] tileSolid2 = Main.tileSolid;
						tile = Main.tile[i, num + 1];
						if (tileSolid2[tile.type])
						{
							bool[] tileSolidTop2 = Main.tileSolidTop;
							tile = Main.tile[i, num + 1];
							if (!tileSolidTop2[tile.type])
							{
								tile = Main.tile[i, num + 1];
								if (!tile.topSlope())
								{
									tile = Main.tile[i, num + 1];
									if (!tile.halfBrick())
									{
										goto IL_05aa;
									}
								}
								tile = Main.tile[i, num + 1];
								tile.slope(0);
								tile = Main.tile[i, num + 1];
								tile.halfBrick(halfBrick: false);
								goto IL_0690;
							}
						}
						goto IL_05aa;
					}
					goto IL_06be;
					IL_05aa:
					tile = Main.tile[i, num];
					switch (tile.type)
					{
					case 53:
						tile = Main.tile[i, num];
						tile.type = 397;
						break;
					case 112:
						tile = Main.tile[i, num];
						tile.type = 398;
						break;
					case 234:
						tile = Main.tile[i, num];
						tile.type = 399;
						break;
					case 224:
						tile = Main.tile[i, num];
						tile.type = 147;
						break;
					case 123:
						tile = Main.tile[i, num];
						tile.type = 1;
						break;
					}
					goto IL_0690;
					IL_0753:
					tile = Main.tile[i, num];
					if (tile.type != 485)
					{
						tile = Main.tile[i, num];
						if (tile.type != 187)
						{
							tile = Main.tile[i, num];
							if (tile.type != 165)
							{
								goto IL_07bb;
							}
						}
					}
					TileFrame(i, num);
					goto IL_07bb;
					IL_0825:
					tile = Main.tile[i, num];
					if (tile.type == 26)
					{
						TileFrame(i, num);
					}
					bool[] isATreeTrunk = TileID.Sets.IsATreeTrunk;
					tile = Main.tile[i, num];
					if (!isATreeTrunk[tile.type])
					{
						tile = Main.tile[i, num];
						if (tile.type != 323)
						{
							goto IL_0896;
						}
					}
					TileFrame(i, num);
					goto IL_0896;
					IL_0690:
					tile = Main.tile[i, num - 1];
					if (tile.type == 323)
					{
						TileFrame(i, num - 1);
					}
					goto IL_06be;
					IL_07bb:
					tile = Main.tile[i, num];
					if (tile.type == 28)
					{
						TileFrame(i, num);
					}
					tile = Main.tile[i, num];
					if (tile.type != 10)
					{
						tile = Main.tile[i, num];
						if (tile.type != 11)
						{
							goto IL_0825;
						}
					}
					TileFrame(i, num);
					goto IL_0825;
					IL_0896:
					tile = Main.tile[i, num];
					if (tile.type == 137)
					{
						tile = Main.tile[i, num];
						tile.slope(0);
						tile = Main.tile[i, num];
						tile.halfBrick(halfBrick: false);
					}
					tile = Main.tile[i, num];
					if (tile.active())
					{
						bool[] boulders = TileID.Sets.Boulders;
						tile = Main.tile[i, num];
						if (boulders[tile.type])
						{
							tile = Main.tile[i, num];
							int num4 = tile.frameX / 18;
							int num5 = i;
							num5 -= num4;
							tile = Main.tile[i, num];
							int num6 = tile.frameY / 18;
							int num7 = num;
							num7 -= num6;
							bool flag = false;
							for (int k = 0; k < 2; k++)
							{
								Tile tile2 = Main.tile[num5 + k, num7 - 1];
								if (tile2 != null && tile2.active() && tile2.type == 26)
								{
									flag = true;
									break;
								}
								for (int l = 0; l < 2; l++)
								{
									int x = num5 + k;
									int y = num7 + l;
									tile = Main.tile[x, y];
									tile.active(active: true);
									tile = Main.tile[x, y];
									tile.slope(0);
									tile = Main.tile[x, y];
									tile.halfBrick(halfBrick: false);
									tile = Main.tile[x, y];
									ref ushort type2 = ref tile.type;
									tile = Main.tile[i, num];
									type2 = tile.type;
									tile = Main.tile[x, y];
									tile.frameX = (short)(k * 18);
									tile = Main.tile[x, y];
									tile.frameY = (short)(l * 18);
								}
							}
							if (flag)
							{
								ushort num8 = 0;
								tile = Main.tile[i, num];
								if (tile.type == 484)
								{
									num8 = 397;
								}
								for (int m = 0; m < 2; m++)
								{
									for (int n = 0; n < 2; n++)
									{
										int x2 = num5 + m;
										int y2 = num7 + n;
										tile = Main.tile[x2, y2];
										tile.active(active: true);
										tile = Main.tile[x2, y2];
										tile.slope(0);
										tile = Main.tile[x2, y2];
										tile.halfBrick(halfBrick: false);
										tile = Main.tile[x2, y2];
										tile.type = num8;
										tile = Main.tile[x2, y2];
										tile.frameX = 0;
										tile = Main.tile[x2, y2];
										tile.frameY = 0;
									}
								}
							}
						}
					}
					tile = Main.tile[i, num];
					if (tile.type == 323)
					{
						tile = Main.tile[i, num];
						if (tile.liquid > 0)
						{
							KillTile(i, num);
						}
					}
					bool[] wallDungeon = Main.wallDungeon;
					tile = Main.tile[i, num];
					if (wallDungeon[tile.wall])
					{
						tile = Main.tile[i, num];
						tile.lava(lava: false);
						tile = Main.tile[i, num];
						if (tile.active())
						{
							tile = Main.tile[i, num];
							if (tile.type == 56)
							{
								KillTile(i, num);
								tile = Main.tile[i, num];
								tile.lava(lava: false);
								tile = Main.tile[i, num];
								tile.liquid = byte.MaxValue;
							}
						}
					}
					tile = Main.tile[i, num];
					if (tile.active())
					{
						tile = Main.tile[i, num];
						if (tile.type == 314)
						{
							int num9 = 15;
							int num10 = 1;
							int num11 = num;
							while (num - num11 < num9)
							{
								tile = Main.tile[i, num11];
								tile.liquid = 0;
								num11--;
							}
							for (num11 = num; num11 - num < num10; num11++)
							{
								tile = Main.tile[i, num11];
								tile.liquid = 0;
							}
						}
					}
					tile = Main.tile[i, num];
					if (tile.active())
					{
						tile = Main.tile[i, num];
						if (tile.type == 332)
						{
							tile = Main.tile[i, num + 1];
							if (!tile.active())
							{
								tile = Main.tile[i, num + 1];
								tile.ClearEverything();
								tile = Main.tile[i, num + 1];
								tile.active(active: true);
								tile = Main.tile[i, num + 1];
								tile.type = 332;
							}
						}
					}
					if (i > beachDistance && i < Main.maxTilesX - beachDistance && (double)num < Main.worldSurface)
					{
						tile = Main.tile[i, num];
						if (tile.liquid > 0)
						{
							tile = Main.tile[i, num];
							if (tile.liquid < byte.MaxValue)
							{
								tile = Main.tile[i - 1, num];
								if (tile.liquid < byte.MaxValue)
								{
									tile = Main.tile[i + 1, num];
									if (tile.liquid < byte.MaxValue)
									{
										tile = Main.tile[i, num + 1];
										if (tile.liquid < byte.MaxValue)
										{
											bool[] clouds = TileID.Sets.Clouds;
											tile = Main.tile[i - 1, num];
											if (!clouds[tile.type])
											{
												bool[] clouds2 = TileID.Sets.Clouds;
												tile = Main.tile[i + 1, num];
												if (!clouds2[tile.type])
												{
													bool[] clouds3 = TileID.Sets.Clouds;
													tile = Main.tile[i, num + 1];
													if (!clouds3[tile.type])
													{
														tile = Main.tile[i, num];
														tile.liquid = 0;
													}
												}
											}
										}
									}
								}
							}
						}
					}
					num++;
					continue;
					IL_06be:
					tile = Main.tile[i, num];
					if (tile.wall != 187)
					{
						tile = Main.tile[i, num];
						if (tile.wall != 216)
						{
							goto IL_0753;
						}
					}
					tile = Main.tile[i, num];
					if (tile.liquid > 0 && !remixWorldGen)
					{
						tile = Main.tile[i, num];
						tile.liquid = byte.MaxValue;
						tile = Main.tile[i, num];
						tile.lava(lava: true);
					}
					goto IL_0753;
				}
			}
			int num12 = 0;
			int num13 = 3;
			num13 = GetWorldSize() switch
			{
				1 => 6, 
				2 => 9, 
				_ => 3, 
			};
			if (tenthAnniversaryWorldGen)
			{
				num13 *= 5;
			}
			int num14 = 50;
			int minValue = num14;
			int minValue2 = num14;
			int maxValue = Main.maxTilesX - num14;
			int maxValue2 = Main.maxTilesY - 200;
			int num15 = 3000;
			while (num12 < num13)
			{
				num15--;
				if (num15 <= 0)
				{
					break;
				}
				int x3 = genRand.Next(minValue, maxValue);
				int y3 = genRand.Next(minValue2, maxValue2);
				Tile tile3 = Main.tile[x3, y3];
				if (tile3.active() && tile3.type >= 0)
				{
					bool flag2 = TileID.Sets.Dirt[tile3.type];
					if (notTheBees)
					{
						flag2 = flag2 || TileID.Sets.Mud[tile3.type];
					}
					if (flag2)
					{
						num12++;
						tile3.ClearTile();
						tile3.active(active: true);
						tile3.type = 668;
					}
				}
			}
			if (noTrapsWorldGen)
			{
				FinishNoTraps();
			}
			if (Main.tenthAnniversaryWorld)
			{
				FinishTenthAnniversaryWorld();
			}
			if (drunkWorldGen)
			{
				FinishDrunkGen();
			}
			if (notTheBees)
			{
				NotTheBees();
				FinishNotTheBees();
			}
			if (getGoodWorldGen)
			{
				FinishGetGoodWorld();
			}
			if (remixWorldGen)
			{
				FinishRemixWorld();
			}
			ShimmerCleanUp();
			notTheBees = false;
			getGoodWorldGen = false;
			noTileActions = false;
			Main.tileSolid[659] = true;
			Main.tileSolid[GenVars.crackedType] = true;
			Main.tileSolid[484] = true;
			gen = false;
			Main.AnglerQuestSwap();
			skipFramingDuringGen = false;
			progress.Message = Lang.gen[87].Value;
		});
	}

	private static void AddGenPassesFromLoadTime()
	{
		foreach (KeyValuePair<string, GenPass> pass in _vanillaGenPasses)
		{
			_generator.Append(pass.Value);
		}
	}

	private static void GenerateWorld_RunTasksAndFinish(int seed, Stopwatch generationStopwatch, GenerationProgress customProgressObject)
	{
		SystemLoader.ModifyWorldGenTasks(_generator._passes, ref _generator._totalLoadWeight);
		_generator.GenerateWorld(customProgressObject);
		ConsumePostGenActions(GenVars.structures);
		SystemLoader.PostWorldGen();
		Main.WorldFileMetadata = FileMetadata.FromCurrentSettings(FileType.World);
		Main.ActiveWorldFileData.modVersionsDuringWorldGen = Terraria.ModLoader.ModLoader.Mods.ToDictionary((Mod x) => x.Name, (Mod x) => x.Version);
		Main.NotifyOfEvent(GameNotificationType.WorldGen);
		drunkWorldGenText = false;
		BackupIO.archiveLock = true;
		generationStopwatch.Stop();
		Logging.tML.Info((object)$"Generation of {Main.maxTilesX}x{Main.maxTilesY} {(crimson ? "Crimson" : "Corruption")} world with seed {seed} completed in {generationStopwatch.Elapsed:m'm 's's 'fff'ms'}");
	}

	private static Point GetAdjustedFloorPosition(int x, int y)
	{
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		int num = x - 1;
		int num2 = y - 2;
		bool isEmpty = false;
		bool hasFloor = false;
		while (!isEmpty && num2 > Main.spawnTileY - 10)
		{
			Scan3By3(num, num2, out isEmpty, out hasFloor);
			if (!isEmpty)
			{
				num2--;
			}
		}
		while (!hasFloor && num2 < Main.spawnTileY + 10)
		{
			Scan3By3(num, num2, out isEmpty, out hasFloor);
			if (!hasFloor)
			{
				num2++;
			}
		}
		return new Point(num + 1, num2 + 2);
	}

	private static void Scan3By3(int topLeftX, int topLeftY, out bool isEmpty, out bool hasFloor)
	{
		isEmpty = true;
		hasFloor = false;
		for (int i = 0; i < 3; i++)
		{
			int num = 0;
			while (num < 3)
			{
				int i2 = topLeftX + i;
				int j = topLeftY + num;
				if (!SolidTile(i2, j))
				{
					num++;
					continue;
				}
				goto IL_0028;
			}
			continue;
			IL_0028:
			isEmpty = false;
			break;
		}
		for (int k = 0; k < 3; k++)
		{
			int i3 = topLeftX + k;
			int j2 = topLeftY + 3;
			if (SolidTile(i3, j2))
			{
				hasFloor = true;
				break;
			}
		}
	}

	private static void FinishTenthAnniversaryWorld()
	{
		if (!remixWorldGen)
		{
			if (!getGoodWorldGen && !drunkWorldGen)
			{
				ConvertSkyIslands(2, growTrees: true);
			}
			PaintTheDungeon(24, 24);
			PaintTheLivingTrees(12, 12);
			PaintTheTemple(10, 5);
			PaintTheClouds(12, 12);
			PaintTheSand(7, 7);
			PaintThePyramids(12, 12);
		}
		PaintTheTrees();
		PaintTheMushrooms();
		if (!getGoodWorldGen)
		{
			for (int i = 50; i < Main.maxTilesX - 50; i++)
			{
				for (int j = 50; j < Main.maxTilesY - 50; j++)
				{
					Tile tile = Main.tile[i, j];
					if (genRand.Next(4) == 0 && tile.active() && tile.type == 138 && tile.frameX == 0 && tile.frameY == 0)
					{
						Main.tile[i, j].type = 665;
						Main.tile[i, j + 1].type = 665;
						Main.tile[i + 1, j].type = 665;
						Main.tile[i + 1, j + 1].type = 665;
					}
				}
			}
		}
		if (!getGoodWorldGen)
		{
			ImproveAllChestContents();
		}
	}

	private static void PaintTheMushrooms()
	{
		int num = Main.maxTilesY - 20;
		byte b = (byte)genRand.Next(1, 13);
		if (remixWorldGen)
		{
			b = 2;
			num = Main.maxTilesY - 500;
			int num2 = genRand.Next(5, 31);
			if (genRand.Next(2) == 0)
			{
				num2 = genRand.Next(5, 16);
			}
			for (int i = 20; i < Main.maxTilesX - 20; i++)
			{
				if (i % num2 == 0)
				{
					b++;
					if (b > 12)
					{
						b = 1;
					}
				}
				for (int j = Main.maxTilesY - 450; j < Main.maxTilesY - 20; j++)
				{
					Tile tile = Main.tile[i, j];
					if (tile.active() && (tile.type == 70 || tile.type == 578 || tile.type == 190 || tile.type == 71 || tile.type == 528 || (tile.type == 519 && tile.frameY == 90)))
					{
						tile.color(b);
					}
					if (tile.wall == 80 || tile.wall == 74)
					{
						tile.wallColor(b);
					}
				}
			}
		}
		b = (byte)genRand.Next(1, 13);
		int num3 = 0;
		for (int k = 20; k < Main.maxTilesX - 20; k++)
		{
			for (int l = 20; l < num; l++)
			{
				Tile tile2 = Main.tile[k, l];
				if (tile2.active() && (tile2.type == 70 || tile2.type == 578 || tile2.type == 190 || tile2.type == 71 || tile2.type == 528 || (tile2.type == 519 && tile2.frameY == 90)))
				{
					tile2.color(b);
					num3 = 10;
				}
				if (tile2.wall == 80 || tile2.wall == 74)
				{
					tile2.wallColor(b);
					num3 = 10;
				}
			}
			num3--;
			if (num3 == 0)
			{
				b += (byte)genRand.Next(1, 3);
				if (b > 12)
				{
					b = 1;
				}
			}
		}
	}

	private static void PaintTheTrees()
	{
		int num = 20;
		if (remixWorldGen)
		{
			num = (int)Main.worldSurface;
		}
		byte b = (byte)genRand.Next(1, 13);
		bool flag = false;
		for (int i = 20; i < Main.maxTilesX - 20; i++)
		{
			bool flag2 = false;
			for (int j = num; j < Main.maxTilesY - 20; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile.active() && (tile.type == 5 || tile.type == 323 || tile.type == 596 || tile.type == 616))
				{
					tile.color(b);
					flag2 = true;
					flag = true;
				}
			}
			if (flag && !flag2)
			{
				flag = false;
				b++;
				if (b > 12)
				{
					b = 1;
				}
			}
		}
	}

	private static void PaintTheSand(byte tilePaintColor, byte wallPaintColor)
	{
		for (int i = 20; i < Main.maxTilesX - 20; i++)
		{
			for (int j = 20; j < Main.maxTilesY - 20; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile.active() && (tile.type == 53 || tile.type == 396 || tile.type == 397))
				{
					tile.color(tilePaintColor);
					if ((double)j > Main.worldSurface)
					{
						if (Main.tile[i, j - 1].type == 165 || Main.tile[i, j - 1].type == 185 || Main.tile[i, j - 1].type == 186 || Main.tile[i, j - 1].type == 187)
						{
							Main.tile[i, j - 1].color(tilePaintColor);
						}
						if (Main.tile[i, j - 2].type == 165 || Main.tile[i, j - 2].type == 185 || Main.tile[i, j - 2].type == 186 || Main.tile[i, j - 2].type == 187)
						{
							Main.tile[i, j - 2].color(tilePaintColor);
						}
						if (Main.tile[i, j + 1].type == 165)
						{
							Main.tile[i, j + 1].color(tilePaintColor);
						}
						if (Main.tile[i, j + 2].type == 165)
						{
							Main.tile[i, j + 2].color(tilePaintColor);
						}
					}
				}
				if (tile.wall == 187 || tile.wall == 216)
				{
					tile.wallColor(tilePaintColor);
				}
			}
		}
	}

	private static void PaintThePurityGrass(byte tilePaintColor, byte wallPaintColor)
	{
		for (int i = 0; i < Main.maxTilesX; i++)
		{
			for (int j = 0; j < Main.maxTilesY; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile.active())
				{
					if (tile.type == 2)
					{
						tile.color(tilePaintColor);
					}
					else if (tile.type == 185 || tile.type == 186 || tile.type == 187)
					{
						Tile tile2 = tile;
						int num = j;
						while (num < Main.maxTilesY - 20 && (tile2.type == 185 || tile2.type == 186 || tile2.type == 187 || tile2.type == 3 || tile2.type == 73))
						{
							tile2 = Main.tile[i, ++num];
						}
						if (tile2.type == 2)
						{
							tile.color(tilePaintColor);
						}
					}
				}
				if (tile.wall == 66 || tile.wall == 63)
				{
					tile.wallColor(wallPaintColor);
				}
			}
		}
	}

	private static void PaintThePyramids(byte tilePaintColor, byte wallPaintColor)
	{
		for (int i = 0; i < Main.maxTilesX; i++)
		{
			for (int j = 0; j < Main.maxTilesY; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile.active() && tile.type == 151)
				{
					tile.color(tilePaintColor);
				}
				if (tile.wall == 34)
				{
					tile.wallColor(wallPaintColor);
				}
			}
		}
	}

	private static void PaintTheTemple(byte tilePaintColor, byte wallPaintColor)
	{
		for (int i = 0; i < Main.maxTilesX; i++)
		{
			for (int j = 0; j < Main.maxTilesY; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile.active())
				{
					bool flag = false;
					if (tile.type == 226)
					{
						flag = true;
					}
					if (tile.type == 137)
					{
						int num = tile.frameY / 18;
						if (num >= 1 && num <= 4)
						{
							flag = true;
						}
					}
					if (flag)
					{
						tile.color(tilePaintColor);
					}
				}
				if (tile.wall == 87)
				{
					tile.wallColor(wallPaintColor);
				}
			}
		}
	}

	private static void PaintTheClouds(byte tilePaintColor, byte wallPaintColor)
	{
		for (int i = 0; i < Main.maxTilesX; i++)
		{
			for (int j = 0; j < Main.maxTilesY; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile.active() && (tile.type == 189 || tile.type == 196 || tile.type == 460))
				{
					tile.color(tilePaintColor);
				}
				if (tile.wall == 73)
				{
					tile.wallColor(wallPaintColor);
				}
			}
		}
	}

	private static void PaintTheDungeon(byte tilePaintColor, byte wallPaintColor)
	{
		for (int i = 0; i < Main.maxTilesX; i++)
		{
			for (int j = 0; j < Main.maxTilesY; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile.active())
				{
					if (Main.tileDungeon[tile.type] || TileID.Sets.CrackedBricks[tile.type])
					{
						tile.color(tilePaintColor);
					}
					if (tile.type == 19)
					{
						int num = tile.frameY / 18;
						if (num >= 6 && num <= 12)
						{
							tile.color(tilePaintColor);
						}
					}
				}
				if (Main.wallDungeon[tile.wall])
				{
					tile.wallColor(wallPaintColor);
				}
			}
		}
	}

	private static void PaintTheLivingTrees(byte livingTreePaintColor, byte livingTreeWallPaintColor)
	{
		for (int i = 0; i < Main.maxTilesX; i++)
		{
			for (int j = 0; j < Main.maxTilesY; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile.active())
				{
					if (tile.wall == 244)
					{
						tile.color(livingTreePaintColor);
					}
					else if (tile.type == 192 || tile.type == 191)
					{
						tile.color(livingTreePaintColor);
					}
					else if (tile.type == 52 || tile.type == 382)
					{
						int x = i;
						int y = j;
						GetVineTop(i, j, out x, out y);
						if (Main.tile[x, y].type == 192)
						{
							tile.color(livingTreePaintColor);
						}
					}
					else if (tile.type == 187)
					{
						Tile tile2 = tile;
						int num = 0;
						while (tile2.type == 187)
						{
							num++;
							tile2 = Main.tile[i, j + num];
						}
						if (tile2.type == 192)
						{
							tile.color(livingTreePaintColor);
						}
					}
				}
				if (tile.wall == 244)
				{
					tile.wallColor(livingTreeWallPaintColor);
				}
			}
		}
	}

	private static void ConvertSkyIslands(int convertType, bool growTrees)
	{
		int num = 0;
		for (int i = 20; (double)i < Main.worldSurface; i++)
		{
			for (int j = 20; j < Main.maxTilesX - 20; j++)
			{
				Tile tile = Main.tile[j, i];
				if (tile.active() && TileID.Sets.Clouds[tile.type])
				{
					num = i;
					break;
				}
			}
		}
		for (int k = 20; k <= Main.maxTilesX - 20; k++)
		{
			for (int l = 20; l < num; l++)
			{
				Tile tile2 = Main.tile[k, l];
				Tile tile3 = Main.tile[k, l - 1];
				if (tile2.active() && tile2.type == 2)
				{
					if (tile3.type == 596 || tile3.type == 616)
					{
						KillTile(k, l - 1);
					}
					Convert(k, l, convertType, 1);
					ushort type = tile3.type;
					if ((uint)(type - 82) <= 1u || (uint)(type - 185) <= 2u || type == 227)
					{
						KillTile(k, l - 1);
					}
					if (growTrees && _genRand.Next(3) == 0)
					{
						GrowTree(k, l);
					}
				}
			}
		}
	}

	private static void ImproveAllChestContents()
	{
		for (int i = 0; i < 8000; i++)
		{
			Chest chest = Main.chest[i];
			if (chest == null)
			{
				continue;
			}
			for (int j = 0; j < 40; j++)
			{
				Item item = chest.item[j];
				if (item != null && !item.IsAir)
				{
					GiveItemGoodPrefixes(item);
				}
			}
		}
	}

	private static void GiveItemGoodPrefixes(Item item)
	{
		if (item.accessory)
		{
			PrefixItemFromOptions(item, TenthAnniversaryWorldInfo.GoodPrefixIdsForAccessory);
		}
		if (item.melee)
		{
			PrefixItemFromOptions(item, TenthAnniversaryWorldInfo.GoodPrefixIdsForMeleeWeapon);
		}
		if (item.ranged)
		{
			PrefixItemFromOptions(item, TenthAnniversaryWorldInfo.GoodPrefixIdsForRangedWeapon);
		}
		if (item.magic)
		{
			PrefixItemFromOptions(item, TenthAnniversaryWorldInfo.GoodPrefixIdsForMagicWeapon);
		}
		if (item.summon)
		{
			PrefixItemFromOptions(item, TenthAnniversaryWorldInfo.GoodPrefixIdsForSummonerWeapon);
		}
	}

	private static void PrefixItemFromOptions(Item item, int[] options)
	{
		int prefix = item.prefix;
		if (!item.Prefix(-3))
		{
			return;
		}
		List<int> list = new List<int>(options);
		while (list.Count > 0)
		{
			int index = _genRand.Next(list.Count);
			int num = list[index];
			item.Prefix(num);
			if (item.prefix == num)
			{
				return;
			}
			list.RemoveAt(index);
		}
		item.Prefix(prefix);
	}

	private static void NotTheBees()
	{
		int num = Main.maxTilesX / 7;
		if (!notTheBees)
		{
			return;
		}
		for (int i = 0; i < Main.maxTilesX; i++)
		{
			for (int j = 0; j < Main.maxTilesY - 180; j++)
			{
				if (remixWorldGen && (i < num + genRand.Next(3) || i >= Main.maxTilesX - num - genRand.Next(3) || ((double)j > (Main.worldSurface * 2.0 + Main.rockLayer) / 3.0 + (double)genRand.Next(3) && j < Main.maxTilesY - 350 - genRand.Next(3))))
				{
					continue;
				}
				if (Main.tile[i, j].type == 52)
				{
					Main.tile[i, j].type = 62;
				}
				if ((SolidOrSlopedTile(i, j) || TileID.Sets.CrackedBricks[Main.tile[i, j].type]) && !TileID.Sets.Ore[Main.tile[i, j].type] && Main.tile[i, j].type != 123 && Main.tile[i, j].type != 40)
				{
					if (Main.tile[i, j].type == 191 || Main.tile[i, j].type == 383)
					{
						if (!remixWorldGen)
						{
							Main.tile[i, j].type = 383;
						}
					}
					else if (Main.tile[i, j].type == 192 || Main.tile[i, j].type == 384)
					{
						if (!remixWorldGen)
						{
							Main.tile[i, j].type = 384;
						}
					}
					else if (Main.tile[i, j].type != 151 && Main.tile[i, j].type != 662 && Main.tile[i, j].type != 661 && Main.tile[i, j].type != 189 && Main.tile[i, j].type != 196 && Main.tile[i, j].type != 120 && Main.tile[i, j].type != 158 && Main.tile[i, j].type != 175 && Main.tile[i, j].type != 45 && Main.tile[i, j].type != 119)
					{
						if (Main.tile[i, j].type >= 63 && Main.tile[i, j].type <= 68)
						{
							Main.tile[i, j].type = 230;
						}
						else if (Main.tile[i, j].type != 57 && Main.tile[i, j].type != 76 && Main.tile[i, j].type != 75 && Main.tile[i, j].type != 229 && Main.tile[i, j].type != 230 && Main.tile[i, j].type != 407 && Main.tile[i, j].type != 404)
						{
							if (Main.tile[i, j].type == 224)
							{
								Main.tile[i, j].type = 229;
							}
							else if (Main.tile[i, j].type == 53)
							{
								if (i < beachDistance + genRand.Next(3) || i > Main.maxTilesX - beachDistance - genRand.Next(3))
								{
									Main.tile[i, j].type = 229;
								}
							}
							else if ((i <= beachDistance - genRand.Next(3) || i >= Main.maxTilesX - beachDistance + genRand.Next(3) || (Main.tile[i, j].type != 397 && Main.tile[i, j].type != 396)) && Main.tile[i, j].type != 10 && Main.tile[i, j].type != 203 && Main.tile[i, j].type != 25 && Main.tile[i, j].type != 137 && Main.tile[i, j].type != 138 && Main.tile[i, j].type != 141)
							{
								if (Main.tileDungeon[Main.tile[i, j].type] || TileID.Sets.CrackedBricks[Main.tile[i, j].type])
								{
									Main.tile[i, j].color(14);
								}
								else if (Main.tile[i, j].type == 226)
								{
									Main.tile[i, j].color(15);
								}
								else if (Main.tile[i, j].type != 202 && Main.tile[i, j].type != 70 && Main.tile[i, j].type != 48 && Main.tile[i, j].type != 232)
								{
									if (TileID.Sets.Conversion.Grass[Main.tile[i, j].type] || Main.tile[i, j].type == 60 || Main.tile[i, j].type == 70)
									{
										if (j > GenVars.lavaLine + genRand.Next(-2, 3) + 2)
										{
											Main.tile[i, j].type = 70;
										}
										else
										{
											Main.tile[i, j].type = 60;
										}
									}
									else if (Main.tile[i, j].type == 0 || Main.tile[i, j].type == 59)
									{
										Main.tile[i, j].type = 59;
									}
									else if (Main.tile[i, j].type != 633)
									{
										if (j > GenVars.lavaLine + genRand.Next(-2, 3) + 2)
										{
											Main.tile[i, j].type = 230;
										}
										else if (!remixWorldGen || (double)j > Main.worldSurface + (double)genRand.Next(-1, 2))
										{
											Main.tile[i, j].type = 225;
										}
									}
								}
							}
						}
					}
				}
				if (Main.tile[i, j].wall != 15 && Main.tile[i, j].wall != 64 && Main.tile[i, j].wall != 204 && Main.tile[i, j].wall != 205 && Main.tile[i, j].wall != 206 && Main.tile[i, j].wall != 207 && Main.tile[i, j].wall != 23 && Main.tile[i, j].wall != 24 && Main.tile[i, j].wall != 42 && Main.tile[i, j].wall != 10 && Main.tile[i, j].wall != 21 && Main.tile[i, j].wall != 82 && Main.tile[i, j].wall != 187 && Main.tile[i, j].wall != 216 && Main.tile[i, j].wall != 34 && Main.tile[i, j].wall != 244)
				{
					if (Main.tile[i, j].wall == 87)
					{
						Main.tile[i, j].wallColor(15);
					}
					else if (Main.wallDungeon[Main.tile[i, j].wall])
					{
						Main.tile[i, j].wallColor(14);
					}
					else if (Main.tile[i, j].wall == 2)
					{
						Main.tile[i, j].wall = 2;
					}
					else if (Main.tile[i, j].wall == 196)
					{
						Main.tile[i, j].wall = 196;
					}
					else if (Main.tile[i, j].wall == 197)
					{
						Main.tile[i, j].wall = 197;
					}
					else if (Main.tile[i, j].wall == 198)
					{
						Main.tile[i, j].wall = 198;
					}
					else if (Main.tile[i, j].wall == 199)
					{
						Main.tile[i, j].wall = 199;
					}
					else if (Main.tile[i, j].wall == 63)
					{
						Main.tile[i, j].wall = 64;
					}
					else if (Main.tile[i, j].wall != 3 && Main.tile[i, j].wall != 83 && Main.tile[i, j].wall != 73 && Main.tile[i, j].wall != 62 && Main.tile[i, j].wall != 13 && Main.tile[i, j].wall != 14 && Main.tile[i, j].wall > 0 && (!remixWorldGen || (double)j > Main.worldSurface + (double)genRand.Next(-1, 2)))
					{
						Main.tile[i, j].wall = 86;
					}
				}
				if (Main.tile[i, j].liquid > 0 && j <= GenVars.lavaLine + 2)
				{
					if ((double)j > Main.rockLayer && (i < beachDistance + 200 || i > Main.maxTilesX - beachDistance - 200))
					{
						Main.tile[i, j].honey(honey: false);
					}
					else if (Main.wallDungeon[Main.tile[i, j].wall])
					{
						Main.tile[i, j].honey(honey: false);
					}
					else
					{
						Main.tile[i, j].honey(honey: true);
					}
				}
			}
		}
	}

	private static void FinishNotTheBees()
	{
		if (!notTheBees)
		{
			return;
		}
		int num = 0;
		for (int i = 20; (double)i < Main.worldSurface; i++)
		{
			for (int j = 20; j < Main.maxTilesX - 20; j++)
			{
				if (Main.tile[j, i].active() && TileID.Sets.Clouds[Main.tile[j, i].type])
				{
					num = i;
					break;
				}
			}
		}
		for (int k = 25; k < Main.maxTilesX - 25; k++)
		{
			for (int l = 25; l < Main.maxTilesY - 25; l++)
			{
				if (Main.tile[k, l].type == 571)
				{
					TileFrame(k, l);
				}
				int num2 = 20;
				if (remixWorldGen)
				{
					num2 = 10;
				}
				if (Main.tile[k, l].type == 25 || (remixWorldGen && Main.tile[k, l].type == 23 && (double)l < Main.worldSurface))
				{
					for (int m = k - num2; m <= k + num2; m++)
					{
						for (int n = l - num2; n <= l + num2; n++)
						{
							if (Main.tile[m, n].type == 60)
							{
								if (Main.tile[m, n + 1].type == 444)
								{
									KillTile(m, n + 1);
								}
								Main.tile[m, n].type = 661;
								if (Main.tile[m, n - 1].type == 61 || Main.tile[m, n - 1].type == 74)
								{
									Main.tile[m, n - 1].active(active: false);
									PlaceTile(m, n - 1, 24);
								}
							}
							else if (Main.tile[m, n - 1].type == 233 || Main.tile[m, n - 1].type == 82)
							{
								KillTile(m, n - 1);
							}
						}
					}
				}
				else if (Main.tile[k, l].type == 203 || (remixWorldGen && Main.tile[k, l].type == 199 && (double)l < Main.worldSurface))
				{
					for (int num3 = k - num2; num3 <= k + num2; num3++)
					{
						for (int num4 = l - num2; num4 <= l + num2; num4++)
						{
							if (Main.tile[num3, num4].type == 60)
							{
								if (Main.tile[num3, num4 + 1].type == 444)
								{
									KillTile(num3, num4 + 1);
								}
								Main.tile[num3, num4].type = 662;
								if (Main.tile[num3, num4 - 1].type == 61 || Main.tile[num3, num4 - 1].type == 74)
								{
									Main.tile[num3, num4 - 1].active(active: false);
									PlaceTile(num3, num4 - 1, 201);
								}
								else if (Main.tile[num3, num4 - 1].type == 233 || Main.tile[num3, num4 - 1].type == 82)
								{
									KillTile(num3, num4 - 1);
								}
							}
						}
					}
				}
				if (Main.tile[k, l].type == 382 || Main.tile[k, l].type == 52)
				{
					Main.tile[k, l].type = 62;
				}
				if (l > GenVars.lavaLine + genRand.Next(-2, 3) + 2)
				{
					if (!remixWorldGen)
					{
						SpreadGrass(k, l, 59, 70);
					}
				}
				else
				{
					SpreadGrass(k, l, 59, 60);
				}
				if ((double)l > Main.rockLayer + 20.0 + (double)genRand.Next(-2, 3) && l <= GenVars.lavaLine + 2 - 20 - genRand.Next(-2, 3) && (k < beachDistance + 200 - 20 - genRand.Next(-2, 3) || k > Main.maxTilesX - beachDistance - 200 + 20 + genRand.Next(-2, 3)))
				{
					if (Main.tile[k, l].liquid > 0)
					{
						Main.tile[k, l].honey(honey: false);
						Main.tile[k, l].lava(lava: false);
					}
					if (Main.tile[k, l].type == 59)
					{
						bool flag = false;
						for (int num5 = k - 1; num5 <= k + 1; num5++)
						{
							for (int num6 = l - 1; num6 <= l + 1; num6++)
							{
								if (Main.tile[num5, num6].type == 60)
								{
									flag = true;
								}
							}
						}
						if (!flag)
						{
							if ((double)l < (Main.rockLayer + (double)GenVars.lavaLine) / 2.0)
							{
								Main.tile[k, l].type = 161;
							}
							else
							{
								Main.tile[k, l].type = 147;
							}
						}
					}
				}
				if (!remixWorldGen)
				{
					if ((Main.tile[k, l].type == 7 || Main.tile[k, l].type == 166 || Main.tile[k, l].type == 6 || Main.tile[k, l].type == 167) && (double)l > ((double)GenVars.lavaLine + Main.rockLayer * 2.0) / 3.0 + (double)genRand.Next(-2, 3) + 2.0)
					{
						Main.tile[k, l].type = 0;
					}
				}
				else if (!remixWorldGen && (Main.tile[k, l].type == 123 || Main.tile[k, l].type == 40) && (double)l > ((double)GenVars.lavaLine + Main.rockLayer) / 2.0 + (double)genRand.Next(-2, 3) + 2.0)
				{
					Main.tile[k, l].type = 1;
				}
				if (l <= num || (Main.tile[k, l].liquid != 0 && (Main.tile[k, l].lava() || Main.tile[k, l].shimmer())))
				{
					continue;
				}
				if (getGoodWorldGen)
				{
					if (genRand.Next(150) == 0)
					{
						PlaceTile(k, l, 231, mute: true);
					}
				}
				else if (genRand.Next(25) == 0)
				{
					PlaceTile(k, l, 231, mute: true);
				}
			}
		}
		for (int num7 = 20; num7 < num; num7++)
		{
			for (int num8 = 20; num8 <= Main.maxTilesX - 20; num8++)
			{
				Main.tile[num8, num7].honey(honey: false);
				if (Main.tile[num8, num7].type == 375)
				{
					Main.tile[num8, num7].type = 373;
				}
				if (!remixWorldGen)
				{
					if (Main.tile[num8, num7].type == 60)
					{
						Main.tile[num8, num7].type = 2;
						if (genRand.Next(2) == 0)
						{
							GrowTreeWithSettings(num8, num7, GrowTreeSettings.Profiles.VanityTree_Willow);
						}
						else
						{
							GrowTreeWithSettings(num8, num7, GrowTreeSettings.Profiles.VanityTree_Sakura);
						}
						if (!Main.tile[num8, num7 - 1].active())
						{
							PlaceTile(num8, num7 - 1, 3);
						}
					}
					if (Main.tile[num8, num7].type == 59)
					{
						Main.tile[num8, num7].type = 0;
					}
				}
				else
				{
					GrowTree(num8, num7);
				}
			}
		}
	}

	private static void FinishGetGoodWorld()
	{
		int num = 0;
		for (int i = 20; (double)i < Main.worldSurface; i++)
		{
			for (int j = 20; j < Main.maxTilesX - 20; j++)
			{
				if (Main.tile[j, i].active() && TileID.Sets.Clouds[Main.tile[j, i].type])
				{
					num = i;
					break;
				}
			}
		}
		byte b = (byte)genRand.Next(13, 25);
		for (int k = 0; k < Main.maxTilesX; k++)
		{
			bool flag = false;
			for (int l = 0; l < Main.maxTilesY; l++)
			{
				if (!Main.tile[k, l].active() || !Main.tileDungeon[Main.tile[k, l].type])
				{
					continue;
				}
				if (Main.tile[k, l].type == 44)
				{
					b = (byte)genRand.Next(13, 15);
					if (genRand.Next(2) == 0)
					{
						b = (byte)genRand.Next(23, 25);
					}
				}
				if (Main.tile[k, l].type == 43)
				{
					b = (byte)genRand.Next(15, 19);
				}
				if (Main.tile[k, l].type == 41)
				{
					b = (byte)genRand.Next(19, 23);
				}
			}
			if (flag)
			{
				break;
			}
		}
		for (int m = 0; m < Main.maxTilesX; m++)
		{
			for (int n = 5; n < Main.maxTilesY - 5; n++)
			{
				if (Main.tile[m, n].active() && (Main.tileDungeon[Main.tile[m, n].type] || TileID.Sets.CrackedBricks[Main.tile[m, n].type]))
				{
					Main.tile[m, n].color(b);
				}
				if (Main.wallDungeon[Main.tile[m, n].wall])
				{
					Main.tile[m, n].wallColor(b);
				}
				if (Main.tile[m, n].active())
				{
					bool flag2 = false;
					if (Main.tile[m, n].type == 226)
					{
						flag2 = true;
					}
					if (Main.tile[m, n].type == 137)
					{
						int num2 = Main.tile[m, n].frameY / 18;
						if (num2 >= 1 && num2 <= 4)
						{
							flag2 = true;
						}
					}
					if (flag2)
					{
						Main.tile[m, n].color(17);
					}
				}
				if (Main.tile[m, n].wall == 87)
				{
					Main.tile[m, n].wallColor(25);
				}
				if (!Main.tile[m, n].active())
				{
					continue;
				}
				if (!remixWorldGen && Main.tile[m, n].type == 57 && genRand.Next(15) == 0)
				{
					if (Main.tile[m, n - 1].type == 57)
					{
						Main.tile[m, n].active(active: false);
					}
					Main.tile[m, n].liquid = byte.MaxValue;
					Main.tile[m, n].lava(lava: true);
				}
				if (n < num && Main.tile[m, n].type == 2)
				{
					if (crimson)
					{
						Main.tile[m, n].type = 199;
					}
					else
					{
						Main.tile[m, n].type = 23;
					}
					if (Main.tile[m, n - 1].type == 3)
					{
						Main.tile[m, n - 1].active(active: false);
					}
					if (Main.tile[m, n - 1].type == 73)
					{
						Main.tile[m, n - 1].active(active: false);
					}
					if (Main.tile[m, n - 1].type == 27)
					{
						KillTile(m, n - 1);
					}
					if (Main.tile[m, n - 1].type == 596)
					{
						KillTile(m, n - 1);
					}
					if (Main.tile[m, n - 1].type == 616)
					{
						KillTile(m, n - 1);
					}
					if (Main.tile[m, n - 1].type == 82)
					{
						KillTile(m, n - 1);
					}
					if (Main.tile[m, n - 1].type == 83)
					{
						KillTile(m, n - 1);
					}
					if (Main.tile[m, n - 1].type == 186)
					{
						KillTile(m, n - 1);
					}
					if (Main.tile[m, n - 1].type == 187)
					{
						KillTile(m, n - 1);
					}
					if (Main.tile[m, n - 1].type == 185)
					{
						KillTile(m, n - 1);
					}
					if (Main.tile[m, n - 1].type == 227)
					{
						KillTile(m, n - 1);
					}
				}
			}
		}
		for (int num3 = 0; num3 < 8000 && Main.chest[num3] != null; num3++)
		{
			if (genRand.Next(10) != 0 || Main.chest[num3].item[1].stack == 0)
			{
				continue;
			}
			for (int num4 = 1; num4 < 40; num4++)
			{
				if (Main.chest[num3].item[num4].stack == 0)
				{
					Main.chest[num3].item[num4].SetDefaults(678);
					break;
				}
			}
		}
	}

	private static void FinishNoTraps()
	{
		Main.tileSolid[138] = false;
		for (int i = 50; i < Main.maxTilesX - 50; i++)
		{
			for (int j = 50; j < Main.maxTilesY - 50; j++)
			{
				Tile tile = Main.tile[i, j];
				if (genRand.Next(5) == 0 && tile.active() && tile.type == 12 && tile.frameX == 0 && tile.frameY == 0)
				{
					Main.tile[i, j].type = 665;
					Main.tile[i, j + 1].type = 665;
					Main.tile[i + 1, j].type = 665;
					Main.tile[i + 1, j + 1].type = 665;
				}
				if (i % 2 != 0 || j % 2 != 0 || !Main.tile[i, j].active() || (Main.tile[i, j].type != 105 && (Main.tile[i, j].type != 467 || (Main.tile[i, j].frameX != 144 && Main.tile[i, j].frameX != 162))))
				{
					continue;
				}
				bool flag = false;
				for (int k = i - 1; k <= i + 1; k++)
				{
					for (int l = j - 1; l <= j + 1; l++)
					{
						if (Main.tile[k, l].wire())
						{
							flag = true;
						}
					}
				}
				if (!flag)
				{
					bool flag2 = false;
					int num = 25;
					int num10 = -1;
					int num11 = -1;
					for (int m = 0; m < num * num; m++)
					{
						num10 = genRand.Next(i - num, i + num + 1);
						num11 = genRand.Next(j - num, j + num + 1);
						if (Main.tile[num10, num11].wire())
						{
							flag2 = true;
							break;
						}
					}
					if (flag2)
					{
						int num12 = i;
						int num13 = j;
						Main.tile[num12, num13].wire(wire: true);
						while (num12 != num10)
						{
							if (num12 < num10)
							{
								num12++;
							}
							if (num12 > num10)
							{
								num12--;
							}
							Main.tile[num12, num13].wire(wire: true);
						}
						while (num13 != num11)
						{
							if (num13 < num11)
							{
								num13++;
							}
							if (num13 > num11)
							{
								num13--;
							}
							Main.tile[num12, num13].wire(wire: true);
						}
					}
					else if (Main.tile[i, j].type == 105)
					{
						num = 15;
						bool flag3 = false;
						for (int n = 0; n < num * num; n++)
						{
							num10 = i + genRand.Next(-num, num + 1);
							num11 = j + genRand.Next(-num, num + 1);
							PlaceTile(num10, num11, 135, mute: true, forced: true, -1, genRand.Next(2, 4));
							if (Main.tile[num10, num11].type == 135)
							{
								flag3 = true;
								break;
							}
						}
						if (flag3)
						{
							int num14 = i;
							int num15 = j;
							Main.tile[num14, num15].wire(wire: true);
							while (num14 != num10)
							{
								if (num14 < num10)
								{
									num14++;
								}
								if (num14 > num10)
								{
									num14--;
								}
								Main.tile[num14, num15].wire(wire: true);
							}
							while (num15 != num11)
							{
								if (num15 < num11)
								{
									num15++;
								}
								if (num15 > num11)
								{
									num15--;
								}
								Main.tile[num14, num15].wire(wire: true);
							}
						}
					}
				}
				if (Main.tile[i, j].type == 467)
				{
					int num16 = 8;
					for (int num17 = 0; num17 < num16 * num16; num17++)
					{
						int num2 = i + genRand.Next(-num16, num16 + 1);
						int num3 = j + genRand.Next(-num16, num16 + 1);
						if (Main.tile[num2, num3].type != 0 && Main.tile[num2, num3].type != 1 && !TileID.Sets.Ore[Main.tile[num2, num3].type] && Main.tile[num2, num3].type != 59 && Main.tile[num2, num3].type != 151)
						{
							continue;
						}
						bool flag4 = true;
						for (int num4 = num2 - 1; num4 <= num2 + 1; num4++)
						{
							for (int num5 = num3 - 1; num5 <= num3 + 1; num5++)
							{
								if (!SolidTile(num4, num5))
								{
									flag4 = false;
								}
							}
						}
						if (!flag4)
						{
							continue;
						}
						Tile tile2 = Main.tile[num2, num3];
						tile2.type = 141;
						tile2.frameX = (tile2.frameY = 0);
						tile2.slope(0);
						tile2.halfBrick(halfBrick: false);
						TileFrame(num2, num3, resetFrame: true);
						if (Main.tile[num2, num3].type != 141)
						{
							continue;
						}
						int num6 = i;
						int num7 = j;
						Main.tile[num6, num7].wire(wire: true);
						while (num6 != num2)
						{
							if (num6 < num2)
							{
								num6++;
							}
							if (num6 > num2)
							{
								num6--;
							}
							Main.tile[num6, num7].wire(wire: true);
						}
						while (num7 != num3)
						{
							if (num7 < num3)
							{
								num7++;
							}
							if (num7 > num3)
							{
								num7--;
							}
							Main.tile[num6, num7].wire(wire: true);
						}
						break;
					}
				}
				else
				{
					j++;
				}
			}
		}
		Main.tileSolid[138] = true;
		for (int num8 = 0; num8 < 8000 && Main.chest[num8] != null; num8++)
		{
			if (genRand.Next(20) != 0 || Main.chest[num8].item[1].stack == 0)
			{
				continue;
			}
			for (int num9 = 1; num9 < 40; num9++)
			{
				if (Main.chest[num8].item[num9].stack == 0)
				{
					Main.chest[num8].item[num9].SetDefaults(5346);
					break;
				}
			}
		}
	}

	private static void FinishDrunkGen()
	{
		byte color = (byte)genRand.Next(13, 25);
		byte b = 16;
		for (int i = 0; i < Main.maxTilesX; i++)
		{
			bool flag = false;
			for (int j = 0; j < Main.maxTilesY; j++)
			{
				if (!Main.tile[i, j].active() || !Main.tileDungeon[Main.tile[i, j].type])
				{
					continue;
				}
				if (Main.tile[i, j].type == 44)
				{
					color = (byte)genRand.Next(13, 15);
					if (genRand.Next(2) == 0)
					{
						color = (byte)genRand.Next(23, 25);
					}
				}
				if (Main.tile[i, j].type == 43)
				{
					color = (byte)genRand.Next(15, 19);
				}
				if (Main.tile[i, j].type == 41)
				{
					color = (byte)genRand.Next(19, 23);
				}
			}
			if (flag)
			{
				break;
			}
		}
		for (int k = 10; k < Main.maxTilesX - 10; k++)
		{
			for (int l = 10; l < Main.maxTilesY - 10; l++)
			{
				if (Main.tile[k, l].active() && (Main.tileDungeon[Main.tile[k, l].type] || TileID.Sets.CrackedBricks[Main.tile[k, l].type]))
				{
					Main.tile[k, l].color(color);
				}
				if (Main.wallDungeon[Main.tile[k, l].wall])
				{
					Main.tile[k, l].wallColor(25);
				}
				if (Main.tile[k, l].active())
				{
					if (Main.tile[k, l].type == 60)
					{
						int num = 1;
						for (int m = k - num; m <= k + num; m++)
						{
							for (int n = l - num; n <= l + num; n++)
							{
								if (Main.tile[m, n].type == 147 || Main.tile[m, n].type == 161)
								{
									Main.tile[m, n].type = 59;
								}
							}
						}
					}
					bool flag2 = false;
					if (Main.tile[k, l].type == 226)
					{
						flag2 = true;
					}
					if (Main.tile[k, l].type == 137)
					{
						int num2 = Main.tile[k, l].frameY / 18;
						if (num2 >= 1 && num2 <= 4)
						{
							flag2 = true;
						}
					}
					if (flag2)
					{
						Main.tile[k, l].color(b);
					}
				}
				if (Main.tile[k, l].wall == 87)
				{
					Main.tile[k, l].wallColor(b);
				}
			}
		}
		for (int num3 = 0; num3 < 8000 && Main.chest[num3] != null; num3++)
		{
			if (genRand.Next(15) == 0 && Main.chest[num3].item[1].stack != 0)
			{
				for (int num4 = 1; num4 < 40; num4++)
				{
					if (Main.chest[num3].item[num4].stack == 0)
					{
						Main.chest[num3].item[num4].SetDefaults(5001);
						break;
					}
				}
			}
			if (genRand.Next(30) != 0 || Main.chest[num3].item[1].stack == 0)
			{
				continue;
			}
			for (int num5 = 1; num5 < 40; num5++)
			{
				if (Main.chest[num3].item[num5].stack == 0)
				{
					Main.chest[num3].item[num5].SetDefaults(678);
					break;
				}
			}
		}
	}

	private static void FinishRemixWorld()
	{
		for (int i = 25; i < Main.maxTilesX - 25; i++)
		{
			for (int j = 25; j < Main.maxTilesY - 25; j++)
			{
				int conversionType = 1;
				if (crimson)
				{
					conversionType = 4;
				}
				if (notTheBees && (double)j < Main.worldSurface)
				{
					if (Main.tile[i, j].honey())
					{
						if (Main.tileLavaDeath[Main.tile[i, j].type])
						{
							KillTile(i, j);
						}
						Main.tile[i, j].lava(lava: true);
					}
					if (Main.tile[i, j].type == 375)
					{
						Main.tile[i, j].type = 374;
					}
					if (Main.tile[i, j].type == 230 || Main.tile[i, j].type == 229 || Main.tile[i, j].type == 659 || Main.tile[i, j].type == 56)
					{
						KillTile(i, j);
					}
					if (Main.tile[i, j].type == 82 || Main.tile[i, j].type == 83 || Main.tile[i, j].type == 84)
					{
						TileFrame(i, j);
					}
				}
				if ((double)j < Main.worldSurface + (double)genRand.Next(3))
				{
					if (drunkWorldGen)
					{
						if (GenVars.crimsonLeft)
						{
							if (i < Main.maxTilesX / 2 + genRand.Next(-2, 3))
							{
								Convert(i, j, 4, 1);
							}
							else
							{
								Convert(i, j, 1, 1);
							}
						}
						else if (i < Main.maxTilesX / 2 + genRand.Next(-2, 3))
						{
							Convert(i, j, 1, 1);
						}
						else
						{
							Convert(i, j, 4, 1);
						}
					}
					else
					{
						Convert(i, j, conversionType, 1);
					}
				}
				if ((double)j < Main.worldSurface - (double)genRand.Next(19, 22) && (Main.tile[i, j].wall == 178 || Main.tile[i, j].wall == 180))
				{
					Main.tile[i, j].wall = 0;
				}
				if (Main.tile[i, j].active() && Main.tile[i, j].type == 56)
				{
					KillTile(i, j);
				}
				if (Main.tile[i, j].type == 189 || Main.tile[i, j].type == 196 || Main.tile[i, j].type == 202)
				{
					if (drunkWorldGen)
					{
						if (GenVars.crimsonLeft)
						{
							if (i < Main.maxTilesX / 2 + genRand.Next(-2, 3))
							{
								Main.tile[i, j].type = 195;
							}
							else
							{
								Main.tile[i, j].type = 474;
							}
						}
						else if (i < Main.maxTilesX / 2 + genRand.Next(-2, 3))
						{
							Main.tile[i, j].type = 474;
						}
						else
						{
							Main.tile[i, j].type = 195;
						}
					}
					else if (crimson)
					{
						Main.tile[i, j].type = 195;
					}
					else
					{
						Main.tile[i, j].type = 474;
					}
				}
				if (Main.tile[i, j].wall == 73 || Main.tile[i, j].wall == 82)
				{
					if (drunkWorldGen)
					{
						if (GenVars.crimsonLeft)
						{
							if (i < Main.maxTilesX / 2 + genRand.Next(-2, 3))
							{
								Main.tile[i, j].wall = 77;
							}
							else
							{
								Main.tile[i, j].wall = 233;
							}
						}
						else if (i < Main.maxTilesX / 2 + genRand.Next(-2, 3))
						{
							Main.tile[i, j].wall = 233;
						}
						else
						{
							Main.tile[i, j].wall = 77;
						}
					}
					else if (crimson)
					{
						Main.tile[i, j].wall = 77;
					}
					else
					{
						Main.tile[i, j].wall = 233;
					}
				}
				if ((double)j > Main.rockLayer && j < Main.maxTilesY - 350 && Main.tile[i, j].type == 0 && Main.tile[i, j].active() && (!Main.tile[i - 1, j - 1].active() || !SolidTile(i, j - 1) || !Main.tile[i + 1, j - 1].active() || !Main.tile[i - 1, j].active() || !Main.tile[i + 1, j].active() || !Main.tile[i - 1, j + 1].active() || !Main.tile[i, j + 1].active() || !Main.tile[i + 1, j + 1].active()))
				{
					Main.tile[i, j].type = 2;
				}
			}
		}
		Liquid.QuickWater(-2);
		int num23 = (int)((double)Main.maxTilesX * 0.38);
		int num15 = (int)((double)Main.maxTilesX * 0.62);
		_ = Main.maxTilesY;
		int num16 = Main.maxTilesY - 135;
		_ = Main.maxTilesY;
		for (int k = num23; k < num15 + 15; k++)
		{
			for (int l = Main.maxTilesY - 200; l < num16 + 10; l++)
			{
				Main.tile[k, l].liquid = 0;
				if (Main.tile[k, l].type == 58)
				{
					Main.tile[k, l].type = 57;
				}
			}
		}
		AddTrees(undergroundOnly: true);
		for (int m = 0; m < Main.maxTilesX; m++)
		{
			byte color = 22;
			byte color2 = 22;
			if (drunkWorldGen)
			{
				if ((GenVars.crimsonLeft && m < Main.maxTilesX / 2) || (!GenVars.crimsonLeft && m > Main.maxTilesX / 2))
				{
					color2 = 13;
					color = 13;
				}
			}
			else if (crimson)
			{
				color2 = 13;
				color = 13;
			}
			for (int n = 0; n < Main.maxTilesY; n++)
			{
				if (Main.tile[m, n].active() && (Main.tileDungeon[Main.tile[m, n].type] || TileID.Sets.CrackedBricks[Main.tile[m, n].type]))
				{
					Main.tile[m, n].color(color);
				}
				if (Main.wallDungeon[Main.tile[m, n].wall])
				{
					Main.tile[m, n].wallColor(25);
					if (Main.tile[m, n].type == 19 && Main.tile[m, n].frameY != 180)
					{
						Main.tile[m, n].color(color);
					}
				}
				if (Main.tile[m, n].active())
				{
					bool flag = false;
					if (Main.tenthAnniversaryWorld)
					{
						if (Main.tile[m, n].type == 191)
						{
							flag = true;
						}
						if (Main.tile[m, n].active() && Main.tile[m, n].type == 151)
						{
							Main.tile[m, n].color(color);
						}
					}
					if (Main.tile[m, n].type == 226)
					{
						flag = true;
					}
					if (Main.tile[m, n].type == 137)
					{
						int num17 = Main.tile[m, n].frameY / 18;
						if (num17 >= 1 && num17 <= 4)
						{
							flag = true;
						}
					}
					if (flag)
					{
						Main.tile[m, n].color(color2);
					}
				}
				if (Main.tile[m, n].wall == 244)
				{
					Main.tile[m, n].wallColor(25);
				}
				if (Main.tile[m, n].wall == 34)
				{
					Main.tile[m, n].wallColor(25);
				}
				if (Main.tile[m, n].wall == 87)
				{
					Main.tile[m, n].wallColor(25);
					Main.tile[m, n].color(color2);
				}
			}
		}
		double num18 = (double)Main.maxTilesX / 4200.0;
		num18 *= (double)genRand.Next(2, 5);
		for (int num19 = 0; (double)num19 < num18; num19++)
		{
			int num20 = genRand.Next((int)((double)Main.maxTilesX * 0.39), (int)((double)Main.maxTilesX * 0.61));
			int num21 = genRand.Next(10, 31);
			for (int num22 = num20 - num21; num22 <= num20 + num21; num22++)
			{
				for (int num10 = Main.maxTilesY - 250; num10 < Main.maxTilesY - 25; num10++)
				{
					if (Main.tile[num22, num10].type == 637)
					{
						Main.tile[num22, num10].frameX = (short)(18 * Main.rand.Next(6, 11));
					}
				}
			}
		}
		if (notTheBees)
		{
			for (int num11 = 3; num11 < Main.maxTilesX - 3; num11++)
			{
				bool flag2 = true;
				for (int num12 = 0; (double)num12 < Main.worldSurface; num12++)
				{
					if (flag2)
					{
						if (Main.tile[num11, num12].wall == 86)
						{
							Main.tile[num11, num12].wall = 0;
						}
						if (Main.tile[num11, num12].active())
						{
							flag2 = false;
						}
					}
					else if (Main.tile[num11, num12].wall == 0 && Main.tile[num11, num12 + 1].wall == 0 && Main.tile[num11, num12 + 2].wall == 0 && Main.tile[num11, num12 + 3].wall == 0 && Main.tile[num11, num12 + 4].wall == 0 && Main.tile[num11 - 1, num12].wall == 0 && Main.tile[num11 + 1, num12].wall == 0 && Main.tile[num11 - 2, num12].wall == 0 && Main.tile[num11 + 2, num12].wall == 0 && !Main.tile[num11, num12].active() && !Main.tile[num11, num12 + 1].active() && !Main.tile[num11, num12 + 2].active() && !Main.tile[num11, num12 + 3].active())
					{
						flag2 = true;
					}
				}
			}
		}
		Liquid.QuickWater(-2);
		for (int num13 = 0; num13 < Main.maxTilesX; num13++)
		{
			for (int num14 = 0; num14 < Main.maxTilesY; num14++)
			{
				if (Main.tile[num13, num14].type == 518)
				{
					CheckLilyPad(num13, num14);
				}
			}
		}
	}

	public static bool IsItATrap(Tile tile)
	{
		if (tile.actuator())
		{
			return true;
		}
		if (tile.active() && TileID.Sets.IsAMechanism[tile.type])
		{
			return true;
		}
		return false;
	}

	public static bool IsItATrigger(Tile tile)
	{
		if (tile.active())
		{
			if (TileID.Sets.IsATrigger[tile.type])
			{
				return true;
			}
			if (tile.type == 467 && tile.frameX / 36 == 4)
			{
				return true;
			}
			if (tile.type == 314 && Minecart.IsPressurePlate(tile))
			{
				return true;
			}
		}
		return false;
	}

	public static void ClearAllBrokenTraps()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		List<Point> list = new List<Point>();
		for (int i = 50; i < Main.maxTilesX - 50; i++)
		{
			for (int j = 50; j < Main.maxTilesY - 50; j++)
			{
				if (Main.tile[i, j].wire() && !list.Contains(new Point(i, j)))
				{
					ClearBrokenTraps(new Point(i, j), list);
				}
			}
		}
	}

	public static void ClearBrokenTraps(Point startTileCoords, List<Point> pointsWeAlreadyWentOver)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		List<Point> t = new List<Point>();
		List<Point> t2 = new List<Point>();
		List<Point> list = new List<Point>();
		bool flag = false;
		bool flag2 = false;
		t2.Add(startTileCoords);
		Point item2 = default(Point);
		while (t2.Count > 0)
		{
			Utils.Swap(ref t, ref t2);
			while (t.Count > 0)
			{
				Point item = t[0];
				t.RemoveAt(0);
				if (!InWorld(item.X, item.Y, 5))
				{
					continue;
				}
				Tile tile = Main.tile[item.X, item.Y];
				if (tile.wire())
				{
					pointsWeAlreadyWentOver.Add(item);
					list.Add(item);
					if (IsItATrap(tile))
					{
						flag = true;
					}
					if (IsItATrigger(tile))
					{
						flag2 = true;
					}
					if (flag2 && flag)
					{
						break;
					}
					((Point)(ref item2))._002Ector(item.X - 1, item.Y);
					if (!list.Contains(item2))
					{
						t2.Add(item2);
					}
					((Point)(ref item2))._002Ector(item.X + 1, item.Y);
					if (!list.Contains(item2))
					{
						t2.Add(item2);
					}
					((Point)(ref item2))._002Ector(item.X, item.Y - 1);
					if (!list.Contains(item2))
					{
						t2.Add(item2);
					}
					((Point)(ref item2))._002Ector(item.X, item.Y + 1);
					if (!list.Contains(item2))
					{
						t2.Add(item2);
					}
				}
			}
			if (flag2 && flag)
			{
				break;
			}
		}
		if (flag2 && flag)
		{
			return;
		}
		foreach (Point item3 in list)
		{
			Tile tile2 = Main.tile[item3.X, item3.Y];
			tile2.wire(wire: false);
			if (IsItATrap(tile2))
			{
				if (tile2.actuator())
				{
					Main.tile[item3.X, item3.Y].actuator(actuator: false);
				}
				else if (tile2.type != 105)
				{
					KillTile(item3.X, item3.Y);
				}
			}
			else if (IsItATrigger(tile2))
			{
				if (tile2.type == 314)
				{
					tile2.frameX = 1;
				}
				else
				{
					KillTile(item3.X, item3.Y);
				}
			}
		}
	}

	private static double TuneOceanDepth(int count, double depth, bool floridaStyle = false)
	{
		if (!floridaStyle)
		{
			if (count < 3)
			{
				depth += (double)genRand.Next(10, 20) * 0.2;
			}
			else if (count < 6)
			{
				depth += (double)genRand.Next(10, 20) * 0.15;
			}
			else if (count < 9)
			{
				depth += (double)genRand.Next(10, 20) * 0.1;
			}
			else if (count < 15)
			{
				depth += (double)genRand.Next(10, 20) * 0.07;
			}
			else if (count < 50)
			{
				depth += (double)genRand.Next(10, 20) * 0.05;
			}
			else if (count < 75)
			{
				depth += (double)genRand.Next(10, 20) * 0.04;
			}
			else if (count < 100)
			{
				depth += (double)genRand.Next(10, 20) * 0.03;
			}
			else if (count < 125)
			{
				depth += (double)genRand.Next(10, 20) * 0.02;
			}
			else if (count < 150)
			{
				depth += (double)genRand.Next(10, 20) * 0.01;
			}
			else if (count < 175)
			{
				depth += (double)genRand.Next(10, 20) * 0.005;
			}
			else if (count < 200)
			{
				depth += (double)genRand.Next(10, 20) * 0.001;
			}
			else if (count < 230)
			{
				depth += (double)genRand.Next(10, 20) * 0.01;
			}
			else if (count < 235)
			{
				depth += (double)genRand.Next(10, 20) * 0.05;
			}
			else if (count < 240)
			{
				depth += (double)genRand.Next(10, 20) * 0.1;
			}
			else if (count < 245)
			{
				depth += (double)genRand.Next(10, 20) * 0.05;
			}
			else if (count < 255)
			{
				depth += (double)genRand.Next(10, 20) * 0.01;
			}
		}
		else if (count < 3)
		{
			depth += (double)genRand.Next(10, 20) * 0.001;
		}
		else if (count < 6)
		{
			depth += (double)genRand.Next(10, 20) * 0.002;
		}
		else if (count < 9)
		{
			depth += (double)genRand.Next(10, 20) * 0.004;
		}
		else if (count < 15)
		{
			depth += (double)genRand.Next(10, 20) * 0.007;
		}
		else if (count < 50)
		{
			depth += (double)genRand.Next(10, 20) * 0.01;
		}
		else if (count < 75)
		{
			depth += (double)genRand.Next(10, 20) * 0.014;
		}
		else if (count < 100)
		{
			depth += (double)genRand.Next(10, 20) * 0.019;
		}
		else if (count < 125)
		{
			depth += (double)genRand.Next(10, 20) * 0.027;
		}
		else if (count < 150)
		{
			depth += (double)genRand.Next(10, 20) * 0.038;
		}
		else if (count < 175)
		{
			depth += (double)genRand.Next(10, 20) * 0.052;
		}
		else if (count < 200)
		{
			depth += (double)genRand.Next(10, 20) * 0.08;
		}
		else if (count < 230)
		{
			depth += (double)genRand.Next(10, 20) * 0.12;
		}
		else if (count < 235)
		{
			depth += (double)genRand.Next(10, 20) * 0.16;
		}
		else if (count < 240)
		{
			depth += (double)genRand.Next(10, 20) * 0.27;
		}
		else if (count < 245)
		{
			depth += (double)genRand.Next(10, 20) * 0.43;
		}
		else if (count < 255)
		{
			depth += (double)genRand.Next(10, 20) * 0.6;
		}
		return depth;
	}

	public static void QueuePostGenAction(Action<StructureMap> action)
	{
		_postGenActions.Enqueue(action);
	}

	public static void ConsumePostGenActions(StructureMap structures)
	{
		while (_postGenActions.Count > 0)
		{
			_postGenActions.Dequeue()(structures);
		}
	}

	public static Point RandomRectanglePoint(Rectangle rectangle)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		return new Point(genRand.Next(rectangle.X, rectangle.X + rectangle.Width), genRand.Next(rectangle.Y, rectangle.Y + rectangle.Height));
	}

	public static Point RandomRectanglePoint(int x, int y, int width, int height)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		return new Point(genRand.Next(x, x + width), genRand.Next(y, y + height));
	}

	public static Point RandomWorldPoint(int padding)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		return RandomWorldPoint(padding, padding, padding, padding);
	}

	public static Point RandomWorldPoint(int top = 0, int right = 0, int bottom = 0, int left = 0)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		return new Point(genRand.Next(left, Main.maxTilesX - right), genRand.Next(top, Main.maxTilesY - bottom));
	}

	public static bool GrowPalmTree(int i, int y)
	{
		int num = y;
		if (!InWorld(i, y))
		{
			return false;
		}
		while (TileID.Sets.TreeSapling[Main.tile[i, num].type])
		{
			num++;
			if (Main.tile[i, num] == null)
			{
				return false;
			}
		}
		Tile tile = Main.tile[i, num];
		Tile tile2 = Main.tile[i, num - 1];
		byte color = 0;
		if (Main.tenthAnniversaryWorld && !gen)
		{
			color = (byte)genRand.Next(1, 13);
		}
		tile.slope();
		tile.halfBrick();
		if (!tile.active() || tile.halfBrick() || tile.slope() != 0)
		{
			return false;
		}
		if (tile2.wall != 0 || tile2.liquid != 0)
		{
			return false;
		}
		bool vanillaCanGrow = true;
		if (tile.type != 53 && tile.type != 234 && tile.type != 116 && tile.type != 112)
		{
			vanillaCanGrow = false;
		}
		if (!vanillaCanGrow && !TileLoader.CanGrowModPalmTree(tile.type))
		{
			return false;
		}
		if (!EmptyTileCheck(i, i, num - 2, num - 1, 20))
		{
			return false;
		}
		if (!EmptyTileCheck(i - 1, i + 1, num - 30, num - 3, 20))
		{
			return false;
		}
		int num2 = genRand.Next(10, 21);
		int num3 = genRand.Next(-8, 9);
		num3 *= 2;
		short num4 = 0;
		for (int j = 0; j < num2; j++)
		{
			tile = Main.tile[i, num - 1 - j];
			if (j == 0)
			{
				tile.active(active: true);
				tile.type = 323;
				tile.frameX = 66;
				tile.frameY = 0;
				tile.color(color);
				continue;
			}
			if (j == num2 - 1)
			{
				tile.active(active: true);
				tile.type = 323;
				tile.frameX = (short)(22 * genRand.Next(4, 7));
				tile.frameY = num4;
				tile.color(color);
				continue;
			}
			if (num4 != num3)
			{
				double num5 = (double)j / (double)num2;
				if (!(num5 < 0.25))
				{
					if ((!(num5 < 0.5) || genRand.Next(13) != 0) && (!(num5 < 0.7) || genRand.Next(9) != 0) && num5 < 0.95)
					{
						genRand.Next(5);
					}
					short num6 = (short)Math.Sign(num3);
					num4 += (short)(num6 * 2);
				}
			}
			tile.active(active: true);
			tile.type = 323;
			tile.frameX = (short)(22 * genRand.Next(0, 3));
			tile.frameY = num4;
			tile.color(color);
		}
		RangeFrame(i - 2, num - num2 - 1, i + 2, num + 1);
		NetMessage.SendTileSquare(-1, i, num - num2, 1, num2);
		return true;
	}

	public static bool IsPalmOasisTree(int x)
	{
		if (x >= beachDistance)
		{
			return x <= Main.maxTilesX - beachDistance;
		}
		return false;
	}

	public static bool GrowEpicTree(int i, int y)
	{
		int j;
		for (j = y; TileID.Sets.TreeSapling[Main.tile[i, j].type]; j++)
		{
		}
		if (Main.tile[i, j].active() && !Main.tile[i, j].halfBrick() && Main.tile[i, j].slope() == 0 && Main.tile[i, j].type == 2 && Main.tile[i, j - 1].wall == 0 && Main.tile[i, j - 1].liquid == 0 && ((Main.tile[i - 1, j].active() && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109 || TileLoader.CanGrowModTree(Main.tile[i - 1, j].type))) || (Main.tile[i + 1, j].active() && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109 || TileLoader.CanGrowModTree(Main.tile[i + 1, j].type)))))
		{
			int num = 2;
			if (EmptyTileCheck(i - num, i + num, j - 55, j - 1, 20))
			{
				bool flag = false;
				bool flag2 = false;
				int num2 = genRand.Next(20, 30);
				if (drunkWorldGen)
				{
					num2 = genRand.Next(3, 7);
				}
				int num3;
				for (int k = j - num2; k < j; k++)
				{
					Main.tile[i, k].frameNumber((byte)genRand.Next(3));
					Main.tile[i, k].active(active: true);
					Main.tile[i, k].type = 5;
					num3 = genRand.Next(3);
					int num4 = genRand.Next(10);
					if (k == j - 1 || k == j - num2)
					{
						num4 = 0;
					}
					while (((num4 == 5 || num4 == 7) && flag) || ((num4 == 6 || num4 == 7) && flag2))
					{
						num4 = genRand.Next(10);
					}
					flag = false;
					flag2 = false;
					if (num4 == 5 || num4 == 7)
					{
						flag = true;
					}
					if (num4 == 6 || num4 == 7)
					{
						flag2 = true;
					}
					switch (num4)
					{
					case 1:
						if (num3 == 0)
						{
							Main.tile[i, k].frameX = 0;
							Main.tile[i, k].frameY = 66;
						}
						if (num3 == 1)
						{
							Main.tile[i, k].frameX = 0;
							Main.tile[i, k].frameY = 88;
						}
						if (num3 == 2)
						{
							Main.tile[i, k].frameX = 0;
							Main.tile[i, k].frameY = 110;
						}
						break;
					case 2:
						if (num3 == 0)
						{
							Main.tile[i, k].frameX = 22;
							Main.tile[i, k].frameY = 0;
						}
						if (num3 == 1)
						{
							Main.tile[i, k].frameX = 22;
							Main.tile[i, k].frameY = 22;
						}
						if (num3 == 2)
						{
							Main.tile[i, k].frameX = 22;
							Main.tile[i, k].frameY = 44;
						}
						break;
					case 3:
						if (num3 == 0)
						{
							Main.tile[i, k].frameX = 44;
							Main.tile[i, k].frameY = 66;
						}
						if (num3 == 1)
						{
							Main.tile[i, k].frameX = 44;
							Main.tile[i, k].frameY = 88;
						}
						if (num3 == 2)
						{
							Main.tile[i, k].frameX = 44;
							Main.tile[i, k].frameY = 110;
						}
						break;
					case 4:
						if (num3 == 0)
						{
							Main.tile[i, k].frameX = 22;
							Main.tile[i, k].frameY = 66;
						}
						if (num3 == 1)
						{
							Main.tile[i, k].frameX = 22;
							Main.tile[i, k].frameY = 88;
						}
						if (num3 == 2)
						{
							Main.tile[i, k].frameX = 22;
							Main.tile[i, k].frameY = 110;
						}
						break;
					case 5:
						if (num3 == 0)
						{
							Main.tile[i, k].frameX = 88;
							Main.tile[i, k].frameY = 0;
						}
						if (num3 == 1)
						{
							Main.tile[i, k].frameX = 88;
							Main.tile[i, k].frameY = 22;
						}
						if (num3 == 2)
						{
							Main.tile[i, k].frameX = 88;
							Main.tile[i, k].frameY = 44;
						}
						break;
					case 6:
						if (num3 == 0)
						{
							Main.tile[i, k].frameX = 66;
							Main.tile[i, k].frameY = 66;
						}
						if (num3 == 1)
						{
							Main.tile[i, k].frameX = 66;
							Main.tile[i, k].frameY = 88;
						}
						if (num3 == 2)
						{
							Main.tile[i, k].frameX = 66;
							Main.tile[i, k].frameY = 110;
						}
						break;
					case 7:
						if (num3 == 0)
						{
							Main.tile[i, k].frameX = 110;
							Main.tile[i, k].frameY = 66;
						}
						if (num3 == 1)
						{
							Main.tile[i, k].frameX = 110;
							Main.tile[i, k].frameY = 88;
						}
						if (num3 == 2)
						{
							Main.tile[i, k].frameX = 110;
							Main.tile[i, k].frameY = 110;
						}
						break;
					default:
						if (num3 == 0)
						{
							Main.tile[i, k].frameX = 0;
							Main.tile[i, k].frameY = 0;
						}
						if (num3 == 1)
						{
							Main.tile[i, k].frameX = 0;
							Main.tile[i, k].frameY = 22;
						}
						if (num3 == 2)
						{
							Main.tile[i, k].frameX = 0;
							Main.tile[i, k].frameY = 44;
						}
						break;
					}
					if (num4 == 5 || num4 == 7)
					{
						Main.tile[i - 1, k].active(active: true);
						Main.tile[i - 1, k].type = 5;
						num3 = genRand.Next(3);
						if (genRand.Next(3) < 2)
						{
							if (num3 == 0)
							{
								Main.tile[i - 1, k].frameX = 44;
								Main.tile[i - 1, k].frameY = 198;
							}
							if (num3 == 1)
							{
								Main.tile[i - 1, k].frameX = 44;
								Main.tile[i - 1, k].frameY = 220;
							}
							if (num3 == 2)
							{
								Main.tile[i - 1, k].frameX = 44;
								Main.tile[i - 1, k].frameY = 242;
							}
						}
						else
						{
							if (num3 == 0)
							{
								Main.tile[i - 1, k].frameX = 66;
								Main.tile[i - 1, k].frameY = 0;
							}
							if (num3 == 1)
							{
								Main.tile[i - 1, k].frameX = 66;
								Main.tile[i - 1, k].frameY = 22;
							}
							if (num3 == 2)
							{
								Main.tile[i - 1, k].frameX = 66;
								Main.tile[i - 1, k].frameY = 44;
							}
						}
					}
					if (num4 != 6 && num4 != 7)
					{
						continue;
					}
					Main.tile[i + 1, k].active(active: true);
					Main.tile[i + 1, k].type = 5;
					num3 = genRand.Next(3);
					if (genRand.Next(3) < 2)
					{
						if (num3 == 0)
						{
							Main.tile[i + 1, k].frameX = 66;
							Main.tile[i + 1, k].frameY = 198;
						}
						if (num3 == 1)
						{
							Main.tile[i + 1, k].frameX = 66;
							Main.tile[i + 1, k].frameY = 220;
						}
						if (num3 == 2)
						{
							Main.tile[i + 1, k].frameX = 66;
							Main.tile[i + 1, k].frameY = 242;
						}
					}
					else
					{
						if (num3 == 0)
						{
							Main.tile[i + 1, k].frameX = 88;
							Main.tile[i + 1, k].frameY = 66;
						}
						if (num3 == 1)
						{
							Main.tile[i + 1, k].frameX = 88;
							Main.tile[i + 1, k].frameY = 88;
						}
						if (num3 == 2)
						{
							Main.tile[i + 1, k].frameX = 88;
							Main.tile[i + 1, k].frameY = 110;
						}
					}
				}
				int num5 = genRand.Next(3);
				bool flag3 = false;
				bool flag4 = false;
				if (Main.tile[i - 1, j].active() && !Main.tile[i - 1, j].halfBrick() && Main.tile[i - 1, j].slope() == 0 && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109 || TileLoader.CanGrowModTree(Main.tile[i - 1, j].type)))
				{
					flag3 = true;
				}
				if (Main.tile[i + 1, j].active() && !Main.tile[i + 1, j].halfBrick() && Main.tile[i + 1, j].slope() == 0 && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109 || TileLoader.CanGrowModTree(Main.tile[i + 1, j].type)))
				{
					flag4 = true;
				}
				if (!flag3)
				{
					if (num5 == 0)
					{
						num5 = 2;
					}
					if (num5 == 1)
					{
						num5 = 3;
					}
				}
				if (!flag4)
				{
					if (num5 == 0)
					{
						num5 = 1;
					}
					if (num5 == 2)
					{
						num5 = 3;
					}
				}
				if (flag3 && !flag4)
				{
					num5 = 2;
				}
				if (flag4 && !flag3)
				{
					num5 = 1;
				}
				if (num5 == 0 || num5 == 1)
				{
					Main.tile[i + 1, j - 1].active(active: true);
					Main.tile[i + 1, j - 1].type = 5;
					num3 = genRand.Next(3);
					if (num3 == 0)
					{
						Main.tile[i + 1, j - 1].frameX = 22;
						Main.tile[i + 1, j - 1].frameY = 132;
					}
					if (num3 == 1)
					{
						Main.tile[i + 1, j - 1].frameX = 22;
						Main.tile[i + 1, j - 1].frameY = 154;
					}
					if (num3 == 2)
					{
						Main.tile[i + 1, j - 1].frameX = 22;
						Main.tile[i + 1, j - 1].frameY = 176;
					}
				}
				if (num5 == 0 || num5 == 2)
				{
					Main.tile[i - 1, j - 1].active(active: true);
					Main.tile[i - 1, j - 1].type = 5;
					num3 = genRand.Next(3);
					if (num3 == 0)
					{
						Main.tile[i - 1, j - 1].frameX = 44;
						Main.tile[i - 1, j - 1].frameY = 132;
					}
					if (num3 == 1)
					{
						Main.tile[i - 1, j - 1].frameX = 44;
						Main.tile[i - 1, j - 1].frameY = 154;
					}
					if (num3 == 2)
					{
						Main.tile[i - 1, j - 1].frameX = 44;
						Main.tile[i - 1, j - 1].frameY = 176;
					}
				}
				num3 = genRand.Next(3);
				switch (num5)
				{
				case 0:
					if (num3 == 0)
					{
						Main.tile[i, j - 1].frameX = 88;
						Main.tile[i, j - 1].frameY = 132;
					}
					if (num3 == 1)
					{
						Main.tile[i, j - 1].frameX = 88;
						Main.tile[i, j - 1].frameY = 154;
					}
					if (num3 == 2)
					{
						Main.tile[i, j - 1].frameX = 88;
						Main.tile[i, j - 1].frameY = 176;
					}
					break;
				case 1:
					if (num3 == 0)
					{
						Main.tile[i, j - 1].frameX = 0;
						Main.tile[i, j - 1].frameY = 132;
					}
					if (num3 == 1)
					{
						Main.tile[i, j - 1].frameX = 0;
						Main.tile[i, j - 1].frameY = 154;
					}
					if (num3 == 2)
					{
						Main.tile[i, j - 1].frameX = 0;
						Main.tile[i, j - 1].frameY = 176;
					}
					break;
				case 2:
					if (num3 == 0)
					{
						Main.tile[i, j - 1].frameX = 66;
						Main.tile[i, j - 1].frameY = 132;
					}
					if (num3 == 1)
					{
						Main.tile[i, j - 1].frameX = 66;
						Main.tile[i, j - 1].frameY = 154;
					}
					if (num3 == 2)
					{
						Main.tile[i, j - 1].frameX = 66;
						Main.tile[i, j - 1].frameY = 176;
					}
					break;
				}
				if (genRand.Next(13) != 0)
				{
					num3 = genRand.Next(3);
					if (num3 == 0)
					{
						Main.tile[i, j - num2].frameX = 22;
						Main.tile[i, j - num2].frameY = 198;
					}
					if (num3 == 1)
					{
						Main.tile[i, j - num2].frameX = 22;
						Main.tile[i, j - num2].frameY = 220;
					}
					if (num3 == 2)
					{
						Main.tile[i, j - num2].frameX = 22;
						Main.tile[i, j - num2].frameY = 242;
					}
				}
				else
				{
					num3 = genRand.Next(3);
					if (num3 == 0)
					{
						Main.tile[i, j - num2].frameX = 0;
						Main.tile[i, j - num2].frameY = 198;
					}
					if (num3 == 1)
					{
						Main.tile[i, j - num2].frameX = 0;
						Main.tile[i, j - num2].frameY = 220;
					}
					if (num3 == 2)
					{
						Main.tile[i, j - num2].frameX = 0;
						Main.tile[i, j - num2].frameY = 242;
					}
				}
				RangeFrame(i - 2, j - num2 - 1, i + 2, j + 1);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, (int)((double)j - (double)num2 * 0.5), num2 + 1);
				}
				return true;
			}
		}
		return false;
	}

	public static bool Pyramid(int i, int j)
	{
		ushort num = 151;
		if (Main.tile[i, j].type == 151 || Main.tile[i, j].wall == 151)
		{
			return false;
		}
		int num35 = j - genRand.Next(0, 7);
		int num22 = genRand.Next(9, 13);
		int num29 = 1;
		int num30 = j + genRand.Next(75, 125);
		for (int k = num35; k < num30; k++)
		{
			for (int l = i - num29; l < i + num29 - 1; l++)
			{
				Main.tile[l, k].type = num;
				Main.tile[l, k].active(active: true);
				Main.tile[l, k].halfBrick(halfBrick: false);
				Main.tile[l, k].slope(0);
			}
			num29++;
		}
		for (int m = i - num29 - 5; m <= i + num29 + 5; m++)
		{
			for (int n = j - 1; n <= num30 + 1; n++)
			{
				bool flag = true;
				for (int num31 = m - 1; num31 <= m + 1; num31++)
				{
					for (int num32 = n - 1; num32 <= n + 1; num32++)
					{
						if (Main.tile[num31, num32].type != num)
						{
							flag = false;
						}
					}
				}
				if (flag)
				{
					Main.tile[m, n].wall = 34;
					SquareWallFrame(m, n);
				}
			}
		}
		int num33 = 1;
		if (genRand.Next(2) == 0)
		{
			num33 = -1;
		}
		int num34 = i - num22 * num33;
		int num2 = j + num22;
		int num3 = genRand.Next(5, 8);
		bool flag2 = true;
		int num4 = genRand.Next(20, 30);
		while (flag2)
		{
			flag2 = false;
			bool flag3 = false;
			for (int num5 = num2; num5 <= num2 + num3; num5++)
			{
				int num6 = num34;
				if (Main.tile[num6, num5 - 1].type == 53)
				{
					flag3 = true;
				}
				if (Main.tile[num6, num5].type == num)
				{
					Main.tile[num6, num5 + 1].wall = 34;
					Main.tile[num6 + num33, num5].wall = 34;
					Main.tile[num6, num5].active(active: false);
					flag2 = true;
				}
				if (flag3)
				{
					Main.tile[num6, num5].type = 53;
					Main.tile[num6, num5].active(active: true);
					Main.tile[num6, num5].halfBrick(halfBrick: false);
					Main.tile[num6, num5].slope(0);
				}
			}
			num34 -= num33;
		}
		num34 = i - num22 * num33;
		bool flag4 = true;
		bool flag5 = false;
		flag2 = true;
		while (flag2)
		{
			for (int num7 = num2; num7 <= num2 + num3; num7++)
			{
				int num8 = num34;
				Main.tile[num8, num7].active(active: false);
			}
			num34 += num33;
			num2++;
			num4--;
			if (num2 >= num30 - num3 * 2)
			{
				num4 = 10;
			}
			if (num4 <= 0)
			{
				bool flag6 = false;
				if (!flag4 && !flag5)
				{
					flag5 = true;
					flag6 = true;
					int num9 = genRand.Next(7, 13);
					int num10 = genRand.Next(23, 28);
					int num11 = num10;
					int num12 = num34;
					while (num10 > 0)
					{
						for (int num13 = num2 - num9 + num3; num13 <= num2 + num3; num13++)
						{
							if (num10 == num11 || num10 == 1)
							{
								if (num13 >= num2 - num9 + num3 + 2)
								{
									Main.tile[num34, num13].active(active: false);
								}
							}
							else if (num10 == num11 - 1 || num10 == 2 || num10 == num11 - 2 || num10 == 3)
							{
								if (num13 >= num2 - num9 + num3 + 1)
								{
									Main.tile[num34, num13].active(active: false);
								}
							}
							else
							{
								Main.tile[num34, num13].active(active: false);
							}
						}
						num10--;
						num34 += num33;
					}
					int num14 = num34 - num33;
					int num15 = num14;
					int num16 = num12;
					if (num14 > num12)
					{
						num15 = num12;
						num16 = num14;
					}
					int num17 = genRand.Next(3);
					if (num17 == 0)
					{
						num17 = genRand.Next(3);
					}
					if (Main.tenthAnniversaryWorld && num17 == 0)
					{
						num17 = 1;
					}
					switch (num17)
					{
					case 0:
						num17 = 848;
						break;
					case 1:
						num17 = 857;
						break;
					case 2:
						num17 = 934;
						break;
					}
					AddBuriedChest((num15 + num16) / 2, num2, num17, notNearOtherChests: false, 1, trySlope: false, 0);
					int num18 = genRand.Next(1, 10);
					for (int num19 = 0; num19 < num18; num19++)
					{
						int i2 = genRand.Next(num15, num16);
						int j2 = num2 + num3;
						PlaceSmallPile(i2, j2, genRand.Next(16, 19), 1, 185);
					}
					PlaceTile(num15 + 2, num2 - num9 + num3 + 1, 91, mute: true, forced: false, -1, genRand.Next(4, 7));
					PlaceTile(num15 + 3, num2 - num9 + num3, 91, mute: true, forced: false, -1, genRand.Next(4, 7));
					PlaceTile(num16 - 2, num2 - num9 + num3 + 1, 91, mute: true, forced: false, -1, genRand.Next(4, 7));
					PlaceTile(num16 - 3, num2 - num9 + num3, 91, mute: true, forced: false, -1, genRand.Next(4, 7));
					for (int num20 = num15; num20 <= num16; num20++)
					{
						PlacePot(num20, num2 + num3, 28, genRand.Next(25, 28));
					}
				}
				if (flag4)
				{
					flag4 = false;
					num33 *= -1;
					num4 = genRand.Next(15, 20);
				}
				else if (flag6)
				{
					num4 = genRand.Next(10, 15);
				}
				else
				{
					num33 *= -1;
					num4 = genRand.Next(20, 40);
				}
			}
			if (num2 >= num30 - num3)
			{
				flag2 = false;
			}
		}
		int num21 = genRand.Next(100, 200);
		int num23 = genRand.Next(500, 800);
		flag2 = true;
		int num24 = num3;
		num4 = genRand.Next(10, 50);
		if (num33 == 1)
		{
			num34 -= num24;
		}
		int num25 = genRand.Next(5, 10);
		while (flag2)
		{
			num21--;
			num23--;
			num4--;
			for (int num26 = num34 - num25 - genRand.Next(0, 2); num26 <= num34 + num24 + num25 + genRand.Next(0, 2); num26++)
			{
				int num27 = num2;
				if (num26 >= num34 && num26 <= num34 + num24)
				{
					Main.tile[num26, num27].active(active: false);
				}
				else
				{
					Main.tile[num26, num27].type = num;
					Main.tile[num26, num27].active(active: true);
					Main.tile[num26, num27].halfBrick(halfBrick: false);
					Main.tile[num26, num27].slope(0);
				}
				if (num26 >= num34 - 1 && num26 <= num34 + 1 + num24)
				{
					Main.tile[num26, num27].wall = 34;
				}
			}
			num2++;
			num34 += num33;
			if (num21 <= 0)
			{
				flag2 = false;
				for (int num28 = num34 + 1; num28 <= num34 + num24 - 1; num28++)
				{
					if (Main.tile[num28, num2].active())
					{
						flag2 = true;
					}
				}
			}
			if (num4 < 0)
			{
				num4 = genRand.Next(10, 50);
				num33 *= -1;
			}
			if (num23 <= 0)
			{
				flag2 = false;
			}
		}
		return true;
	}

	public static bool GrowLivingTree(int i, int j, bool patch = false)
	{
		int num = 0;
		int[] array = new int[1000];
		int[] array2 = new int[1000];
		int[] array3 = new int[1000];
		int[] array4 = new int[1000];
		int num12 = 0;
		int[] array5 = new int[2000];
		int[] array6 = new int[2000];
		bool[] array7 = new bool[2000];
		if (!SolidTile(i, j + 1))
		{
			return false;
		}
		if (Main.tile[i, j].active())
		{
			return false;
		}
		if (Main.tile[i, j + 1].type != 0 && Main.tile[i, j + 1].type != 2 && Main.tile[i, j + 1].type != 1 && Main.tile[i, j + 1].type != 40 && !TileID.Sets.Ore[Main.tile[i, j + 1].type] && (!remixWorldGen || !notTheBees || (Main.tile[i, j + 1].type != 60 && Main.tile[i, j + 1].type != 59)))
		{
			return false;
		}
		if (j < 150)
		{
			return false;
		}
		int num23 = i - genRand.Next(2, 3);
		int num34 = i + genRand.Next(2, 3);
		if (genRand.Next(5) == 0)
		{
			if (genRand.Next(2) == 0)
			{
				num23--;
			}
			else
			{
				num34++;
			}
		}
		int num45 = num34 - num23;
		bool flag = num45 >= 4;
		int num52 = i - 50;
		int num53 = i + 50;
		if (patch)
		{
			num52 = i - 20;
			num53 = i + 20;
			num23 = i - genRand.Next(1, 3);
			num34 = i + genRand.Next(1, 3);
			flag = num45 >= 4;
		}
		for (int k = num52; k <= num53; k++)
		{
			for (int l = 5; l < j - 5; l++)
			{
				if (Main.tile[k, l].active())
				{
					if (!patch)
					{
						return false;
					}
					int type = Main.tile[k, l].type;
					if (type != 2 && type != 0 && type != 1 && type != 191 && type != 192)
					{
						return false;
					}
				}
			}
		}
		int num54 = num23;
		int num55 = num34;
		int minl = num23;
		int minr = num34;
		bool flag2 = true;
		int num2 = genRand.Next(-8, -4);
		int num3 = genRand.Next(2);
		int num4 = j;
		int num5 = genRand.Next(5, 15);
		Main.tileSolid[48] = false;
		while (flag2)
		{
			num2++;
			if (num2 > num5)
			{
				num5 = genRand.Next(5, 15);
				num2 = 0;
				array2[num] = num4 + genRand.Next(5);
				if (genRand.Next(5) == 0)
				{
					num3 = ((num3 == 0) ? 1 : 0);
				}
				if (num3 == 0)
				{
					array3[num] = -1;
					array[num] = num23;
					array4[num] = num34 - num23;
					if (genRand.Next(2) == 0)
					{
						num23++;
					}
					num54++;
					num3 = 1;
				}
				else
				{
					array3[num] = 1;
					array[num] = num34;
					array4[num] = num34 - num23;
					if (genRand.Next(2) == 0)
					{
						num34--;
					}
					num55--;
					num3 = 0;
				}
				if (num54 == num55)
				{
					flag2 = false;
				}
				num++;
			}
			for (int m = num23; m <= num34; m++)
			{
				Main.tile[m, num4].type = 191;
				Main.tile[m, num4].active(active: true);
				Main.tile[m, num4].halfBrick(halfBrick: false);
			}
			num4--;
		}
		for (int n = 0; n < num - 1; n++)
		{
			int num6 = array[n] + array3[n];
			int num7 = array2[n];
			int num8 = (int)((double)array4[n] * (1.0 + (double)genRand.Next(20, 30) * 0.1));
			Main.tile[num6, num7 + 1].type = 191;
			Main.tile[num6, num7 + 1].active(active: true);
			Main.tile[num6, num7 + 1].halfBrick(halfBrick: false);
			int num9 = genRand.Next(3, 5);
			while (num8 > 0)
			{
				num8--;
				Main.tile[num6, num7].type = 191;
				Main.tile[num6, num7].active(active: true);
				Main.tile[num6, num7].halfBrick(halfBrick: false);
				if (genRand.Next(10) == 0)
				{
					num7 = ((genRand.Next(2) != 0) ? (num7 + 1) : (num7 - 1));
				}
				else
				{
					num6 += array3[n];
				}
				if (num9 > 0)
				{
					num9--;
				}
				else if (genRand.Next(2) == 0)
				{
					num9 = genRand.Next(2, 5);
					if (genRand.Next(2) == 0)
					{
						Main.tile[num6, num7].type = 191;
						Main.tile[num6, num7].active(active: true);
						Main.tile[num6, num7].halfBrick(halfBrick: false);
						Main.tile[num6, num7 - 1].type = 191;
						Main.tile[num6, num7 - 1].active(active: true);
						Main.tile[num6, num7 - 1].halfBrick(halfBrick: false);
						array5[num12] = num6;
						array6[num12] = num7;
						num12++;
					}
					else
					{
						Main.tile[num6, num7].type = 191;
						Main.tile[num6, num7].active(active: true);
						Main.tile[num6, num7].halfBrick(halfBrick: false);
						Main.tile[num6, num7 + 1].type = 191;
						Main.tile[num6, num7 + 1].active(active: true);
						Main.tile[num6, num7 + 1].halfBrick(halfBrick: false);
						array5[num12] = num6;
						array6[num12] = num7;
						num12++;
					}
				}
				if (num8 == 0)
				{
					array5[num12] = num6;
					array6[num12] = num7;
					num12++;
				}
			}
		}
		int num10 = (num23 + num34) / 2;
		int num11 = num4;
		int num13 = genRand.Next(num45 * 3, num45 * 5);
		int num14 = 0;
		int num15 = 0;
		while (num13 > 0)
		{
			Main.tile[num10, num11].type = 191;
			Main.tile[num10, num11].active(active: true);
			Main.tile[num10, num11].halfBrick(halfBrick: false);
			if (num14 > 0)
			{
				num14--;
			}
			if (num15 > 0)
			{
				num15--;
			}
			for (int num16 = -1; num16 < 2; num16++)
			{
				if (num16 == 0 || ((num16 >= 0 || num14 != 0) && (num16 <= 0 || num15 != 0)) || genRand.Next(2) != 0)
				{
					continue;
				}
				int num17 = num10;
				int num18 = num11;
				int num19 = genRand.Next(num45, num45 * 3);
				if (num16 < 0)
				{
					num14 = genRand.Next(3, 5);
				}
				if (num16 > 0)
				{
					num15 = genRand.Next(3, 5);
				}
				int num20 = 0;
				while (num19 > 0)
				{
					num19--;
					num17 += num16;
					Main.tile[num17, num18].type = 191;
					Main.tile[num17, num18].active(active: true);
					Main.tile[num17, num18].halfBrick(halfBrick: false);
					if (num19 == 0)
					{
						array5[num12] = num17;
						array6[num12] = num18;
						array7[num12] = true;
						num12++;
					}
					if (genRand.Next(5) == 0)
					{
						num18 = ((genRand.Next(2) != 0) ? (num18 + 1) : (num18 - 1));
						Main.tile[num17, num18].type = 191;
						Main.tile[num17, num18].active(active: true);
						Main.tile[num17, num18].halfBrick(halfBrick: false);
					}
					if (num20 > 0)
					{
						num20--;
					}
					else if (genRand.Next(3) == 0)
					{
						num20 = genRand.Next(2, 4);
						int num21 = num17;
						int num22 = num18;
						num22 = ((genRand.Next(2) != 0) ? (num22 + 1) : (num22 - 1));
						Main.tile[num21, num22].type = 191;
						Main.tile[num21, num22].active(active: true);
						Main.tile[num21, num22].halfBrick(halfBrick: false);
						array5[num12] = num21;
						array6[num12] = num22;
						array7[num12] = true;
						num12++;
						array5[num12] = num21 + genRand.Next(-5, 6);
						array6[num12] = num22 + genRand.Next(-5, 6);
						array7[num12] = true;
						num12++;
					}
				}
			}
			array5[num12] = num10;
			array6[num12] = num11;
			num12++;
			if (genRand.Next(4) == 0)
			{
				num10 = ((genRand.Next(2) != 0) ? (num10 + 1) : (num10 - 1));
				Main.tile[num10, num11].type = 191;
				Main.tile[num10, num11].active(active: true);
				Main.tile[num10, num11].halfBrick(halfBrick: false);
			}
			num11--;
			num13--;
		}
		for (int num24 = minl; num24 <= minr; num24++)
		{
			int num25 = genRand.Next(1, 6);
			int num26 = j + 1;
			while (num25 > 0)
			{
				if (SolidTile(num24, num26))
				{
					num25--;
				}
				Main.tile[num24, num26].type = 191;
				Main.tile[num24, num26].active(active: true);
				Main.tile[num24, num26].halfBrick(halfBrick: false);
				num26++;
			}
			int num27 = num26;
			int num28 = genRand.Next(2, num45 + 1);
			for (int num29 = 0; num29 < num28; num29++)
			{
				num26 = num27;
				int num30 = (minl + minr) / 2;
				int num31 = 0;
				int num32 = 1;
				num31 = ((num24 >= num30) ? 1 : (-1));
				if (num24 == num30 || (num45 > 6 && (num24 == num30 - 1 || num24 == num30 + 1)))
				{
					num31 = 0;
				}
				int num33 = num31;
				int num35 = num24;
				num25 = genRand.Next((int)((double)num45 * 3.5), num45 * 6);
				while (num25 > 0)
				{
					num25--;
					num35 += num31;
					if (Main.tile[num35, num26].wall != 244)
					{
						Main.tile[num35, num26].type = 191;
						Main.tile[num35, num26].active(active: true);
						Main.tile[num35, num26].halfBrick(halfBrick: false);
					}
					num26 += num32;
					if (Main.tile[num35, num26].wall != 244)
					{
						Main.tile[num35, num26].type = 191;
						Main.tile[num35, num26].active(active: true);
						Main.tile[num35, num26].halfBrick(halfBrick: false);
					}
					if (!Main.tile[num35, num26 + 1].active())
					{
						num31 = 0;
						num32 = 1;
					}
					if (genRand.Next(3) == 0)
					{
						num31 = ((num33 >= 0) ? ((num33 <= 0) ? genRand.Next(-1, 2) : ((num31 == 0) ? 1 : 0)) : ((num31 == 0) ? (-1) : 0));
					}
					if (genRand.Next(3) == 0)
					{
						num32 = ((num32 == 0) ? 1 : 0);
					}
				}
			}
		}
		if (remixWorldGen)
		{
			num12 = 0;
		}
		for (int num36 = 0; num36 < num12; num36++)
		{
			int num37 = genRand.Next(5, 8);
			num37 = (int)((double)num37 * (1.0 + (double)num45 * 0.05));
			if (array7[num36])
			{
				num37 = genRand.Next(6, 12) + num45;
			}
			int num38 = array5[num36] - num37 * 2;
			int num39 = array5[num36] + num37 * 2;
			int num40 = array6[num36] - num37 * 2;
			int num41 = array6[num36] + num37 * 2;
			double num42 = 2.0 - (double)genRand.Next(5) * 0.1;
			for (int num43 = num38; num43 <= num39; num43++)
			{
				for (int num44 = num40; num44 <= num41; num44++)
				{
					if (Main.tile[num43, num44].type == 191)
					{
						continue;
					}
					if (array7[num36])
					{
						if ((new Vector2D(array5[num36], array6[num36]) - new Vector2D(num43, num44)).Length() < (double)num37 * 0.9)
						{
							Main.tile[num43, num44].type = 192;
							Main.tile[num43, num44].active(active: true);
							Main.tile[num43, num44].halfBrick(halfBrick: false);
						}
					}
					else if ((double)Math.Abs(array5[num36] - num43) + (double)Math.Abs(array6[num36] - num44) * num42 < (double)num37)
					{
						Main.tile[num43, num44].type = 192;
						Main.tile[num43, num44].active(active: true);
						Main.tile[num43, num44].halfBrick(halfBrick: false);
					}
				}
				if (genRand.Next(30) == 0)
				{
					int num46 = num40;
					if (!Main.tile[num43, num46].active())
					{
						for (; !Main.tile[num43, num46 + 1].active() && num46 < num41; num46++)
						{
						}
						if (Main.tile[num43, num46 + 1].type == 192)
						{
							PlaceTile(num43, num46, 187, mute: true, forced: false, -1, genRand.Next(50, 52));
						}
					}
				}
				if (array7[num36] || genRand.Next(15) != 0)
				{
					continue;
				}
				int num47 = num41;
				int num48 = num47 + 100;
				if (Main.tile[num43, num47].active())
				{
					continue;
				}
				for (; !Main.tile[num43, num47 + 1].active() && num47 < num48; num47++)
				{
				}
				if (Main.tile[num43, num47 + 1].type == 192)
				{
					continue;
				}
				if (genRand.Next(2) == 0)
				{
					PlaceTile(num43, num47, 187, mute: true, forced: false, -1, genRand.Next(47, 50));
					continue;
				}
				int num49 = genRand.Next(2);
				int x = 72;
				if (num49 == 1)
				{
					x = genRand.Next(59, 62);
				}
				PlaceSmallPile(num43, num47, x, num49, 185);
			}
		}
		if (flag)
		{
			bool flag3 = false;
			for (int num50 = j; num50 < j + 20 && !((double)num50 >= Main.worldSurface - 2.0); num50++)
			{
				for (int num51 = minl; num51 <= minr; num51++)
				{
					if (Main.tile[num51, num50].wall == 0 && !SolidTile(num51, num50))
					{
						flag3 = true;
					}
				}
			}
			if (!flag3)
			{
				GrowLivingTree_MakePassage(j, num45, ref minl, ref minr, patch);
			}
		}
		Main.tileSolid[48] = true;
		return true;
	}

	public static bool GrowDungeonTree(int i, int j, bool patch = false)
	{
		int num = 0;
		int[] array = new int[1000];
		int[] array2 = new int[1000];
		int[] array3 = new int[1000];
		int[] array4 = new int[1000];
		int num12 = 0;
		int[] array5 = new int[2000];
		int[] array6 = new int[2000];
		bool[] array7 = new bool[2000];
		int num23 = i - genRand.Next(2, 3);
		int num34 = i + genRand.Next(2, 3);
		if (genRand.Next(5) == 0)
		{
			if (genRand.Next(2) == 0)
			{
				num23--;
			}
			else
			{
				num34++;
			}
		}
		int num41 = num34 - num23;
		int num42 = num23;
		int num43 = num34;
		int minl = num23;
		int minr = num34;
		bool flag = true;
		int num44 = genRand.Next(-8, -4);
		int num45 = genRand.Next(2);
		int num2 = j;
		int num3 = genRand.Next(5, 15);
		Main.tileSolid[48] = false;
		while (flag)
		{
			num44++;
			if (num44 > num3)
			{
				num3 = genRand.Next(5, 15);
				num44 = 0;
				array2[num] = num2 + genRand.Next(5);
				if (genRand.Next(5) == 0)
				{
					num45 = ((num45 == 0) ? 1 : 0);
				}
				if (num45 == 0)
				{
					array3[num] = -1;
					array[num] = num23;
					array4[num] = num34 - num23;
					if (genRand.Next(2) == 0)
					{
						num23++;
					}
					num42++;
					num45 = 1;
				}
				else
				{
					array3[num] = 1;
					array[num] = num34;
					array4[num] = num34 - num23;
					if (genRand.Next(2) == 0)
					{
						num34--;
					}
					num43--;
					num45 = 0;
				}
				if (num42 == num43)
				{
					flag = false;
				}
				num++;
			}
			for (int k = num23; k <= num34; k++)
			{
				Main.tile[k, num2].type = 191;
				Main.tile[k, num2].active(active: true);
				Main.tile[k, num2].halfBrick(halfBrick: false);
				Main.tile[k, num2].slope(0);
				Main.tile[k, num2].color(28);
			}
			num2--;
		}
		for (int l = 0; l < num - 1; l++)
		{
			int num4 = array[l] + array3[l];
			int num5 = array2[l];
			int num6 = (int)((double)array4[l] * (1.0 + (double)genRand.Next(20, 30) * 0.1));
			Main.tile[num4, num5 + 1].type = 191;
			Main.tile[num4, num5 + 1].active(active: true);
			Main.tile[num4, num5 + 1].halfBrick(halfBrick: false);
			Main.tile[num4, num5 + 1].color(28);
			int num7 = genRand.Next(3, 5);
			while (num6 > 0)
			{
				num6--;
				Main.tile[num4, num5].type = 191;
				Main.tile[num4, num5].active(active: true);
				Main.tile[num4, num5].halfBrick(halfBrick: false);
				Main.tile[num4, num5].color(28);
				Main.tile[num4, num5].slope(0);
				if (genRand.Next(10) == 0)
				{
					num5 = ((genRand.Next(2) != 0) ? (num5 + 1) : (num5 - 1));
				}
				else
				{
					num4 += array3[l];
				}
				if (num7 > 0)
				{
					num7--;
				}
				else if (genRand.Next(2) == 0)
				{
					num7 = genRand.Next(2, 5);
					if (genRand.Next(2) == 0)
					{
						Main.tile[num4, num5].type = 191;
						Main.tile[num4, num5].active(active: true);
						Main.tile[num4, num5].halfBrick(halfBrick: false);
						Main.tile[num4, num5].color(28);
						Main.tile[num4, num5].slope(0);
						Main.tile[num4, num5 - 1].type = 191;
						Main.tile[num4, num5 - 1].active(active: true);
						Main.tile[num4, num5 - 1].halfBrick(halfBrick: false);
						Main.tile[num4, num5 - 1].color(28);
						array5[num12] = num4;
						array6[num12] = num5;
						num12++;
					}
					else
					{
						Main.tile[num4, num5].type = 191;
						Main.tile[num4, num5].active(active: true);
						Main.tile[num4, num5].halfBrick(halfBrick: false);
						Main.tile[num4, num5].color(28);
						Main.tile[num4, num5].slope(0);
						Main.tile[num4, num5 + 1].type = 191;
						Main.tile[num4, num5 + 1].active(active: true);
						Main.tile[num4, num5 + 1].halfBrick(halfBrick: false);
						Main.tile[num4, num5 + 1].color(28);
						array5[num12] = num4;
						array6[num12] = num5;
						num12++;
					}
				}
				if (num6 == 0)
				{
					array5[num12] = num4;
					array6[num12] = num5;
					num12++;
				}
			}
		}
		int num8 = (num23 + num34) / 2;
		int num9 = num2;
		int num10 = genRand.Next(num41 * 3, num41 * 5);
		int num11 = 0;
		int num13 = 0;
		while (num10 > 0)
		{
			Main.tile[num8, num9].type = 191;
			Main.tile[num8, num9].active(active: true);
			Main.tile[num8, num9].halfBrick(halfBrick: false);
			Main.tile[num8, num9].color(28);
			if (num11 > 0)
			{
				num11--;
			}
			if (num13 > 0)
			{
				num13--;
			}
			for (int m = -1; m < 2; m++)
			{
				if (m == 0 || ((m >= 0 || num11 != 0) && (m <= 0 || num13 != 0)) || genRand.Next(2) != 0)
				{
					continue;
				}
				int num14 = num8;
				int num15 = num9;
				int num16 = genRand.Next(num41, num41 * 3);
				if (m < 0)
				{
					num11 = genRand.Next(3, 5);
				}
				if (m > 0)
				{
					num13 = genRand.Next(3, 5);
				}
				int num17 = 0;
				while (num16 > 0)
				{
					num16--;
					num14 += m;
					Main.tile[num14, num15].type = 191;
					Main.tile[num14, num15].active(active: true);
					Main.tile[num14, num15].halfBrick(halfBrick: false);
					Main.tile[num14, num15].color(28);
					if (num16 == 0)
					{
						array5[num12] = num14;
						array6[num12] = num15;
						array7[num12] = true;
						num12++;
					}
					if (genRand.Next(5) == 0)
					{
						num15 = ((genRand.Next(2) != 0) ? (num15 + 1) : (num15 - 1));
						Main.tile[num14, num15].type = 191;
						Main.tile[num14, num15].active(active: true);
						Main.tile[num14, num15].halfBrick(halfBrick: false);
						Main.tile[num14, num15].color(28);
					}
					if (num17 > 0)
					{
						num17--;
					}
					else if (genRand.Next(3) == 0)
					{
						num17 = genRand.Next(2, 4);
						int num18 = num14;
						int num19 = num15;
						num19 = ((genRand.Next(2) != 0) ? (num19 + 1) : (num19 - 1));
						Main.tile[num18, num19].type = 191;
						Main.tile[num18, num19].active(active: true);
						Main.tile[num18, num19].halfBrick(halfBrick: false);
						Main.tile[num18, num19].color(28);
						array5[num12] = num18;
						array6[num12] = num19;
						array7[num12] = true;
						num12++;
						array5[num12] = num18 + genRand.Next(-5, 6);
						array6[num12] = num19 + genRand.Next(-5, 6);
						array7[num12] = true;
						num12++;
					}
				}
			}
			array5[num12] = num8;
			array6[num12] = num9;
			num12++;
			if (genRand.Next(4) == 0)
			{
				num8 = ((genRand.Next(2) != 0) ? (num8 + 1) : (num8 - 1));
				Main.tile[num8, num9].type = 191;
				Main.tile[num8, num9].active(active: true);
				Main.tile[num8, num9].halfBrick(halfBrick: false);
				Main.tile[num8, num9].color(28);
			}
			num9--;
			num10--;
		}
		for (int n = minl; n <= minr; n++)
		{
			int num20 = genRand.Next(1, 6);
			int num21 = j + 1;
			while (num20 > 0)
			{
				if (SolidTile(n, num21))
				{
					num20--;
				}
				Main.tile[n, num21].type = 191;
				Main.tile[n, num21].active(active: true);
				Main.tile[n, num21].halfBrick(halfBrick: false);
				Main.tile[n, num21].slope(0);
				num21++;
			}
			int num22 = num21;
			int num24 = genRand.Next(2, num41 + 1);
			for (int num25 = 0; num25 < num24; num25++)
			{
				num21 = num22;
				int num26 = (minl + minr) / 2;
				int num27 = 0;
				int num28 = 1;
				num27 = ((n >= num26) ? 1 : (-1));
				if (n == num26 || (num41 > 6 && (n == num26 - 1 || n == num26 + 1)))
				{
					num27 = 0;
				}
				int num29 = num27;
				int num30 = n;
				num20 = genRand.Next((int)((double)num41 * 3.5), num41 * 6);
				while (num20 > 0)
				{
					num20--;
					num30 += num27;
					if (Main.tile[num30, num21].wall != 244)
					{
						Main.tile[num30, num21].type = 191;
						Main.tile[num30, num21].active(active: true);
						Main.tile[num30, num21].halfBrick(halfBrick: false);
						Main.tile[num30, num21].slope(0);
					}
					num21 += num28;
					if (Main.tile[num30, num21].wall != 244)
					{
						Main.tile[num30, num21].type = 191;
						Main.tile[num30, num21].active(active: true);
						Main.tile[num30, num21].halfBrick(halfBrick: false);
						Main.tile[num30, num21].slope(0);
					}
					if (!Main.tile[num30, num21 + 1].active())
					{
						num27 = 0;
						num28 = 1;
					}
					if (genRand.Next(3) == 0)
					{
						num27 = ((num29 >= 0) ? ((num29 <= 0) ? genRand.Next(-1, 2) : ((num27 == 0) ? 1 : 0)) : ((num27 == 0) ? (-1) : 0));
					}
					if (genRand.Next(3) == 0)
					{
						num28 = ((num28 == 0) ? 1 : 0);
					}
				}
			}
		}
		if (!remixWorldGen)
		{
			for (int num31 = 0; num31 < num12; num31++)
			{
				int num32 = genRand.Next(5, 8);
				num32 = (int)((double)num32 * (1.0 + (double)num41 * 0.05));
				if (array7[num31])
				{
					num32 = genRand.Next(6, 12) + num41;
				}
				int num33 = array5[num31] - num32 * 2;
				int num35 = array5[num31] + num32 * 2;
				int num36 = array6[num31] - num32 * 2;
				int num37 = array6[num31] + num32 * 2;
				double num38 = 2.0 - (double)genRand.Next(5) * 0.1;
				for (int num39 = num33; num39 <= num35; num39++)
				{
					for (int num40 = num36; num40 <= num37; num40++)
					{
						if (Main.tile[num39, num40].type == 191)
						{
							continue;
						}
						if (array7[num31])
						{
							if ((new Vector2D(array5[num31], array6[num31]) - new Vector2D(num39, num40)).Length() < (double)num32 * 0.9)
							{
								Main.tile[num39, num40].type = 192;
								Main.tile[num39, num40].active(active: true);
								Main.tile[num39, num40].halfBrick(halfBrick: false);
								Main.tile[num39, num40].color(28);
							}
						}
						else if ((double)Math.Abs(array5[num31] - num39) + (double)Math.Abs(array6[num31] - num40) * num38 < (double)num32)
						{
							Main.tile[num39, num40].type = 192;
							Main.tile[num39, num40].active(active: true);
							Main.tile[num39, num40].halfBrick(halfBrick: false);
							Main.tile[num39, num40].color(28);
						}
					}
				}
			}
		}
		GrowDungeonTree_MakePassage(j, num41, ref minl, ref minr, patch);
		Main.tileSolid[48] = true;
		return true;
	}

	private static bool GrowLivingTree_HorizontalTunnel(int i, int j)
	{
		int num = i;
		int num5 = i;
		int num6 = 80;
		bool flag = false;
		int num7 = 1;
		if (genRand.Next(2) == 0)
		{
			num7 *= -1;
		}
		for (int k = 0; k < 2; k++)
		{
			flag = false;
			if (num == i && num7 > 0)
			{
				for (int l = i + 5; l < i + num6; l++)
				{
					if (!InWorld(l, j, 10))
					{
						return false;
					}
					if ((double)j < Main.worldSurface)
					{
						for (int m = j - 7; m <= j + 7 && Main.tile[l, m].wall != 0; m++)
						{
						}
					}
					if (Main.tile[l, j].type == 48)
					{
						flag = true;
						break;
					}
					if (Main.tile[l, j].type == 191)
					{
						for (int n = j - 2; n <= j; n++)
						{
							if (Main.tile[l + 2, n].wall != 244)
							{
								flag = true;
							}
						}
						if (!flag)
						{
							k = 2;
							num5 = l + 2;
						}
						break;
					}
					if (Main.tile[l, j].active())
					{
						continue;
					}
					bool flag2 = true;
					for (int num8 = j - 2; num8 <= j; num8++)
					{
						if ((double)j < Main.worldSurface + 3.0 && (Main.tile[l + 1, num8].wall == 0 || Main.tile[l + 2, num8].wall == 0 || Main.tile[l + 3, num8].wall == 0))
						{
							return false;
						}
						if (Main.tile[l, num8].active() || Main.tile[l + 1, num8].active() || Main.tile[l + 2, num8].active())
						{
							flag2 = false;
						}
					}
					if (flag2)
					{
						k = 2;
						num5 = l;
						break;
					}
				}
			}
			flag = false;
			if (num5 == i && num7 < 0)
			{
				for (int num9 = i - 5; num9 > i - num6; num9--)
				{
					if (!InWorld(num9, j, 10))
					{
						return false;
					}
					if ((double)j < Main.worldSurface)
					{
						for (int num10 = j - 7; num10 <= j + 7 && Main.tile[num9, num10].wall != 0; num10++)
						{
						}
					}
					if (Main.tile[num9, j].type == 48)
					{
						flag = true;
						break;
					}
					if (Main.tile[num9, j].type == 191)
					{
						for (int num11 = j - 2; num11 <= j; num11++)
						{
							if (Main.tile[num9 - 3, num11].wall != 244)
							{
								flag = true;
							}
						}
						if (!flag)
						{
							k = 2;
							num = num9 - 2;
						}
						break;
					}
					if (!Main.tile[num9, j].active())
					{
						bool flag3 = true;
						for (int num12 = j - 2; num12 <= j; num12++)
						{
							if ((double)j < Main.worldSurface + 3.0 && (Main.tile[num9 - 1, num12].wall == 0 || Main.tile[num9 - 2, num12].wall == 0 || Main.tile[num9 - 3, num12].wall == 0))
							{
								return false;
							}
							if (Main.tile[num9, num12].active() || Main.tile[num9 - 1, num12].active() || Main.tile[num9 - 2, num12].active())
							{
								flag3 = false;
							}
						}
						if (flag3)
						{
							k = 2;
							num = num9;
							break;
						}
					}
				}
			}
			num7 *= -1;
		}
		if (num == num5)
		{
			return false;
		}
		bool flag4 = false;
		bool flag5 = false;
		for (int num2 = j - 5; num2 <= j + 1; num2++)
		{
			for (int num3 = num; num3 <= num5; num3++)
			{
				int num4 = 2;
				if (Math.Abs(num3 - num5) > 3 && Math.Abs(num3 - num) > 3)
				{
					num4 = 4;
				}
				if (Main.tile[num3, num2].wall != 244 && Main.tile[num3, num2].type != 19 && Main.tile[num3, num2].type != 15 && Main.tile[num3, num2].type != 304 && Main.tile[num3, num2].type != 21 && Main.tile[num3, num2].type != 10)
				{
					if (!Main.wallDungeon[Main.tile[num3, num2].wall] && (!Main.tile[num3, num2].active() || (!Main.wallDungeon[Main.tile[num3, num2 - 1].wall] && !Main.wallDungeon[Main.tile[num3, num2 + 1].wall])))
					{
						Main.tile[num3, num2].active(active: true);
						Main.tile[num3, num2].type = 191;
						Main.tile[num3, num2].halfBrick(halfBrick: false);
					}
					if (Main.tile[num3, num2 - 1].type == 40)
					{
						Main.tile[num3, num2 - 1].type = 0;
					}
					if (Main.tile[num3, num2 + 1].type == 40)
					{
						Main.tile[num3, num2 + 1].type = 0;
					}
				}
				if (num2 >= j - num4 && num2 <= j && Main.tile[num3, num2].type != 19 && Main.tile[num3, num2].type != 15 && Main.tile[num3, num2].type != 304 && Main.tile[num3, num2].type != 21 && Main.tile[num3, num2].type != 10 && Main.tile[num3, num2 - 1].type != 15 && Main.tile[num3, num2 - 1].type != 304 && Main.tile[num3, num2 - 1].type != 21 && Main.tile[num3, num2 - 1].type != 10 && Main.tile[num3, num2 + 1].type != 10)
				{
					if (!Main.wallDungeon[Main.tile[num3, num2].wall])
					{
						Main.tile[num3, num2].wall = 244;
					}
					Main.tile[num3, num2].liquid = 0;
					Main.tile[num3, num2].active(active: false);
				}
				if (num2 != j)
				{
					continue;
				}
				int style = 7;
				if (Main.wallDungeon[Main.tile[num3, num2].wall] || Main.wallDungeon[Main.tile[num3, num2 - 1].wall] || Main.wallDungeon[Main.tile[num3, num2 - 2].wall])
				{
					style = 13;
				}
				if (num3 <= num + 4 && !flag4)
				{
					if (Main.tile[num3 - 1, num2].type == 10 || Main.tile[num3 + 1, num2].type == 10)
					{
						flag4 = true;
					}
					else if (genRand.Next(3) == 0)
					{
						PlaceTile(num3, num2, 10, mute: true, forced: false, -1, style);
						if (Main.tile[num3, num2].type == 10)
						{
							flag4 = true;
						}
					}
				}
				if (num3 < num5 - 4 || flag5)
				{
					continue;
				}
				if (Main.tile[num3 - 1, num2].type == 10 || Main.tile[num3 + 1, num2].type == 10)
				{
					flag5 = true;
				}
				else if (genRand.Next(3) == 0)
				{
					PlaceTile(num3, num2, 10, mute: true, forced: false, -1, style);
					if (Main.tile[num3, num2].type == 10)
					{
						flag5 = true;
					}
				}
			}
		}
		return true;
	}

	private static void GrowDungeonTree_MakePassage(int j, int W, ref int minl, ref int minr, bool noSecretRoom = false)
	{
		int num = minl;
		int num2 = minr;
		_ = (minl + minr) / 2;
		int num3 = 5;
		int num4 = j - 6;
		int num5 = 0;
		bool flag = true;
		genRand.Next(5, 16);
		while (true)
		{
			num4++;
			if (num4 > GenVars.dungeonY - 5)
			{
				break;
			}
			int num6 = (minl + minr) / 2;
			int num7 = 1;
			if (num4 > j && W <= 4)
			{
				num7++;
			}
			for (int i = minl - num7; i <= minr + num7; i++)
			{
				if (i > num6 - 2 && i <= num6 + 1)
				{
					if (num4 > j - 4)
					{
						if (Main.tile[i, num4].type != 19 && Main.tile[i, num4].type != 15 && Main.tile[i, num4].type != 304 && Main.tile[i, num4].type != 21 && Main.tile[i, num4].type != 10 && Main.tile[i, num4 - 1].type != 15 && Main.tile[i, num4 - 1].type != 304 && Main.tile[i, num4 - 1].type != 21 && Main.tile[i, num4 - 1].type != 10 && Main.tile[i, num4 + 1].type != 10)
						{
							Main.tile[i, num4].active(active: false);
						}
						if (!Main.wallDungeon[Main.tile[i, num4].wall])
						{
							Main.tile[i, num4].wall = 244;
						}
						if (!Main.wallDungeon[Main.tile[i - 1, num4].wall] && (Main.tile[i - 1, num4].wall > 0 || (double)num4 >= Main.worldSurface))
						{
							Main.tile[i - 1, num4].wall = 244;
						}
						if (!Main.wallDungeon[Main.tile[i + 1, num4].wall] && (Main.tile[i + 1, num4].wall > 0 || (double)num4 >= Main.worldSurface))
						{
							Main.tile[i + 1, num4].wall = 244;
						}
						if (num4 == j && i > num6 - 2 && i <= num6 + 1)
						{
							Main.tile[i, num4 + 1].active(active: false);
							PlaceTile(i, num4 + 1, 19, mute: true, forced: false, -1, 23);
						}
					}
				}
				else
				{
					if (Main.tile[i, num4].type != 15 && Main.tile[i, num4].type != 304 && Main.tile[i, num4].type != 21 && Main.tile[i, num4].type != 10 && Main.tile[i - 1, num4].type != 10 && Main.tile[i + 1, num4].type != 10)
					{
						if (!Main.wallDungeon[Main.tile[i, num4].wall])
						{
							Main.tile[i, num4].type = 191;
							Main.tile[i, num4].active(active: true);
							Main.tile[i, num4].halfBrick(halfBrick: false);
						}
						if (Main.tile[i - 1, num4].type == 40)
						{
							Main.tile[i - 1, num4].type = 0;
						}
						if (Main.tile[i + 1, num4].type == 40)
						{
							Main.tile[i + 1, num4].type = 0;
						}
					}
					if (num4 <= j && num4 > j - 4 && i > minl - num7 && i <= minr + num7 - 1)
					{
						Main.tile[i, num4].wall = 244;
					}
				}
				if (!gen)
				{
					SquareTileFrame(i, num4);
					SquareWallFrame(i, num4);
				}
			}
			num5++;
			if (num5 < 6)
			{
				continue;
			}
			num5 = 0;
			int num8 = genRand.Next(3);
			if (num8 == 0)
			{
				num8 = -1;
			}
			if (flag)
			{
				num8 = 2;
			}
			if (num8 == -1 && Main.tile[minl - num3, num4].wall == 244)
			{
				num8 = 1;
			}
			else if (num8 == 1 && Main.tile[minr + num3, num4].wall == 244)
			{
				num8 = -1;
			}
			if (num8 == 2)
			{
				flag = false;
				int num9 = 23;
				if (Main.wallDungeon[Main.tile[minl, num4 + 1].wall] || Main.wallDungeon[Main.tile[minl + 1, num4 + 1].wall] || Main.wallDungeon[Main.tile[minl + 2, num4 + 1].wall])
				{
					num9 = 12;
				}
				if (!SolidTile(minl - 1, num4 + 1) && !SolidTile(minr + 1, num4 + 1) && num9 == 12)
				{
					continue;
				}
				for (int k = minl; k <= minr; k++)
				{
					if (k > num6 - 2 && k <= num6 + 1)
					{
						Main.tile[k, num4 + 1].active(active: false);
						Main.tile[k, num4 + 1].halfBrick(halfBrick: false);
						Main.tile[k, num4 + 1].slope(0);
						PlaceTile(k, num4 + 1, 19, mute: true, forced: false, -1, num9);
					}
				}
			}
			else
			{
				minl += num8;
				minr += num8;
			}
		}
		minl = num;
		minr = num2;
		_ = (minl + minr) / 2;
		for (int l = minl; l <= minr; l++)
		{
			for (int m = j - 3; m <= j; m++)
			{
				Main.tile[l, m].active(active: false);
				if (!Main.wallDungeon[Main.tile[l, m].wall])
				{
					Main.tile[l, m].wall = 244;
				}
			}
		}
	}

	private static void GrowLivingTree_MakePassage(int j, int W, ref int minl, ref int minr, bool noSecretRoom = false)
	{
		bool flag = noSecretRoom;
		int num = minl;
		int num9 = minr;
		bool flag2 = false;
		_ = (minl + minr) / 2;
		int num10 = 5;
		int num11 = j - 6;
		int num12 = 50;
		int num13 = genRand.Next(400, 700);
		int num14 = 0;
		bool flag3 = true;
		int num15 = genRand.Next(5, 16);
		while (num13 > 0)
		{
			num11++;
			num13--;
			num12--;
			int num16 = (minl + minr) / 2;
			if (!Main.tile[minl, num11].active() && Main.tile[minl, num11].wall == 244 && !Main.tile[minr, num11].active() && Main.tile[minr, num11].wall == 244)
			{
				num13 = 0;
				break;
			}
			int num2 = 1;
			if (num11 > j && W <= 4)
			{
				num2++;
			}
			for (int i = minl - num2; i <= minr + num2; i++)
			{
				if (Main.wallDungeon[Main.tile[i, num11].wall])
				{
					flag = true;
					flag2 = true;
				}
				if (i > num16 - 2 && i <= num16 + 1)
				{
					if (num11 > j - 4)
					{
						if (Main.tile[i, num11].type != 19 && Main.tile[i, num11].type != 15 && Main.tile[i, num11].type != 304 && Main.tile[i, num11].type != 21 && Main.tile[i, num11].type != 10 && Main.tile[i, num11 - 1].type != 15 && Main.tile[i, num11 - 1].type != 304 && Main.tile[i, num11 - 1].type != 21 && Main.tile[i, num11 - 1].type != 10 && Main.tile[i, num11 + 1].type != 10)
						{
							Main.tile[i, num11].active(active: false);
						}
						if (!Main.wallDungeon[Main.tile[i, num11].wall])
						{
							Main.tile[i, num11].wall = 244;
						}
						if (!Main.wallDungeon[Main.tile[i - 1, num11].wall] && (Main.tile[i - 1, num11].wall > 0 || (double)num11 >= Main.worldSurface))
						{
							Main.tile[i - 1, num11].wall = 244;
						}
						if (!Main.wallDungeon[Main.tile[i + 1, num11].wall] && (Main.tile[i + 1, num11].wall > 0 || (double)num11 >= Main.worldSurface))
						{
							Main.tile[i + 1, num11].wall = 244;
						}
						if (num11 == j && i > num16 - 2 && i <= num16 + 1)
						{
							Main.tile[i, num11 + 1].active(active: false);
							PlaceTile(i, num11 + 1, 19, mute: true, forced: false, -1, 23);
						}
					}
				}
				else
				{
					if (Main.tile[i, num11].type != 15 && Main.tile[i, num11].type != 304 && Main.tile[i, num11].type != 21 && Main.tile[i, num11].type != 10 && Main.tile[i - 1, num11].type != 10 && Main.tile[i + 1, num11].type != 10)
					{
						if (!Main.wallDungeon[Main.tile[i, num11].wall])
						{
							Main.tile[i, num11].type = 191;
							Main.tile[i, num11].active(active: true);
							Main.tile[i, num11].halfBrick(halfBrick: false);
						}
						if (Main.tile[i - 1, num11].type == 40)
						{
							Main.tile[i - 1, num11].type = 0;
						}
						if (Main.tile[i + 1, num11].type == 40)
						{
							Main.tile[i + 1, num11].type = 0;
						}
					}
					if (num11 <= j && num11 > j - 4 && i > minl - num2 && i <= minr + num2 - 1)
					{
						Main.tile[i, num11].wall = 244;
					}
				}
				if (!gen)
				{
					SquareTileFrame(i, num11);
					SquareWallFrame(i, num11);
				}
			}
			num14++;
			if (num14 >= 6)
			{
				num14 = 0;
				int num3 = genRand.Next(3);
				if (num3 == 0)
				{
					num3 = -1;
				}
				if (flag3)
				{
					num3 = 2;
				}
				if (num3 == -1 && Main.tile[minl - num10, num11].wall == 244)
				{
					num3 = 1;
				}
				else if (num3 == 1 && Main.tile[minr + num10, num11].wall == 244)
				{
					num3 = -1;
				}
				if (num3 == 2)
				{
					flag3 = false;
					int style = 23;
					if (Main.wallDungeon[Main.tile[minl, num11 + 1].wall] || Main.wallDungeon[Main.tile[minl + 1, num11 + 1].wall] || Main.wallDungeon[Main.tile[minl + 2, num11 + 1].wall])
					{
						style = 12;
					}
					for (int k = minl; k <= minr; k++)
					{
						if (k > num16 - 2 && k <= num16 + 1)
						{
							Main.tile[k, num11 + 1].active(active: false);
							PlaceTile(k, num11 + 1, 19, mute: true, forced: false, -1, style);
						}
					}
				}
				else
				{
					minl += num3;
					minr += num3;
				}
				if (noSecretRoom)
				{
					num15--;
					if (num15 <= 0)
					{
						num15 = ((!GrowLivingTree_HorizontalTunnel(num16, num11)) ? genRand.Next(2, 11) : genRand.Next(5, 21));
					}
				}
				if (num12 <= 0 && !flag)
				{
					flag = true;
					GrowLivingTreePassageRoom(minl, minr, num11);
				}
			}
			if (flag2)
			{
				bool flag4 = true;
				for (int l = minl; l <= minr; l++)
				{
					for (int m = num11 + 1; m <= num11 + 2; m++)
					{
						if (SolidTile(l, m))
						{
							flag4 = false;
						}
					}
				}
				if (flag4)
				{
					num13 = 0;
				}
			}
			else
			{
				if (num12 > 0)
				{
					continue;
				}
				bool flag5 = true;
				for (int n = minl; n <= minr; n++)
				{
					for (int num4 = num11 + 1; num4 <= num11 + 4; num4++)
					{
						if (SolidTile(n, num4))
						{
							flag5 = false;
						}
					}
				}
				if (flag5)
				{
					num13 = 0;
				}
			}
		}
		minl = num;
		minr = num9;
		_ = (minl + minr) / 2;
		for (int num5 = minl; num5 <= minr; num5++)
		{
			for (int num6 = j - 3; num6 <= j; num6++)
			{
				Main.tile[num5, num6].active(active: false);
				bool flag6 = true;
				for (int num7 = num5 - 1; num7 <= num5 + 1; num7++)
				{
					for (int num8 = num6 - 1; num8 <= num6 + 1; num8++)
					{
						if (!Main.tile[num7, num8].active() && Main.tile[num7, num8].wall == 0)
						{
							flag6 = false;
						}
					}
				}
				if (flag6 && !Main.wallDungeon[Main.tile[num5, num6].wall])
				{
					Main.tile[num5, num6].wall = 244;
				}
			}
		}
	}

	private static void GrowLivingTreePassageRoom(int minl, int minr, int Y)
	{
		int num = genRand.Next(2);
		if (num == 0)
		{
			num = -1;
		}
		int num6 = Y - 2;
		int num7 = (minl + minr) / 2;
		if (num < 0)
		{
			num7--;
		}
		if (num > 0)
		{
			num7++;
		}
		int num8 = genRand.Next(15, 30);
		int num9 = num7 + num8;
		if (num < 0)
		{
			num9 = num7;
			num7 -= num8;
		}
		Tile tile;
		for (int i = num7; i < num9; i++)
		{
			for (int j = Y - 20; j < Y + 10; j++)
			{
				tile = Main.tile[i, j];
				if (tile.wall == 0)
				{
					tile = Main.tile[i, j];
					if (!tile.active() && (double)j < Main.worldSurface)
					{
						return;
					}
				}
			}
		}
		GenVars.dMinX = num7;
		GenVars.dMaxX = num9;
		if (num < 0)
		{
			GenVars.dMinX -= 40;
		}
		else
		{
			GenVars.dMaxX += 40;
		}
		for (int k = num7; k <= num9; k++)
		{
			for (int l = num6 - 2; l <= Y + 2; l++)
			{
				tile = Main.tile[k - 1, l];
				if (tile.type == 40)
				{
					tile = Main.tile[k - 1, l];
					tile.type = 0;
				}
				tile = Main.tile[k + 1, l];
				if (tile.type == 40)
				{
					tile = Main.tile[k + 1, l];
					tile.type = 0;
				}
				tile = Main.tile[k, l - 1];
				if (tile.type == 40)
				{
					tile = Main.tile[k, l - 1];
					tile.type = 0;
				}
				tile = Main.tile[k, l + 1];
				if (tile.type == 40)
				{
					tile = Main.tile[k, l + 1];
					tile.type = 0;
				}
				tile = Main.tile[k, l];
				if (tile.wall != 244)
				{
					tile = Main.tile[k, l];
					if (tile.type != 19)
					{
						tile = Main.tile[k, l];
						tile.active(active: true);
						tile = Main.tile[k, l];
						tile.type = 191;
						tile = Main.tile[k, l];
						tile.halfBrick(halfBrick: false);
					}
				}
				if (l >= num6 && l <= Y)
				{
					tile = Main.tile[k, l];
					tile.liquid = 0;
					tile = Main.tile[k, l];
					tile.wall = 244;
					tile = Main.tile[k, l];
					tile.active(active: false);
				}
			}
		}
		int i2 = (minl + minr) / 2 + 3 * num;
		PlaceTile(i2, Y, 10, mute: true, forced: false, -1, 7);
		int num10 = genRand.Next(5, 9);
		int num11 = genRand.Next(4, 6);
		if (num < 0)
		{
			num9 = num7 + num10;
			num7 -= num10;
		}
		else
		{
			num7 = num9 - num10;
			num9 += num10;
		}
		num6 = Y - num11;
		for (int m = num7 - 2; m <= num9 + 2; m++)
		{
			for (int n = num6 - 2; n <= Y + 2; n++)
			{
				tile = Main.tile[m - 1, n];
				if (tile.type == 40)
				{
					tile = Main.tile[m - 1, n];
					tile.type = 40;
				}
				tile = Main.tile[m + 1, n];
				if (tile.type == 40)
				{
					tile = Main.tile[m + 1, n];
					tile.type = 40;
				}
				tile = Main.tile[m, n - 1];
				if (tile.type == 40)
				{
					tile = Main.tile[m, n - 1];
					tile.type = 40;
				}
				tile = Main.tile[m, n + 1];
				if (tile.type == 40)
				{
					tile = Main.tile[m, n + 1];
					tile.type = 40;
				}
				tile = Main.tile[m, n];
				if (tile.wall != 244)
				{
					tile = Main.tile[m, n];
					if (tile.type != 19)
					{
						tile = Main.tile[m, n];
						tile.active(active: true);
						tile = Main.tile[m, n];
						tile.type = 191;
						tile = Main.tile[m, n];
						tile.halfBrick(halfBrick: false);
					}
				}
				if (n >= num6 && n <= Y && m >= num7 && m <= num9)
				{
					tile = Main.tile[m, n];
					tile.liquid = 0;
					tile = Main.tile[m, n];
					tile.wall = 244;
					tile = Main.tile[m, n];
					tile.active(active: false);
				}
			}
		}
		i2 = num7 - 2;
		if (num < 0)
		{
			i2 = num9 + 2;
		}
		PlaceTile(i2, Y, 10, mute: true, forced: false, -1, 7);
		int num12 = num9;
		if (num < 0)
		{
			num12 = num7;
		}
		int num13 = 2;
		if (genRand.Next(num13) == 0)
		{
			num13 += 2;
			PlaceTile(num12, Y, 15, mute: true, forced: false, -1, 5);
			if (num < 0)
			{
				tile = Main.tile[num12, Y - 1];
				tile.frameX += 18;
				tile = Main.tile[num12, Y];
				tile.frameX += 18;
			}
		}
		num12 = num9 - 2;
		if (num < 0)
		{
			num12 = num7 + 2;
		}
		PlaceTile(num12, Y, 304, mute: true);
		num12 = num9 - 4;
		if (num < 0)
		{
			num12 = num7 + 4;
		}
		if (genRand.Next(num13) == 0)
		{
			PlaceTile(num12, Y, 15, mute: true, forced: false, -1, 5);
			if (num > 0)
			{
				tile = Main.tile[num12, Y - 1];
				tile.frameX += 18;
				tile = Main.tile[num12, Y];
				tile.frameX += 18;
			}
		}
		num12 = num9 - 7;
		if (num < 0)
		{
			num12 = num7 + 8;
		}
		int contain = 832;
		if (genRand.Next(3) == 0)
		{
			contain = 4281;
		}
		if (remixWorldGen)
		{
			int num2 = genRand.Next(1, 3);
			for (int num3 = 0; num3 < num2; num3++)
			{
				bool flag = false;
				while (!flag)
				{
					int num4 = genRand.Next(Main.maxTilesX / 8, Main.maxTilesX - Main.maxTilesX / 8);
					int num5 = genRand.Next((int)Main.rockLayer, Main.maxTilesY - 350);
					if (!IsTileNearby(num4, num5, 53, 20) && !IsTileNearby(num4, num5, 147, 20) && !IsTileNearby(num4, num5, 59, 20))
					{
						flag = AddBuriedChest(num4, num5, contain, notNearOtherChests: false, 12, trySlope: false, 0);
					}
				}
			}
			if (crimson)
			{
				AddBuriedChest(num12, Y, 0, notNearOtherChests: false, 14, trySlope: false, 0);
			}
			else
			{
				AddBuriedChest(num12, Y, 0, notNearOtherChests: false, 7, trySlope: false, 0);
			}
		}
		else
		{
			AddBuriedChest(num12, Y, contain, notNearOtherChests: false, 12, trySlope: false, 0);
		}
	}

	public static void TreeGrowFXCheck(int x, int y)
	{
		int treeHeight = 1;
		int passStyle = -1;
		Tile topTile = default(Tile);
		for (int num = -1; num > -100; num--)
		{
			Tile tile = Main.tile[x, y + num];
			if (!tile.active() || !TileID.Sets.GetsCheckedForLeaves[tile.type])
			{
				break;
			}
			topTile = tile;
			treeHeight++;
		}
		for (int i = 1; i < 5; i++)
		{
			Tile tile2 = Main.tile[x, y + i];
			if (tile2.active() && TileID.Sets.GetsCheckedForLeaves[tile2.type])
			{
				treeHeight++;
				continue;
			}
			GetTreeLeaf(x, topTile, tile2, ref treeHeight, out var _, out passStyle);
			break;
		}
		if (treeHeight > 0 && passStyle > 0)
		{
			if (Main.netMode == 2)
			{
				NetMessage.SendData(112, -1, -1, null, 1, x, y, treeHeight, passStyle);
			}
			if (Main.netMode == 0)
			{
				TreeGrowFX(x, y, treeHeight, passStyle);
			}
		}
	}

	public static void GetTreeLeaf(int x, Tile topTile, Tile t, ref int treeHeight, out int treeFrame, out int passStyle)
	{
		treeFrame = 0;
		passStyle = -1;
		if (topTile.frameX == 22 || topTile.frameX == 44 || topTile.frameX == 66)
		{
			if (topTile.frameY == 220)
			{
				treeFrame = 1;
			}
			else if (topTile.frameY == 242)
			{
				treeFrame = 2;
			}
		}
		if (topTile.frameX == 44 || topTile.frameX == 66)
		{
			if (topTile.frameY == 220)
			{
				treeFrame = 1;
			}
			else if (topTile.frameY == 242)
			{
				treeFrame = 2;
			}
		}
		switch (topTile.type)
		{
		case 596:
			passStyle = 1248;
			break;
		case 616:
			passStyle = 1257;
			break;
		case 634:
			passStyle = 1278;
			break;
		case 583:
		case 584:
		case 585:
		case 586:
		case 587:
		case 588:
		case 589:
			passStyle = 1249 + (topTile.type - 583);
			break;
		}
		if (passStyle > -1)
		{
			return;
		}
		switch (t.type)
		{
		case 2:
		case 477:
			passStyle = 910;
			break;
		case 60:
			passStyle = 914;
			break;
		case 70:
			passStyle = 912;
			break;
		case 23:
		case 112:
			passStyle = 915;
			break;
		case 199:
		case 234:
			passStyle = 916;
			break;
		case 53:
			passStyle = 911;
			break;
		case 116:
			passStyle = 919;
			break;
		case 147:
			passStyle = 913;
			break;
		case 633:
			passStyle = 1278;
			break;
		case 109:
		case 492:
		{
			int num = 917;
			if (GetHollowTreeFoliageStyle() != 20)
			{
				if (x % 3 == 1)
				{
					treeFrame += 3;
				}
				if (x % 3 == 2)
				{
					treeFrame += 6;
				}
				switch (treeFrame)
				{
				case 0:
					passStyle = 2;
					break;
				case 1:
					passStyle = 1;
					break;
				case 2:
					passStyle = 7;
					break;
				case 3:
					passStyle = 4;
					break;
				case 4:
					passStyle = 5;
					break;
				case 5:
					passStyle = 6;
					break;
				case 6:
					passStyle = 3;
					break;
				case 7:
					passStyle = 8;
					break;
				case 8:
					passStyle = 0;
					break;
				}
			}
			else
			{
				int num2 = 196;
				if (x % 6 == 1)
				{
					treeFrame += 3;
				}
				else if (x % 6 == 2)
				{
					treeFrame += 6;
				}
				else if (x % 6 == 3)
				{
					treeFrame += 9;
				}
				else if (x % 6 == 4)
				{
					treeFrame += 12;
				}
				else if (x % 6 == 5)
				{
					treeFrame += 15;
				}
				switch (treeFrame)
				{
				case 0:
					passStyle = num2;
					break;
				case 1:
					passStyle = num2;
					break;
				case 2:
					passStyle = num2;
					break;
				case 3:
					passStyle = num2 + 1;
					break;
				case 4:
					passStyle = num2 + 2;
					break;
				case 5:
					passStyle = num2 + 1;
					break;
				case 6:
					passStyle = num2 + 3;
					break;
				case 7:
					passStyle = num2 + 4;
					break;
				case 8:
					passStyle = num2 + 5;
					break;
				case 9:
					passStyle = num2 + 6;
					break;
				case 10:
					passStyle = num2 + 6;
					break;
				case 11:
					passStyle = num2 + 6;
					break;
				case 12:
					passStyle = num2 + 7;
					break;
				case 13:
					passStyle = num2 + 7;
					break;
				case 14:
					passStyle = num2 + 7;
					break;
				case 15:
					passStyle = num2 + 8;
					break;
				case 16:
					passStyle = num2 + 8;
					break;
				case 17:
					passStyle = num2 + 8;
					break;
				}
			}
			passStyle += num;
			treeHeight += 5;
			break;
		}
		}
		PlantLoader.GetTreeLeaf(t.type, ref passStyle);
	}

	public static void TreeGrowFX(int x, int y, int height, int treeGore, bool hitTree = false)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		Vector2 vector = new Vector2((float)x, (float)y) * 16f + new Vector2(8f, 8f);
		if (treeGore == 1278)
		{
			TreeGrowFX_AshShake(x, y, height, hitTree);
			return;
		}
		Vector2 vector2 = default(Vector2);
		for (int num = 0; num > -height; num--)
		{
			float num2 = 10f;
			((Vector2)(ref vector2))._002Ector(5f, 7f);
			Gore.NewGore(vector + new Vector2(-16f, (float)(num * 16)) - vector2, Utils.RandomVector2(Main.rand, 0f - num2, num2), treeGore, 0.7f + Main.rand.NextFloat() * 0.6f);
			Gore.NewGore(vector + new Vector2(0f, (float)(num * 16)) - vector2, Utils.RandomVector2(Main.rand, 0f - num2, num2), treeGore, 0.7f + Main.rand.NextFloat() * 0.6f);
			Gore.NewGore(vector + new Vector2(16f, (float)(num * 16)) - vector2, Utils.RandomVector2(Main.rand, 0f - num2, num2), treeGore, 0.7f + Main.rand.NextFloat() * 0.6f);
			if (num == -height + 1)
			{
				int num3 = 20;
				if (hitTree)
				{
					num3 = 5;
				}
				for (int i = 0; i < num3; i++)
				{
					Gore.NewGore(vector + new Vector2(0f, (float)(num * 16 - 40)) + Utils.RandomVector2(Main.rand, -40f, 40f) - vector2, Utils.RandomVector2(Main.rand, -10f, 10f), treeGore, 0.7f + Main.rand.NextFloat() * 0.6f);
				}
			}
		}
	}

	private static void TreeGrowFX_AshShake(int x, int y, int height, bool hitTree = false)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		Vector2 vector = new Vector2((float)x, (float)y) * 16f + new Vector2(8f, 8f);
		for (int num = 0; num > -height; num--)
		{
			if (num >= -height / 2 && Main.rand.Next(3) != 0)
			{
				int num2 = (hitTree ? 10 : 5);
				for (int i = 0; i < num2; i++)
				{
					Dust.NewDustDirect(vector + new Vector2(-16f, (float)(num * 16)) + Utils.RandomVector2(Main.rand, -30f, 30f), 4, 4, 31, 0f, -3f, 100).velocity = Main.rand.NextVector2Circular(2f, 2f) + new Vector2(0f, -0.6f);
				}
			}
			if ((float)num >= (float)(-height) * 0.7f && Main.rand.Next(3) != 0)
			{
				int num3 = (hitTree ? 16 : 10);
				for (int j = 0; j < num3; j++)
				{
					Dust dust = Dust.NewDustDirect(vector + new Vector2(-16f, (float)(num * 16)) + Utils.RandomVector2(Main.rand, -30f, 30f), 4, 4, 6, 0f, -4f, 0, default(Color), 1f + 0.7f * Main.rand.NextFloat());
					dust.velocity = Main.rand.NextVector2Circular(2f, 2f) + new Vector2(0f, -0.6f);
					if (Main.rand.Next(2) == 0)
					{
						dust.velocity *= 2f;
						dust.noGravity = true;
					}
					dust.velocity += new Vector2(0f, hitTree ? (-1f) : (-2f));
				}
			}
			if (!hitTree)
			{
				Gore gore = Gore.NewGoreDirect(vector + new Vector2(-16f, (float)(num * 16 - 40)) + Utils.RandomVector2(Main.rand, -40f, 40f) * new Vector2(0.5f, 1f), Vector2.Zero, 61 + Main.rand.Next(3));
				gore.velocity *= 0.5f;
			}
		}
	}

	public static bool IsTileALeafyTreeTop(int i, int j)
	{
		Tile tileSafely = Framing.GetTileSafely(i, j);
		if (tileSafely.active() && TileID.Sets.GetsCheckedForLeaves[tileSafely.type])
		{
			if (tileSafely.type == 323 && tileSafely.frameX >= 88)
			{
				return true;
			}
			if (tileSafely.frameX == 22 && tileSafely.frameY >= 198 && tileSafely.frameY <= 242)
			{
				return true;
			}
		}
		return false;
	}

	public static bool IsTileTypeFitForTree(ushort type)
	{
		switch (type)
		{
		case 2:
		case 23:
		case 60:
		case 70:
		case 109:
		case 147:
		case 199:
		case 477:
		case 492:
		case 633:
		case 661:
		case 662:
			return true;
		default:
			return TileLoader.CanGrowModTree(type);
		}
	}

	public static bool GrowTree(int i, int y)
	{
		int j;
		for (j = y; TileID.Sets.TreeSapling[Main.tile[i, j].type]; j++)
		{
		}
		if ((Main.tile[i - 1, j - 1].liquid != 0 || Main.tile[i, j - 1].liquid != 0 || Main.tile[i + 1, j - 1].liquid != 0) && !notTheBees)
		{
			return false;
		}
		if (Main.tile[i, j].nactive() && !Main.tile[i, j].halfBrick() && Main.tile[i, j].slope() == 0 && IsTileTypeFitForTree(Main.tile[i, j].type) && ((Main.remixWorld && (double)j > Main.worldSurface) || Main.tile[i, j - 1].wall == 0 || DefaultTreeWallTest(Main.tile[i, j - 1].wall)) && ((Main.tile[i - 1, j].active() && IsTileTypeFitForTree(Main.tile[i - 1, j].type)) || (Main.tile[i + 1, j].active() && IsTileTypeFitForTree(Main.tile[i + 1, j].type))))
		{
			TileColorCache cache = Main.tile[i, j].BlockColorAndCoating();
			if (Main.tenthAnniversaryWorld && !gen)
			{
				cache.Color = (byte)genRand.Next(1, 13);
			}
			int num = 2;
			int num2 = genRand.Next(5, 17);
			int num3 = num2 + 4;
			if (Main.tile[i, j].type == 60)
			{
				num3 += 5;
			}
			bool flag = false;
			if (Main.tile[i, j].type == 70 && EmptyTileCheck(i - num, i + num, j - num3, j - 3, 20) && EmptyTileCheck(i - 1, i + 1, j - 2, j - 1, 20))
			{
				flag = true;
			}
			if (EmptyTileCheck(i - num, i + num, j - num3, j - 1, 20))
			{
				flag = true;
			}
			if (flag)
			{
				bool flag2 = Main.remixWorld && (double)j < Main.worldSurface;
				bool flag3 = false;
				bool flag4 = false;
				int num4;
				for (int k = j - num2; k < j; k++)
				{
					Main.tile[i, k].frameNumber((byte)genRand.Next(3));
					Main.tile[i, k].active(active: true);
					Main.tile[i, k].type = 5;
					Main.tile[i, k].UseBlockColors(cache);
					num4 = genRand.Next(3);
					int num5 = genRand.Next(10);
					if (k == j - 1 || k == j - num2)
					{
						num5 = 0;
					}
					while (((num5 == 5 || num5 == 7) && flag3) || ((num5 == 6 || num5 == 7) && flag4))
					{
						num5 = genRand.Next(10);
					}
					flag3 = false;
					flag4 = false;
					if (num5 == 5 || num5 == 7)
					{
						flag3 = true;
					}
					if (num5 == 6 || num5 == 7)
					{
						flag4 = true;
					}
					switch (num5)
					{
					case 1:
						if (num4 == 0)
						{
							Main.tile[i, k].frameX = 0;
							Main.tile[i, k].frameY = 66;
						}
						if (num4 == 1)
						{
							Main.tile[i, k].frameX = 0;
							Main.tile[i, k].frameY = 88;
						}
						if (num4 == 2)
						{
							Main.tile[i, k].frameX = 0;
							Main.tile[i, k].frameY = 110;
						}
						break;
					case 2:
						if (num4 == 0)
						{
							Main.tile[i, k].frameX = 22;
							Main.tile[i, k].frameY = 0;
						}
						if (num4 == 1)
						{
							Main.tile[i, k].frameX = 22;
							Main.tile[i, k].frameY = 22;
						}
						if (num4 == 2)
						{
							Main.tile[i, k].frameX = 22;
							Main.tile[i, k].frameY = 44;
						}
						break;
					case 3:
						if (num4 == 0)
						{
							Main.tile[i, k].frameX = 44;
							Main.tile[i, k].frameY = 66;
						}
						if (num4 == 1)
						{
							Main.tile[i, k].frameX = 44;
							Main.tile[i, k].frameY = 88;
						}
						if (num4 == 2)
						{
							Main.tile[i, k].frameX = 44;
							Main.tile[i, k].frameY = 110;
						}
						break;
					case 4:
						if (num4 == 0)
						{
							Main.tile[i, k].frameX = 22;
							Main.tile[i, k].frameY = 66;
						}
						if (num4 == 1)
						{
							Main.tile[i, k].frameX = 22;
							Main.tile[i, k].frameY = 88;
						}
						if (num4 == 2)
						{
							Main.tile[i, k].frameX = 22;
							Main.tile[i, k].frameY = 110;
						}
						break;
					case 5:
						if (num4 == 0)
						{
							Main.tile[i, k].frameX = 88;
							Main.tile[i, k].frameY = 0;
						}
						if (num4 == 1)
						{
							Main.tile[i, k].frameX = 88;
							Main.tile[i, k].frameY = 22;
						}
						if (num4 == 2)
						{
							Main.tile[i, k].frameX = 88;
							Main.tile[i, k].frameY = 44;
						}
						break;
					case 6:
						if (num4 == 0)
						{
							Main.tile[i, k].frameX = 66;
							Main.tile[i, k].frameY = 66;
						}
						if (num4 == 1)
						{
							Main.tile[i, k].frameX = 66;
							Main.tile[i, k].frameY = 88;
						}
						if (num4 == 2)
						{
							Main.tile[i, k].frameX = 66;
							Main.tile[i, k].frameY = 110;
						}
						break;
					case 7:
						if (num4 == 0)
						{
							Main.tile[i, k].frameX = 110;
							Main.tile[i, k].frameY = 66;
						}
						if (num4 == 1)
						{
							Main.tile[i, k].frameX = 110;
							Main.tile[i, k].frameY = 88;
						}
						if (num4 == 2)
						{
							Main.tile[i, k].frameX = 110;
							Main.tile[i, k].frameY = 110;
						}
						break;
					default:
						if (num4 == 0)
						{
							Main.tile[i, k].frameX = 0;
							Main.tile[i, k].frameY = 0;
						}
						if (num4 == 1)
						{
							Main.tile[i, k].frameX = 0;
							Main.tile[i, k].frameY = 22;
						}
						if (num4 == 2)
						{
							Main.tile[i, k].frameX = 0;
							Main.tile[i, k].frameY = 44;
						}
						break;
					}
					if (num5 == 5 || num5 == 7)
					{
						Main.tile[i - 1, k].active(active: true);
						Main.tile[i - 1, k].type = 5;
						Main.tile[i - 1, k].UseBlockColors(cache);
						num4 = genRand.Next(3);
						if (genRand.Next(3) < 2 && !flag2)
						{
							if (num4 == 0)
							{
								Main.tile[i - 1, k].frameX = 44;
								Main.tile[i - 1, k].frameY = 198;
							}
							if (num4 == 1)
							{
								Main.tile[i - 1, k].frameX = 44;
								Main.tile[i - 1, k].frameY = 220;
							}
							if (num4 == 2)
							{
								Main.tile[i - 1, k].frameX = 44;
								Main.tile[i - 1, k].frameY = 242;
							}
						}
						else
						{
							if (num4 == 0)
							{
								Main.tile[i - 1, k].frameX = 66;
								Main.tile[i - 1, k].frameY = 0;
							}
							if (num4 == 1)
							{
								Main.tile[i - 1, k].frameX = 66;
								Main.tile[i - 1, k].frameY = 22;
							}
							if (num4 == 2)
							{
								Main.tile[i - 1, k].frameX = 66;
								Main.tile[i - 1, k].frameY = 44;
							}
						}
					}
					if (num5 != 6 && num5 != 7)
					{
						continue;
					}
					Main.tile[i + 1, k].active(active: true);
					Main.tile[i + 1, k].type = 5;
					Main.tile[i + 1, k].UseBlockColors(cache);
					num4 = genRand.Next(3);
					if (genRand.Next(3) < 2 && !flag2)
					{
						if (num4 == 0)
						{
							Main.tile[i + 1, k].frameX = 66;
							Main.tile[i + 1, k].frameY = 198;
						}
						if (num4 == 1)
						{
							Main.tile[i + 1, k].frameX = 66;
							Main.tile[i + 1, k].frameY = 220;
						}
						if (num4 == 2)
						{
							Main.tile[i + 1, k].frameX = 66;
							Main.tile[i + 1, k].frameY = 242;
						}
					}
					else
					{
						if (num4 == 0)
						{
							Main.tile[i + 1, k].frameX = 88;
							Main.tile[i + 1, k].frameY = 66;
						}
						if (num4 == 1)
						{
							Main.tile[i + 1, k].frameX = 88;
							Main.tile[i + 1, k].frameY = 88;
						}
						if (num4 == 2)
						{
							Main.tile[i + 1, k].frameX = 88;
							Main.tile[i + 1, k].frameY = 110;
						}
					}
				}
				int num6 = genRand.Next(3);
				bool flag5 = false;
				bool flag6 = false;
				if (Main.tile[i - 1, j].nactive() && !Main.tile[i - 1, j].halfBrick() && Main.tile[i - 1, j].slope() == 0 && IsTileTypeFitForTree(Main.tile[i - 1, j].type))
				{
					flag5 = true;
				}
				if (Main.tile[i + 1, j].nactive() && !Main.tile[i + 1, j].halfBrick() && Main.tile[i + 1, j].slope() == 0 && IsTileTypeFitForTree(Main.tile[i + 1, j].type))
				{
					flag6 = true;
				}
				if (!flag5)
				{
					if (num6 == 0)
					{
						num6 = 2;
					}
					if (num6 == 1)
					{
						num6 = 3;
					}
				}
				if (!flag6)
				{
					if (num6 == 0)
					{
						num6 = 1;
					}
					if (num6 == 2)
					{
						num6 = 3;
					}
				}
				if (flag5 && !flag6)
				{
					num6 = 2;
				}
				if (flag6 && !flag5)
				{
					num6 = 1;
				}
				if (num6 == 0 || num6 == 1)
				{
					Main.tile[i + 1, j - 1].active(active: true);
					Main.tile[i + 1, j - 1].type = 5;
					Main.tile[i + 1, j - 1].UseBlockColors(cache);
					num4 = genRand.Next(3);
					if (num4 == 0)
					{
						Main.tile[i + 1, j - 1].frameX = 22;
						Main.tile[i + 1, j - 1].frameY = 132;
					}
					if (num4 == 1)
					{
						Main.tile[i + 1, j - 1].frameX = 22;
						Main.tile[i + 1, j - 1].frameY = 154;
					}
					if (num4 == 2)
					{
						Main.tile[i + 1, j - 1].frameX = 22;
						Main.tile[i + 1, j - 1].frameY = 176;
					}
				}
				if (num6 == 0 || num6 == 2)
				{
					Main.tile[i - 1, j - 1].active(active: true);
					Main.tile[i - 1, j - 1].type = 5;
					Main.tile[i - 1, j - 1].UseBlockColors(cache);
					num4 = genRand.Next(3);
					if (num4 == 0)
					{
						Main.tile[i - 1, j - 1].frameX = 44;
						Main.tile[i - 1, j - 1].frameY = 132;
					}
					if (num4 == 1)
					{
						Main.tile[i - 1, j - 1].frameX = 44;
						Main.tile[i - 1, j - 1].frameY = 154;
					}
					if (num4 == 2)
					{
						Main.tile[i - 1, j - 1].frameX = 44;
						Main.tile[i - 1, j - 1].frameY = 176;
					}
				}
				num4 = genRand.Next(3);
				switch (num6)
				{
				case 0:
					if (num4 == 0)
					{
						Main.tile[i, j - 1].frameX = 88;
						Main.tile[i, j - 1].frameY = 132;
					}
					if (num4 == 1)
					{
						Main.tile[i, j - 1].frameX = 88;
						Main.tile[i, j - 1].frameY = 154;
					}
					if (num4 == 2)
					{
						Main.tile[i, j - 1].frameX = 88;
						Main.tile[i, j - 1].frameY = 176;
					}
					break;
				case 1:
					if (num4 == 0)
					{
						Main.tile[i, j - 1].frameX = 0;
						Main.tile[i, j - 1].frameY = 132;
					}
					if (num4 == 1)
					{
						Main.tile[i, j - 1].frameX = 0;
						Main.tile[i, j - 1].frameY = 154;
					}
					if (num4 == 2)
					{
						Main.tile[i, j - 1].frameX = 0;
						Main.tile[i, j - 1].frameY = 176;
					}
					break;
				case 2:
					if (num4 == 0)
					{
						Main.tile[i, j - 1].frameX = 66;
						Main.tile[i, j - 1].frameY = 132;
					}
					if (num4 == 1)
					{
						Main.tile[i, j - 1].frameX = 66;
						Main.tile[i, j - 1].frameY = 154;
					}
					if (num4 == 2)
					{
						Main.tile[i, j - 1].frameX = 66;
						Main.tile[i, j - 1].frameY = 176;
					}
					break;
				}
				if (genRand.Next(13) != 0 && !flag2)
				{
					num4 = genRand.Next(3);
					if (num4 == 0)
					{
						Main.tile[i, j - num2].frameX = 22;
						Main.tile[i, j - num2].frameY = 198;
					}
					if (num4 == 1)
					{
						Main.tile[i, j - num2].frameX = 22;
						Main.tile[i, j - num2].frameY = 220;
					}
					if (num4 == 2)
					{
						Main.tile[i, j - num2].frameX = 22;
						Main.tile[i, j - num2].frameY = 242;
					}
				}
				else
				{
					num4 = genRand.Next(3);
					if (num4 == 0)
					{
						Main.tile[i, j - num2].frameX = 0;
						Main.tile[i, j - num2].frameY = 198;
					}
					if (num4 == 1)
					{
						Main.tile[i, j - num2].frameX = 0;
						Main.tile[i, j - num2].frameY = 220;
					}
					if (num4 == 2)
					{
						Main.tile[i, j - num2].frameX = 0;
						Main.tile[i, j - num2].frameY = 242;
					}
				}
				RangeFrame(i - 2, j - num2 - 1, i + 2, j + 1);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i - 1, j - num2, 3, num2);
				}
				return true;
			}
		}
		return false;
	}

	public static bool DefaultTreeWallTest(int wallType)
	{
		if (wallType >= 0 && WallID.Sets.AllowsPlantsToGrow[wallType])
		{
			return true;
		}
		return false;
	}

	public static bool GemTreeWallTest(int wallType)
	{
		if (DefaultTreeWallTest(wallType))
		{
			return true;
		}
		switch (wallType)
		{
		case 2:
		case 54:
		case 55:
		case 56:
		case 57:
		case 58:
		case 59:
		case 61:
		case 185:
		case 196:
		case 197:
		case 198:
		case 199:
		case 208:
		case 209:
		case 210:
		case 211:
		case 212:
		case 213:
		case 214:
		case 215:
			return true;
		default:
			return false;
		}
	}

	public static bool GemTreeGroundTest(int tileType)
	{
		if (tileType < 0)
		{
			return false;
		}
		if (TileID.Sets.Conversion.Stone[tileType] || TileID.Sets.Conversion.Moss[tileType])
		{
			return true;
		}
		return false;
	}

	public static bool VanityTreeGroundTest(int tileType)
	{
		if (tileType < 0)
		{
			return false;
		}
		if (TileID.Sets.Conversion.Grass[tileType])
		{
			return true;
		}
		return false;
	}

	public static bool AshTreeGroundTest(int tileType)
	{
		if (tileType < 0)
		{
			return false;
		}
		if (tileType == 633)
		{
			return true;
		}
		return false;
	}

	public static bool TryGrowingTreeByType(int treeTileType, int checkedX, int checkedY)
	{
		bool result = false;
		switch (treeTileType)
		{
		case 5:
			result = GrowTree(checkedX, checkedY);
			break;
		case 587:
			result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Ruby);
			break;
		case 588:
			result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Diamond);
			break;
		case 583:
			result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Topaz);
			break;
		case 584:
			result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Amethyst);
			break;
		case 589:
			result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Amber);
			break;
		case 586:
			result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Emerald);
			break;
		case 585:
			result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Sappphire);
			break;
		case 596:
			result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.VanityTree_Sakura);
			break;
		case 616:
			result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.VanityTree_Willow);
			break;
		case 634:
			result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.Tree_Ash);
			break;
		}
		return result;
	}

	public static bool GrowTreeWithSettings(int checkedX, int checkedY, GrowTreeSettings settings)
	{
		int i;
		for (i = checkedY; Main.tile[checkedX, i].type == settings.SaplingTileType; i++)
		{
		}
		if (Main.tile[checkedX - 1, i - 1].liquid != 0 || Main.tile[checkedX, i - 1].liquid != 0 || Main.tile[checkedX + 1, i - 1].liquid != 0)
		{
			return false;
		}
		Tile tile = Main.tile[checkedX, i];
		if (!tile.nactive() || tile.halfBrick() || tile.slope() != 0)
		{
			return false;
		}
		bool flag = settings.WallTest(Main.tile[checkedX, i - 1].wall);
		if (!settings.GroundTest(tile.type) || !flag)
		{
			return false;
		}
		if ((!Main.tile[checkedX - 1, i].active() || !settings.GroundTest(Main.tile[checkedX - 1, i].type)) && (!Main.tile[checkedX + 1, i].active() || !settings.GroundTest(Main.tile[checkedX + 1, i].type)))
		{
			return false;
		}
		TileColorCache cache = Main.tile[checkedX, i].BlockColorAndCoating();
		if (Main.tenthAnniversaryWorld && !gen && (settings.TreeTileType == 596 || settings.TreeTileType == 616))
		{
			cache.Color = (byte)genRand.Next(1, 13);
		}
		int num = 2;
		int num2 = genRand.Next(settings.TreeHeightMin, settings.TreeHeightMax + 1);
		int num3 = num2 + settings.TreeTopPaddingNeeded;
		if (!EmptyTileCheck(checkedX - num, checkedX + num, i - num3, i - 1, 20))
		{
			return false;
		}
		bool flag2 = false;
		bool flag3 = false;
		int num4;
		for (int j = i - num2; j < i; j++)
		{
			Tile tile2 = Main.tile[checkedX, j];
			tile2.frameNumber((byte)genRand.Next(3));
			tile2.active(active: true);
			tile2.type = settings.TreeTileType;
			tile2.UseBlockColors(cache);
			num4 = genRand.Next(3);
			int num5 = genRand.Next(10);
			if (j == i - 1 || j == i - num2)
			{
				num5 = 0;
			}
			while (((num5 == 5 || num5 == 7) && flag2) || ((num5 == 6 || num5 == 7) && flag3))
			{
				num5 = genRand.Next(10);
			}
			flag2 = false;
			flag3 = false;
			if (num5 == 5 || num5 == 7)
			{
				flag2 = true;
			}
			if (num5 == 6 || num5 == 7)
			{
				flag3 = true;
			}
			switch (num5)
			{
			case 1:
				if (num4 == 0)
				{
					tile2.frameX = 0;
					tile2.frameY = 66;
				}
				if (num4 == 1)
				{
					tile2.frameX = 0;
					tile2.frameY = 88;
				}
				if (num4 == 2)
				{
					tile2.frameX = 0;
					tile2.frameY = 110;
				}
				break;
			case 2:
				if (num4 == 0)
				{
					tile2.frameX = 22;
					tile2.frameY = 0;
				}
				if (num4 == 1)
				{
					tile2.frameX = 22;
					tile2.frameY = 22;
				}
				if (num4 == 2)
				{
					tile2.frameX = 22;
					tile2.frameY = 44;
				}
				break;
			case 3:
				if (num4 == 0)
				{
					tile2.frameX = 44;
					tile2.frameY = 66;
				}
				if (num4 == 1)
				{
					tile2.frameX = 44;
					tile2.frameY = 88;
				}
				if (num4 == 2)
				{
					tile2.frameX = 44;
					tile2.frameY = 110;
				}
				break;
			case 4:
				if (num4 == 0)
				{
					tile2.frameX = 22;
					tile2.frameY = 66;
				}
				if (num4 == 1)
				{
					tile2.frameX = 22;
					tile2.frameY = 88;
				}
				if (num4 == 2)
				{
					tile2.frameX = 22;
					tile2.frameY = 110;
				}
				break;
			case 5:
				if (num4 == 0)
				{
					tile2.frameX = 88;
					tile2.frameY = 0;
				}
				if (num4 == 1)
				{
					tile2.frameX = 88;
					tile2.frameY = 22;
				}
				if (num4 == 2)
				{
					tile2.frameX = 88;
					tile2.frameY = 44;
				}
				break;
			case 6:
				if (num4 == 0)
				{
					tile2.frameX = 66;
					tile2.frameY = 66;
				}
				if (num4 == 1)
				{
					tile2.frameX = 66;
					tile2.frameY = 88;
				}
				if (num4 == 2)
				{
					tile2.frameX = 66;
					tile2.frameY = 110;
				}
				break;
			case 7:
				if (num4 == 0)
				{
					tile2.frameX = 110;
					tile2.frameY = 66;
				}
				if (num4 == 1)
				{
					tile2.frameX = 110;
					tile2.frameY = 88;
				}
				if (num4 == 2)
				{
					tile2.frameX = 110;
					tile2.frameY = 110;
				}
				break;
			default:
				if (num4 == 0)
				{
					tile2.frameX = 0;
					tile2.frameY = 0;
				}
				if (num4 == 1)
				{
					tile2.frameX = 0;
					tile2.frameY = 22;
				}
				if (num4 == 2)
				{
					tile2.frameX = 0;
					tile2.frameY = 44;
				}
				break;
			}
			if (num5 == 5 || num5 == 7)
			{
				Tile tile3 = Main.tile[checkedX - 1, j];
				tile3.active(active: true);
				tile3.type = settings.TreeTileType;
				tile3.UseBlockColors(cache);
				num4 = genRand.Next(3);
				if (genRand.Next(3) < 2)
				{
					if (num4 == 0)
					{
						tile3.frameX = 44;
						tile3.frameY = 198;
					}
					if (num4 == 1)
					{
						tile3.frameX = 44;
						tile3.frameY = 220;
					}
					if (num4 == 2)
					{
						tile3.frameX = 44;
						tile3.frameY = 242;
					}
				}
				else
				{
					if (num4 == 0)
					{
						tile3.frameX = 66;
						tile3.frameY = 0;
					}
					if (num4 == 1)
					{
						tile3.frameX = 66;
						tile3.frameY = 22;
					}
					if (num4 == 2)
					{
						tile3.frameX = 66;
						tile3.frameY = 44;
					}
				}
			}
			if (num5 != 6 && num5 != 7)
			{
				continue;
			}
			Tile tile4 = Main.tile[checkedX + 1, j];
			tile4.active(active: true);
			tile4.type = settings.TreeTileType;
			tile4.UseBlockColors(cache);
			num4 = genRand.Next(3);
			if (genRand.Next(3) < 2)
			{
				if (num4 == 0)
				{
					tile4.frameX = 66;
					tile4.frameY = 198;
				}
				if (num4 == 1)
				{
					tile4.frameX = 66;
					tile4.frameY = 220;
				}
				if (num4 == 2)
				{
					tile4.frameX = 66;
					tile4.frameY = 242;
				}
			}
			else
			{
				if (num4 == 0)
				{
					tile4.frameX = 88;
					tile4.frameY = 66;
				}
				if (num4 == 1)
				{
					tile4.frameX = 88;
					tile4.frameY = 88;
				}
				if (num4 == 2)
				{
					tile4.frameX = 88;
					tile4.frameY = 110;
				}
			}
		}
		bool flag4 = false;
		bool flag5 = false;
		if (Main.tile[checkedX - 1, i].nactive() && !Main.tile[checkedX - 1, i].halfBrick() && Main.tile[checkedX - 1, i].slope() == 0 && IsTileTypeFitForTree(Main.tile[checkedX - 1, i].type))
		{
			flag4 = true;
		}
		if (Main.tile[checkedX + 1, i].nactive() && !Main.tile[checkedX + 1, i].halfBrick() && Main.tile[checkedX + 1, i].slope() == 0 && IsTileTypeFitForTree(Main.tile[checkedX + 1, i].type))
		{
			flag5 = true;
		}
		if (genRand.Next(3) == 0)
		{
			flag4 = false;
		}
		if (genRand.Next(3) == 0)
		{
			flag5 = false;
		}
		if (flag5)
		{
			Main.tile[checkedX + 1, i - 1].active(active: true);
			Main.tile[checkedX + 1, i - 1].type = settings.TreeTileType;
			Main.tile[checkedX + 1, i - 1].UseBlockColors(cache);
			num4 = genRand.Next(3);
			if (num4 == 0)
			{
				Main.tile[checkedX + 1, i - 1].frameX = 22;
				Main.tile[checkedX + 1, i - 1].frameY = 132;
			}
			if (num4 == 1)
			{
				Main.tile[checkedX + 1, i - 1].frameX = 22;
				Main.tile[checkedX + 1, i - 1].frameY = 154;
			}
			if (num4 == 2)
			{
				Main.tile[checkedX + 1, i - 1].frameX = 22;
				Main.tile[checkedX + 1, i - 1].frameY = 176;
			}
		}
		if (flag4)
		{
			Main.tile[checkedX - 1, i - 1].active(active: true);
			Main.tile[checkedX - 1, i - 1].type = settings.TreeTileType;
			Main.tile[checkedX - 1, i - 1].UseBlockColors(cache);
			num4 = genRand.Next(3);
			if (num4 == 0)
			{
				Main.tile[checkedX - 1, i - 1].frameX = 44;
				Main.tile[checkedX - 1, i - 1].frameY = 132;
			}
			if (num4 == 1)
			{
				Main.tile[checkedX - 1, i - 1].frameX = 44;
				Main.tile[checkedX - 1, i - 1].frameY = 154;
			}
			if (num4 == 2)
			{
				Main.tile[checkedX - 1, i - 1].frameX = 44;
				Main.tile[checkedX - 1, i - 1].frameY = 176;
			}
		}
		num4 = genRand.Next(3);
		if (flag4 && flag5)
		{
			if (num4 == 0)
			{
				Main.tile[checkedX, i - 1].frameX = 88;
				Main.tile[checkedX, i - 1].frameY = 132;
			}
			if (num4 == 1)
			{
				Main.tile[checkedX, i - 1].frameX = 88;
				Main.tile[checkedX, i - 1].frameY = 154;
			}
			if (num4 == 2)
			{
				Main.tile[checkedX, i - 1].frameX = 88;
				Main.tile[checkedX, i - 1].frameY = 176;
			}
		}
		else if (flag4)
		{
			if (num4 == 0)
			{
				Main.tile[checkedX, i - 1].frameX = 0;
				Main.tile[checkedX, i - 1].frameY = 132;
			}
			if (num4 == 1)
			{
				Main.tile[checkedX, i - 1].frameX = 0;
				Main.tile[checkedX, i - 1].frameY = 154;
			}
			if (num4 == 2)
			{
				Main.tile[checkedX, i - 1].frameX = 0;
				Main.tile[checkedX, i - 1].frameY = 176;
			}
		}
		else if (flag5)
		{
			if (num4 == 0)
			{
				Main.tile[checkedX, i - 1].frameX = 66;
				Main.tile[checkedX, i - 1].frameY = 132;
			}
			if (num4 == 1)
			{
				Main.tile[checkedX, i - 1].frameX = 66;
				Main.tile[checkedX, i - 1].frameY = 154;
			}
			if (num4 == 2)
			{
				Main.tile[checkedX, i - 1].frameX = 66;
				Main.tile[checkedX, i - 1].frameY = 176;
			}
		}
		if (genRand.Next(13) != 0)
		{
			num4 = genRand.Next(3);
			if (num4 == 0)
			{
				Main.tile[checkedX, i - num2].frameX = 22;
				Main.tile[checkedX, i - num2].frameY = 198;
			}
			if (num4 == 1)
			{
				Main.tile[checkedX, i - num2].frameX = 22;
				Main.tile[checkedX, i - num2].frameY = 220;
			}
			if (num4 == 2)
			{
				Main.tile[checkedX, i - num2].frameX = 22;
				Main.tile[checkedX, i - num2].frameY = 242;
			}
		}
		else
		{
			num4 = genRand.Next(3);
			if (num4 == 0)
			{
				Main.tile[checkedX, i - num2].frameX = 0;
				Main.tile[checkedX, i - num2].frameY = 198;
			}
			if (num4 == 1)
			{
				Main.tile[checkedX, i - num2].frameX = 0;
				Main.tile[checkedX, i - num2].frameY = 220;
			}
			if (num4 == 2)
			{
				Main.tile[checkedX, i - num2].frameX = 0;
				Main.tile[checkedX, i - num2].frameY = 242;
			}
		}
		RangeFrame(checkedX - 2, i - num2 - 1, checkedX + 2, i + 1);
		if (Main.netMode == 2)
		{
			NetMessage.SendTileSquare(-1, checkedX - 1, i - num2, 3, num2);
		}
		return true;
	}

	public static void GrowUndergroundTree(int i, int y)
	{
		if (Main.tile[i, y].type != 60 || !Main.tile[i, y].nactive() || Main.tile[i, y].halfBrick() || Main.tile[i, y].slope() != 0 || Main.tile[i, y].type != 60 || ((!Main.tile[i - 1, y].active() || Main.tile[i - 1, y].type != 60) && (!Main.tile[i + 1, y].active() || Main.tile[i + 1, y].type != 60)))
		{
			return;
		}
		int num = 1;
		int num2 = genRand.Next(5, 15);
		int num3 = num2 + 2;
		if (Main.tile[i, y].type == 60)
		{
			num3 += 5;
		}
		if (!EmptyTileCheck(i - num, i + num, y - num3, y - 1, 20))
		{
			return;
		}
		bool flag = false;
		bool flag2 = false;
		int num4;
		for (int j = y - num2; j < y; j++)
		{
			Main.tile[i, j].frameNumber((byte)genRand.Next(3));
			Main.tile[i, j].active(active: true);
			Main.tile[i, j].type = 5;
			num4 = genRand.Next(3);
			int num5 = genRand.Next(10);
			if (j == y - 1 || j == y - num2)
			{
				num5 = 0;
			}
			while (((num5 == 5 || num5 == 7) && flag) || ((num5 == 6 || num5 == 7) && flag2))
			{
				num5 = genRand.Next(10);
			}
			flag = false;
			flag2 = false;
			if (num5 == 5 || num5 == 7)
			{
				flag = true;
			}
			if (num5 == 6 || num5 == 7)
			{
				flag2 = true;
			}
			switch (num5)
			{
			case 1:
				if (num4 == 0)
				{
					Main.tile[i, j].frameX = 0;
					Main.tile[i, j].frameY = 66;
				}
				if (num4 == 1)
				{
					Main.tile[i, j].frameX = 0;
					Main.tile[i, j].frameY = 88;
				}
				if (num4 == 2)
				{
					Main.tile[i, j].frameX = 0;
					Main.tile[i, j].frameY = 110;
				}
				break;
			case 2:
				if (num4 == 0)
				{
					Main.tile[i, j].frameX = 22;
					Main.tile[i, j].frameY = 0;
				}
				if (num4 == 1)
				{
					Main.tile[i, j].frameX = 22;
					Main.tile[i, j].frameY = 22;
				}
				if (num4 == 2)
				{
					Main.tile[i, j].frameX = 22;
					Main.tile[i, j].frameY = 44;
				}
				break;
			case 3:
				if (num4 == 0)
				{
					Main.tile[i, j].frameX = 44;
					Main.tile[i, j].frameY = 66;
				}
				if (num4 == 1)
				{
					Main.tile[i, j].frameX = 44;
					Main.tile[i, j].frameY = 88;
				}
				if (num4 == 2)
				{
					Main.tile[i, j].frameX = 44;
					Main.tile[i, j].frameY = 110;
				}
				break;
			case 4:
				if (num4 == 0)
				{
					Main.tile[i, j].frameX = 22;
					Main.tile[i, j].frameY = 66;
				}
				if (num4 == 1)
				{
					Main.tile[i, j].frameX = 22;
					Main.tile[i, j].frameY = 88;
				}
				if (num4 == 2)
				{
					Main.tile[i, j].frameX = 22;
					Main.tile[i, j].frameY = 110;
				}
				break;
			case 5:
				if (num4 == 0)
				{
					Main.tile[i, j].frameX = 88;
					Main.tile[i, j].frameY = 0;
				}
				if (num4 == 1)
				{
					Main.tile[i, j].frameX = 88;
					Main.tile[i, j].frameY = 22;
				}
				if (num4 == 2)
				{
					Main.tile[i, j].frameX = 88;
					Main.tile[i, j].frameY = 44;
				}
				break;
			case 6:
				if (num4 == 0)
				{
					Main.tile[i, j].frameX = 66;
					Main.tile[i, j].frameY = 66;
				}
				if (num4 == 1)
				{
					Main.tile[i, j].frameX = 66;
					Main.tile[i, j].frameY = 88;
				}
				if (num4 == 2)
				{
					Main.tile[i, j].frameX = 66;
					Main.tile[i, j].frameY = 110;
				}
				break;
			case 7:
				if (num4 == 0)
				{
					Main.tile[i, j].frameX = 110;
					Main.tile[i, j].frameY = 66;
				}
				if (num4 == 1)
				{
					Main.tile[i, j].frameX = 110;
					Main.tile[i, j].frameY = 88;
				}
				if (num4 == 2)
				{
					Main.tile[i, j].frameX = 110;
					Main.tile[i, j].frameY = 110;
				}
				break;
			default:
				if (num4 == 0)
				{
					Main.tile[i, j].frameX = 0;
					Main.tile[i, j].frameY = 0;
				}
				if (num4 == 1)
				{
					Main.tile[i, j].frameX = 0;
					Main.tile[i, j].frameY = 22;
				}
				if (num4 == 2)
				{
					Main.tile[i, j].frameX = 0;
					Main.tile[i, j].frameY = 44;
				}
				break;
			}
			if (num5 == 5 || num5 == 7)
			{
				Main.tile[i - 1, j].active(active: true);
				Main.tile[i - 1, j].type = 5;
				num4 = genRand.Next(3);
				if (genRand.Next(3) < 2)
				{
					if (num4 == 0)
					{
						Main.tile[i - 1, j].frameX = 44;
						Main.tile[i - 1, j].frameY = 198;
					}
					if (num4 == 1)
					{
						Main.tile[i - 1, j].frameX = 44;
						Main.tile[i - 1, j].frameY = 220;
					}
					if (num4 == 2)
					{
						Main.tile[i - 1, j].frameX = 44;
						Main.tile[i - 1, j].frameY = 242;
					}
				}
				else
				{
					if (num4 == 0)
					{
						Main.tile[i - 1, j].frameX = 66;
						Main.tile[i - 1, j].frameY = 0;
					}
					if (num4 == 1)
					{
						Main.tile[i - 1, j].frameX = 66;
						Main.tile[i - 1, j].frameY = 22;
					}
					if (num4 == 2)
					{
						Main.tile[i - 1, j].frameX = 66;
						Main.tile[i - 1, j].frameY = 44;
					}
				}
			}
			if (num5 != 6 && num5 != 7)
			{
				continue;
			}
			Main.tile[i + 1, j].active(active: true);
			Main.tile[i + 1, j].type = 5;
			num4 = genRand.Next(3);
			if (genRand.Next(3) < 2)
			{
				if (num4 == 0)
				{
					Main.tile[i + 1, j].frameX = 66;
					Main.tile[i + 1, j].frameY = 198;
				}
				if (num4 == 1)
				{
					Main.tile[i + 1, j].frameX = 66;
					Main.tile[i + 1, j].frameY = 220;
				}
				if (num4 == 2)
				{
					Main.tile[i + 1, j].frameX = 66;
					Main.tile[i + 1, j].frameY = 242;
				}
			}
			else
			{
				if (num4 == 0)
				{
					Main.tile[i + 1, j].frameX = 88;
					Main.tile[i + 1, j].frameY = 66;
				}
				if (num4 == 1)
				{
					Main.tile[i + 1, j].frameX = 88;
					Main.tile[i + 1, j].frameY = 88;
				}
				if (num4 == 2)
				{
					Main.tile[i + 1, j].frameX = 88;
					Main.tile[i + 1, j].frameY = 110;
				}
			}
		}
		int num6 = genRand.Next(3);
		bool flag3 = false;
		bool flag4 = false;
		if (Main.tile[i - 1, y].nactive() && !Main.tile[i - 1, y].halfBrick() && Main.tile[i - 1, y].slope() == 0 && (Main.tile[i - 1, y].type == 2 || Main.tile[i - 1, y].type == 23 || Main.tile[i - 1, y].type == 60 || Main.tile[i - 1, y].type == 109 || Main.tile[i - 1, y].type == 147 || TileLoader.CanGrowModTree(Main.tile[i - 1, y].type)))
		{
			flag3 = true;
		}
		if (Main.tile[i + 1, y].nactive() && !Main.tile[i + 1, y].halfBrick() && Main.tile[i + 1, y].slope() == 0 && (Main.tile[i + 1, y].type == 2 || Main.tile[i + 1, y].type == 23 || Main.tile[i + 1, y].type == 60 || Main.tile[i + 1, y].type == 109 || Main.tile[i + 1, y].type == 147 || TileLoader.CanGrowModTree(Main.tile[i + 1, y].type)))
		{
			flag4 = true;
		}
		if (!flag3)
		{
			if (num6 == 0)
			{
				num6 = 2;
			}
			if (num6 == 1)
			{
				num6 = 3;
			}
		}
		if (!flag4)
		{
			if (num6 == 0)
			{
				num6 = 1;
			}
			if (num6 == 2)
			{
				num6 = 3;
			}
		}
		if (flag3 && !flag4)
		{
			num6 = 2;
		}
		if (flag4 && !flag3)
		{
			num6 = 1;
		}
		if (num6 == 0 || num6 == 1)
		{
			Main.tile[i + 1, y - 1].active(active: true);
			Main.tile[i + 1, y - 1].type = 5;
			num4 = genRand.Next(3);
			if (num4 == 0)
			{
				Main.tile[i + 1, y - 1].frameX = 22;
				Main.tile[i + 1, y - 1].frameY = 132;
			}
			if (num4 == 1)
			{
				Main.tile[i + 1, y - 1].frameX = 22;
				Main.tile[i + 1, y - 1].frameY = 154;
			}
			if (num4 == 2)
			{
				Main.tile[i + 1, y - 1].frameX = 22;
				Main.tile[i + 1, y - 1].frameY = 176;
			}
		}
		if (num6 == 0 || num6 == 2)
		{
			Main.tile[i - 1, y - 1].active(active: true);
			Main.tile[i - 1, y - 1].type = 5;
			num4 = genRand.Next(3);
			if (num4 == 0)
			{
				Main.tile[i - 1, y - 1].frameX = 44;
				Main.tile[i - 1, y - 1].frameY = 132;
			}
			if (num4 == 1)
			{
				Main.tile[i - 1, y - 1].frameX = 44;
				Main.tile[i - 1, y - 1].frameY = 154;
			}
			if (num4 == 2)
			{
				Main.tile[i - 1, y - 1].frameX = 44;
				Main.tile[i - 1, y - 1].frameY = 176;
			}
		}
		num4 = genRand.Next(3);
		switch (num6)
		{
		case 0:
			if (num4 == 0)
			{
				Main.tile[i, y - 1].frameX = 88;
				Main.tile[i, y - 1].frameY = 132;
			}
			if (num4 == 1)
			{
				Main.tile[i, y - 1].frameX = 88;
				Main.tile[i, y - 1].frameY = 154;
			}
			if (num4 == 2)
			{
				Main.tile[i, y - 1].frameX = 88;
				Main.tile[i, y - 1].frameY = 176;
			}
			break;
		case 1:
			if (num4 == 0)
			{
				Main.tile[i, y - 1].frameX = 0;
				Main.tile[i, y - 1].frameY = 132;
			}
			if (num4 == 1)
			{
				Main.tile[i, y - 1].frameX = 0;
				Main.tile[i, y - 1].frameY = 154;
			}
			if (num4 == 2)
			{
				Main.tile[i, y - 1].frameX = 0;
				Main.tile[i, y - 1].frameY = 176;
			}
			break;
		case 2:
			if (num4 == 0)
			{
				Main.tile[i, y - 1].frameX = 66;
				Main.tile[i, y - 1].frameY = 132;
			}
			if (num4 == 1)
			{
				Main.tile[i, y - 1].frameX = 66;
				Main.tile[i, y - 1].frameY = 154;
			}
			if (num4 == 2)
			{
				Main.tile[i, y - 1].frameX = 66;
				Main.tile[i, y - 1].frameY = 176;
			}
			break;
		}
		if (genRand.Next(8) != 0)
		{
			num4 = genRand.Next(3);
			if (num4 == 0)
			{
				Main.tile[i, y - num2].frameX = 22;
				Main.tile[i, y - num2].frameY = 198;
			}
			if (num4 == 1)
			{
				Main.tile[i, y - num2].frameX = 22;
				Main.tile[i, y - num2].frameY = 220;
			}
			if (num4 == 2)
			{
				Main.tile[i, y - num2].frameX = 22;
				Main.tile[i, y - num2].frameY = 242;
			}
		}
		else
		{
			num4 = genRand.Next(3);
			if (num4 == 0)
			{
				Main.tile[i, y - num2].frameX = 0;
				Main.tile[i, y - num2].frameY = 198;
			}
			if (num4 == 1)
			{
				Main.tile[i, y - num2].frameX = 0;
				Main.tile[i, y - num2].frameY = 220;
			}
			if (num4 == 2)
			{
				Main.tile[i, y - num2].frameX = 0;
				Main.tile[i, y - num2].frameY = 242;
			}
		}
		RangeFrame(i - 2, y - num2 - 1, i + 2, y + 1);
		if (Main.netMode == 2 && !gen)
		{
			NetMessage.SendTileSquare(-1, i - 1, y - num2, 3, num2);
		}
	}

	public static bool GrowShroom(int i, int y)
	{
		if (Main.tile[i - 1, y - 1].lava() || Main.tile[i - 1, y - 1].lava() || Main.tile[i + 1, y - 1].lava())
		{
			return false;
		}
		if (Main.tile[i, y].nactive() && Main.tile[i, y].type == 70 && Main.tile[i, y - 1].wall == 0 && Main.tile[i - 1, y].active() && Main.tile[i - 1, y].type == 70 && Main.tile[i + 1, y].active() && Main.tile[i + 1, y].type == 70 && EmptyTileCheck(i - 2, i + 2, y - 13, y - 3, 71) && EmptyTileCheck(i - 1, i + 1, y - 3, y - 1, 71))
		{
			if (gen && genRand.Next(3) != 0)
			{
				Main.tile[i, y].halfBrick(halfBrick: false);
				Main.tile[i, y].slope(0);
			}
			if (!Main.tile[i, y].halfBrick() && Main.tile[i, y].slope() == 0)
			{
				int num = genRand.Next(4, 11);
				for (int j = y - num; j < y; j++)
				{
					Main.tile[i, j].frameNumber((byte)genRand.Next(3));
					Main.tile[i, j].active(active: true);
					Main.tile[i, j].type = 72;
					int num2 = genRand.Next(3);
					if (num2 == 0)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 0;
					}
					if (num2 == 1)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 18;
					}
					if (num2 == 2)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 36;
					}
				}
				int num3 = genRand.Next(3);
				if (num3 == 0)
				{
					Main.tile[i, y - num].frameX = 36;
					Main.tile[i, y - num].frameY = 0;
				}
				if (num3 == 1)
				{
					Main.tile[i, y - num].frameX = 36;
					Main.tile[i, y - num].frameY = 18;
				}
				if (num3 == 2)
				{
					Main.tile[i, y - num].frameX = 36;
					Main.tile[i, y - num].frameY = 36;
				}
				RangeFrame(i - 2, y - num - 1, i + 2, y + 1);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i - 1, y - num, 3, num);
				}
				return true;
			}
		}
		return false;
	}

	public static void AddTrees(bool undergroundOnly = false)
	{
		double num = 0.1 + genRand.NextDouble() * 0.35;
		double num2 = 0.1 + genRand.NextDouble() * 0.35;
		int num3 = 20;
		int num4 = (int)Main.worldSurface;
		if (!undergroundOnly)
		{
			for (int i = 1; i < Main.maxTilesX - 1; i++)
			{
				for (int j = num3; j < num4; j++)
				{
					if (i < 380)
					{
						if (genRand.NextDouble() < num && Main.tile[i, j].liquid == 0)
						{
							GrowPalmTree(i, j);
						}
					}
					else if (i > Main.maxTilesX - 380 && genRand.NextDouble() < num2 && Main.tile[i, j].liquid == 0)
					{
						GrowPalmTree(i, j);
					}
					int num5 = 20;
					if (drunkWorldGen)
					{
						num5 /= 3;
					}
					if (remixWorldGen)
					{
						num5 /= 2;
					}
					if (Main.tile[i, j].type == 2 && (Main.tenthAnniversaryWorld || genRand.Next(num5) == 0))
					{
						if (genRand.Next(2) == 0)
						{
							GrowTreeWithSettings(i, j, GrowTreeSettings.Profiles.VanityTree_Willow);
						}
						else
						{
							GrowTreeWithSettings(i, j, GrowTreeSettings.Profiles.VanityTree_Sakura);
						}
					}
					else
					{
						GrowTree(i, j);
					}
				}
				if (genRand.Next(3) == 0)
				{
					i++;
				}
				if (genRand.Next(4) == 0)
				{
					i++;
				}
			}
		}
		if (!remixWorldGen)
		{
			return;
		}
		num3 = (int)Main.worldSurface;
		num4 = Main.maxTilesY - 300;
		for (int k = 1; k < Main.maxTilesX - 1; k++)
		{
			for (int l = num3; l < num4; l++)
			{
				int maxValue = 7;
				if (Main.tile[k, l].type == 2 && (Main.tenthAnniversaryWorld || genRand.Next(maxValue) == 0))
				{
					if (genRand.Next(2) == 0)
					{
						GrowTreeWithSettings(k, l, GrowTreeSettings.Profiles.VanityTree_Willow);
					}
					else
					{
						GrowTreeWithSettings(k, l, GrowTreeSettings.Profiles.VanityTree_Sakura);
					}
				}
				else
				{
					GrowTree(k, l);
				}
			}
		}
	}

	public static void ExplodeMine(int i, int j, bool fromWiring)
	{
		_ = ref Main.tile[i, j].type;
		KillTile(i, j, fail: false, effectOnly: false, noItem: true);
		NetMessage.SendTileSquare(-1, i, j);
		Projectile.NewProjectile(GetProjectileSource_PlayerOrWires(i, j, fromWiring, Main.LocalPlayer), i * 16 + 8, j * 16 + 8, 0f, 0f, 164, 250, 10f, Main.myPlayer);
	}

	public static bool EmptyTileCheck(int startX, int endX, int startY, int endY, int ignoreID = -1)
	{
		if (startX < 0)
		{
			return false;
		}
		if (endX >= Main.maxTilesX)
		{
			return false;
		}
		if (startY < 0)
		{
			return false;
		}
		if (endY >= Main.maxTilesY)
		{
			return false;
		}
		bool flag = false;
		if (ignoreID != -1 && TileID.Sets.CommonSapling[ignoreID])
		{
			flag = true;
		}
		for (int i = startX; i < endX + 1; i++)
		{
			for (int j = startY; j < endY + 1; j++)
			{
				if (!Main.tile[i, j].active())
				{
					continue;
				}
				switch (ignoreID)
				{
				case -1:
					return false;
				case 11:
					if (Main.tile[i, j].type == 11)
					{
						continue;
					}
					return false;
				case 71:
					if (Main.tile[i, j].type == 71)
					{
						continue;
					}
					return false;
				}
				if (flag)
				{
					if (TileID.Sets.CommonSapling[Main.tile[i, j].type])
					{
						break;
					}
					if (!TileID.Sets.IgnoredByGrowingSaplings[Main.tile[i, j].type])
					{
						return false;
					}
				}
			}
		}
		return true;
	}

	public static void StartHardmode()
	{
		if (Main.netMode != 1 && !Main.hardMode)
		{
			Main.hardMode = true;
			ThreadPool.QueueUserWorkItem(smCallBack, 1);
		}
	}

	public static void TryProtectingSpawnedItems()
	{
		for (int i = 0; i < 400; i++)
		{
			Item item = Main.item[i];
			if (EligibleForSpawnProtection(item))
			{
				item.timeSinceItemSpawned -= 18000;
			}
		}
	}

	private static bool EligibleForSpawnProtection(Item item)
	{
		if (item.active)
		{
			return ItemID.Sets.OverflowProtectionTimeOffset[item.type] == 0;
		}
		return false;
	}

	public static void UndoSpawnedItemProtection()
	{
		for (int i = 0; i < 400; i++)
		{
			Item item = Main.item[i];
			if (EligibleForSpawnProtection(item) && item.timeSinceItemSpawned < 0)
			{
				item.timeSinceItemSpawned += 18000;
			}
		}
	}

	public static void smCallBack(object threadContext)
	{
		List<GenPass> list = new List<GenPass>();
		IsGeneratingHardMode = true;
		TryProtectingSpawnedItems();
		if (Main.rand == null)
		{
			Main.rand = new UnifiedRandom((int)DateTime.Now.Ticks);
		}
		double num = (double)genRand.Next(300, 400) * 0.001;
		double num2 = (double)genRand.Next(200, 300) * 0.001;
		int num3 = (int)((double)Main.maxTilesX * num);
		int num4 = (int)((double)Main.maxTilesX * (1.0 - num));
		int num5 = 1;
		if (genRand.Next(2) == 0)
		{
			num4 = (int)((double)Main.maxTilesX * num);
			num3 = (int)((double)Main.maxTilesX * (1.0 - num));
			num5 = -1;
		}
		int num6 = 1;
		if (GenVars.dungeonX < Main.maxTilesX / 2)
		{
			num6 = -1;
		}
		if (num6 < 0)
		{
			if (num4 < num3)
			{
				num4 = (int)((double)Main.maxTilesX * num2);
			}
			else
			{
				num3 = (int)((double)Main.maxTilesX * num2);
			}
		}
		else if (num4 > num3)
		{
			num4 = (int)((double)Main.maxTilesX * (1.0 - num2));
		}
		else
		{
			num3 = (int)((double)Main.maxTilesX * (1.0 - num2));
		}
		PassLegacy HardmodeGoodRemixPass = new PassLegacy("Hardmode Good Remix", HardmodeGoodRemixTask);
		PassLegacy HardmodeGoodPass = new PassLegacy("Hardmode Good", HardmodeGoodTask);
		PassLegacy HardmodeEvilPass = new PassLegacy("Hardmode Evil", HardmodeEvilTask);
		list.Add(HardmodeGoodRemixPass);
		list.Add(HardmodeGoodPass);
		list.Add(HardmodeEvilPass);
		if (Main.remixWorld)
		{
			HardmodeGoodPass.Disable();
			HardmodeEvilPass.Disable();
		}
		else
		{
			HardmodeGoodRemixPass.Disable();
		}
		list.Add(new PassLegacy("Hardmode Walls", HardmodeWallsTask));
		list.Add(new PassLegacy("Hardmode Announcement", HardmodeAnnouncementTask));
		smCallback_End(list);
		void HardmodeEvilTask(GenerationProgress progress, GameConfiguration configuration)
		{
			GERunner(num4, 0, 3 * -num5, 5.0, good: false);
		}
		static void HardmodeGoodRemixTask(GenerationProgress progress, GameConfiguration configuration)
		{
			int num7 = Main.maxTilesX / 7;
			int num8 = Main.maxTilesX / 14;
			if (Main.dungeonX < Main.maxTilesX / 2)
			{
				for (int i = Main.maxTilesX - num7 - num8; i < Main.maxTilesX; i++)
				{
					for (int j = (int)Main.worldSurface + genRand.Next(-1, 2); j < Main.maxTilesY - 10; j++)
					{
						if (i > Main.maxTilesX - num7)
						{
							Convert(i, j, 2, 1);
						}
						else if (TileID.Sets.Crimson[Main.tile[i, j].type] || TileID.Sets.Corrupt[Main.tile[i, j].type])
						{
							Convert(i, j, 2, 1);
						}
					}
				}
			}
			else
			{
				for (int k = 0; k < num7 + num8; k++)
				{
					for (int l = (int)Main.worldSurface + genRand.Next(-1, 2); l < Main.maxTilesY - 10; l++)
					{
						if (k < num7)
						{
							Convert(k, l, 2, 1);
						}
						else if (TileID.Sets.Crimson[Main.tile[k, l].type] || TileID.Sets.Corrupt[Main.tile[k, l].type])
						{
							Convert(k, l, 2, 1);
						}
					}
				}
			}
		}
		void HardmodeGoodTask(GenerationProgress progress, GameConfiguration configuration)
		{
			GERunner(num3, 0, 3 * num5, 5.0);
		}
	}

	private static void HardmodeWallsTask(GenerationProgress progress, GameConfiguration configuration)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		double num13 = (double)Main.maxTilesX / 4200.0;
		int num10 = (int)(25.0 * num13);
		ShapeData shapeData = new ShapeData();
		int num11 = 0;
		while (num10 > 0)
		{
			if (++num11 % 15000 == 0)
			{
				num10--;
			}
			Point point = RandomWorldPoint((int)Main.worldSurface - 100, 1, 190, 1);
			Tile tile = Main.tile[point.X, point.Y];
			Tile tile2 = Main.tile[point.X, point.Y - 1];
			ushort num12 = 0;
			if (TileID.Sets.Crimson[tile.type])
			{
				num12 = (ushort)(192 + genRand.Next(4));
			}
			else if (TileID.Sets.Corrupt[tile.type])
			{
				num12 = (ushort)(188 + genRand.Next(4));
			}
			else if (TileID.Sets.Hallow[tile.type])
			{
				num12 = (ushort)(200 + genRand.Next(4));
			}
			if (tile.active() && num12 != 0 && !tile2.active())
			{
				bool flag = WorldUtils.Gen(new Point(point.X, point.Y - 1), new ShapeFloodFill(1000), Actions.Chain(new Modifiers.IsNotSolid(), new Modifiers.OnlyWalls(0, 54, 55, 56, 57, 58, 59, 61, 185, 212, 213, 214, 215, 2, 196, 197, 198, 199, 15, 40, 71, 64, 204, 205, 206, 207, 208, 209, 210, 211, 71), new Actions.Blank().Output(shapeData)));
				if (shapeData.Count > 50 && flag)
				{
					WorldUtils.Gen(new Point(point.X, point.Y), new ModShapes.OuterOutline(shapeData, useDiagonals: true, useInterior: true), new Actions.PlaceWall(num12));
					num10--;
				}
				shapeData.Clear();
			}
		}
	}

	private static void HardmodeAnnouncementTask(GenerationProgress progress, GameConfiguration configuration)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (Main.netMode == 0)
		{
			Main.NewText(Lang.misc[15].Value, 50, byte.MaxValue, 130);
		}
		else if (Main.netMode == 2)
		{
			ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[15].Key), new Color(50, 255, 130));
		}
		AchievementsHelper.NotifyProgressionEvent(9);
	}

	private static void smCallback_End(List<GenPass> hardmodeTasks)
	{
		SystemLoader.ModifyHardmodeTasks(hardmodeTasks);
		foreach (GenPass hardmodeTask in hardmodeTasks)
		{
			hardmodeTask.Apply(null, null);
		}
		if (Main.netMode == 2)
		{
			Netplay.ResetSections();
		}
		UndoSpawnedItemProtection();
		IsGeneratingHardMode = false;
	}

	public static bool PlaceDoor(int i, int j, int type, int style = 0)
	{
		int num = style / 36;
		int num2 = style % 36;
		int num3 = 54 * num;
		int num4 = 54 * num2;
		try
		{
			if (Main.tile[i, j - 2].nactive() && Main.tileSolid[Main.tile[i, j - 2].type] && SolidTile(i, j + 2))
			{
				Main.tile[i, j - 1].active(active: true);
				Main.tile[i, j - 1].type = 10;
				Main.tile[i, j - 1].frameY = (short)num4;
				Main.tile[i, j - 1].frameX = (short)(num3 + genRand.Next(3) * 18);
				Main.tile[i, j].active(active: true);
				Main.tile[i, j].type = 10;
				Main.tile[i, j].frameY = (short)(num4 + 18);
				Main.tile[i, j].frameX = (short)(num3 + genRand.Next(3) * 18);
				Main.tile[i, j + 1].active(active: true);
				Main.tile[i, j + 1].type = 10;
				Main.tile[i, j + 1].frameY = (short)(num4 + 36);
				Main.tile[i, j + 1].frameX = (short)(num3 + genRand.Next(3) * 18);
				return true;
			}
			return false;
		}
		catch
		{
			return false;
		}
	}

	public static bool CloseDoor(int i, int j, bool forced = false)
	{
		int num = 0;
		int num2 = i;
		int num3 = j;
		if (Main.tile[i, j] == null)
		{
			Main.tile[i, j] = default(Tile);
		}
		int frameX = Main.tile[i, j].frameX;
		Tile tile = Main.tile[i, j];
		if (TileLoader.CloseDoorID(Main.tile[i, j]) < 0)
		{
			return false;
		}
		int num4 = tile.frameY;
		int num5 = 0;
		int num6 = 0;
		while (num4 >= 54)
		{
			num4 -= 54;
			num5++;
		}
		if (frameX >= 72)
		{
			num5 += 36 * (frameX / 72);
			num6 += 54 * (frameX / 72);
		}
		num3 = j - num4 / 18;
		switch (frameX % 72)
		{
		case 0:
			num2 = i;
			num = 1;
			break;
		case 18:
			num2 = i - 1;
			num = 1;
			break;
		case 36:
			num2 = i + 1;
			num = -1;
			break;
		case 54:
			num2 = i;
			num = -1;
			break;
		}
		int num7 = num2;
		if (num == -1)
		{
			num7 = num2 - 1;
		}
		if (!forced)
		{
			for (int k = num3; k < num3 + 3; k++)
			{
				if (!Collision.EmptyTile(num2, k, ignoreTiles: true))
				{
					return false;
				}
			}
		}
		ushort closeDoorID = (ushort)TileLoader.CloseDoorID(tile);
		for (int l = num7; l < num7 + 2; l++)
		{
			for (int m = num3; m < num3 + 3; m++)
			{
				if (l == num2)
				{
					if (Main.tile[l, m] == null)
					{
						Main.tile[l, m] = default(Tile);
					}
					Main.tile[l, m].type = closeDoorID;
					Main.tile[l, m].frameX = (short)(genRand.Next(3) * 18 + num6);
				}
				else
				{
					if (Main.tile[l, m] == null)
					{
						Main.tile[l, m] = default(Tile);
					}
					Main.tile[l, m].active(active: false);
				}
			}
		}
		if (Main.netMode != 1 && Wiring.running)
		{
			Wiring.SkipWire(num2, num3);
			Wiring.SkipWire(num2, num3 + 1);
			Wiring.SkipWire(num2, num3 + 2);
		}
		for (int n = num2 - 1; n <= num2 + 1; n++)
		{
			for (int num8 = num3 - 1; num8 <= num3 + 2; num8++)
			{
				TileFrame(n, num8);
			}
		}
		SoundEngine.PlaySound(9, i * 16, j * 16);
		return true;
	}

	public static bool AddLifeCrystal(int i, int j)
	{
		for (int k = j; k < Main.maxTilesY; k++)
		{
			if (Main.tile[i, k].active() && Main.tileSolid[Main.tile[i, k].type])
			{
				int num = k - 1;
				if (Main.tile[i, num - 1].lava() || Main.tile[i - 1, num - 1].lava())
				{
					return false;
				}
				if (Main.tile[i, num - 1].shimmer())
				{
					return false;
				}
				if (!EmptyTileCheck(i - 1, i, num - 1, num))
				{
					return false;
				}
				if (Main.wallDungeon[Main.tile[i, num].wall])
				{
					return false;
				}
				Tile tile = Main.tile[i - 1, num + 1];
				Tile tile2 = Main.tile[i, num + 1];
				if (!tile.nactive() || !Main.tileSolid[tile.type])
				{
					return false;
				}
				if (!tile2.nactive() || !Main.tileSolid[tile2.type])
				{
					return false;
				}
				if (tile.blockType() != 0)
				{
					tile.slope(0);
					tile.halfBrick(halfBrick: false);
				}
				if (tile2.blockType() != 0)
				{
					tile2.slope(0);
					tile2.halfBrick(halfBrick: false);
				}
				Main.tile[i - 1, num - 1].active(active: true);
				Main.tile[i - 1, num - 1].type = 12;
				Main.tile[i - 1, num - 1].frameX = 0;
				Main.tile[i - 1, num - 1].frameY = 0;
				Main.tile[i, num - 1].active(active: true);
				Main.tile[i, num - 1].type = 12;
				Main.tile[i, num - 1].frameX = 18;
				Main.tile[i, num - 1].frameY = 0;
				Main.tile[i - 1, num].active(active: true);
				Main.tile[i - 1, num].type = 12;
				Main.tile[i - 1, num].frameX = 0;
				Main.tile[i - 1, num].frameY = 18;
				Main.tile[i, num].active(active: true);
				Main.tile[i, num].type = 12;
				Main.tile[i, num].frameX = 18;
				Main.tile[i, num].frameY = 18;
				return true;
			}
		}
		return false;
	}

	public static void AddShadowOrb(int x, int y)
	{
		if (x < 10 || x > Main.maxTilesX - 10 || y < 10 || y > Main.maxTilesY - 10)
		{
			return;
		}
		for (int i = x - 1; i < x + 1; i++)
		{
			for (int j = y - 1; j < y + 1; j++)
			{
				if (Main.tile[i, j].active() && Main.tile[i, j].type == 31)
				{
					return;
				}
			}
		}
		short num = 0;
		if (crimson)
		{
			num += 36;
		}
		Main.tile[x - 1, y - 1].active(active: true);
		Main.tile[x - 1, y - 1].type = 31;
		Main.tile[x - 1, y - 1].frameX = num;
		Main.tile[x - 1, y - 1].frameY = 0;
		Main.tile[x, y - 1].active(active: true);
		Main.tile[x, y - 1].type = 31;
		Main.tile[x, y - 1].frameX = (short)(18 + num);
		Main.tile[x, y - 1].frameY = 0;
		Main.tile[x - 1, y].active(active: true);
		Main.tile[x - 1, y].type = 31;
		Main.tile[x - 1, y].frameX = num;
		Main.tile[x - 1, y].frameY = 18;
		Main.tile[x, y].active(active: true);
		Main.tile[x, y].type = 31;
		Main.tile[x, y].frameX = (short)(18 + num);
		Main.tile[x, y].frameY = 18;
	}

	public static void AddHellHouses()
	{
		int num = (int)((double)Main.maxTilesX * 0.25);
		Tile tile2;
		for (int i = 100; i < Main.maxTilesX - 100; i++)
		{
			if (((drunkWorldGen || remixWorldGen) && i > num && i < Main.maxTilesX - num) || (!drunkWorldGen && !remixWorldGen && (i < num || i > Main.maxTilesX - num)))
			{
				continue;
			}
			int num12 = Main.maxTilesY - 40;
			while (true)
			{
				tile2 = Main.tile[i, num12];
				if (!tile2.active())
				{
					tile2 = Main.tile[i, num12];
					if (tile2.liquid <= 0)
					{
						break;
					}
				}
				num12--;
			}
			tile2 = Main.tile[i, num12 + 1];
			if (tile2.active())
			{
				ushort num23 = (ushort)genRand.Next(75, 77);
				byte wallType = 13;
				if (genRand.Next(5) > 0)
				{
					num23 = 75;
				}
				if (num23 == 75)
				{
					wallType = 14;
				}
				if (getGoodWorldGen)
				{
					num23 = 76;
				}
				HellFort(i, num12, num23, wallType);
				i += genRand.Next(30, 130);
				if (genRand.Next(10) == 0)
				{
					i += genRand.Next(0, 200);
				}
			}
		}
		float num33 = Main.maxTilesX / 4200;
		for (int j = 0; (float)j < 200f * num33; j++)
		{
			int num38 = 0;
			bool flag = false;
			while (!flag)
			{
				num38++;
				int num39 = genRand.Next((int)((double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.8));
				int num40 = genRand.Next(Main.maxTilesY - 300, Main.maxTilesY - 20);
				tile2 = Main.tile[num39, num40];
				if (tile2.active())
				{
					tile2 = Main.tile[num39, num40];
					if (tile2.type != 75)
					{
						tile2 = Main.tile[num39, num40];
						if (tile2.type != 76)
						{
							goto IL_0330;
						}
					}
					int num41 = 0;
					tile2 = Main.tile[num39 - 1, num40];
					if (tile2.wall > 0)
					{
						num41 = -1;
					}
					else
					{
						tile2 = Main.tile[num39 + 1, num40];
						if (tile2.wall > 0)
						{
							num41 = 1;
						}
					}
					tile2 = Main.tile[num39 + num41, num40];
					if (!tile2.active())
					{
						tile2 = Main.tile[num39 + num41, num40 + 1];
						if (!tile2.active())
						{
							bool flag2 = false;
							for (int k = num39 - 8; k < num39 + 8; k++)
							{
								for (int l = num40 - 8; l < num40 + 8; l++)
								{
									tile2 = Main.tile[k, l];
									if (tile2.active())
									{
										bool[] torch = TileID.Sets.Torch;
										tile2 = Main.tile[k, l];
										if (torch[tile2.type])
										{
											flag2 = true;
											break;
										}
									}
								}
							}
							if (!flag2)
							{
								PlaceTile(num39 + num41, num40, 4, mute: true, forced: true, -1, 7);
								flag = true;
							}
						}
					}
				}
				goto IL_0330;
				IL_0330:
				if (num38 > 1000)
				{
					flag = true;
				}
			}
		}
		double num42 = 4200000.0 / (double)Main.maxTilesX;
		for (int m = 0; (double)m < num42; m++)
		{
			int num2 = 0;
			int num3 = genRand.Next(num, Main.maxTilesX - num);
			int n = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
			do
			{
				tile2 = Main.tile[num3, n];
				if (tile2.wall != 13)
				{
					tile2 = Main.tile[num3, n];
					if (tile2.wall != 14)
					{
						goto IL_03ac;
					}
				}
				tile2 = Main.tile[num3, n];
				if (!tile2.active())
				{
					break;
				}
				goto IL_03ac;
				IL_03ac:
				num3 = genRand.Next(num, Main.maxTilesX - num);
				n = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
				if (drunkWorldGen || remixWorldGen)
				{
					num3 = ((genRand.Next(2) != 0) ? genRand.Next(Main.maxTilesX - num, Main.maxTilesX - 50) : genRand.Next(50, num));
				}
				num2++;
			}
			while (num2 <= 100000);
			if (num2 > 100000)
			{
				continue;
			}
			tile2 = Main.tile[num3, n];
			if (tile2.wall != 13)
			{
				tile2 = Main.tile[num3, n];
				if (tile2.wall != 14)
				{
					continue;
				}
			}
			tile2 = Main.tile[num3, n];
			if (tile2.active())
			{
				continue;
			}
			for (; !SolidTile(num3, n) && n < Main.maxTilesY - 20; n++)
			{
			}
			n--;
			int num4 = num3;
			int num5 = num3;
			while (true)
			{
				tile2 = Main.tile[num4, n];
				if (tile2.active() || !SolidTile(num4, n + 1))
				{
					break;
				}
				num4--;
			}
			num4++;
			while (true)
			{
				tile2 = Main.tile[num5, n];
				if (tile2.active() || !SolidTile(num5, n + 1))
				{
					break;
				}
				num5++;
			}
			num5--;
			int num6 = num5 - num4;
			int num7 = (num5 + num4) / 2;
			tile2 = Main.tile[num7, n];
			if (tile2.active())
			{
				continue;
			}
			tile2 = Main.tile[num7, n];
			if (tile2.wall != 13)
			{
				tile2 = Main.tile[num7, n];
				if (tile2.wall != 14)
				{
					continue;
				}
			}
			if (!SolidTile(num7, n + 1))
			{
				continue;
			}
			int style = 16;
			int style9 = 13;
			int style10 = 14;
			int style11 = 49;
			int style12 = 4;
			int style13 = 8;
			int style14 = 15;
			int style15 = 9;
			int style16 = 10;
			int style2 = 17;
			int style3 = 25;
			int style4 = 25;
			int style5 = 23;
			int style6 = 25;
			int num8 = genRand.Next(13);
			int num9 = 0;
			int num10 = 0;
			if (num8 == 0)
			{
				num9 = 5;
				num10 = 4;
			}
			if (num8 == 1)
			{
				num9 = 4;
				num10 = 3;
			}
			if (num8 == 2)
			{
				num9 = 3;
				num10 = 5;
			}
			if (num8 == 3)
			{
				num9 = 4;
				num10 = 6;
			}
			if (num8 == 4)
			{
				num9 = 3;
				num10 = 3;
			}
			if (num8 == 5)
			{
				num9 = 5;
				num10 = 3;
			}
			if (num8 == 6)
			{
				num9 = 5;
				num10 = 4;
			}
			if (num8 == 7)
			{
				num9 = 5;
				num10 = 4;
			}
			if (num8 == 8)
			{
				num9 = 5;
				num10 = 4;
			}
			if (num8 == 9)
			{
				num9 = 3;
				num10 = 5;
			}
			if (num8 == 10)
			{
				num9 = 5;
				num10 = 3;
			}
			if (num8 == 11)
			{
				num9 = 2;
				num10 = 4;
			}
			if (num8 == 12)
			{
				num9 = 3;
				num10 = 3;
			}
			for (int num11 = num7 - num9; num11 <= num7 + num9; num11++)
			{
				for (int num13 = n - num10; num13 <= n; num13++)
				{
					tile2 = Main.tile[num11, num13];
					if (tile2.active())
					{
						num8 = -1;
						break;
					}
				}
			}
			if ((double)num6 < (double)num9 * 1.75)
			{
				num8 = -1;
			}
			switch (num8)
			{
			case 0:
			{
				PlaceTile(num7, n, 14, mute: true, forced: false, -1, style9);
				int num15 = genRand.Next(6);
				if (num15 < 3)
				{
					PlaceTile(num7 + num15, n - 2, 33, mute: true, forced: false, -1, style4);
				}
				tile2 = Main.tile[num7, n];
				if (!tile2.active())
				{
					break;
				}
				tile2 = Main.tile[num7 - 2, n];
				if (!tile2.active())
				{
					PlaceTile(num7 - 2, n, 15, mute: true, forced: false, -1, style);
					tile2 = Main.tile[num7 - 2, n];
					if (tile2.active())
					{
						tile2 = Main.tile[num7 - 2, n];
						tile2.frameX += 18;
						tile2 = Main.tile[num7 - 2, n - 1];
						tile2.frameX += 18;
					}
				}
				tile2 = Main.tile[num7 + 2, n];
				if (!tile2.active())
				{
					PlaceTile(num7 + 2, n, 15, mute: true, forced: false, -1, style);
				}
				break;
			}
			case 1:
			{
				PlaceTile(num7, n, 18, mute: true, forced: false, -1, style10);
				int num14 = genRand.Next(4);
				if (num14 < 2)
				{
					PlaceTile(num7 + num14, n - 1, 33, mute: true, forced: false, -1, style4);
				}
				tile2 = Main.tile[num7, n];
				if (!tile2.active())
				{
					break;
				}
				if (genRand.Next(2) == 0)
				{
					tile2 = Main.tile[num7 - 1, n];
					if (!tile2.active())
					{
						PlaceTile(num7 - 1, n, 15, mute: true, forced: false, -1, style);
						tile2 = Main.tile[num7 - 1, n];
						if (tile2.active())
						{
							tile2 = Main.tile[num7 - 1, n];
							tile2.frameX += 18;
							tile2 = Main.tile[num7 - 1, n - 1];
							tile2.frameX += 18;
						}
					}
				}
				else
				{
					tile2 = Main.tile[num7 + 2, n];
					if (!tile2.active())
					{
						PlaceTile(num7 + 2, n, 15, mute: true, forced: false, -1, style);
					}
				}
				break;
			}
			case 2:
				PlaceTile(num7, n, 105, mute: true, forced: false, -1, style11);
				break;
			case 3:
				PlaceTile(num7, n, 101, mute: true, forced: false, -1, style12);
				break;
			case 4:
				if (genRand.Next(2) == 0)
				{
					PlaceTile(num7, n, 15, mute: true, forced: false, -1, style);
					tile2 = Main.tile[num7, n];
					tile2.frameX += 18;
					tile2 = Main.tile[num7, n - 1];
					tile2.frameX += 18;
				}
				else
				{
					PlaceTile(num7, n, 15, mute: true, forced: false, -1, style);
				}
				break;
			case 5:
				if (genRand.Next(2) == 0)
				{
					Place4x2(num7, n, 79, 1, style13);
				}
				else
				{
					Place4x2(num7, n, 79, -1, style13);
				}
				break;
			case 6:
				PlaceTile(num7, n, 87, mute: true, forced: false, -1, style14);
				break;
			case 7:
				PlaceTile(num7, n, 88, mute: true, forced: false, -1, style15);
				break;
			case 8:
				PlaceTile(num7, n, 89, mute: true, forced: false, -1, style16);
				break;
			case 9:
				PlaceTile(num7, n, 104, mute: true, forced: false, -1, style2);
				break;
			case 10:
				if (genRand.Next(2) == 0)
				{
					Place4x2(num7, n, 90, 1, style6);
				}
				else
				{
					Place4x2(num7, n, 90, -1, style6);
				}
				break;
			case 11:
				PlaceTile(num7, n, 93, mute: true, forced: false, -1, style5);
				break;
			case 12:
				PlaceTile(num7, n, 100, mute: true, forced: false, -1, style3);
				break;
			}
		}
		num42 = 420000.0 / (double)Main.maxTilesX;
		for (int num16 = 0; (double)num16 < num42; num16++)
		{
			int num17 = 0;
			int num18 = genRand.Next(num, Main.maxTilesX - num);
			int num19 = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
			do
			{
				tile2 = Main.tile[num18, num19];
				if (tile2.wall != 13)
				{
					tile2 = Main.tile[num18, num19];
					if (tile2.wall != 14)
					{
						goto IL_0b99;
					}
				}
				tile2 = Main.tile[num18, num19];
				if (!tile2.active())
				{
					break;
				}
				goto IL_0b99;
				IL_0b99:
				num18 = genRand.Next(num, Main.maxTilesX - num);
				num19 = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
				if (drunkWorldGen || remixWorldGen)
				{
					num18 = ((genRand.Next(2) != 0) ? genRand.Next(Main.maxTilesX - num, Main.maxTilesX - 50) : genRand.Next(50, num));
				}
				num17++;
			}
			while (num17 <= 100000);
			if (num17 > 100000)
			{
				continue;
			}
			int num20 = num18;
			int num21 = num18;
			int num22 = num19;
			int num24 = num19;
			int num25 = 0;
			for (int num26 = 0; num26 < 2; num26++)
			{
				num20 = num18;
				num21 = num18;
				while (true)
				{
					tile2 = Main.tile[num20, num19];
					if (tile2.active())
					{
						break;
					}
					tile2 = Main.tile[num20, num19];
					if (tile2.wall != 13)
					{
						tile2 = Main.tile[num20, num19];
						if (tile2.wall != 14)
						{
							break;
						}
					}
					num20--;
				}
				num20++;
				while (true)
				{
					tile2 = Main.tile[num21, num19];
					if (tile2.active())
					{
						break;
					}
					tile2 = Main.tile[num21, num19];
					if (tile2.wall != 13)
					{
						tile2 = Main.tile[num21, num19];
						if (tile2.wall != 14)
						{
							break;
						}
					}
					num21++;
				}
				num21--;
				num18 = (num20 + num21) / 2;
				num22 = num19;
				num24 = num19;
				while (true)
				{
					tile2 = Main.tile[num18, num22];
					if (tile2.active())
					{
						break;
					}
					tile2 = Main.tile[num18, num22];
					if (tile2.wall != 13)
					{
						tile2 = Main.tile[num18, num22];
						if (tile2.wall != 14)
						{
							break;
						}
					}
					num22--;
				}
				num22++;
				while (true)
				{
					tile2 = Main.tile[num18, num24];
					if (tile2.active())
					{
						break;
					}
					tile2 = Main.tile[num18, num24];
					if (tile2.wall != 13)
					{
						tile2 = Main.tile[num18, num24];
						if (tile2.wall != 14)
						{
							break;
						}
					}
					num24++;
				}
				num24--;
				num19 = (num22 + num24) / 2;
			}
			num20 = num18;
			num21 = num18;
			while (true)
			{
				tile2 = Main.tile[num20, num19];
				if (tile2.active())
				{
					break;
				}
				tile2 = Main.tile[num20, num19 - 1];
				if (tile2.active())
				{
					break;
				}
				tile2 = Main.tile[num20, num19 + 1];
				if (tile2.active())
				{
					break;
				}
				num20--;
			}
			num20++;
			while (true)
			{
				tile2 = Main.tile[num21, num19];
				if (tile2.active())
				{
					break;
				}
				tile2 = Main.tile[num21, num19 - 1];
				if (tile2.active())
				{
					break;
				}
				tile2 = Main.tile[num21, num19 + 1];
				if (tile2.active())
				{
					break;
				}
				num21++;
			}
			num21--;
			num22 = num19;
			num24 = num19;
			while (true)
			{
				tile2 = Main.tile[num18, num22];
				if (tile2.active())
				{
					break;
				}
				tile2 = Main.tile[num18 - 1, num22];
				if (tile2.active())
				{
					break;
				}
				tile2 = Main.tile[num18 + 1, num22];
				if (tile2.active())
				{
					break;
				}
				num22--;
			}
			num22++;
			while (true)
			{
				tile2 = Main.tile[num18, num24];
				if (tile2.active())
				{
					break;
				}
				tile2 = Main.tile[num18 - 1, num24];
				if (tile2.active())
				{
					break;
				}
				tile2 = Main.tile[num18 + 1, num24];
				if (tile2.active())
				{
					break;
				}
				num24++;
			}
			num24--;
			num18 = (num20 + num21) / 2;
			num19 = (num22 + num24) / 2;
			int num43 = num21 - num20;
			num25 = num24 - num22;
			if (num43 <= 7 || num25 <= 5)
			{
				continue;
			}
			int num27 = 0;
			if (nearPicture2(num18, num19))
			{
				num27 = -1;
			}
			if (num27 == 0)
			{
				PaintingEntry paintingEntry = RandHellPicture();
				if (!nearPicture(num18, num19))
				{
					PlaceTile(num18, num19, paintingEntry.tileType, mute: true, forced: false, -1, paintingEntry.style);
				}
			}
		}
		int[] array = new int[3]
		{
			genRand.Next(16, 22),
			genRand.Next(16, 22),
			genRand.Next(16, 22)
		};
		while (array[1] == array[0])
		{
			array[1] = genRand.Next(16, 22);
		}
		while (array[2] == array[0] || array[2] == array[1])
		{
			array[2] = genRand.Next(16, 22);
		}
		num42 = 420000.0 / (double)Main.maxTilesX;
		for (int num28 = 0; (double)num28 < num42; num28++)
		{
			int num29 = 0;
			int num30;
			int num31;
			do
			{
				IL_10d9:
				num30 = genRand.Next(num, Main.maxTilesX - num);
				num31 = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
				if (drunkWorldGen || remixWorldGen)
				{
					num30 = ((genRand.Next(2) != 0) ? genRand.Next(Main.maxTilesX - num, Main.maxTilesX - 50) : genRand.Next(50, num));
				}
				num29++;
				if (num29 > 100000)
				{
					break;
				}
				tile2 = Main.tile[num30, num31];
				if (tile2.wall != 13)
				{
					tile2 = Main.tile[num30, num31];
					if (tile2.wall != 14)
					{
						goto IL_10d9;
					}
				}
				tile2 = Main.tile[num30, num31];
			}
			while (tile2.active());
			if (num29 > 100000)
			{
				continue;
			}
			while (!SolidTile(num30, num31) && num31 > 10)
			{
				num31--;
			}
			num31++;
			tile2 = Main.tile[num30, num31];
			if (tile2.wall != 13)
			{
				tile2 = Main.tile[num30, num31];
				if (tile2.wall != 14)
				{
					continue;
				}
			}
			int num32 = genRand.Next(3);
			int style7 = 32;
			int style8 = 32;
			int num34;
			int num35;
			switch (num32)
			{
			default:
				num34 = 1;
				num35 = 3;
				break;
			case 1:
				num34 = 3;
				num35 = 3;
				break;
			case 2:
				num34 = 1;
				num35 = 2;
				break;
			}
			for (int num36 = num30 - 1; num36 <= num30 + num34; num36++)
			{
				for (int num37 = num31; num37 <= num31 + num35; num37++)
				{
					Tile tile = Main.tile[num30, num31];
					if (num36 < num30 || num36 == num30 + num34)
					{
						if (tile.active())
						{
							switch (tile.type)
							{
							case 10:
							case 11:
							case 34:
							case 42:
							case 91:
								num32 = -1;
								break;
							}
						}
					}
					else if (tile.active())
					{
						num32 = -1;
					}
				}
			}
			switch (num32)
			{
			case 0:
				PlaceTile(num30, num31, 91, mute: true, forced: false, -1, array[genRand.Next(3)]);
				break;
			case 1:
				PlaceTile(num30, num31, 34, mute: true, forced: false, -1, style7);
				break;
			case 2:
				PlaceTile(num30, num31, 42, mute: true, forced: false, -1, style8);
				break;
			}
		}
	}

	public static void HellFort(int i, int j, ushort tileType = 75, byte wallType = 14)
	{
		int[] array = new int[5];
		int[] array2 = new int[5];
		int[] array3 = new int[10];
		int[] array4 = new int[10];
		int num = 8;
		int num12 = 20;
		if (drunkWorldGen)
		{
			num /= 2;
			num12 *= 2;
		}
		array[2] = i - genRand.Next(num / 2, num12 / 2);
		array2[2] = i + genRand.Next(num / 2, num12 / 2);
		array[3] = array2[2];
		array2[3] = array[3] + genRand.Next(num, num12);
		array[4] = array2[3];
		array2[4] = array[4] + genRand.Next(num, num12);
		array2[1] = array[2];
		array[1] = array2[1] - genRand.Next(num, num12);
		array2[0] = array[1];
		array[0] = array2[0] - genRand.Next(num, num12);
		num = 6;
		num12 = 12;
		array3[3] = j - genRand.Next(num, num12);
		array4[3] = j;
		for (int k = 4; k < 10; k++)
		{
			array3[k] = array4[k - 1];
			array4[k] = array3[k] + genRand.Next(num, num12);
		}
		for (int num23 = 2; num23 >= 0; num23--)
		{
			array4[num23] = array3[num23 + 1];
			array3[num23] = array4[num23] - genRand.Next(num, num12);
		}
		bool flag = false;
		bool flag3 = false;
		bool[,] array5 = new bool[5, 10];
		int num34 = 3;
		int num44 = 3;
		for (int l = 0; l < 2; l++)
		{
			if (genRand.Next(3) == 0 || drunkWorldGen)
			{
				flag = true;
				int num45 = genRand.Next(10);
				if (num45 < num34)
				{
					num34 = num45;
				}
				if (num45 > num44)
				{
					num44 = num45;
				}
				int num46 = 1;
				if (genRand.Next(2) == 0 || drunkWorldGen)
				{
					array5[0, num45] = true;
					array5[1, num45] = true;
					num46 = 0;
				}
				else
				{
					array5[1, num45] = true;
				}
				int num47 = genRand.Next(2);
				if (num47 == 0)
				{
					num47 = -1;
				}
				int num48 = genRand.Next(10);
				while (num48 > 0 && num45 >= 0 && num45 < 10)
				{
					array5[num46, num45] = true;
					num45 += num47;
				}
			}
			if (genRand.Next(3) == 0 || drunkWorldGen)
			{
				flag3 = true;
				int num2 = genRand.Next(10);
				if (num2 < num34)
				{
					num34 = num2;
				}
				if (num2 > num44)
				{
					num44 = num2;
				}
				int num3 = 3;
				if (genRand.Next(2) == 0 || drunkWorldGen)
				{
					array5[3, num2] = true;
					array5[4, num2] = true;
					num3 = 4;
				}
				else
				{
					array5[3, num2] = true;
				}
				int num4 = genRand.Next(2);
				if (num4 == 0)
				{
					num4 = -1;
				}
				int num5 = genRand.Next(10);
				while (num5 > 0 && num2 >= 0 && num2 < 10)
				{
					array5[num3, num2] = true;
					num2 += num4;
				}
			}
		}
		for (int m = 0; m < 5; m++)
		{
			int num6 = array[m];
			bool flag4 = false;
			if (num6 < 10 || num6 > Main.maxTilesX - 10)
			{
				flag4 = true;
			}
			else
			{
				for (int n = Main.UnderworldLayer; n < Main.maxTilesY; n++)
				{
					if (Main.tile[num6, n].wall > 0)
					{
						flag4 = true;
					}
				}
			}
			if (flag4)
			{
				for (int num7 = 0; num7 < 10; num7++)
				{
					array5[m, num7] = false;
				}
			}
		}
		int num8 = genRand.Next(10);
		if (num8 < num34)
		{
			num34 = num8;
		}
		num8 = genRand.Next(10);
		if (num8 > num44)
		{
			num44 = num8;
		}
		if (!flag && !flag3)
		{
			while (num44 - num34 < 5)
			{
				num8 = genRand.Next(10);
				if (num8 < num34)
				{
					num34 = num8;
				}
				num8 = genRand.Next(10);
				if (num8 > num44)
				{
					num44 = num8;
				}
			}
		}
		for (int num9 = num34; num9 <= num44; num9++)
		{
			array5[2, num9] = true;
		}
		for (int num10 = 0; num10 < 5; num10++)
		{
			for (int num11 = 0; num11 < 10; num11++)
			{
				if (array5[num10, num11] && (array3[num11] < Main.UnderworldLayer || array4[num11] > Main.maxTilesY - 20))
				{
					array5[num10, num11] = false;
				}
			}
		}
		for (int num13 = 0; num13 < 5; num13++)
		{
			for (int num14 = 0; num14 < 10; num14++)
			{
				if (!array5[num13, num14])
				{
					continue;
				}
				for (int num15 = array[num13]; num15 <= array2[num13]; num15++)
				{
					for (int num16 = array3[num14]; num16 <= array4[num14]; num16++)
					{
						if (num15 < 10)
						{
							break;
						}
						if (num15 > Main.maxTilesX - 10)
						{
							break;
						}
						Main.tile[num15, num16].liquid = 0;
						if (num15 == array[num13] || num15 == array2[num13] || num16 == array3[num14] || num16 == array4[num14])
						{
							Main.tile[num15, num16].active(active: true);
							Main.tile[num15, num16].type = tileType;
							Main.tile[num15, num16].halfBrick(halfBrick: false);
							Main.tile[num15, num16].slope(0);
						}
						else
						{
							Main.tile[num15, num16].wall = wallType;
							Main.tile[num15, num16].active(active: false);
						}
					}
				}
			}
		}
		int style = 19;
		int style2 = 13;
		for (int num17 = 0; num17 < 4; num17++)
		{
			bool[] array6 = new bool[10];
			bool flag5 = false;
			for (int num18 = 0; num18 < 10; num18++)
			{
				if (array5[num17, num18] && array5[num17 + 1, num18])
				{
					array6[num18] = true;
					flag5 = true;
				}
			}
			while (flag5)
			{
				int num19 = genRand.Next(10);
				if (array6[num19])
				{
					flag5 = false;
					Main.tile[array2[num17], array4[num19] - 1].active(active: false);
					Main.tile[array2[num17], array4[num19] - 2].active(active: false);
					Main.tile[array2[num17], array4[num19] - 3].active(active: false);
					Main.tile[array2[num17], array4[num19] - 1].wall = wallType;
					Main.tile[array2[num17], array4[num19] - 2].wall = wallType;
					Main.tile[array2[num17], array4[num19] - 3].wall = wallType;
					PlaceTile(array2[num17], array4[num19] - 1, 10, mute: true, forced: false, -1, style);
				}
			}
		}
		for (int num20 = 0; num20 < 5; num20++)
		{
			for (int num21 = 0; num21 < 10; num21++)
			{
				if (!array5[num20, num21])
				{
					continue;
				}
				if (num21 > 0 && array5[num20, num21 - 1])
				{
					int num22 = genRand.Next(array[num20] + 2, array2[num20] - 1);
					int num24 = genRand.Next(array[num20] + 2, array2[num20] - 1);
					int num25 = 0;
					while (num24 - num22 < 2 || num24 - num22 > 5)
					{
						num22 = genRand.Next(array[num20] + 2, array2[num20] - 1);
						num24 = genRand.Next(array[num20] + 2, array2[num20] - 1);
						num25++;
						if (num25 > 10000)
						{
							break;
						}
					}
					if (num25 > 10000)
					{
						break;
					}
					for (int num26 = num22; num26 <= num24 && num26 >= 20 && num26 <= Main.maxTilesX - 20; num26++)
					{
						Main.tile[num26, array3[num21]].active(active: false);
						PlaceTile(num26, array3[num21], 19, mute: true, forced: true, -1, style2);
						Main.tile[num26, array3[num21]].wall = wallType;
					}
				}
				if (num20 < 4 && array5[num20 + 1, num21] && genRand.Next(3) == 0)
				{
					Main.tile[array2[num20], array4[num21] - 1].active(active: false);
					Main.tile[array2[num20], array4[num21] - 2].active(active: false);
					Main.tile[array2[num20], array4[num21] - 3].active(active: false);
					Main.tile[array2[num20], array4[num21] - 1].wall = wallType;
					Main.tile[array2[num20], array4[num21] - 2].wall = wallType;
					Main.tile[array2[num20], array4[num21] - 3].wall = wallType;
					PlaceTile(array2[num20], array4[num21] - 1, 10, mute: true, forced: false, -1, style);
				}
			}
		}
		bool flag6 = false;
		for (int num27 = 0; num27 < 5; num27++)
		{
			bool[] array7 = new bool[10];
			for (int num28 = 0; num28 < 10; num28++)
			{
				if (array5[num27, num28])
				{
					flag6 = true;
					array7[num28] = true;
				}
			}
			if (!flag6)
			{
				continue;
			}
			bool flag7 = false;
			for (int num29 = 0; num29 < 10; num29++)
			{
				if (array7[num29])
				{
					if (!Main.tile[array[num27] - 1, array4[num29] - 1].active() && !Main.tile[array[num27] - 1, array4[num29] - 2].active() && !Main.tile[array[num27] - 1, array4[num29] - 3].active() && Main.tile[array[num27] - 1, array4[num29] - 1].liquid == 0 && Main.tile[array[num27] - 1, array4[num29] - 2].liquid == 0 && Main.tile[array[num27] - 1, array4[num29] - 3].liquid == 0)
					{
						flag7 = true;
					}
					else
					{
						array7[num29] = false;
					}
				}
			}
			while (flag7)
			{
				int num30 = genRand.Next(10);
				if (array7[num30])
				{
					flag7 = false;
					Main.tile[array[num27], array4[num30] - 1].active(active: false);
					Main.tile[array[num27], array4[num30] - 2].active(active: false);
					Main.tile[array[num27], array4[num30] - 3].active(active: false);
					PlaceTile(array[num27], array4[num30] - 1, 10, mute: true, forced: false, -1, style);
				}
			}
			break;
		}
		bool flag8 = false;
		for (int num31 = 4; num31 >= 0; num31--)
		{
			bool[] array8 = new bool[10];
			for (int num32 = 0; num32 < 10; num32++)
			{
				if (array5[num31, num32])
				{
					flag8 = true;
					array8[num32] = true;
				}
			}
			if (flag8)
			{
				bool flag9 = false;
				for (int num33 = 0; num33 < 10; num33++)
				{
					if (array8[num33])
					{
						if (num31 < 20 || num31 > Main.maxTilesX - 20)
						{
							break;
						}
						if (!Main.tile[array2[num31] + 1, array4[num33] - 1].active() && !Main.tile[array2[num31] + 1, array4[num33] - 2].active() && !Main.tile[array2[num31] + 1, array4[num33] - 3].active() && Main.tile[array2[num31] + 1, array4[num33] - 1].liquid == 0 && Main.tile[array2[num31] + 1, array4[num33] - 2].liquid == 0 && Main.tile[array2[num31] + 1, array4[num33] - 3].liquid == 0)
						{
							flag9 = true;
						}
						else
						{
							array8[num33] = false;
						}
					}
				}
				while (flag9)
				{
					int num35 = genRand.Next(10);
					if (array8[num35])
					{
						flag9 = false;
						Main.tile[array2[num31], array4[num35] - 1].active(active: false);
						Main.tile[array2[num31], array4[num35] - 2].active(active: false);
						Main.tile[array2[num31], array4[num35] - 3].active(active: false);
						PlaceTile(array2[num31], array4[num35] - 1, 10, mute: true, forced: false, -1, style);
					}
				}
				break;
			}
		}
		bool flag10 = false;
		for (int num36 = 0; num36 < 10; num36++)
		{
			bool[] array9 = new bool[10];
			for (int num37 = 0; num37 < 5; num37++)
			{
				if (array5[num37, num36])
				{
					flag10 = true;
					array9[num37] = true;
				}
			}
			if (!flag10)
			{
				continue;
			}
			bool flag2 = true;
			while (flag2)
			{
				int num38 = genRand.Next(5);
				if (!array9[num38])
				{
					continue;
				}
				int num39 = genRand.Next(array[num38] + 2, array2[num38] - 1);
				int num40 = genRand.Next(array[num38] + 2, array2[num38] - 1);
				int num41 = 0;
				while (num40 - num39 < 2 || num40 - num39 > 5)
				{
					num39 = genRand.Next(array[num38] + 2, array2[num38] - 1);
					num40 = genRand.Next(array[num38] + 2, array2[num38] - 1);
					num41++;
					if (num41 > 10000)
					{
						break;
					}
				}
				if (num41 > 10000)
				{
					break;
				}
				for (int num42 = num39; num42 <= num40 && num42 >= 10 && num42 <= Main.maxTilesX - 10; num42++)
				{
					if (Main.tile[num42, array3[num36] - 1].active() || Main.tile[num42, array3[num36] - 1].liquid > 0)
					{
						flag2 = false;
					}
				}
				if (flag2)
				{
					for (int num43 = num39; num43 <= num40 && num43 >= 10 && num43 <= Main.maxTilesX - 10; num43++)
					{
						Main.tile[num43, array3[num36]].active(active: false);
						PlaceTile(num43, array3[num36], 19, mute: true, forced: true, -1, style2);
					}
				}
				flag2 = false;
			}
			break;
		}
	}

	public static void HellHouse(int i, int j, byte type = 76, byte wall = 13)
	{
		int num = genRand.Next(8, 20);
		int num11 = genRand.Next(1, 3);
		int num13 = genRand.Next(4, 13);
		int num14 = j;
		for (int k = 0; k < num11; k++)
		{
			int num15 = genRand.Next(5, 9);
			HellRoom(i, num14, num, num15, type, wall);
			num14 -= num15;
		}
		num14 = j;
		for (int l = 0; l < num13; l++)
		{
			int num16 = genRand.Next(5, 9);
			num14 += num16;
			HellRoom(i, num14, num, num16, type, wall);
		}
		for (int m = i - num / 2; m <= i + num / 2; m++)
		{
			for (num14 = j; num14 < Main.maxTilesY && ((Main.tile[m, num14].active() && (Main.tile[m, num14].type == 76 || Main.tile[m, num14].type == 75)) || Main.tile[i, num14].wall == 13 || Main.tile[i, num14].wall == 14); num14++)
			{
			}
			int num17 = 6 + genRand.Next(3);
			while (num14 < Main.maxTilesY && !Main.tile[m, num14].active())
			{
				num17--;
				Main.tile[m, num14].active(active: true);
				Main.tile[m, num14].type = 57;
				num14++;
				if (num17 <= 0)
				{
					break;
				}
			}
		}
		int num18 = 0;
		int num19 = 0;
		for (num14 = j; num14 < Main.maxTilesY && ((Main.tile[i, num14].active() && (Main.tile[i, num14].type == 76 || Main.tile[i, num14].type == 75)) || Main.tile[i, num14].wall == 13 || Main.tile[i, num14].wall == 14); num14++)
		{
		}
		num14--;
		num19 = num14;
		while ((Main.tile[i, num14].active() && (Main.tile[i, num14].type == 76 || Main.tile[i, num14].type == 75)) || Main.tile[i, num14].wall == 13 || Main.tile[i, num14].wall == 14)
		{
			num14--;
			if (!Main.tile[i, num14].active() || (Main.tile[i, num14].type != 76 && Main.tile[i, num14].type != 75))
			{
				continue;
			}
			int num2 = genRand.Next(i - num / 2 + 1, i + num / 2 - 1);
			int num3 = genRand.Next(i - num / 2 + 1, i + num / 2 - 1);
			if (num2 > num3)
			{
				int num20 = num2;
				num2 = num3;
				num3 = num20;
			}
			if (num2 == num3)
			{
				if (num2 < i)
				{
					num3++;
				}
				else
				{
					num2--;
				}
			}
			for (int n = num2; n <= num3; n++)
			{
				if (Main.tile[n, num14 - 1].wall == 13)
				{
					Main.tile[n, num14].wall = 13;
				}
				if (Main.tile[n, num14 - 1].wall == 14)
				{
					Main.tile[n, num14].wall = 14;
				}
				Main.tile[n, num14].type = 19;
				Main.tile[n, num14].active(active: true);
			}
			num14--;
		}
		num18 = num14;
		double num4 = (double)((num19 - num18) * num) * 0.02;
		for (int num5 = 0; (double)num5 < num4; num5++)
		{
			int num6 = genRand.Next(i - num / 2, i + num / 2 + 1);
			int num7 = genRand.Next(num18, num19);
			int num8 = genRand.Next(3, 8);
			for (int num9 = num6 - num8; num9 <= num6 + num8; num9++)
			{
				for (int num10 = num7 - num8; num10 <= num7 + num8; num10++)
				{
					double num21 = Math.Abs(num9 - num6);
					double num12 = Math.Abs(num10 - num7);
					if (!(Math.Sqrt(num21 * num21 + num12 * num12) < (double)num8 * 0.4))
					{
						continue;
					}
					try
					{
						if (Main.tile[num9, num10].type == 76 || Main.tile[num9, num10].type == 19)
						{
							Main.tile[num9, num10].active(active: false);
						}
						Main.tile[num9, num10].wall = 0;
					}
					catch
					{
					}
				}
			}
		}
	}

	public static void HellRoom(int i, int j, int width, int height, byte type = 76, byte wall = 13)
	{
		if (j > Main.maxTilesY - 40)
		{
			return;
		}
		for (int k = i - width / 2; k <= i + width / 2; k++)
		{
			for (int l = j - height; l <= j; l++)
			{
				try
				{
					Main.tile[k, l].active(active: true);
					Main.tile[k, l].type = type;
					Main.tile[k, l].liquid = 0;
					Main.tile[k, l].lava(lava: false);
				}
				catch
				{
				}
			}
		}
		for (int m = i - width / 2 + 1; m <= i + width / 2 - 1; m++)
		{
			for (int n = j - height + 1; n <= j - 1; n++)
			{
				try
				{
					Main.tile[m, n].active(active: false);
					Main.tile[m, n].wall = wall;
					Main.tile[m, n].liquid = 0;
					Main.tile[m, n].lava(lava: false);
				}
				catch
				{
				}
			}
		}
	}

	public static void templeCleaner(int x, int y)
	{
		int num = 0;
		if (Main.tile[x + 1, y].active() && Main.tile[x + 1, y].type == 226)
		{
			num++;
		}
		if (Main.tile[x - 1, y].active() && Main.tile[x - 1, y].type == 226)
		{
			num++;
		}
		if (Main.tile[x, y + 1].active() && Main.tile[x, y + 1].type == 226)
		{
			num++;
		}
		if (Main.tile[x, y - 1].active() && Main.tile[x, y - 1].type == 226)
		{
			num++;
		}
		if (Main.tile[x, y].active() && Main.tile[x, y].type == 226)
		{
			if (num <= 1)
			{
				Main.tile[x, y].active(active: false);
				Main.tile[x, y].wall = 87;
			}
		}
		else if (!Main.tile[x, y].active() && num == 3)
		{
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].type = 226;
			Main.tile[x, y].liquid = 0;
			Main.tile[x, y].slope(0);
			Main.tile[x, y].halfBrick(halfBrick: false);
		}
	}

	public static Vector2D templePather(Vector2D templePath, int destX, int destY)
	{
		int num = (int)templePath.X;
		int num2 = (int)templePath.Y;
		int num3 = genRand.Next(5, 20);
		int num4 = genRand.Next(2, 5);
		while (num3 > 0 && (num != destX || num2 != destY))
		{
			num3--;
			if (num > destX)
			{
				num--;
			}
			if (num < destX)
			{
				num++;
			}
			if (num2 > destY)
			{
				num2--;
			}
			if (num2 < destY)
			{
				num2++;
			}
			for (int i = num - num4; i < num + num4; i++)
			{
				for (int j = num2 - num4; j < num2 + num4; j++)
				{
					Main.tile[i, j].active(active: false);
					Main.tile[i, j].wall = 87;
				}
			}
		}
		return new Vector2D(num, num2);
	}

	public static void outerTempled(int x, int y)
	{
		if ((Main.tile[x, y].active() & (Main.tile[x, y].type == 226)) || Main.tile[x, y].wall == 87)
		{
			return;
		}
		int num = 6;
		for (int i = x - num; i <= x + num; i++)
		{
			for (int j = y - num; j <= y + num; j++)
			{
				if (!Main.tile[i, j].active() && Main.tile[i, j].wall == 87)
				{
					i = x;
					j = y;
					Main.tile[i, j].active(active: true);
					Main.tile[i, j].type = 226;
					Main.tile[i, j].liquid = 0;
					Main.tile[i, j].slope(0);
					Main.tile[i, j].halfBrick(halfBrick: false);
					return;
				}
			}
		}
	}

	public static void makeTemple(int x, int y)
	{
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_08aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_08eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_08f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_08f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_090d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0914: Unknown result type (might be due to invalid IL or missing references)
		//IL_091b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0931: Unknown result type (might be due to invalid IL or missing references)
		//IL_0938: Unknown result type (might be due to invalid IL or missing references)
		//IL_0953: Unknown result type (might be due to invalid IL or missing references)
		//IL_095a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b4b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0b54: Unknown result type (might be due to invalid IL or missing references)
		//IL_144f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1454: Unknown result type (might be due to invalid IL or missing references)
		//IL_1456: Unknown result type (might be due to invalid IL or missing references)
		//IL_1461: Unknown result type (might be due to invalid IL or missing references)
		//IL_1472: Unknown result type (might be due to invalid IL or missing references)
		//IL_148e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1533: Unknown result type (might be due to invalid IL or missing references)
		//IL_153f: Unknown result type (might be due to invalid IL or missing references)
		Rectangle[] array = (Rectangle[])(object)new Rectangle[100];
		double num = (double)Main.maxTilesX / 4200.0;
		int num30 = genRand.Next((int)(num * 10.0), (int)(num * 16.0));
		if (drunkWorldGen)
		{
			num30 *= 3;
		}
		else if (getGoodWorldGen)
		{
			num30 *= 3;
		}
		else if (remixWorldGen)
		{
			num30 *= 2;
		}
		int num41 = 1;
		if (genRand.Next(2) == 0)
		{
			num41 = -1;
		}
		int num52 = num41;
		int num63 = x;
		int num74 = y;
		int num85 = x;
		int num96 = y;
		int num107 = genRand.Next(1, 3);
		int num2 = 0;
		Rectangle rectangle = default(Rectangle);
		for (int i = 0; i < num30; i++)
		{
			num2++;
			int num13 = num41;
			int num22 = num85;
			int num23 = num96;
			bool flag = true;
			int num24 = 0;
			int num25 = 0;
			int num26 = -10;
			((Rectangle)(ref rectangle))._002Ector(num22 - num24 / 2, num23 - num25 / 2, num24, num25);
			while (flag)
			{
				num22 = num85;
				num23 = num96;
				num24 = genRand.Next(25, 50);
				num25 = genRand.Next(20, 35);
				if (num25 > num24)
				{
					num25 = num24;
				}
				if (i == num30 - 1)
				{
					num24 = genRand.Next(55, 65);
					num25 = genRand.Next(45, 50);
					if (num25 > num24)
					{
						num25 = num24;
					}
					num24 = (int)((double)num24 * 1.6);
					num25 = (int)((double)num25 * 1.35);
					num23 += genRand.Next(5, 10);
				}
				if (num2 > num107)
				{
					num23 += genRand.Next(num25 + 1, num25 + 3) + num26;
					num22 += genRand.Next(-5, 6);
					num13 = num41 * -1;
				}
				else
				{
					num22 += (genRand.Next(num24 + 1, num24 + 3) + num26) * num13;
					num23 += genRand.Next(-5, 6);
				}
				flag = false;
				((Rectangle)(ref rectangle))._002Ector(num22 - num24 / 2, num23 - num25 / 2, num24, num25);
				for (int j = 0; j < i; j++)
				{
					if (((Rectangle)(ref rectangle)).Intersects(array[j]))
					{
						flag = true;
					}
					if (genRand.Next(100) == 0)
					{
						num26++;
					}
				}
			}
			if (num2 > num107)
			{
				num107++;
				num2 = 1;
			}
			array[i] = rectangle;
			num41 = num13;
			num85 = num22;
			num96 = num23;
		}
		for (int k = 0; k < num30; k++)
		{
			for (int l = 0; l < 2; l++)
			{
				for (int m = 0; m < num30; m++)
				{
					for (int n = 0; n < 2; n++)
					{
						int num27 = array[k].X;
						if (l == 1)
						{
							num27 += array[k].Width - 1;
						}
						int num28 = array[k].Y;
						int num29 = num28 + array[k].Height;
						int num31 = array[m].X;
						if (n == 1)
						{
							num31 += array[m].Width - 1;
						}
						int y2 = array[m].Y;
						int num32 = y2 + array[m].Height;
						while (num27 != num31 || num28 != y2 || num29 != num32)
						{
							if (num27 < num31)
							{
								num27++;
							}
							if (num27 > num31)
							{
								num27--;
							}
							if (num28 < y2)
							{
								num28++;
							}
							if (num28 > y2)
							{
								num28--;
							}
							if (num29 < num32)
							{
								num29++;
							}
							if (num29 > num32)
							{
								num29--;
							}
							int num33 = num27;
							for (int num34 = num28; num34 < num29; num34++)
							{
								Main.tile[num33, num34].active(active: true);
								Main.tile[num33, num34].type = 226;
								Main.tile[num33, num34].liquid = 0;
								Main.tile[num33, num34].slope(0);
								Main.tile[num33, num34].halfBrick(halfBrick: false);
							}
						}
					}
				}
			}
		}
		for (int num35 = 0; num35 < num30; num35++)
		{
			for (int num36 = array[num35].X; num36 < array[num35].X + array[num35].Width; num36++)
			{
				for (int num37 = array[num35].Y; num37 < array[num35].Y + array[num35].Height; num37++)
				{
					Main.tile[num36, num37].active(active: true);
					Main.tile[num36, num37].type = 226;
					Main.tile[num36, num37].liquid = 0;
					Main.tile[num36, num37].slope(0);
					Main.tile[num36, num37].halfBrick(halfBrick: false);
				}
			}
			int x2 = array[num35].X;
			int num38 = x2 + array[num35].Width;
			int y3 = array[num35].Y;
			int num39 = y3 + array[num35].Height;
			x2 += genRand.Next(3, 8);
			num38 -= genRand.Next(3, 8);
			y3 += genRand.Next(3, 8);
			num39 -= genRand.Next(3, 8);
			int num40 = x2;
			int num42 = num38;
			int num43 = y3;
			int num44 = num39;
			int num45 = (x2 + num38) / 2;
			int num46 = (y3 + num39) / 2;
			for (int num47 = x2; num47 < num38; num47++)
			{
				for (int num48 = y3; num48 < num39; num48++)
				{
					if (genRand.Next(20) == 0)
					{
						num43 += genRand.Next(-1, 2);
					}
					if (genRand.Next(20) == 0)
					{
						num44 += genRand.Next(-1, 2);
					}
					if (genRand.Next(20) == 0)
					{
						num40 += genRand.Next(-1, 2);
					}
					if (genRand.Next(20) == 0)
					{
						num42 += genRand.Next(-1, 2);
					}
					if (num40 < x2)
					{
						num40 = x2;
					}
					if (num42 > num38)
					{
						num42 = num38;
					}
					if (num43 < y3)
					{
						num43 = y3;
					}
					if (num44 > num39)
					{
						num44 = num39;
					}
					if (num40 > num45)
					{
						num40 = num45;
					}
					if (num42 < num45)
					{
						num42 = num45;
					}
					if (num43 > num46)
					{
						num43 = num46;
					}
					if (num44 < num46)
					{
						num44 = num46;
					}
					if (num47 >= num40 && num47 < num42 && num48 >= num43 && num48 <= num44)
					{
						Main.tile[num47, num48].active(active: false);
						Main.tile[num47, num48].wall = 87;
					}
				}
			}
			for (int num49 = num39; num49 > y3; num49--)
			{
				for (int num50 = num38; num50 > x2; num50--)
				{
					if (genRand.Next(20) == 0)
					{
						num43 += genRand.Next(-1, 2);
					}
					if (genRand.Next(20) == 0)
					{
						num44 += genRand.Next(-1, 2);
					}
					if (genRand.Next(20) == 0)
					{
						num40 += genRand.Next(-1, 2);
					}
					if (genRand.Next(20) == 0)
					{
						num42 += genRand.Next(-1, 2);
					}
					if (num40 < x2)
					{
						num40 = x2;
					}
					if (num42 > num38)
					{
						num42 = num38;
					}
					if (num43 < y3)
					{
						num43 = y3;
					}
					if (num44 > num39)
					{
						num44 = num39;
					}
					if (num40 > num45)
					{
						num40 = num45;
					}
					if (num42 < num45)
					{
						num42 = num45;
					}
					if (num43 > num46)
					{
						num43 = num46;
					}
					if (num44 < num46)
					{
						num44 = num46;
					}
					if (num50 >= num40 && num50 < num42 && num49 >= num43 && num49 <= num44)
					{
						Main.tile[num50, num49].active(active: false);
						Main.tile[num50, num49].wall = 87;
					}
				}
			}
		}
		Vector2D templePath = new Vector2D(num63, num74);
		for (int num51 = 0; num51 < num30; num51++)
		{
			Rectangle rectangle2 = array[num51];
			rectangle2.X += 8;
			rectangle2.Y += 8;
			rectangle2.Width -= 16;
			rectangle2.Height -= 16;
			bool flag2 = true;
			while (flag2)
			{
				int num53 = genRand.Next(rectangle2.X, rectangle2.X + rectangle2.Width);
				int num54 = genRand.Next(rectangle2.Y, rectangle2.Y + rectangle2.Height);
				if (num51 == num30 - 1)
				{
					num53 = rectangle2.X + rectangle2.Width / 2 + genRand.Next(-10, 10);
					num54 = rectangle2.Y + rectangle2.Height / 2 + genRand.Next(-10, 10);
				}
				templePath = templePather(templePath, num53, num54);
				if (templePath.X == (double)num53 && templePath.Y == (double)num54)
				{
					flag2 = false;
				}
			}
			if (num51 >= num30 - 1)
			{
				continue;
			}
			if (genRand.Next(3) != 0)
			{
				int num55 = num51 + 1;
				if (array[num55].Y >= array[num51].Y + array[num51].Height)
				{
					rectangle2.X = array[num55].X;
					if (num51 == 0)
					{
						if (num41 > 0)
						{
							rectangle2.X += (int)((double)array[num55].Width * 0.8);
						}
						else
						{
							rectangle2.X += (int)((double)array[num55].Width * 0.2);
						}
					}
					else if (array[num55].X < array[num51].X)
					{
						rectangle2.X += (int)((double)array[num55].Width * 0.2);
					}
					else
					{
						rectangle2.X += (int)((double)array[num55].Width * 0.8);
					}
					rectangle2.Y = array[num55].Y;
				}
				else
				{
					rectangle2.X = (array[num51].X + array[num51].Width / 2 + array[num55].X + array[num55].Width / 2) / 2;
					rectangle2.Y = (int)((double)array[num55].Y + (double)array[num55].Height * 0.8);
				}
				int x3 = rectangle2.X;
				int y4 = rectangle2.Y;
				flag2 = true;
				while (flag2)
				{
					int num56 = genRand.Next(x3 - 6, x3 + 7);
					int num57 = genRand.Next(y4 - 6, y4 + 7);
					templePath = templePather(templePath, num56, num57);
					if (templePath.X == (double)num56 && templePath.Y == (double)num57)
					{
						flag2 = false;
					}
				}
				continue;
			}
			int num58 = num51 + 1;
			int num59 = (array[num51].X + array[num51].Width / 2 + array[num58].X + array[num58].Width / 2) / 2;
			int num60 = (array[num51].Y + array[num51].Height / 2 + array[num58].Y + array[num58].Height / 2) / 2;
			flag2 = true;
			while (flag2)
			{
				int num61 = genRand.Next(num59 - 6, num59 + 7);
				int num62 = genRand.Next(num60 - 6, num60 + 7);
				templePath = templePather(templePath, num61, num62);
				if (templePath.X == (double)num61 && templePath.Y == (double)num62)
				{
					flag2 = false;
				}
			}
		}
		int num64 = Main.maxTilesX - 20;
		int num65 = 20;
		int num66 = Main.maxTilesY - 20;
		int num67 = 20;
		for (int num68 = 0; num68 < num30; num68++)
		{
			if (array[num68].X < num64)
			{
				num64 = array[num68].X;
			}
			if (array[num68].X + array[num68].Width > num65)
			{
				num65 = array[num68].X + array[num68].Width;
			}
			if (array[num68].Y < num66)
			{
				num66 = array[num68].Y;
			}
			if (array[num68].Y + array[num68].Height > num67)
			{
				num67 = array[num68].Y + array[num68].Height;
			}
		}
		num64 -= 10;
		num65 += 10;
		num66 -= 10;
		num67 += 10;
		for (int num69 = num64; num69 < num65; num69++)
		{
			for (int num70 = num66; num70 < num67; num70++)
			{
				outerTempled(num69, num70);
			}
		}
		for (int num71 = num65; num71 >= num64; num71--)
		{
			for (int num72 = num66; num72 < num67 / 2; num72++)
			{
				outerTempled(num71, num72);
			}
		}
		for (int num73 = num66; num73 < num67; num73++)
		{
			for (int num75 = num64; num75 < num65; num75++)
			{
				outerTempled(num75, num73);
			}
		}
		for (int num76 = num67; num76 >= num66; num76--)
		{
			for (int num77 = num64; num77 < num65; num77++)
			{
				outerTempled(num77, num76);
			}
		}
		int num78 = num74;
		num41 = -num52;
		Vector2D vector2D = new Vector2D(num63, num74);
		int num79 = genRand.Next(2, 5);
		bool flag3 = true;
		int num80 = 0;
		int num81 = genRand.Next(9, 14);
		while (flag3)
		{
			num80++;
			if (num80 >= num81)
			{
				num80 = 0;
				vector2D.Y -= 1.0;
			}
			vector2D.X += num41;
			int num82 = (int)vector2D.X;
			flag3 = false;
			for (int num83 = (int)vector2D.Y - num79; (double)num83 < vector2D.Y + (double)num79; num83++)
			{
				if (Main.tile[num82, num83].wall == 87 || (Main.tile[num82, num83].active() && Main.tile[num82, num83].type == 226))
				{
					flag3 = true;
				}
				if (Main.tile[num82, num83].active() && Main.tile[num82, num83].type == 226)
				{
					if (num83 > num78)
					{
						num78 = num83;
					}
					Main.tile[num82, num83].active(active: false);
					Main.tile[num82, num83].wall = 87;
				}
			}
		}
		num78 += 2;
		int num84 = num63;
		int num86 = num74;
		while (!Main.tile[num84, num86].active())
		{
			num86++;
			if (num86 >= num78)
			{
				num86 = num78;
				Main.tile[num84, num86].ClearEverything();
				Main.tile[num84, num86].active(active: true);
				Main.tile[num84, num86].type = 226;
				break;
			}
		}
		num86 -= 4;
		int num87 = num86;
		while ((Main.tile[num84, num87].active() && Main.tile[num84, num87].type == 226) || Main.tile[num84, num87].wall == 87)
		{
			num87--;
		}
		num87 += 2;
		for (int num88 = num84 - 1; num88 <= num84 + 1; num88++)
		{
			for (int num89 = num87; num89 <= num86; num89++)
			{
				Main.tile[num88, num89].active(active: true);
				Main.tile[num88, num89].type = 226;
				Main.tile[num88, num89].liquid = 0;
				Main.tile[num88, num89].slope(0);
				Main.tile[num88, num89].halfBrick(halfBrick: false);
			}
		}
		for (int num90 = num84 - 4; num90 <= num84 + 4; num90++)
		{
			for (int num91 = num86 - 1; num91 < num86 + 3; num91++)
			{
				Main.tile[num90, num91].active(active: false);
				Main.tile[num90, num91].wall = 87;
			}
		}
		for (int num92 = num84 - 1; num92 <= num84 + 1; num92++)
		{
			for (int num93 = num86 - 5; num93 <= num86 + 8; num93++)
			{
				Main.tile[num92, num93].active(active: true);
				Main.tile[num92, num93].type = 226;
				Main.tile[num92, num93].liquid = 0;
				Main.tile[num92, num93].slope(0);
				Main.tile[num92, num93].halfBrick(halfBrick: false);
			}
		}
		for (int num94 = num84 - 3; num94 <= num84 + 3; num94++)
		{
			for (int num95 = num86 - 2; num95 < num86 + 3; num95++)
			{
				if (num95 >= num86 || num94 < num63 - 1 || num94 > num63 + 1)
				{
					Main.tile[num94, num95].active(active: false);
					Main.tile[num94, num95].wall = 87;
				}
			}
		}
		PlaceTile(num84, num86, 10, mute: true, forced: false, -1, 11);
		for (int num97 = num64; num97 < num65; num97++)
		{
			for (int num98 = num66; num98 < num67; num98++)
			{
				templeCleaner(num97, num98);
			}
		}
		for (int num99 = num67; num99 >= num66; num99--)
		{
			for (int num100 = num65; num100 >= num64; num100--)
			{
				templeCleaner(num100, num99);
			}
		}
		for (int num101 = num64; num101 < num65; num101++)
		{
			for (int num102 = num66; num102 < num67; num102++)
			{
				bool flag4 = true;
				for (int num103 = num101 - 1; num103 <= num101 + 1; num103++)
				{
					for (int num104 = num102 - 1; num104 <= num102 + 1; num104++)
					{
						if ((!Main.tile[num103, num104].active() || Main.tile[num103, num104].type != 226) && Main.tile[num103, num104].wall != 87)
						{
							flag4 = false;
							break;
						}
					}
				}
				if (flag4)
				{
					Main.tile[num101, num102].wall = 87;
				}
			}
		}
		int num105 = 0;
		Rectangle rectangle3 = array[num30 - 1];
		int num106 = rectangle3.Width / 2;
		int num108 = rectangle3.Height / 2;
		while (true)
		{
			num105++;
			int num109 = rectangle3.X + num106 + 15 - genRand.Next(30);
			int num110 = rectangle3.Y + num108 + 15 - genRand.Next(30);
			PlaceTile(num109, num110, 237);
			if (Main.tile[num109, num110].type == 237)
			{
				GenVars.lAltarX = num109 - Main.tile[num109, num110].frameX / 18;
				GenVars.lAltarY = num110 - Main.tile[num109, num110].frameY / 18;
				break;
			}
			if (num105 < 1000)
			{
				continue;
			}
			num109 = rectangle3.X + num106;
			num110 = rectangle3.Y + num108;
			num109 += genRand.Next(-10, 11);
			for (num110 += genRand.Next(-10, 11); !Main.tile[num109, num110].active(); num110++)
			{
			}
			Main.tile[num109 - 1, num110].active(active: true);
			Main.tile[num109 - 1, num110].slope(0);
			Main.tile[num109 - 1, num110].halfBrick(halfBrick: false);
			Main.tile[num109 - 1, num110].type = 226;
			Main.tile[num109, num110].active(active: true);
			Main.tile[num109, num110].slope(0);
			Main.tile[num109, num110].halfBrick(halfBrick: false);
			Main.tile[num109, num110].type = 226;
			Main.tile[num109 + 1, num110].active(active: true);
			Main.tile[num109 + 1, num110].slope(0);
			Main.tile[num109 + 1, num110].halfBrick(halfBrick: false);
			Main.tile[num109 + 1, num110].type = 226;
			num110 -= 2;
			num109--;
			for (int num111 = -1; num111 <= 3; num111++)
			{
				for (int num112 = -1; num112 <= 1; num112++)
				{
					x = num109 + num111;
					y = num110 + num112;
					Main.tile[x, y].active(active: false);
				}
			}
			GenVars.lAltarX = num109;
			GenVars.lAltarY = num110;
			for (int num113 = 0; num113 <= 2; num113++)
			{
				for (int num114 = 0; num114 <= 1; num114++)
				{
					x = num109 + num113;
					y = num110 + num114;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].type = 237;
					Main.tile[x, y].frameX = (short)(num113 * 18);
					Main.tile[x, y].frameY = (short)(num114 * 18);
				}
			}
			for (int num115 = 0; num115 <= 2; num115++)
			{
				for (int num116 = 0; num116 <= 1; num116++)
				{
					x = num109 + num115;
					y = num110 + num116;
					SquareTileFrame(x, y);
				}
			}
			break;
		}
		double num117 = (double)num30 * 1.1;
		num117 *= 1.0 + (double)genRand.Next(-25, 26) * 0.01;
		if (drunkWorldGen)
		{
			num117 *= 1.5;
		}
		int num3 = 0;
		while (num117 > 0.0)
		{
			num3++;
			int num4 = genRand.Next(num30);
			int num5 = genRand.Next(array[num4].X, array[num4].X + array[num4].Width);
			int num6 = genRand.Next(array[num4].Y, array[num4].Y + array[num4].Height);
			if (Main.tile[num5, num6].wall == 87 && !Main.tile[num5, num6].active())
			{
				bool flag5 = false;
				if (genRand.Next(2) == 0)
				{
					int num7 = 1;
					if (genRand.Next(2) == 0)
					{
						num7 = -1;
					}
					for (; !Main.tile[num5, num6].active(); num6 += num7)
					{
					}
					num6 -= num7;
					int num8 = genRand.Next(2);
					int num9 = genRand.Next(3, 10);
					bool flag6 = true;
					for (int num10 = num5 - num9; num10 < num5 + num9; num10++)
					{
						for (int num11 = num6 - num9; num11 < num6 + num9; num11++)
						{
							if (Main.tile[num10, num11].active() && (Main.tile[num10, num11].type == 10 || Main.tile[num10, num11].type == 237))
							{
								flag6 = false;
								break;
							}
						}
					}
					if (flag6)
					{
						for (int num12 = num5 - num9; num12 < num5 + num9; num12++)
						{
							for (int num14 = num6 - num9; num14 < num6 + num9; num14++)
							{
								if (!SolidTile(num12, num14) || Main.tile[num12, num14].type == 232 || SolidTile(num12, num14 - num7))
								{
									continue;
								}
								Main.tile[num12, num14].type = 232;
								flag5 = true;
								if (num8 == 0)
								{
									Main.tile[num12, num14 - 1].type = 232;
									Main.tile[num12, num14 - 1].active(active: true);
									if (drunkWorldGen)
									{
										Main.tile[num12, num14 - 2].type = 232;
										Main.tile[num12, num14 - 2].active(active: true);
									}
								}
								else
								{
									Main.tile[num12, num14 + 1].type = 232;
									Main.tile[num12, num14 + 1].active(active: true);
									if (drunkWorldGen)
									{
										Main.tile[num12, num14 + 2].type = 232;
										Main.tile[num12, num14 + 2].active(active: true);
									}
								}
								num8++;
								if (num8 > 1)
								{
									num8 = 0;
								}
							}
						}
					}
					if (flag5)
					{
						num3 = 0;
						num117 -= 1.0;
					}
				}
				else
				{
					int num15 = 1;
					if (genRand.Next(2) == 0)
					{
						num15 = -1;
					}
					for (; !Main.tile[num5, num6].active(); num5 += num15)
					{
					}
					num5 -= num15;
					int num16 = genRand.Next(2);
					int num17 = genRand.Next(3, 10);
					bool flag7 = true;
					for (int num18 = num5 - num17; num18 < num5 + num17; num18++)
					{
						for (int num19 = num6 - num17; num19 < num6 + num17; num19++)
						{
							if (Main.tile[num18, num19].active() && Main.tile[num18, num19].type == 10)
							{
								flag7 = false;
								break;
							}
						}
					}
					if (flag7)
					{
						for (int num20 = num5 - num17; num20 < num5 + num17; num20++)
						{
							for (int num21 = num6 - num17; num21 < num6 + num17; num21++)
							{
								if (!SolidTile(num20, num21) || Main.tile[num20, num21].type == 232 || SolidTile(num20 - num15, num21))
								{
									continue;
								}
								Main.tile[num20, num21].type = 232;
								flag5 = true;
								if (num16 == 0)
								{
									Main.tile[num20 - 1, num21].type = 232;
									Main.tile[num20 - 1, num21].active(active: true);
									if (drunkWorldGen)
									{
										Main.tile[num20 - 2, num21].type = 232;
										Main.tile[num20 - 2, num21].active(active: true);
									}
								}
								else
								{
									Main.tile[num20 + 1, num21].type = 232;
									Main.tile[num20 + 1, num21].active(active: true);
									if (drunkWorldGen)
									{
										Main.tile[num20 - 2, num21].type = 232;
										Main.tile[num20 - 2, num21].active(active: true);
									}
								}
								num16++;
								if (num16 > 1)
								{
									num16 = 0;
								}
							}
						}
					}
					if (flag5)
					{
						num3 = 0;
						num117 -= 1.0;
					}
				}
			}
			if (num3 > 1000)
			{
				num3 = 0;
				num117 -= 1.0;
			}
		}
		GenVars.tLeft = num64;
		GenVars.tRight = num65;
		GenVars.tTop = num66;
		GenVars.tBottom = num67;
		GenVars.tRooms = num30;
	}

	public static void templePart2()
	{
		int tLeft = GenVars.tLeft;
		int tRight = GenVars.tRight;
		int tTop = GenVars.tTop;
		int tBottom = GenVars.tBottom;
		int tRooms = GenVars.tRooms;
		double num = (double)tRooms * 1.9;
		num *= 1.0 + (double)genRand.Next(-15, 16) * 0.01;
		int num12 = 0;
		while (num > 0.0)
		{
			int num16 = genRand.Next(tLeft, tRight);
			int num17 = genRand.Next(tTop, tBottom);
			if (Main.tile[num16, num17].wall == 87 && !Main.tile[num16, num17].active())
			{
				if (mayanTrap(num16, num17))
				{
					num -= 1.0;
					num12 = 0;
				}
				else
				{
					num12++;
				}
			}
			else
			{
				num12++;
			}
			if (num12 > 100)
			{
				num12 = 0;
				num -= 1.0;
			}
		}
		Main.tileSolid[232] = false;
		double num18 = (double)tRooms * 0.35;
		num18 *= 1.0 + (double)genRand.Next(-15, 16) * 0.01;
		int contain = 1293;
		num12 = 0;
		while (num18 > 0.0)
		{
			int num19 = genRand.Next(tLeft, tRight);
			int num20 = genRand.Next(tTop, tBottom);
			if (Main.tile[num19, num20].wall == 87 && !Main.tile[num19, num20].active() && AddBuriedChest(num19, num20, contain, notNearOtherChests: true, 16, trySlope: false, 0))
			{
				num18 -= 1.0;
				num12 = 0;
			}
			num12++;
			if (num12 > 10000)
			{
				break;
			}
		}
		double num21 = (double)tRooms * 1.25;
		num21 *= 1.0 + (double)genRand.Next(-25, 36) * 0.01;
		num12 = 0;
		while (num21 > 0.0)
		{
			num12++;
			int num22 = genRand.Next(tLeft, tRight);
			int num2 = genRand.Next(tTop, tBottom);
			if (Main.tile[num22, num2].wall != 87 || Main.tile[num22, num2].active())
			{
				continue;
			}
			int num3 = num22;
			int num4 = num2;
			while (!Main.tile[num3, num4].active())
			{
				num4++;
				if (num4 > tBottom)
				{
					break;
				}
			}
			num4--;
			if (num4 <= tBottom)
			{
				PlaceTile(num3, num4, 105, mute: true, forced: false, -1, genRand.Next(43, 46));
				if (Main.tile[num3, num4].type == 105)
				{
					num21 -= 1.0;
				}
			}
		}
		double num5 = (double)tRooms * 1.35;
		num5 *= 1.0 + (double)genRand.Next(-15, 26) * 0.01;
		num12 = 0;
		while (num5 > 0.0)
		{
			num12++;
			int num6 = genRand.Next(tLeft, tRight);
			int num7 = genRand.Next(tTop, tBottom);
			if (Main.tile[num6, num7].wall == 87 && !Main.tile[num6, num7].active())
			{
				int num8 = num6;
				int num9 = num7;
				while (!Main.tile[num8, num9].active())
				{
					num9++;
					if (num9 > tBottom)
					{
						break;
					}
				}
				num9--;
				if (num9 <= tBottom)
				{
					switch (genRand.Next(3))
					{
					case 0:
						PlaceTile(num8, num9, 18, mute: true, forced: false, -1, 10);
						if (Main.tile[num8, num9].type == 18)
						{
							num5 -= 1.0;
						}
						break;
					case 1:
						PlaceTile(num8, num9, 14, mute: true, forced: false, -1, 9);
						if (Main.tile[num8, num9].type == 14)
						{
							num5 -= 1.0;
						}
						break;
					case 2:
						PlaceTile(num8, num9, 15, mute: true, forced: false, -1, 12);
						if (Main.tile[num8, num9].type == 15)
						{
							num5 -= 1.0;
						}
						break;
					}
				}
			}
			if (num12 > 10000)
			{
				break;
			}
		}
		int num10 = 1;
		if (Main.maxTilesX > 4200)
		{
			num10++;
		}
		if (Main.maxTilesX > 6400)
		{
			num10 += genRand.Next(2);
		}
		num12 = 0;
		while (num10 > 0)
		{
			num12++;
			int num11 = genRand.Next(tLeft, tRight);
			int num13 = genRand.Next(tTop, tBottom);
			if (Main.tile[num11, num13].wall == 87 && !Main.tile[num11, num13].active())
			{
				bool flag = false;
				for (int i = -70; i <= 70; i++)
				{
					for (int j = -70; j <= 70; j++)
					{
						int num14 = i + num11;
						int num15 = j + num13;
						if (!InWorld(num14, num15, 5))
						{
							continue;
						}
						Tile tile = Main.tile[num14, num15];
						if (tile.active())
						{
							if (tile.type == 240)
							{
								flag = true;
								break;
							}
							if (i >= -4 && i <= 4 && j >= -4 && j <= 4 && tile.type == 226)
							{
								flag = true;
								break;
							}
						}
					}
					if (flag)
					{
						break;
					}
				}
				if (flag)
				{
					continue;
				}
				if (PlaceTile(num11, num13, 240, mute: true, forced: false, -1, 88))
				{
					num10--;
				}
			}
			if (num12 > 10000)
			{
				break;
			}
		}
		Main.tileSolid[232] = true;
	}

	public static bool nearPicture(int x, int y)
	{
		for (int i = x - 4; i <= x + 3; i++)
		{
			for (int j = y - 3; j <= y + 2; j++)
			{
				if (Main.tile[i, j].active())
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool nearPicture2(int x, int y)
	{
		if (Main.tile[x, y].wall != 7 && Main.tile[x, y].wall != 8 && Main.tile[x, y].wall != 9)
		{
			for (int i = x - 8; i <= x + 8; i++)
			{
				for (int j = y - 5; j <= y + 5; j++)
				{
					if (Main.tile[i, j].active() && (Main.tile[i, j].type == 240 || Main.tile[i, j].type == 241 || Main.tile[i, j].type == 242))
					{
						return true;
					}
				}
			}
		}
		else
		{
			for (int k = x - 15; k <= x + 15; k++)
			{
				for (int l = y - 10; l <= y + 10; l++)
				{
					if (Main.tile[k, l].active() && (Main.tile[k, l].type == 240 || Main.tile[k, l].type == 241 || Main.tile[k, l].type == 242))
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	private static void ShimmerCleanUp()
	{
		ShimmerRemoveWater();
		int num = 120;
		int num3 = 90;
		int num4 = (int)GenVars.shimmerPosition.X - num;
		int num5 = (int)GenVars.shimmerPosition.X + num;
		int num9 = (int)GenVars.shimmerPosition.Y - num;
		int num6 = (int)GenVars.shimmerPosition.Y + num;
		_ = num / 4;
		for (int i = num9; i <= num6; i++)
		{
			for (int j = num4; j <= num5; j++)
			{
				if ((int)Math.Sqrt(Math.Pow(Math.Abs((double)j - GenVars.shimmerPosition.X), 2.0) + Math.Pow(Math.Abs((double)i - GenVars.shimmerPosition.Y), 2.0)) < num)
				{
					if (Main.tile[j, i].type == 22 || Main.tile[j, i].type == 204)
					{
						Main.tile[j, i].type = 1;
					}
					if (Main.tile[j, i].type == 51 || Main.tile[j, i].type == 56 || Main.tile[j, i].type == 229 || Main.tile[j, i].type == 230 || Main.tile[j, i].type == 659)
					{
						Main.tile[j, i].active(active: false);
					}
					if (TileID.Sets.Conversion.Moss[Main.tile[j, i].type])
					{
						Main.tile[j, i].type = 1;
					}
					if (Main.tile[j, i].type == 184)
					{
						Main.tile[j, i].active(active: false);
					}
				}
				if (((!((double)i > GenVars.shimmerPosition.Y)) ? ((int)Math.Sqrt(Math.Pow(Math.Abs((double)j - GenVars.shimmerPosition.X) * (1.0 + genRand.NextDouble() * 0.02), 2.0) + Math.Pow(Math.Abs((double)i - GenVars.shimmerPosition.Y) * 1.4 * (1.0 + genRand.NextDouble() * 0.02), 2.0))) : ((int)Math.Sqrt(Math.Pow(Math.Abs((double)j - GenVars.shimmerPosition.X) * (1.0 + genRand.NextDouble() * 0.02), 2.0) + Math.Pow(Math.Abs((double)i - GenVars.shimmerPosition.Y) * 1.2 * (1.0 + genRand.NextDouble() * 0.02), 2.0)))) < num3)
				{
					Convert(j, i, 0, 3);
				}
			}
		}
		int num7 = (int)GenVars.shimmerPosition.X;
		int num8 = (int)GenVars.shimmerPosition.Y;
		byte b = 127;
		Liquid.tilesIgnoreWater(ignoreSolids: true);
		while (Main.tile[num7, num8].liquid <= b || !Main.tile[num7, num8].shimmer())
		{
			while (!Main.tile[num7, num8].active())
			{
				Main.tile[num7, num8].liquid = b;
				Main.tile[num7, num8].shimmer(shimmer: true);
				num7--;
			}
			for (num7 = (int)GenVars.shimmerPosition.X; !Main.tile[num7, num8].active(); num7++)
			{
				Main.tile[num7, num8].liquid = b;
				Main.tile[num7, num8].shimmer(shimmer: true);
			}
			num7 = (int)GenVars.shimmerPosition.X;
			num8++;
			b = byte.MaxValue;
			if (Main.tile[num7, num8].active())
			{
				break;
			}
		}
		if (tenthAnniversaryWorldGen)
		{
			int num2 = 170;
			for (int k = (int)GenVars.shimmerPosition.X - num2; (double)k <= GenVars.shimmerPosition.X + (double)num2; k++)
			{
				for (int l = (int)GenVars.shimmerPosition.Y + 40; l < Main.maxTilesY - 330 - 100; l++)
				{
					if (InWorld(k, l))
					{
						if (Main.tile[k, l].type == 375 || Main.tile[k, l].type == 374 || Main.tile[k, l].type == 373)
						{
							Main.tile[k, l].active(active: false);
						}
						if (Main.tile[k, l].liquid > 0 && !Main.tile[k, l].shimmer())
						{
							Shimmerator(k, l);
						}
					}
				}
			}
		}
		Liquid.tilesIgnoreWater(ignoreSolids: false);
		for (int m = 10; m < Main.maxTilesX - 10; m++)
		{
			for (int n = 10; n < Main.maxTilesY - 10; n++)
			{
				if (Main.tile[m, n].liquid > 0 && Main.tile[m, n].shimmer() && Main.tile[m, n].type == 5)
				{
					KillTile(m, n);
				}
			}
		}
	}

	public static void ShimmerRemoveWater()
	{
		if (!generatingWorld)
		{
			return;
		}
		int num = 150;
		int num2 = (int)GenVars.shimmerPosition.X - num;
		int num3 = (int)GenVars.shimmerPosition.X + num;
		int num5 = (int)GenVars.shimmerPosition.Y - num;
		int num4 = (int)GenVars.shimmerPosition.Y + num / 2;
		for (int i = num5; i <= num4; i++)
		{
			for (int j = num2; j <= num3; j++)
			{
				if (InWorld(j, i) && (int)Math.Sqrt(Math.Pow(Math.Abs(j - (int)GenVars.shimmerPosition.X), 2.0) + Math.Pow(Math.Abs(i - (int)GenVars.shimmerPosition.Y), 2.0)) < num && !Main.tile[j, i].shimmer())
				{
					Main.tile[j, i].liquid = 0;
				}
			}
		}
	}

	public static bool ShimmerMakeBiome(int X, int Y)
	{
		int num = genRand.Next(2);
		double num12 = 0.6;
		double num18 = 1.3;
		double num19 = 0.3;
		if (num == 0)
		{
			num12 = 0.55;
			num18 = 2.0;
		}
		num12 *= 1.05 - genRand.NextDouble() * 0.1;
		num18 *= 1.05 - genRand.NextDouble() * 0.1;
		num19 *= 1.0 - genRand.NextDouble() * 0.1;
		int num20 = genRand.Next(105, 125);
		int num21 = (int)((double)num20 * num19);
		int num22 = (int)((double)num20 * num12);
		int num23 = genRand.Next(9, 13);
		int num24 = X - num20;
		int num2 = X + num20;
		int num3 = Y - num20;
		int num4 = Y + num20;
		for (int i = num3; i <= num4; i++)
		{
			for (int j = num24; j <= num2; j++)
			{
				if (!InWorld(j, i, 50))
				{
					return false;
				}
				if (Main.tile[j, i].type == 203 || Main.tile[j, i].type == 25)
				{
					return false;
				}
			}
		}
		int num5 = Y;
		if (genRand.Next(4) == 0)
		{
			num5 = Y - genRand.Next(2);
		}
		int num6 = Y - num23;
		if (genRand.Next(4) == 0)
		{
			num6 = Y - num23 - genRand.Next(2);
		}
		for (int k = num3; k <= num4; k++)
		{
			for (int l = num24; l <= num2; l++)
			{
				Main.tile[l, k].liquid = 0;
				if (genRand.Next(4) == 0)
				{
					num5 = Y - genRand.Next(2);
				}
				if (genRand.Next(4) == 0)
				{
					num6 = Y - num23 + genRand.Next(2);
				}
				int num7 = ((k <= Y) ? ((int)Math.Sqrt(Math.Pow((double)Math.Abs(l - X) * (1.0 + genRand.NextDouble() * 0.02), 2.0) + Math.Pow((double)Math.Abs(k - Y) * 1.4 * (1.0 + genRand.NextDouble() * 0.02), 2.0))) : ((int)Math.Sqrt(Math.Pow((double)Math.Abs(l - X) * (1.0 + genRand.NextDouble() * 0.02), 2.0) + Math.Pow((double)Math.Abs(k - Y) * 1.2 * (1.0 + genRand.NextDouble() * 0.02), 2.0))));
				if (num7 < num20)
				{
					Main.tile[l, k].color(0);
					Main.tile[l, k].wallColor(0);
					Main.tile[l, k].slope(0);
					Main.tile[l, k].halfBrick(halfBrick: false);
					Main.tile[l, k].type = 1;
					if (l > num24 + 5 + genRand.Next(2) && l < num2 - 5 - genRand.Next(2))
					{
						Main.tile[l, k].active(active: true);
					}
					if ((double)num7 < (double)num20 * 0.9)
					{
						Main.tile[l, k].wall = 0;
					}
				}
				num7 = (int)Math.Sqrt(Math.Pow((double)Math.Abs(l - X) * (1.0 + genRand.NextDouble() * 0.02), 2.0) + Math.Pow((double)Math.Abs(k - Y) * num18 * (1.0 + genRand.NextDouble() * 0.02), 2.0));
				if (k > num6 && k < num5)
				{
					Main.tile[l, k].active(active: false);
				}
				if (k < num5 && num7 < (int)((double)num22 * (1.0 + genRand.NextDouble() * 0.02)))
				{
					Main.tile[l, k].active(active: false);
				}
				num7 = (int)Math.Sqrt(Math.Pow((double)Math.Abs(l - X) * (1.0 + genRand.NextDouble() * 0.02), 2.0) + Math.Pow((double)(Math.Abs(k - Y) * 2) * (1.0 + genRand.NextDouble() * 0.02), 2.0));
				if (k < Y - 1 || num7 >= (int)((double)num21 * (1.0 + genRand.NextDouble() * 0.025)))
				{
					continue;
				}
				if (k <= Y + 2 || num7 != num21 - 1 || genRand.Next(2) != 0)
				{
					Main.tile[l, k].active(active: false);
				}
				if (k >= Y)
				{
					if (k == Y)
					{
						Main.tile[l, k].liquid = 127;
					}
					else
					{
						Main.tile[l, k].liquid = byte.MaxValue;
					}
					Main.tile[l, k].shimmer(shimmer: true);
				}
			}
		}
		if (num == 0)
		{
			num24 = (int)((double)X - (double)num20 * num19) - genRand.Next(-15, 1) - 5;
			num2 = (int)((double)X + (double)num20 * num19) + genRand.Next(0, 16);
			int m = num24;
			int num8 = 0;
			for (; m < num2; m += genRand.Next(9, 14))
			{
				int num9 = Y - 3;
				while (!Main.tile[m, num9].active())
				{
					num9--;
				}
				num9 -= 4;
				int num10 = genRand.Next(5, 10);
				int num11 = genRand.Next(15, 21);
				int n = m - num10;
				while (num10 > 0)
				{
					for (n = m - num10; n < m + num10; n++)
					{
						Main.tile[n, num9].active(active: true);
						Main.tile[n, num9].type = 1;
					}
					num8++;
					if (genRand.Next(3) < num8)
					{
						num8 = 0;
						num10--;
						m += genRand.Next(-1, 2);
					}
					if (num11 <= 0)
					{
						num10--;
					}
					num11--;
					num9++;
				}
				n -= genRand.Next(1, 3);
				Main.tile[n, num9 - 2].active(active: true);
				Main.tile[n, num9 - 2].type = 1;
				Main.tile[n, num9 - 1].active(active: true);
				Main.tile[n, num9 - 1].type = 1;
				Main.tile[n, num9].active(active: true);
				Main.tile[n, num9].type = 1;
				if (genRand.Next(2) == 0)
				{
					Main.tile[n, num9 + 1].active(active: true);
					Main.tile[n, num9 + 1].type = 1;
					PlaceTight(n, num9 + 2);
				}
				else
				{
					PlaceTight(n, num9 + 1);
				}
			}
		}
		ShimmerMakeBiomeOpening(-1, X - num20, Y, num23);
		ShimmerMakeBiomeOpening(1, X + num20, Y, num23);
		int num13 = 70;
		for (int num14 = 0; num14 < 500; num14++)
		{
			int num15 = genRand.Next(X - num13, X + num13);
			int num16 = genRand.Next(Y - 2, Y + 3);
			int num17 = genRand.Next(7);
			int treeTileType = 0;
			switch (num17)
			{
			case 0:
				treeTileType = 583;
				break;
			case 1:
				treeTileType = 584;
				break;
			case 2:
				treeTileType = 585;
				break;
			case 3:
				treeTileType = 586;
				break;
			case 4:
				treeTileType = 587;
				break;
			case 5:
				treeTileType = 588;
				break;
			case 6:
				treeTileType = 589;
				break;
			}
			if (SolidTile(num15 - 1, num16) && SolidTile(num15 + 1, num16))
			{
				TryGrowingTreeByType(treeTileType, num15, num16);
			}
		}
		return true;
	}

	private static void ShimmerMakeBiomeOpening(int direction, int X, int Y, int caveOpenningSize)
	{
		int num = X;
		caveOpenningSize--;
		bool flag;
		do
		{
			num += direction;
			flag = true;
			for (int i = Y - caveOpenningSize + 1; i < Y - 1; i++)
			{
				if (SolidTile(num, i))
				{
					flag = false;
				}
				if (SolidTile(num + direction, i))
				{
					flag = false;
				}
				if (SolidTile(num + direction * 2, i))
				{
					flag = false;
				}
				Main.tile[num, i].active(active: false);
			}
			for (int j = Y - caveOpenningSize; j < Y; j++)
			{
				Main.tile[num - direction, j].active(active: false);
			}
			if (SolidTile(num - direction, Y - caveOpenningSize - 1))
			{
				Main.tile[num - direction, Y - caveOpenningSize - 1].wall = 0;
			}
			if (SolidTile(num - direction, Y))
			{
				Main.tile[num - direction, Y].wall = 0;
			}
			if (genRand.Next(2) == 0)
			{
				Y += genRand.Next(-1, 2);
			}
		}
		while (!flag && num >= 50 && num <= Main.maxTilesX - 50 && Math.Abs(num - X) <= 100);
	}

	private static void Shimminate()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		foreach (KeyValuePair<Point, bool> countedTile in CountedTiles)
		{
			Point key = countedTile.Key;
			Main.tile[key.X, key.Y].shimmer(shimmer: true);
			Main.tile[key.X, key.Y].liquid = byte.MaxValue;
			if (Main.tile[key.X, key.Y].type == 5 || Main.tile[key.X, key.Y].type == 56 || (Main.tileCut[Main.tile[key.X, key.Y].type] && Main.tile[key.X, key.Y].type != 28))
			{
				KillTile(key.X, key.Y);
			}
		}
	}

	public static void Shimmerator(int x, int y, bool jungle = false, bool lavaOk = false)
	{
		numTileCount = 0;
		CountedTiles.Clear();
		ShimmeratorNext(x, y);
		if (numTileCount > 0 && numTileCount < maxTileCount)
		{
			Shimminate();
		}
	}

	private static void ShimmeratorNext(int x, int y)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		if (numTileCount < maxTileCount)
		{
			if (x <= 1 || x >= Main.maxTilesX - 1 || y <= 1 || y >= Main.maxTilesY - 1)
			{
				numTileCount = maxTileCount;
			}
			else if (!CountedTiles.ContainsKey(new Point(x, y)) && ((!SolidTile(x, y) && !Main.tile[x, y].shimmer() && Main.tile[x, y].liquid > 0) || (Main.tile[x, y].active() && Main.tile[x, y].type == 56)))
			{
				CountedTiles.Add(new Point(x, y), value: true);
				numTileCount++;
				ShimmeratorNext(x - 1, y);
				ShimmeratorNext(x + 1, y);
				ShimmeratorNext(x, y - 1);
				ShimmeratorNext(x, y + 1);
			}
		}
	}

	public static void MakeDungeon(int x, int y)
	{
		GenVars.dEnteranceX = 0;
		GenVars.numDRooms = 0;
		GenVars.numDDoors = 0;
		GenVars.numDungeonPlatforms = 0;
		int num = genRand.Next(3);
		genRand.Next(3);
		if (remixWorldGen)
		{
			num = (crimson ? 2 : 0);
		}
		ushort num12;
		int num22;
		switch (num)
		{
		case 0:
			num12 = 41;
			num22 = 7;
			GenVars.crackedType = 481;
			break;
		case 1:
			num12 = 43;
			num22 = 8;
			GenVars.crackedType = 482;
			break;
		default:
			num12 = 44;
			num22 = 9;
			GenVars.crackedType = 483;
			break;
		}
		Main.tileSolid[GenVars.crackedType] = false;
		GenVars.dungeonLake = true;
		GenVars.numDDoors = 0;
		GenVars.numDungeonPlatforms = 0;
		GenVars.numDRooms = 0;
		GenVars.dungeonX = x;
		GenVars.dungeonY = y;
		GenVars.dMinX = x;
		GenVars.dMaxX = x;
		GenVars.dMinY = y;
		GenVars.dMaxY = y;
		GenVars.dxStrength1 = genRand.Next(25, 30);
		GenVars.dyStrength1 = genRand.Next(20, 25);
		GenVars.dxStrength2 = genRand.Next(35, 50);
		GenVars.dyStrength2 = genRand.Next(10, 15);
		double num32 = Main.maxTilesX / 60;
		num32 += (double)genRand.Next(0, (int)(num32 / 3.0));
		double num43 = num32;
		int num53 = 5;
		DungeonRoom(GenVars.dungeonX, GenVars.dungeonY, num12, num22);
		while (num32 > 0.0)
		{
			if (GenVars.dungeonX < GenVars.dMinX)
			{
				GenVars.dMinX = GenVars.dungeonX;
			}
			if (GenVars.dungeonX > GenVars.dMaxX)
			{
				GenVars.dMaxX = GenVars.dungeonX;
			}
			if (GenVars.dungeonY > GenVars.dMaxY)
			{
				GenVars.dMaxY = GenVars.dungeonY;
			}
			num32 -= 1.0;
			Main.statusText = Lang.gen[58].Value + " " + (int)((num43 - num32) / num43 * 60.0) + "%";
			if (num53 > 0)
			{
				num53--;
			}
			if ((num53 == 0) & (genRand.Next(3) == 0))
			{
				num53 = 5;
				if (genRand.Next(2) == 0)
				{
					int dungeonX = GenVars.dungeonX;
					int dungeonY = GenVars.dungeonY;
					DungeonHalls(GenVars.dungeonX, GenVars.dungeonY, num12, num22);
					if (genRand.Next(2) == 0)
					{
						DungeonHalls(GenVars.dungeonX, GenVars.dungeonY, num12, num22);
					}
					DungeonRoom(GenVars.dungeonX, GenVars.dungeonY, num12, num22);
					GenVars.dungeonX = dungeonX;
					GenVars.dungeonY = dungeonY;
				}
				else
				{
					DungeonRoom(GenVars.dungeonX, GenVars.dungeonY, num12, num22);
				}
			}
			else
			{
				DungeonHalls(GenVars.dungeonX, GenVars.dungeonY, num12, num22);
			}
		}
		DungeonRoom(GenVars.dungeonX, GenVars.dungeonY, num12, num22);
		int num63 = GenVars.dRoomX[0];
		int num74 = GenVars.dRoomY[0];
		for (int i = 0; i < GenVars.numDRooms; i++)
		{
			if (GenVars.dRoomY[i] < num74)
			{
				num63 = GenVars.dRoomX[i];
				num74 = GenVars.dRoomY[i];
			}
		}
		GenVars.dungeonX = num63;
		GenVars.dungeonY = num74;
		GenVars.dEnteranceX = num63;
		GenVars.dSurface = false;
		num53 = 5;
		if (drunkWorldGen)
		{
			GenVars.dSurface = true;
		}
		while (!GenVars.dSurface)
		{
			if (num53 > 0)
			{
				num53--;
			}
			if (num53 == 0 && genRand.Next(5) == 0 && (double)GenVars.dungeonY > Main.worldSurface + 100.0)
			{
				num53 = 10;
				int dungeonX2 = GenVars.dungeonX;
				int dungeonY2 = GenVars.dungeonY;
				DungeonHalls(GenVars.dungeonX, GenVars.dungeonY, num12, num22, forceX: true);
				DungeonRoom(GenVars.dungeonX, GenVars.dungeonY, num12, num22);
				GenVars.dungeonX = dungeonX2;
				GenVars.dungeonY = dungeonY2;
			}
			DungeonStairs(GenVars.dungeonX, GenVars.dungeonY, num12, num22);
		}
		DungeonEnt(GenVars.dungeonX, GenVars.dungeonY, num12, num22);
		Main.statusText = Lang.gen[58].Value + " 65%";
		int num85 = Main.maxTilesX * 2;
		int num2;
		for (num2 = 0; num2 < num85; num2++)
		{
			int i3 = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
			int num3 = GenVars.dMinY;
			if ((double)num3 < Main.worldSurface)
			{
				num3 = (int)Main.worldSurface;
			}
			int j = genRand.Next(num3, GenVars.dMaxY);
			num2 = ((!DungeonPitTrap(i3, j, num12, num22)) ? (num2 + 1) : (num2 + 1500));
		}
		for (int k = 0; k < GenVars.numDRooms; k++)
		{
			for (int l = GenVars.dRoomL[k]; l <= GenVars.dRoomR[k]; l++)
			{
				if (!Main.tile[l, GenVars.dRoomT[k] - 1].active())
				{
					GenVars.dungeonPlatformX[GenVars.numDungeonPlatforms] = l;
					GenVars.dungeonPlatformY[GenVars.numDungeonPlatforms] = GenVars.dRoomT[k] - 1;
					GenVars.numDungeonPlatforms++;
					break;
				}
			}
			for (int m = GenVars.dRoomL[k]; m <= GenVars.dRoomR[k]; m++)
			{
				if (!Main.tile[m, GenVars.dRoomB[k] + 1].active())
				{
					GenVars.dungeonPlatformX[GenVars.numDungeonPlatforms] = m;
					GenVars.dungeonPlatformY[GenVars.numDungeonPlatforms] = GenVars.dRoomB[k] + 1;
					GenVars.numDungeonPlatforms++;
					break;
				}
			}
			for (int n = GenVars.dRoomT[k]; n <= GenVars.dRoomB[k]; n++)
			{
				if (!Main.tile[GenVars.dRoomL[k] - 1, n].active())
				{
					GenVars.DDoorX[GenVars.numDDoors] = GenVars.dRoomL[k] - 1;
					GenVars.DDoorY[GenVars.numDDoors] = n;
					GenVars.DDoorPos[GenVars.numDDoors] = -1;
					GenVars.numDDoors++;
					break;
				}
			}
			for (int num4 = GenVars.dRoomT[k]; num4 <= GenVars.dRoomB[k]; num4++)
			{
				if (!Main.tile[GenVars.dRoomR[k] + 1, num4].active())
				{
					GenVars.DDoorX[GenVars.numDDoors] = GenVars.dRoomR[k] + 1;
					GenVars.DDoorY[GenVars.numDDoors] = num4;
					GenVars.DDoorPos[GenVars.numDDoors] = 1;
					GenVars.numDDoors++;
					break;
				}
			}
		}
		Main.statusText = Lang.gen[58].Value + " 70%";
		int num5 = 0;
		int num6 = 1000;
		int num7 = 0;
		int num8 = Main.maxTilesX / 100;
		if (getGoodWorldGen)
		{
			num8 *= 3;
		}
		while (num7 < num8)
		{
			num5++;
			int num9 = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
			int num10 = genRand.Next((int)Main.worldSurface + 25, GenVars.dMaxY);
			if (drunkWorldGen)
			{
				num10 = genRand.Next(GenVars.dungeonY + 25, GenVars.dMaxY);
			}
			int num11 = num9;
			if (Main.tile[num9, num10].wall == num22 && !Main.tile[num9, num10].active())
			{
				int num13 = 1;
				if (genRand.Next(2) == 0)
				{
					num13 = -1;
				}
				for (; !Main.tile[num9, num10].active(); num10 += num13)
				{
				}
				if (Main.tile[num9 - 1, num10].active() && Main.tile[num9 + 1, num10].active() && Main.tile[num9 - 1, num10].type != GenVars.crackedType && !Main.tile[num9 - 1, num10 - num13].active() && !Main.tile[num9 + 1, num10 - num13].active())
				{
					num7++;
					int num14 = genRand.Next(5, 13);
					while (Main.tile[num9 - 1, num10].active() && Main.tile[num9 - 1, num10].type != GenVars.crackedType && Main.tile[num9, num10 + num13].active() && Main.tile[num9, num10].active() && !Main.tile[num9, num10 - num13].active() && num14 > 0)
					{
						Main.tile[num9, num10].type = 48;
						if (!Main.tile[num9 - 1, num10 - num13].active() && !Main.tile[num9 + 1, num10 - num13].active())
						{
							Main.tile[num9, num10 - num13].Clear(TileDataType.Slope);
							Main.tile[num9, num10 - num13].type = 48;
							Main.tile[num9, num10 - num13].active(active: true);
							Main.tile[num9, num10 - num13 * 2].Clear(TileDataType.Slope);
							Main.tile[num9, num10 - num13 * 2].type = 48;
							Main.tile[num9, num10 - num13 * 2].active(active: true);
						}
						num9--;
						num14--;
					}
					num14 = genRand.Next(5, 13);
					num9 = num11 + 1;
					while (Main.tile[num9 + 1, num10].active() && Main.tile[num9 + 1, num10].type != GenVars.crackedType && Main.tile[num9, num10 + num13].active() && Main.tile[num9, num10].active() && !Main.tile[num9, num10 - num13].active() && num14 > 0)
					{
						Main.tile[num9, num10].type = 48;
						if (!Main.tile[num9 - 1, num10 - num13].active() && !Main.tile[num9 + 1, num10 - num13].active())
						{
							Main.tile[num9, num10 - num13].Clear(TileDataType.Slope);
							Main.tile[num9, num10 - num13].type = 48;
							Main.tile[num9, num10 - num13].active(active: true);
							Main.tile[num9, num10 - num13 * 2].Clear(TileDataType.Slope);
							Main.tile[num9, num10 - num13 * 2].type = 48;
							Main.tile[num9, num10 - num13 * 2].active(active: true);
						}
						num9++;
						num14--;
					}
				}
			}
			if (num5 > num6)
			{
				num5 = 0;
				num7++;
			}
		}
		num5 = 0;
		num6 = 1000;
		num7 = 0;
		Main.statusText = Lang.gen[58].Value + " 75%";
		while (num7 < num8)
		{
			num5++;
			int num15 = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
			int num16 = genRand.Next((int)Main.worldSurface + 25, GenVars.dMaxY);
			int num17 = num16;
			if (Main.tile[num15, num16].wall == num22 && !Main.tile[num15, num16].active())
			{
				int num18 = 1;
				if (genRand.Next(2) == 0)
				{
					num18 = -1;
				}
				for (; num15 > 5 && num15 < Main.maxTilesX - 5 && !Main.tile[num15, num16].active(); num15 += num18)
				{
				}
				if (Main.tile[num15, num16 - 1].active() && Main.tile[num15, num16 + 1].active() && Main.tile[num15, num16 - 1].type != GenVars.crackedType && !Main.tile[num15 - num18, num16 - 1].active() && !Main.tile[num15 - num18, num16 + 1].active())
				{
					num7++;
					int num19 = genRand.Next(5, 13);
					while (Main.tile[num15, num16 - 1].active() && Main.tile[num15, num16 - 1].type != GenVars.crackedType && Main.tile[num15 + num18, num16].active() && Main.tile[num15, num16].active() && !Main.tile[num15 - num18, num16].active() && num19 > 0)
					{
						Main.tile[num15, num16].type = 48;
						if (!Main.tile[num15 - num18, num16 - 1].active() && !Main.tile[num15 - num18, num16 + 1].active())
						{
							Main.tile[num15 - num18, num16].type = 48;
							Main.tile[num15 - num18, num16].active(active: true);
							Main.tile[num15 - num18, num16].Clear(TileDataType.Slope);
							Main.tile[num15 - num18 * 2, num16].type = 48;
							Main.tile[num15 - num18 * 2, num16].active(active: true);
							Main.tile[num15 - num18 * 2, num16].Clear(TileDataType.Slope);
						}
						num16--;
						num19--;
					}
					num19 = genRand.Next(5, 13);
					num16 = num17 + 1;
					while (Main.tile[num15, num16 + 1].active() && Main.tile[num15, num16 + 1].type != GenVars.crackedType && Main.tile[num15 + num18, num16].active() && Main.tile[num15, num16].active() && !Main.tile[num15 - num18, num16].active() && num19 > 0)
					{
						Main.tile[num15, num16].type = 48;
						if (!Main.tile[num15 - num18, num16 - 1].active() && !Main.tile[num15 - num18, num16 + 1].active())
						{
							Main.tile[num15 - num18, num16].type = 48;
							Main.tile[num15 - num18, num16].active(active: true);
							Main.tile[num15 - num18, num16].Clear(TileDataType.Slope);
							Main.tile[num15 - num18 * 2, num16].type = 48;
							Main.tile[num15 - num18 * 2, num16].active(active: true);
							Main.tile[num15 - num18 * 2, num16].Clear(TileDataType.Slope);
						}
						num16++;
						num19--;
					}
				}
			}
			if (num5 > num6)
			{
				num5 = 0;
				num7++;
			}
		}
		Main.statusText = Lang.gen[58].Value + " 80%";
		for (int num20 = 0; num20 < GenVars.numDDoors; num20++)
		{
			int num94 = GenVars.DDoorX[num20] - 10;
			int num21 = GenVars.DDoorX[num20] + 10;
			int num23 = 100;
			int num24 = 0;
			int num25 = 0;
			int num26 = 0;
			for (int num27 = num94; num27 < num21; num27++)
			{
				bool flag = true;
				int num28 = GenVars.DDoorY[num20];
				while (num28 > 10 && !Main.tile[num27, num28].active())
				{
					num28--;
				}
				if (!Main.tileDungeon[Main.tile[num27, num28].type])
				{
					flag = false;
				}
				num25 = num28;
				for (num28 = GenVars.DDoorY[num20]; !Main.tile[num27, num28].active(); num28++)
				{
				}
				if (!Main.tileDungeon[Main.tile[num27, num28].type])
				{
					flag = false;
				}
				num26 = num28;
				if (num26 - num25 < 3)
				{
					continue;
				}
				int num95 = num27 - 20;
				int num29 = num27 + 20;
				int num30 = num26 - 10;
				int num31 = num26 + 10;
				for (int num33 = num95; num33 < num29; num33++)
				{
					for (int num34 = num30; num34 < num31; num34++)
					{
						if (Main.tile[num33, num34].active() && Main.tile[num33, num34].type == 10)
						{
							flag = false;
							break;
						}
					}
				}
				if (flag)
				{
					for (int num35 = num26 - 3; num35 < num26; num35++)
					{
						for (int num36 = num27 - 3; num36 <= num27 + 3; num36++)
						{
							if (Main.tile[num36, num35].active())
							{
								flag = false;
								break;
							}
						}
					}
				}
				if (flag && num26 - num25 < 20)
				{
					bool flag2 = false;
					if (GenVars.DDoorPos[num20] == 0 && num26 - num25 < num23)
					{
						flag2 = true;
					}
					if (GenVars.DDoorPos[num20] == -1 && num27 > num24)
					{
						flag2 = true;
					}
					if (GenVars.DDoorPos[num20] == 1 && (num27 < num24 || num24 == 0))
					{
						flag2 = true;
					}
					if (flag2)
					{
						num24 = num27;
						num23 = num26 - num25;
					}
				}
			}
			if (num23 >= 20)
			{
				continue;
			}
			int num37 = num24;
			int num38 = GenVars.DDoorY[num20];
			int num39 = num38;
			for (; !Main.tile[num37, num38].active(); num38++)
			{
				Main.tile[num37, num38].active(active: false);
			}
			while (!Main.tile[num37, num39].active())
			{
				num39--;
			}
			num38--;
			num39++;
			for (int num40 = num39; num40 < num38 - 2; num40++)
			{
				Main.tile[num37, num40].Clear(TileDataType.Slope);
				Main.tile[num37, num40].active(active: true);
				Main.tile[num37, num40].type = num12;
				if (Main.tile[num37 - 1, num40].type == num12)
				{
					Main.tile[num37 - 1, num40].active(active: false);
					Main.tile[num37 - 1, num40].ClearEverything();
					Main.tile[num37 - 1, num40].wall = (ushort)num22;
				}
				if (Main.tile[num37 - 2, num40].type == num12)
				{
					Main.tile[num37 - 2, num40].active(active: false);
					Main.tile[num37 - 2, num40].ClearEverything();
					Main.tile[num37 - 2, num40].wall = (ushort)num22;
				}
				if (Main.tile[num37 + 1, num40].type == num12)
				{
					Main.tile[num37 + 1, num40].active(active: false);
					Main.tile[num37 + 1, num40].ClearEverything();
					Main.tile[num37 + 1, num40].wall = (ushort)num22;
				}
				if (Main.tile[num37 + 2, num40].type == num12)
				{
					Main.tile[num37 + 2, num40].active(active: false);
					Main.tile[num37 + 2, num40].ClearEverything();
					Main.tile[num37 + 2, num40].wall = (ushort)num22;
				}
			}
			int style = 13;
			if (genRand.Next(3) == 0)
			{
				switch (num22)
				{
				case 7:
					style = 16;
					break;
				case 8:
					style = 17;
					break;
				case 9:
					style = 18;
					break;
				}
			}
			PlaceTile(num37, num38, 10, mute: true, forced: false, -1, style);
			num37--;
			int num41 = num38 - 3;
			while (!Main.tile[num37, num41].active())
			{
				num41--;
			}
			if (num38 - num41 < num38 - num39 + 5 && Main.tileDungeon[Main.tile[num37, num41].type])
			{
				for (int num42 = num38 - 4 - genRand.Next(3); num42 > num41; num42--)
				{
					Main.tile[num37, num42].Clear(TileDataType.Slope);
					Main.tile[num37, num42].active(active: true);
					Main.tile[num37, num42].type = num12;
					if (Main.tile[num37 - 1, num42].type == num12)
					{
						Main.tile[num37 - 1, num42].active(active: false);
						Main.tile[num37 - 1, num42].ClearEverything();
						Main.tile[num37 - 1, num42].wall = (ushort)num22;
					}
					if (Main.tile[num37 - 2, num42].type == num12)
					{
						Main.tile[num37 - 2, num42].active(active: false);
						Main.tile[num37 - 2, num42].ClearEverything();
						Main.tile[num37 - 2, num42].wall = (ushort)num22;
					}
				}
			}
			num37 += 2;
			num41 = num38 - 3;
			while (!Main.tile[num37, num41].active())
			{
				num41--;
			}
			if (num38 - num41 < num38 - num39 + 5 && Main.tileDungeon[Main.tile[num37, num41].type])
			{
				for (int num44 = num38 - 4 - genRand.Next(3); num44 > num41; num44--)
				{
					Main.tile[num37, num44].active(active: true);
					Main.tile[num37, num44].Clear(TileDataType.Slope);
					Main.tile[num37, num44].type = num12;
					if (Main.tile[num37 + 1, num44].type == num12)
					{
						Main.tile[num37 + 1, num44].active(active: false);
						Main.tile[num37 + 1, num44].ClearEverything();
						Main.tile[num37 + 1, num44].wall = (ushort)num22;
					}
					if (Main.tile[num37 + 2, num44].type == num12)
					{
						Main.tile[num37 + 2, num44].active(active: false);
						Main.tile[num37 + 2, num44].ClearEverything();
						Main.tile[num37 + 2, num44].wall = (ushort)num22;
					}
				}
			}
			num38++;
			num37--;
			for (int num45 = num38 - 8; num45 < num38; num45++)
			{
				if (Main.tile[num37 + 2, num45].type == num12)
				{
					Main.tile[num37 + 2, num45].active(active: false);
					Main.tile[num37 + 2, num45].ClearEverything();
					Main.tile[num37 + 2, num45].wall = (ushort)num22;
				}
				if (Main.tile[num37 + 3, num45].type == num12)
				{
					Main.tile[num37 + 3, num45].active(active: false);
					Main.tile[num37 + 3, num45].ClearEverything();
					Main.tile[num37 + 3, num45].wall = (ushort)num22;
				}
				if (Main.tile[num37 - 2, num45].type == num12)
				{
					Main.tile[num37 - 2, num45].active(active: false);
					Main.tile[num37 - 2, num45].ClearEverything();
					Main.tile[num37 - 2, num45].wall = (ushort)num22;
				}
				if (Main.tile[num37 - 3, num45].type == num12)
				{
					Main.tile[num37 - 3, num45].active(active: false);
					Main.tile[num37 - 3, num45].ClearEverything();
					Main.tile[num37 - 3, num45].wall = (ushort)num22;
				}
			}
			Main.tile[num37 - 1, num38].active(active: true);
			Main.tile[num37 - 1, num38].type = num12;
			Main.tile[num37 - 1, num38].Clear(TileDataType.Slope);
			Main.tile[num37 + 1, num38].active(active: true);
			Main.tile[num37 + 1, num38].type = num12;
			Main.tile[num37 + 1, num38].Clear(TileDataType.Slope);
		}
		int[] array = new int[3];
		switch (num22)
		{
		case 7:
			array[0] = 7;
			array[1] = 94;
			array[2] = 95;
			break;
		case 9:
			array[0] = 9;
			array[1] = 96;
			array[2] = 97;
			break;
		default:
			array[0] = 8;
			array[1] = 98;
			array[2] = 99;
			break;
		}
		for (int num46 = 0; num46 < 5; num46++)
		{
			for (int num47 = 0; num47 < 3; num47++)
			{
				int num48 = genRand.Next(40, 240);
				int num49 = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
				int num50 = genRand.Next(GenVars.dMinY, GenVars.dMaxY);
				for (int num51 = num49 - num48; num51 < num49 + num48; num51++)
				{
					for (int num52 = num50 - num48; num52 < num50 + num48; num52++)
					{
						if ((double)num52 > Main.worldSurface)
						{
							double num96 = Math.Abs(num49 - num51);
							double num54 = Math.Abs(num50 - num52);
							if (Math.Sqrt(num96 * num96 + num54 * num54) < (double)num48 * 0.4 && Main.wallDungeon[Main.tile[num51, num52].wall])
							{
								Spread.WallDungeon(num51, num52, array[num47]);
							}
						}
					}
				}
			}
		}
		Main.statusText = Lang.gen[58].Value + " 85%";
		for (int num55 = 0; num55 < GenVars.numDungeonPlatforms; num55++)
		{
			int num56 = GenVars.dungeonPlatformX[num55];
			int num57 = GenVars.dungeonPlatformY[num55];
			int num58 = Main.maxTilesX;
			int num59 = 10;
			if ((double)num57 < Main.worldSurface + 50.0)
			{
				num59 = 20;
			}
			for (int num60 = num57 - 5; num60 <= num57 + 5; num60++)
			{
				int num61 = num56;
				int num62 = num56;
				bool flag3 = false;
				if (Main.tile[num61, num60].active())
				{
					flag3 = true;
				}
				else
				{
					while (!Main.tile[num61, num60].active())
					{
						num61--;
						if (!Main.tileDungeon[Main.tile[num61, num60].type] || num61 == 0)
						{
							flag3 = true;
							break;
						}
					}
					while (!Main.tile[num62, num60].active())
					{
						num62++;
						if (!Main.tileDungeon[Main.tile[num62, num60].type] || num62 == Main.maxTilesX - 1)
						{
							flag3 = true;
							break;
						}
					}
				}
				if (flag3 || num62 - num61 > num59)
				{
					continue;
				}
				bool flag4 = true;
				int num97 = num56 - num59 / 2 - 2;
				int num64 = num56 + num59 / 2 + 2;
				int num65 = num60 - 5;
				int num66 = num60 + 5;
				for (int num67 = num97; num67 <= num64; num67++)
				{
					for (int num68 = num65; num68 <= num66; num68++)
					{
						if (Main.tile[num67, num68].active() && Main.tile[num67, num68].type == 19)
						{
							flag4 = false;
							break;
						}
					}
				}
				for (int num69 = num60 + 3; num69 >= num60 - 5; num69--)
				{
					if (Main.tile[num56, num69].active())
					{
						flag4 = false;
						break;
					}
				}
				if (flag4)
				{
					num58 = num60;
					break;
				}
			}
			if (num58 <= num57 - 10 || num58 >= num57 + 10)
			{
				continue;
			}
			int num70 = num56;
			int num71 = num58;
			int num72 = num56 + 1;
			while (!Main.tile[num70, num71].active())
			{
				Main.tile[num70, num71].active(active: true);
				Main.tile[num70, num71].type = 19;
				Main.tile[num70, num71].Clear(TileDataType.Slope);
				switch (num22)
				{
				case 7:
					Main.tile[num70, num71].frameY = 108;
					break;
				case 8:
					Main.tile[num70, num71].frameY = 144;
					break;
				default:
					Main.tile[num70, num71].frameY = 126;
					break;
				}
				TileFrame(num70, num71);
				num70--;
			}
			for (; !Main.tile[num72, num71].active(); num72++)
			{
				Main.tile[num72, num71].active(active: true);
				Main.tile[num72, num71].type = 19;
				Main.tile[num72, num71].Clear(TileDataType.Slope);
				switch (num22)
				{
				case 7:
					Main.tile[num72, num71].frameY = 108;
					break;
				case 8:
					Main.tile[num72, num71].frameY = 144;
					break;
				default:
					Main.tile[num72, num71].frameY = 126;
					break;
				}
				TileFrame(num72, num71);
			}
		}
		int num73 = 5;
		if (drunkWorldGen)
		{
			num73 = 6;
		}
		for (int num75 = 0; num75 < num73; num75++)
		{
			bool flag5 = false;
			while (!flag5)
			{
				int num76 = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
				int num77 = genRand.Next((int)Main.worldSurface, GenVars.dMaxY);
				if (!Main.wallDungeon[Main.tile[num76, num77].wall] || Main.tile[num76, num77].active())
				{
					continue;
				}
				ushort chestTileType = 21;
				int contain = 0;
				int style2 = 0;
				switch (num75)
				{
				case 0:
					style2 = 23;
					contain = 1156;
					break;
				case 1:
					if (!crimson)
					{
						style2 = 24;
						contain = 1571;
					}
					else
					{
						style2 = 25;
						contain = 1569;
					}
					break;
				case 5:
					if (crimson)
					{
						style2 = 24;
						contain = 1571;
					}
					else
					{
						style2 = 25;
						contain = 1569;
					}
					break;
				case 2:
					style2 = 26;
					contain = 1260;
					break;
				case 3:
					style2 = 27;
					contain = 1572;
					break;
				case 4:
					chestTileType = 467;
					style2 = 13;
					contain = 4607;
					break;
				}
				flag5 = AddBuriedChest(num76, num77, contain, notNearOtherChests: false, style2, trySlope: false, chestTileType);
			}
		}
		int[] array2 = new int[3]
		{
			genRand.Next(9, 13),
			genRand.Next(9, 13),
			0
		};
		while (array2[1] == array2[0])
		{
			array2[1] = genRand.Next(9, 13);
		}
		array2[2] = genRand.Next(9, 13);
		while (array2[2] == array2[0] || array2[2] == array2[1])
		{
			array2[2] = genRand.Next(9, 13);
		}
		Main.statusText = Lang.gen[58].Value + " 90%";
		num5 = 0;
		num6 = 1000;
		num7 = 0;
		while (num7 < Main.maxTilesX / 20)
		{
			num5++;
			int num78 = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
			int num79 = genRand.Next(GenVars.dMinY, GenVars.dMaxY);
			bool flag6 = true;
			if (Main.wallDungeon[Main.tile[num78, num79].wall] && !Main.tile[num78, num79].active())
			{
				int num80 = 1;
				if (genRand.Next(2) == 0)
				{
					num80 = -1;
				}
				while (flag6 && !Main.tile[num78, num79].active())
				{
					num78 -= num80;
					if (num78 < 5 || num78 > Main.maxTilesX - 5)
					{
						flag6 = false;
					}
					else if (Main.tile[num78, num79].active() && !Main.tileDungeon[Main.tile[num78, num79].type])
					{
						flag6 = false;
					}
				}
				if (flag6 && Main.tile[num78, num79].active() && Main.tileDungeon[Main.tile[num78, num79].type] && Main.tile[num78, num79 - 1].active() && Main.tileDungeon[Main.tile[num78, num79 - 1].type] && Main.tile[num78, num79 + 1].active() && Main.tileDungeon[Main.tile[num78, num79 + 1].type])
				{
					num78 += num80;
					for (int num81 = num78 - 3; num81 <= num78 + 3; num81++)
					{
						for (int num82 = num79 - 3; num82 <= num79 + 3; num82++)
						{
							if (Main.tile[num81, num82].active() && Main.tile[num81, num82].type == 19)
							{
								flag6 = false;
								break;
							}
						}
					}
					if (flag6 && (!Main.tile[num78, num79 - 1].active() & !Main.tile[num78, num79 - 2].active() & !Main.tile[num78, num79 - 3].active()))
					{
						int num83 = num78;
						int num84 = num78;
						for (; num83 > GenVars.dMinX && num83 < GenVars.dMaxX && !Main.tile[num83, num79].active() && !Main.tile[num83, num79 - 1].active() && !Main.tile[num83, num79 + 1].active(); num83 += num80)
						{
						}
						num83 = Math.Abs(num78 - num83);
						bool flag7 = false;
						if (genRand.Next(2) == 0)
						{
							flag7 = true;
						}
						if (num83 > 5)
						{
							for (int num86 = genRand.Next(1, 4); num86 > 0; num86--)
							{
								Main.tile[num78, num79].active(active: true);
								Main.tile[num78, num79].Clear(TileDataType.Slope);
								Main.tile[num78, num79].type = 19;
								if (Main.tile[num78, num79].wall == array[0])
								{
									Main.tile[num78, num79].frameY = (short)(18 * array2[0]);
								}
								else if (Main.tile[num78, num79].wall == array[1])
								{
									Main.tile[num78, num79].frameY = (short)(18 * array2[1]);
								}
								else
								{
									Main.tile[num78, num79].frameY = (short)(18 * array2[2]);
								}
								TileFrame(num78, num79);
								if (flag7)
								{
									PlaceTile(num78, num79 - 1, 50, mute: true);
									if (genRand.Next(50) == 0 && (double)num79 > (Main.worldSurface + Main.rockLayer) / 2.0 && Main.tile[num78, num79 - 1].type == 50)
									{
										Main.tile[num78, num79 - 1].frameX = 90;
									}
								}
								num78 += num80;
							}
							num5 = 0;
							num7++;
							if (!flag7 && genRand.Next(2) == 0)
							{
								num78 = num84;
								num79--;
								int num87 = 0;
								if (genRand.Next(4) == 0)
								{
									num87 = 1;
								}
								switch (num87)
								{
								case 0:
									num87 = 13;
									break;
								case 1:
									num87 = 49;
									break;
								}
								PlaceTile(num78, num79, num87, mute: true);
								if (Main.tile[num78, num79].type == 13)
								{
									if (genRand.Next(2) == 0)
									{
										Main.tile[num78, num79].frameX = 18;
									}
									else
									{
										Main.tile[num78, num79].frameX = 36;
									}
								}
							}
						}
					}
				}
			}
			if (num5 > num6)
			{
				num5 = 0;
				num7++;
			}
		}
		Main.statusText = Lang.gen[58].Value + " 95%";
		int num88 = 1;
		for (int num89 = 0; num89 < GenVars.numDRooms; num89++)
		{
			int num90 = 0;
			while (num90 < 1000)
			{
				int num91 = (int)((double)GenVars.dRoomSize[num89] * 0.4);
				int i2 = GenVars.dRoomX[num89] + genRand.Next(-num91, num91 + 1);
				int num92 = GenVars.dRoomY[num89] + genRand.Next(-num91, num91 + 1);
				int num93 = 0;
				int style3 = 2;
				if (num88 == 1)
				{
					num88++;
				}
				switch (num88)
				{
				case 2:
					num93 = 155;
					break;
				case 3:
					num93 = 156;
					break;
				case 4:
					num93 = ((!remixWorldGen) ? 157 : 2623);
					break;
				case 5:
					num93 = 163;
					break;
				case 6:
					num93 = 113;
					break;
				case 7:
					num93 = 3317;
					break;
				case 8:
					num93 = 327;
					style3 = 0;
					break;
				default:
					num93 = 164;
					num88 = 0;
					break;
				}
				if ((double)num92 < Main.worldSurface + 50.0)
				{
					num93 = 327;
					style3 = 0;
				}
				if (num93 == 0 && genRand.Next(2) == 0)
				{
					num90 = 1000;
					continue;
				}
				if (AddBuriedChest(i2, num92, num93, notNearOtherChests: false, style3, trySlope: false, 0))
				{
					num90 += 1000;
					num88++;
				}
				num90++;
			}
		}
		GenVars.dMinX -= 25;
		GenVars.dMaxX += 25;
		GenVars.dMinY -= 25;
		GenVars.dMaxY += 25;
		if (GenVars.dMinX < 0)
		{
			GenVars.dMinX = 0;
		}
		if (GenVars.dMaxX > Main.maxTilesX)
		{
			GenVars.dMaxX = Main.maxTilesX;
		}
		if (GenVars.dMinY < 0)
		{
			GenVars.dMinY = 0;
		}
		if (GenVars.dMaxY > Main.maxTilesY)
		{
			GenVars.dMaxY = Main.maxTilesY;
		}
		num5 = 0;
		num6 = 1000;
		num7 = 0;
		MakeDungeon_Lights(num12, ref num5, num6, ref num7, array);
		num5 = 0;
		num6 = 1000;
		num7 = 0;
		MakeDungeon_Traps(ref num5, num6, ref num7);
		double count = MakeDungeon_GroundFurniture(num22);
		count = MakeDungeon_Pictures(array, count);
		count = MakeDungeon_Banners(array, count);
	}

	private static void MakeDungeon_Traps(ref int failCount, int failMax, ref int numAdd)
	{
		while (numAdd < Main.maxTilesX / 500)
		{
			failCount++;
			int num = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
			int num2 = genRand.Next(GenVars.dMinY, GenVars.dMaxY);
			while ((double)num2 < Main.worldSurface)
			{
				num2 = genRand.Next(GenVars.dMinY, GenVars.dMaxY);
			}
			if (Main.wallDungeon[Main.tile[num, num2].wall] && placeTrap(num, num2, 0))
			{
				failCount = failMax;
			}
			if (failCount > failMax)
			{
				numAdd++;
				failCount = 0;
			}
		}
	}

	private static void MakeDungeon_Lights(ushort tileType, ref int failCount, int failMax, ref int numAdd, int[] roomWall)
	{
		//IL_0693: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_0388: Unknown result type (might be due to invalid IL or missing references)
		int[] array = new int[3]
		{
			genRand.Next(7),
			genRand.Next(7),
			0
		};
		while (array[1] == array[0])
		{
			array[1] = genRand.Next(7);
		}
		array[2] = genRand.Next(7);
		while (array[2] == array[0] || array[2] == array[1])
		{
			array[2] = genRand.Next(7);
		}
		while (numAdd < Main.maxTilesX / 150)
		{
			failCount++;
			int num = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
			int num2 = genRand.Next(GenVars.dMinY, GenVars.dMaxY);
			if (Main.wallDungeon[Main.tile[num, num2].wall])
			{
				for (int num3 = num2; num3 > GenVars.dMinY; num3--)
				{
					if (Main.tile[num, num3 - 1].active() && Main.tile[num, num3 - 1].type == tileType)
					{
						bool flag = false;
						for (int i = num - 15; i < num + 15; i++)
						{
							for (int j = num3 - 15; j < num3 + 15; j++)
							{
								if (i > 0 && i < Main.maxTilesX && j > 0 && j < Main.maxTilesY && (Main.tile[i, j].type == 42 || Main.tile[i, j].type == 34))
								{
									flag = true;
									break;
								}
							}
						}
						if (Main.tile[num - 1, num3].active() || Main.tile[num + 1, num3].active() || Main.tile[num - 1, num3 + 1].active() || Main.tile[num + 1, num3 + 1].active() || Main.tile[num, num3 + 2].active())
						{
							flag = true;
						}
						if (flag)
						{
							break;
						}
						bool flag2 = false;
						if (!flag2 && genRand.Next(7) == 0)
						{
							int style = 27;
							switch (roomWall[0])
							{
							case 7:
								style = 27;
								break;
							case 8:
								style = 28;
								break;
							case 9:
								style = 29;
								break;
							}
							bool flag3 = false;
							for (int k = 0; k < 15; k++)
							{
								if (SolidTile(num, num3 + k))
								{
									flag3 = true;
									break;
								}
							}
							if (!flag3)
							{
								PlaceChand(num, num3, 34, style);
							}
							if (Main.tile[num, num3].type == 34)
							{
								flag2 = true;
								failCount = 0;
								numAdd++;
								for (int l = 0; l < 1000; l++)
								{
									int num4 = num + genRand.Next(-12, 13);
									int num5 = num3 + genRand.Next(3, 21);
									if (Main.tile[num4, num5].active() || Main.tile[num4, num5 + 1].active() || !Main.tileDungeon[Main.tile[num4 - 1, num5].type] || !Main.tileDungeon[Main.tile[num4 + 1, num5].type] || !Collision.CanHit(new Point(num4 * 16, num5 * 16), 16, 16, new Point(num * 16, num3 * 16 + 1), 16, 16))
									{
										continue;
									}
									if (((SolidTile(num4 - 1, num5) && Main.tile[num4 - 1, num5].type != 10) || (SolidTile(num4 + 1, num5) && Main.tile[num4 + 1, num5].type != 10) || SolidTile(num4, num5 + 1)) && Main.wallDungeon[Main.tile[num4, num5].wall] && (Main.tileDungeon[Main.tile[num4 - 1, num5].type] || Main.tileDungeon[Main.tile[num4 + 1, num5].type]))
									{
										PlaceTile(num4, num5, 136, mute: true);
									}
									if (!Main.tile[num4, num5].active())
									{
										continue;
									}
									while (num4 != num || num5 != num3)
									{
										Main.tile[num4, num5].wire(wire: true);
										if (num4 > num)
										{
											num4--;
										}
										if (num4 < num)
										{
											num4++;
										}
										Main.tile[num4, num5].wire(wire: true);
										if (num5 > num3)
										{
											num5--;
										}
										if (num5 < num3)
										{
											num5++;
										}
										Main.tile[num4, num5].wire(wire: true);
									}
									if (genRand.Next(3) > 0)
									{
										Main.tile[num, num3].frameX = 18;
										Main.tile[num, num3 + 1].frameX = 18;
									}
									break;
								}
							}
						}
						if (flag2)
						{
							break;
						}
						int style2 = array[0];
						if (Main.tile[num, num3].wall == roomWall[1])
						{
							style2 = array[1];
						}
						if (Main.tile[num, num3].wall == roomWall[2])
						{
							style2 = array[2];
						}
						Place1x2Top(num, num3, 42, style2);
						if (Main.tile[num, num3].type != 42)
						{
							break;
						}
						flag2 = true;
						failCount = 0;
						numAdd++;
						for (int m = 0; m < 1000; m++)
						{
							int num6 = num + genRand.Next(-12, 13);
							int num7 = num3 + genRand.Next(3, 21);
							if (Main.tile[num6, num7].active() || Main.tile[num6, num7 + 1].active() || Main.tile[num6 - 1, num7].type == 48 || Main.tile[num6 + 1, num7].type == 48 || !Collision.CanHit(new Point(num6 * 16, num7 * 16), 16, 16, new Point(num * 16, num3 * 16 + 1), 16, 16))
							{
								continue;
							}
							if ((SolidTile(num6 - 1, num7) && Main.tile[num6 - 1, num7].type != 10) || (SolidTile(num6 + 1, num7) && Main.tile[num6 + 1, num7].type != 10) || SolidTile(num6, num7 + 1))
							{
								PlaceTile(num6, num7, 136, mute: true);
							}
							if (!Main.tile[num6, num7].active())
							{
								continue;
							}
							while (num6 != num || num7 != num3)
							{
								Main.tile[num6, num7].wire(wire: true);
								if (num6 > num)
								{
									num6--;
								}
								if (num6 < num)
								{
									num6++;
								}
								Main.tile[num6, num7].wire(wire: true);
								if (num7 > num3)
								{
									num7--;
								}
								if (num7 < num3)
								{
									num7++;
								}
								Main.tile[num6, num7].wire(wire: true);
							}
							if (genRand.Next(3) > 0)
							{
								Main.tile[num, num3].frameX = 18;
								Main.tile[num, num3 + 1].frameX = 18;
							}
							break;
						}
						break;
					}
				}
			}
			if (failCount > failMax)
			{
				numAdd++;
				failCount = 0;
			}
		}
	}

	private static double MakeDungeon_Banners(int[] roomWall, double count)
	{
		count = 840000.0 / (double)Main.maxTilesX;
		for (int i = 0; (double)i < count; i++)
		{
			int num = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
			int num2 = genRand.Next(GenVars.dMinY, GenVars.dMaxY);
			while (!Main.wallDungeon[Main.tile[num, num2].wall] || Main.tile[num, num2].active())
			{
				num = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
				num2 = genRand.Next(GenVars.dMinY, GenVars.dMaxY);
			}
			while (!SolidTile(num, num2) && num2 > 10)
			{
				num2--;
			}
			num2++;
			if (!Main.wallDungeon[Main.tile[num, num2].wall] || Main.tile[num, num2 - 1].type == 48 || Main.tile[num, num2].active() || Main.tile[num, num2 + 1].active() || Main.tile[num, num2 + 2].active() || Main.tile[num, num2 + 3].active())
			{
				continue;
			}
			bool flag = true;
			for (int j = num - 1; j <= num + 1; j++)
			{
				for (int k = num2; k <= num2 + 3; k++)
				{
					if (Main.tile[j, k].active() && (Main.tile[j, k].type == 10 || Main.tile[j, k].type == 11 || Main.tile[j, k].type == 91))
					{
						flag = false;
					}
				}
			}
			if (flag)
			{
				int num3 = 10;
				if (Main.tile[num, num2].wall == roomWall[1])
				{
					num3 = 12;
				}
				if (Main.tile[num, num2].wall == roomWall[2])
				{
					num3 = 14;
				}
				num3 += genRand.Next(2);
				PlaceTile(num, num2, 91, mute: true, forced: false, -1, num3);
			}
		}
		return count;
	}

	private static double MakeDungeon_Pictures(int[] roomWall, double count)
	{
		count = 420000.0 / (double)Main.maxTilesX;
		for (int i = 0; (double)i < count; i++)
		{
			int num = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
			int num8 = genRand.Next((int)Main.worldSurface, GenVars.dMaxY);
			while (!Main.wallDungeon[Main.tile[num, num8].wall] || Main.tile[num, num8].active())
			{
				num = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
				num8 = genRand.Next((int)Main.worldSurface, GenVars.dMaxY);
			}
			int num9 = num;
			int num10 = num;
			int num11 = num8;
			int num12 = num8;
			int num13 = 0;
			int num14 = 0;
			for (int j = 0; j < 2; j++)
			{
				num9 = num;
				num10 = num;
				while (!Main.tile[num9, num8].active() && Main.wallDungeon[Main.tile[num9, num8].wall])
				{
					num9--;
				}
				num9++;
				for (; !Main.tile[num10, num8].active() && Main.wallDungeon[Main.tile[num10, num8].wall]; num10++)
				{
				}
				num10--;
				num = (num9 + num10) / 2;
				num11 = num8;
				num12 = num8;
				while (!Main.tile[num, num11].active() && Main.wallDungeon[Main.tile[num, num11].wall])
				{
					num11--;
				}
				num11++;
				for (; !Main.tile[num, num12].active() && Main.wallDungeon[Main.tile[num, num12].wall]; num12++)
				{
				}
				num12--;
				num8 = (num11 + num12) / 2;
			}
			num9 = num;
			num10 = num;
			while (!Main.tile[num9, num8].active() && !Main.tile[num9, num8 - 1].active() && !Main.tile[num9, num8 + 1].active())
			{
				num9--;
			}
			num9++;
			for (; !Main.tile[num10, num8].active() && !Main.tile[num10, num8 - 1].active() && !Main.tile[num10, num8 + 1].active(); num10++)
			{
			}
			num10--;
			num11 = num8;
			num12 = num8;
			while (!Main.tile[num, num11].active() && !Main.tile[num - 1, num11].active() && !Main.tile[num + 1, num11].active())
			{
				num11--;
			}
			num11++;
			for (; !Main.tile[num, num12].active() && !Main.tile[num - 1, num12].active() && !Main.tile[num + 1, num12].active(); num12++)
			{
			}
			num12--;
			num = (num9 + num10) / 2;
			num8 = (num11 + num12) / 2;
			num13 = num10 - num9;
			num14 = num12 - num11;
			if (num13 <= 7 || num14 <= 5)
			{
				continue;
			}
			bool[] array = new bool[3] { true, false, false };
			if (num13 > num14 * 3 && num13 > 21)
			{
				array[1] = true;
			}
			if (num14 > num13 * 3 && num14 > 21)
			{
				array[2] = true;
			}
			int num15 = genRand.Next(3);
			if (Main.tile[num, num8].wall == roomWall[0])
			{
				num15 = 0;
			}
			while (!array[num15])
			{
				num15 = genRand.Next(3);
			}
			if (nearPicture2(num, num8))
			{
				num15 = -1;
			}
			switch (num15)
			{
			case 0:
			{
				PaintingEntry paintingEntry2 = RandPictureTile();
				if (Main.tile[num, num8].wall != roomWall[0])
				{
					paintingEntry2 = RandBonePicture();
				}
				if (!nearPicture(num, num8))
				{
					PlaceTile(num, num8, paintingEntry2.tileType, mute: true, forced: false, -1, paintingEntry2.style);
				}
				break;
			}
			case 1:
			{
				PaintingEntry paintingEntry3 = RandPictureTile();
				if (Main.tile[num, num8].wall != roomWall[0])
				{
					paintingEntry3 = RandBonePicture();
				}
				if (!Main.tile[num, num8].active())
				{
					PlaceTile(num, num8, paintingEntry3.tileType, mute: true, forced: false, -1, paintingEntry3.style);
				}
				int num5 = num;
				int num6 = num8;
				int num7 = num8;
				for (int m = 0; m < 2; m++)
				{
					num += 7;
					num11 = num7;
					num12 = num7;
					while (!Main.tile[num, num11].active() && !Main.tile[num - 1, num11].active() && !Main.tile[num + 1, num11].active())
					{
						num11--;
					}
					num11++;
					for (; !Main.tile[num, num12].active() && !Main.tile[num - 1, num12].active() && !Main.tile[num + 1, num12].active(); num12++)
					{
					}
					num12--;
					num7 = (num11 + num12) / 2;
					paintingEntry3 = RandPictureTile();
					if (Main.tile[num, num7].wall != roomWall[0])
					{
						paintingEntry3 = RandBonePicture();
					}
					if (Math.Abs(num6 - num7) >= 4 || nearPicture(num, num7))
					{
						break;
					}
					PlaceTile(num, num7, paintingEntry3.tileType, mute: true, forced: false, -1, paintingEntry3.style);
				}
				num7 = num8;
				num = num5;
				for (int n = 0; n < 2; n++)
				{
					num -= 7;
					num11 = num7;
					num12 = num7;
					while (!Main.tile[num, num11].active() && !Main.tile[num - 1, num11].active() && !Main.tile[num + 1, num11].active())
					{
						num11--;
					}
					num11++;
					for (; !Main.tile[num, num12].active() && !Main.tile[num - 1, num12].active() && !Main.tile[num + 1, num12].active(); num12++)
					{
					}
					num12--;
					num7 = (num11 + num12) / 2;
					paintingEntry3 = RandPictureTile();
					if (Main.tile[num, num7].wall != roomWall[0])
					{
						paintingEntry3 = RandBonePicture();
					}
					if (Math.Abs(num6 - num7) >= 4 || nearPicture(num, num7))
					{
						break;
					}
					PlaceTile(num, num7, paintingEntry3.tileType, mute: true, forced: false, -1, paintingEntry3.style);
				}
				break;
			}
			case 2:
			{
				PaintingEntry paintingEntry = RandPictureTile();
				if (Main.tile[num, num8].wall != roomWall[0])
				{
					paintingEntry = RandBonePicture();
				}
				if (!Main.tile[num, num8].active())
				{
					PlaceTile(num, num8, paintingEntry.tileType, mute: true, forced: false, -1, paintingEntry.style);
				}
				int num2 = num8;
				int num3 = num;
				int num4 = num;
				for (int k = 0; k < 3; k++)
				{
					num8 += 7;
					num9 = num4;
					num10 = num4;
					while (!Main.tile[num9, num8].active() && !Main.tile[num9, num8 - 1].active() && !Main.tile[num9, num8 + 1].active())
					{
						num9--;
					}
					num9++;
					for (; !Main.tile[num10, num8].active() && !Main.tile[num10, num8 - 1].active() && !Main.tile[num10, num8 + 1].active(); num10++)
					{
					}
					num10--;
					num4 = (num9 + num10) / 2;
					paintingEntry = RandPictureTile();
					if (Main.tile[num4, num8].wall != roomWall[0])
					{
						paintingEntry = RandBonePicture();
					}
					if (Math.Abs(num3 - num4) >= 4 || nearPicture(num4, num8))
					{
						break;
					}
					PlaceTile(num4, num8, paintingEntry.tileType, mute: true, forced: false, -1, paintingEntry.style);
				}
				num4 = num;
				num8 = num2;
				for (int l = 0; l < 3; l++)
				{
					num8 -= 7;
					num9 = num4;
					num10 = num4;
					while (!Main.tile[num9, num8].active() && !Main.tile[num9, num8 - 1].active() && !Main.tile[num9, num8 + 1].active())
					{
						num9--;
					}
					num9++;
					for (; !Main.tile[num10, num8].active() && !Main.tile[num10, num8 - 1].active() && !Main.tile[num10, num8 + 1].active(); num10++)
					{
					}
					num10--;
					num4 = (num9 + num10) / 2;
					paintingEntry = RandPictureTile();
					if (Main.tile[num4, num8].wall != roomWall[0])
					{
						paintingEntry = RandBonePicture();
					}
					if (Math.Abs(num3 - num4) >= 4 || nearPicture(num4, num8))
					{
						break;
					}
					PlaceTile(num4, num8, paintingEntry.tileType, mute: true, forced: false, -1, paintingEntry.style);
				}
				break;
			}
			}
		}
		return count;
	}

	private static double MakeDungeon_GroundFurniture(int wallType)
	{
		double num = (double)(2000 * Main.maxTilesX) / 4200.0;
		int num12 = 1 + (int)((double)Main.maxTilesX / 4200.0);
		int num17 = 1 + (int)((double)Main.maxTilesX / 4200.0);
		for (int i = 0; (double)i < num; i++)
		{
			if (num12 > 0 || num17 > 0)
			{
				i--;
			}
			int num18 = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
			int j = genRand.Next((int)Main.worldSurface + 10, GenVars.dMaxY);
			Tile tile;
			while (true)
			{
				bool[] wallDungeon = Main.wallDungeon;
				tile = Main.tile[num18, j];
				if (wallDungeon[tile.wall])
				{
					tile = Main.tile[num18, j];
					if (!tile.active())
					{
						break;
					}
				}
				num18 = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
				j = genRand.Next((int)Main.worldSurface + 10, GenVars.dMaxY);
			}
			bool[] wallDungeon2 = Main.wallDungeon;
			tile = Main.tile[num18, j];
			if (!wallDungeon2[tile.wall])
			{
				continue;
			}
			tile = Main.tile[num18, j];
			if (tile.active())
			{
				continue;
			}
			for (; !SolidTile(num18, j) && j < Main.UnderworldLayer; j++)
			{
			}
			j--;
			int num19 = num18;
			int k = num18;
			while (true)
			{
				tile = Main.tile[num19, j];
				if (tile.active() || !SolidTile(num19, j + 1))
				{
					break;
				}
				num19--;
			}
			num19++;
			while (true)
			{
				tile = Main.tile[k, j];
				if (tile.active() || !SolidTile(k, j + 1))
				{
					break;
				}
				k++;
			}
			k--;
			int num20 = k - num19;
			int num21 = (k + num19) / 2;
			tile = Main.tile[num21, j];
			if (tile.active())
			{
				continue;
			}
			bool[] wallDungeon3 = Main.wallDungeon;
			tile = Main.tile[num21, j];
			if (!wallDungeon3[tile.wall] || !SolidTile(num21, j + 1))
			{
				continue;
			}
			tile = Main.tile[num21, j + 1];
			if (tile.type == 48)
			{
				continue;
			}
			int style = 13;
			int style2 = 10;
			int style3 = 11;
			int num22 = 1;
			int num23 = 46;
			int style4 = 1;
			int num2 = 5;
			int num3 = 11;
			int num4 = 5;
			int num5 = 6;
			int num6 = 21;
			int num7 = 22;
			int num8 = 24;
			int num9 = 30;
			switch (wallType)
			{
			case 8:
				style = 14;
				style2 = 11;
				style3 = 12;
				num22 = 2;
				num23 = 47;
				style4 = 2;
				num2 = 6;
				num3 = 12;
				num4 = 6;
				num5 = 7;
				num6 = 22;
				num7 = 23;
				num8 = 25;
				num9 = 31;
				break;
			case 9:
				style = 15;
				style2 = 12;
				style3 = 13;
				num22 = 3;
				num23 = 48;
				style4 = 3;
				num2 = 7;
				num3 = 13;
				num4 = 7;
				num5 = 8;
				num6 = 23;
				num7 = 24;
				num8 = 26;
				num9 = 32;
				break;
			}
			tile = Main.tile[num21, j];
			if (tile.wall >= 94)
			{
				tile = Main.tile[num21, j];
				if (tile.wall <= 105)
				{
					style = 17;
					style2 = 14;
					style3 = 15;
					num22 = -1;
					num23 = -1;
					style4 = 5;
					num2 = -1;
					num3 = -1;
					num4 = -1;
					num5 = -1;
					num6 = -1;
					num7 = -1;
					num8 = -1;
					num9 = -1;
				}
			}
			int num10 = genRand.Next(13);
			if ((num10 == 10 || num10 == 11 || num10 == 12) && genRand.Next(4) != 0)
			{
				num10 = genRand.Next(13);
			}
			while ((num10 == 2 && num23 == -1) || (num10 == 5 && num2 == -1) || (num10 == 6 && num3 == -1) || (num10 == 7 && num4 == -1) || (num10 == 8 && num5 == -1) || (num10 == 9 && num6 == -1) || (num10 == 10 && num7 == -1) || (num10 == 11 && num8 == -1) || (num10 == 12 && num9 == -1))
			{
				num10 = genRand.Next(13);
			}
			int num11 = 0;
			int num13 = 0;
			if (num10 == 0)
			{
				num11 = 5;
				num13 = 4;
			}
			if (num10 == 1)
			{
				num11 = 4;
				num13 = 3;
			}
			if (num10 == 2)
			{
				num11 = 3;
				num13 = 5;
			}
			if (num10 == 3)
			{
				num11 = 4;
				num13 = 6;
			}
			if (num10 == 4)
			{
				num11 = 3;
				num13 = 3;
			}
			if (num10 == 5)
			{
				num11 = 5;
				num13 = 3;
			}
			if (num10 == 6)
			{
				num11 = 5;
				num13 = 4;
			}
			if (num10 == 7)
			{
				num11 = 5;
				num13 = 4;
			}
			if (num10 == 8)
			{
				num11 = 5;
				num13 = 4;
			}
			if (num10 == 9)
			{
				num11 = 5;
				num13 = 3;
			}
			if (num10 == 10)
			{
				num11 = 2;
				num13 = 4;
			}
			if (num10 == 11)
			{
				num11 = 3;
				num13 = 3;
			}
			if (num10 == 12)
			{
				num11 = 2;
				num13 = 5;
			}
			for (int l = num21 - num11; l <= num21 + num11; l++)
			{
				for (int m = j - num13; m <= j; m++)
				{
					tile = Main.tile[l, m];
					if (tile.active())
					{
						num10 = -1;
						break;
					}
				}
			}
			if ((double)num20 < (double)num11 * 1.75)
			{
				num10 = -1;
			}
			if (num12 > 0 || num17 > 0)
			{
				if (num12 > 0)
				{
					PlaceTile(num21, j, 355, mute: true);
					tile = Main.tile[num21, j];
					if (tile.type == 355)
					{
						num12--;
					}
				}
				else if (num17 > 0)
				{
					PlaceTile(num21, j, 354, mute: true);
					tile = Main.tile[num21, j];
					if (tile.type == 354)
					{
						num17--;
					}
				}
				continue;
			}
			switch (num10)
			{
			case 0:
			{
				PlaceTile(num21, j, 14, mute: true, forced: false, -1, style2);
				tile = Main.tile[num21, j];
				if (tile.active())
				{
					tile = Main.tile[num21 - 2, j];
					if (!tile.active())
					{
						PlaceTile(num21 - 2, j, 15, mute: true, forced: false, -1, style);
						tile = Main.tile[num21 - 2, j];
						if (tile.active())
						{
							tile = Main.tile[num21 - 2, j];
							tile.frameX += 18;
							tile = Main.tile[num21 - 2, j - 1];
							tile.frameX += 18;
						}
					}
					tile = Main.tile[num21 + 2, j];
					if (!tile.active())
					{
						PlaceTile(num21 + 2, j, 15, mute: true, forced: false, -1, style);
					}
				}
				for (int num15 = num21 - 1; num15 <= num21 + 1; num15++)
				{
					if (genRand.Next(2) != 0)
					{
						continue;
					}
					tile = Main.tile[num15, j - 2];
					if (tile.active())
					{
						continue;
					}
					int num16 = genRand.Next(5);
					if (num22 != -1 && num16 <= 1)
					{
						bool[] tileLighted3 = Main.tileLighted;
						tile = Main.tile[num15 - 1, j - 2];
						if (!tileLighted3[tile.type])
						{
							PlaceTile(num15, j - 2, 33, mute: true, forced: false, -1, num22);
						}
					}
					if (num16 == 2)
					{
						bool[] tileLighted4 = Main.tileLighted;
						tile = Main.tile[num15 - 1, j - 2];
						if (!tileLighted4[tile.type])
						{
							PlaceTile(num15, j - 2, 49, mute: true);
						}
					}
					if (num16 == 3)
					{
						PlaceTile(num15, j - 2, 50, mute: true);
					}
					if (num16 == 4)
					{
						PlaceTile(num15, j - 2, 103, mute: true);
					}
				}
				break;
			}
			case 1:
			{
				PlaceTile(num21, j, 18, mute: true, forced: false, -1, style3);
				tile = Main.tile[num21, j];
				if (!tile.active())
				{
					break;
				}
				if (genRand.Next(2) == 0)
				{
					tile = Main.tile[num21 - 1, j];
					if (!tile.active())
					{
						PlaceTile(num21 - 1, j, 15, mute: true, forced: false, -1, style);
						tile = Main.tile[num21 - 1, j];
						if (tile.active())
						{
							tile = Main.tile[num21 - 1, j];
							tile.frameX += 18;
							tile = Main.tile[num21 - 1, j - 1];
							tile.frameX += 18;
						}
					}
				}
				else
				{
					tile = Main.tile[num21 + 2, j];
					if (!tile.active())
					{
						PlaceTile(num21 + 2, j, 15, mute: true, forced: false, -1, style);
					}
				}
				for (int n = num21; n <= num21 + 1; n++)
				{
					if (genRand.Next(2) != 0)
					{
						continue;
					}
					tile = Main.tile[n, j - 1];
					if (tile.active())
					{
						continue;
					}
					int num14 = genRand.Next(5);
					if (num22 != -1 && num14 <= 1)
					{
						bool[] tileLighted = Main.tileLighted;
						tile = Main.tile[n - 1, j - 1];
						if (!tileLighted[tile.type])
						{
							PlaceTile(n, j - 1, 33, mute: true, forced: false, -1, num22);
						}
					}
					if (num14 == 2)
					{
						bool[] tileLighted2 = Main.tileLighted;
						tile = Main.tile[n - 1, j - 1];
						if (!tileLighted2[tile.type])
						{
							PlaceTile(n, j - 1, 49, mute: true);
						}
					}
					if (num14 == 3)
					{
						PlaceTile(n, j - 1, 50, mute: true);
					}
					if (num14 == 4)
					{
						PlaceTile(n, j - 1, 103, mute: true);
					}
				}
				break;
			}
			case 2:
				PlaceTile(num21, j, 105, mute: true, forced: false, -1, num23);
				break;
			case 3:
				PlaceTile(num21, j, 101, mute: true, forced: false, -1, style4);
				break;
			case 4:
				if (genRand.Next(2) == 0)
				{
					PlaceTile(num21, j, 15, mute: true, forced: false, -1, style);
					tile = Main.tile[num21, j];
					tile.frameX += 18;
					tile = Main.tile[num21, j - 1];
					tile.frameX += 18;
				}
				else
				{
					PlaceTile(num21, j, 15, mute: true, forced: false, -1, style);
				}
				break;
			case 5:
				if (genRand.Next(2) == 0)
				{
					Place4x2(num21, j, 79, 1, num2);
				}
				else
				{
					Place4x2(num21, j, 79, -1, num2);
				}
				break;
			case 6:
				PlaceTile(num21, j, 87, mute: true, forced: false, -1, num3);
				break;
			case 7:
				PlaceTile(num21, j, 88, mute: true, forced: false, -1, num4);
				break;
			case 8:
				PlaceTile(num21, j, 89, mute: true, forced: false, -1, num5);
				break;
			case 9:
				if (genRand.Next(2) == 0)
				{
					Place4x2(num21, j, 90, 1, num6);
				}
				else
				{
					Place4x2(num21, j, 90, -1, num6);
				}
				break;
			case 10:
				PlaceTile(num21, j, 93, mute: true, forced: false, -1, num8);
				break;
			case 11:
				PlaceTile(num21, j, 100, mute: true, forced: false, -1, num7);
				break;
			case 12:
				PlaceTile(num21, j, 104, mute: true, forced: false, -1, num9);
				break;
			}
		}
		return num;
	}

	public static PaintingEntry RandBonePicture()
	{
		int num = genRand.Next(2);
		int num2 = 0;
		switch (num)
		{
		case 0:
			num = 240;
			num2 = genRand.Next(2);
			switch (num2)
			{
			case 0:
				num2 = 16;
				break;
			case 1:
				num2 = 17;
				break;
			}
			break;
		case 1:
			num = 241;
			num2 = genRand.Next(9);
			break;
		}
		PaintingEntry result = default(PaintingEntry);
		result.tileType = num;
		result.style = num2;
		return result;
	}

	public static PaintingEntry RandHellPicture()
	{
		int num = genRand.Next(4);
		int num2 = 0;
		if (num == 1)
		{
			num = genRand.Next(4);
		}
		switch (num)
		{
		case 0:
			num = 240;
			num2 = genRand.Next(5);
			switch (num2)
			{
			case 0:
				num2 = 27;
				break;
			case 1:
				num2 = 29;
				break;
			case 2:
				num2 = 30;
				break;
			case 3:
				num2 = 31;
				break;
			case 4:
				num2 = 32;
				break;
			}
			break;
		case 1:
			num = 242;
			num2 = 14;
			break;
		case 2:
			num = 245;
			num2 = genRand.Next(3);
			switch (num2)
			{
			case 0:
				num2 = 1;
				break;
			case 1:
				num2 = 2;
				break;
			case 2:
				num2 = 4;
				break;
			}
			break;
		default:
			num = 246;
			num2 = genRand.Next(3);
			switch (num2)
			{
			case 0:
				num2 = 0;
				break;
			case 1:
				num2 = 16;
				break;
			case 2:
				num2 = 17;
				break;
			}
			break;
		}
		PaintingEntry result = default(PaintingEntry);
		result.tileType = num;
		result.style = num2;
		return result;
	}

	public static PaintingEntry RandHousePictureDesert()
	{
		int num = genRand.Next(4);
		int num2 = 0;
		if (num <= 1)
		{
			num = 240;
			int maxValue = 6;
			num2 = 63 + genRand.Next(maxValue);
		}
		else if (num == 2)
		{
			num = 245;
			int maxValue2 = 2;
			num2 = 7 + genRand.Next(maxValue2);
		}
		else
		{
			num = 242;
			int maxValue3 = 6;
			num2 = 37 + genRand.Next(maxValue3);
		}
		PaintingEntry result = default(PaintingEntry);
		result.tileType = num;
		result.style = num2;
		return result;
	}

	public static PaintingEntry RandHousePicture()
	{
		int num = genRand.Next(4);
		int num2 = 0;
		if (num >= 3 && genRand.Next(2) != 0)
		{
			num = genRand.Next(3);
		}
		if (num <= 1)
		{
			num = 240;
			int maxValue = 15;
			num2 = genRand.Next(maxValue);
			switch (num2)
			{
			case 0:
				num2 = 26;
				break;
			case 1:
				num2 = 28;
				break;
			case 2:
				num2 = 20;
				break;
			case 3:
				num2 = 21;
				break;
			case 4:
				num2 = 22;
				break;
			case 5:
				num2 = 24;
				break;
			case 6:
				num2 = 25;
				break;
			case 7:
				num2 = 33;
				break;
			case 8:
				num2 = 34;
				break;
			case 9:
				num2 = 35;
				break;
			case 10:
				num2 = 76;
				break;
			case 11:
				num2 = 77;
				break;
			case 12:
				num2 = 78;
				break;
			case 13:
				num2 = 79;
				break;
			case 14:
				num2 = 82;
				break;
			}
		}
		else if (num == 2)
		{
			int maxValue2 = 9;
			num = 245;
			num2 = genRand.Next(maxValue2);
			if (num2 == 0 && genRand.Next(3) != 0)
			{
				num2 = genRand.Next(maxValue2);
			}
			switch (num2)
			{
			case 0:
				num2 = 0;
				break;
			case 1:
				num2 = 3;
				break;
			case 2:
				num2 = 5;
				break;
			case 3:
				num2 = 6;
				break;
			case 4:
				num2 = 14;
				break;
			case 5:
			{
				int num3 = genRand.Next(4);
				if (num3 == 0)
				{
					num2 = 15;
				}
				if (num3 == 1)
				{
					num2 = 16;
				}
				if (num3 == 2)
				{
					num2 = 17;
				}
				if (num3 == 3)
				{
					num2 = 18;
				}
				break;
			}
			case 6:
				num2 = 19;
				break;
			case 7:
				num2 = 20;
				break;
			case 8:
				num2 = 21;
				break;
			}
		}
		else
		{
			num = 246;
			int maxValue3 = 8;
			num2 = genRand.Next(maxValue3);
			switch (num2)
			{
			case 0:
				num2 = 1;
				break;
			case 1:
				num2 = 30;
				break;
			case 2:
				num2 = 31;
				break;
			case 3:
				num2 = 32;
				break;
			case 4:
				num2 = 33;
				break;
			case 5:
				num2 = 34;
				break;
			case 6:
				num2 = 35;
				break;
			case 7:
				num2 = 36;
				break;
			}
		}
		PaintingEntry result = default(PaintingEntry);
		result.tileType = num;
		result.style = num2;
		return result;
	}

	public static PaintingEntry RandPictureTile()
	{
		int num = genRand.Next(3);
		int num2 = 0;
		if (num <= 1)
		{
			int maxValue = 7;
			num = 240;
			num2 = genRand.Next(maxValue);
			if (num2 == 6)
			{
				num2 = genRand.Next(maxValue);
			}
			switch (num2)
			{
			case 0:
				num2 = 12;
				break;
			case 1:
				num2 = 13;
				break;
			case 2:
				num2 = 14;
				break;
			case 3:
				num2 = 15;
				break;
			case 4:
				num2 = 18;
				break;
			case 5:
				num2 = 19;
				break;
			case 6:
				num2 = 23;
				break;
			}
		}
		else if (num == 2)
		{
			num = 242;
			int maxValue2 = 17;
			num2 = genRand.Next(maxValue2);
			switch (num2)
			{
			case 14:
				num2 = 15;
				break;
			case 15:
				num2 = 16;
				break;
			case 16:
				num2 = 30;
				break;
			}
		}
		PaintingEntry result = default(PaintingEntry);
		result.tileType = num;
		result.style = num2;
		return result;
	}

	public static void DungeonStairs(int i, int j, ushort tileType, int wallType)
	{
		Vector2D zero = Vector2D.Zero;
		double num = genRand.Next(5, 9);
		int num6 = 1;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		int num7 = genRand.Next(10, 30);
		num6 = ((i <= GenVars.dEnteranceX) ? 1 : (-1));
		if (i > Main.maxTilesX - 400)
		{
			num6 = -1;
		}
		else if (i < 400)
		{
			num6 = 1;
		}
		zero.Y = -1.0;
		zero.X = num6;
		if (genRand.Next(3) != 0)
		{
			zero.X *= 1.0 + (double)genRand.Next(0, 200) * 0.01;
		}
		else if (genRand.Next(3) == 0)
		{
			zero.X *= (double)genRand.Next(50, 76) * 0.01;
		}
		else if (genRand.Next(6) == 0)
		{
			zero.Y *= 2.0;
		}
		if (GenVars.dungeonX < Main.maxTilesX / 2 && zero.X < 0.0 && zero.X < 0.5)
		{
			zero.X = -0.5;
		}
		if (GenVars.dungeonX > Main.maxTilesX / 2 && zero.X > 0.0 && zero.X > 0.5)
		{
			zero.X = -0.5;
		}
		if (drunkWorldGen)
		{
			num6 *= -1;
			zero.X *= -1.0;
		}
		while (num7 > 0)
		{
			num7--;
			int num8 = (int)(vector2D.X - num - 4.0 - (double)genRand.Next(6));
			int num9 = (int)(vector2D.X + num + 4.0 + (double)genRand.Next(6));
			int num10 = (int)(vector2D.Y - num - 4.0);
			int num11 = (int)(vector2D.Y + num + 4.0 + (double)genRand.Next(6));
			if (num8 < 0)
			{
				num8 = 0;
			}
			if (num9 > Main.maxTilesX)
			{
				num9 = Main.maxTilesX;
			}
			if (num10 < 0)
			{
				num10 = 0;
			}
			if (num11 > Main.maxTilesY)
			{
				num11 = Main.maxTilesY;
			}
			int num12 = 1;
			if (vector2D.X > (double)(Main.maxTilesX / 2))
			{
				num12 = -1;
			}
			int num13 = (int)(vector2D.X + GenVars.dxStrength1 * 0.6 * (double)num12 + GenVars.dxStrength2 * (double)num12);
			int num2 = (int)(GenVars.dyStrength2 * 0.5);
			if (vector2D.Y < Main.worldSurface - 5.0 && Main.tile[num13, (int)(vector2D.Y - num - 6.0 + (double)num2)].wall == 0 && Main.tile[num13, (int)(vector2D.Y - num - 7.0 + (double)num2)].wall == 0 && Main.tile[num13, (int)(vector2D.Y - num - 8.0 + (double)num2)].wall == 0)
			{
				GenVars.dSurface = true;
				TileRunner(num13, (int)(vector2D.Y - num - 6.0 + (double)num2), genRand.Next(25, 35), genRand.Next(10, 20), -1, addTile: false, 0.0, -1.0);
			}
			for (int k = num8; k < num9; k++)
			{
				for (int l = num10; l < num11; l++)
				{
					Main.tile[k, l].liquid = 0;
					if (!Main.wallDungeon[Main.tile[k, l].wall])
					{
						Main.tile[k, l].wall = 0;
						Main.tile[k, l].active(active: true);
						Main.tile[k, l].type = tileType;
					}
				}
			}
			for (int m = num8 + 1; m < num9 - 1; m++)
			{
				for (int n = num10 + 1; n < num11 - 1; n++)
				{
					Main.tile[m, n].wall = (ushort)wallType;
				}
			}
			int num3 = 0;
			if (genRand.Next((int)num) == 0)
			{
				num3 = genRand.Next(1, 3);
			}
			num8 = (int)(vector2D.X - num * 0.5 - (double)num3);
			num9 = (int)(vector2D.X + num * 0.5 + (double)num3);
			num10 = (int)(vector2D.Y - num * 0.5 - (double)num3);
			num11 = (int)(vector2D.Y + num * 0.5 + (double)num3);
			if (num8 < 0)
			{
				num8 = 0;
			}
			if (num9 > Main.maxTilesX)
			{
				num9 = Main.maxTilesX;
			}
			if (num10 < 0)
			{
				num10 = 0;
			}
			if (num11 > Main.maxTilesY)
			{
				num11 = Main.maxTilesY;
			}
			for (int num4 = num8; num4 < num9; num4++)
			{
				for (int num5 = num10; num5 < num11; num5++)
				{
					Main.tile[num4, num5].active(active: false);
					PlaceWall(num4, num5, wallType, mute: true);
				}
			}
			if (GenVars.dSurface)
			{
				num7 = 0;
			}
			vector2D += zero;
			if (vector2D.Y < Main.worldSurface)
			{
				zero.Y *= 0.98;
			}
		}
		GenVars.dungeonX = (int)vector2D.X;
		GenVars.dungeonY = (int)vector2D.Y;
	}

	public static bool PlaceSandTrap(int i, int j)
	{
		int num = 6;
		int num12 = 4;
		int num16 = 25;
		int k;
		for (k = j; !Main.tile[i, k].active() && k < Main.UnderworldLayer; k++)
		{
		}
		if (!Main.tileSolid[Main.tile[i, k].type] || Main.tile[i, k].halfBrick() || Main.tile[i, k].topSlope())
		{
			return false;
		}
		if ((Main.tile[i, k].type != 53 && Main.tile[i, k].type != 397 && Main.tile[i, k].type != 396) || (Main.tile[i, k].wall != 216 && Main.tile[i, k].wall != 187))
		{
			return false;
		}
		k--;
		int num17 = -1;
		int num18 = genRand.Next(6, 12);
		int num19 = genRand.Next(6, 14);
		for (int l = i - num16; l <= i + num16; l++)
		{
			for (int m = k - num16; m < k + num16; m++)
			{
				if (Main.tile[l, m].wire())
				{
					return false;
				}
				if (TileID.Sets.BasicChest[Main.tile[l, m].type])
				{
					return false;
				}
				if (TileID.Sets.Paintings[Main.tile[l, m].type])
				{
					return false;
				}
				if (Main.tile[l, m].type == 10)
				{
					return false;
				}
				if (Main.tile[l, m].type == 19)
				{
					return false;
				}
				if (Main.tile[l, m].type == 15)
				{
					return false;
				}
				if (Main.tile[l, m].type == 219)
				{
					return false;
				}
			}
		}
		for (int n = i - 2; n <= i + 2; n++)
		{
			for (int num20 = k + 1; num20 <= k + 3; num20++)
			{
				if (!Main.tile[n, num20].active() || !Main.tileSolid[Main.tile[n, num20].type])
				{
					return false;
				}
			}
		}
		if (Main.tile[i, k + 1].type == 162)
		{
			return false;
		}
		for (int num21 = k; num21 > k - 30; num21--)
		{
			if (Main.tile[i, num21].active())
			{
				if (Main.tile[i, num21].type == 396)
				{
					num17 = num21;
					break;
				}
				return false;
			}
		}
		if (num17 <= -1)
		{
			return false;
		}
		if (k - num17 < num19 + num12)
		{
			return false;
		}
		int num22 = 0;
		int num2 = (k + num17) / 2;
		for (int num3 = i - num18; num3 <= i + num18; num3++)
		{
			if (Main.tile[num3, num2].active() && Main.tileSolid[Main.tile[num3, num2].type])
			{
				return false;
			}
			for (int num4 = num17 - num19; num4 <= num17; num4++)
			{
				if (Main.tile[num3, num4].active())
				{
					if (TileID.Sets.Ore[Main.tile[num3, num4].type] || Main.tile[num3, num4].type == 404)
					{
						return false;
					}
					if (Main.tileSolid[Main.tile[num3, num4].type])
					{
						num22++;
					}
				}
			}
		}
		double num5 = (double)((num18 * 2 + 1) * (num19 + 1)) * 0.75;
		if ((double)num22 < num5)
		{
			return false;
		}
		for (int num6 = i - num18 - 1; num6 <= i + num18 + 1; num6++)
		{
			for (int num7 = num17 - num19; num7 <= num17; num7++)
			{
				bool flag = false;
				if (Main.tile[num6, num7].active() && Main.tileSolid[Main.tile[num6, num7].type])
				{
					flag = true;
				}
				if (num7 == num17)
				{
					Main.tile[num6, num7].slope(0);
					Main.tile[num6, num7].halfBrick(halfBrick: false);
					if (!flag)
					{
						Main.tile[num6, num7].active(active: true);
						Main.tile[num6, num7].type = 396;
					}
				}
				else if (num7 == num17 - num19)
				{
					Main.tile[num6, num7].ClearTile();
					Main.tile[num6, num7].active(active: true);
					if (flag && Main.tile[num6, num7 - 1].active() && Main.tileSolid[Main.tile[num6, num7 - 1].type])
					{
						Main.tile[num6, num7].type = 397;
					}
					else
					{
						Main.tile[num6, num7].type = 396;
					}
				}
				else if (num6 == i - num18 - 1 || num6 == i + num18 + 1)
				{
					if (!flag)
					{
						Main.tile[num6, num7].ClearTile();
						Main.tile[num6, num7].active(active: true);
						Main.tile[num6, num7].type = 396;
					}
					else
					{
						Main.tile[num6, num7].slope(0);
						Main.tile[num6, num7].halfBrick(halfBrick: false);
					}
				}
				else
				{
					Main.tile[num6, num7].ClearTile();
					Main.tile[num6, num7].active(active: true);
					Main.tile[num6, num7].type = 53;
				}
			}
		}
		for (int num8 = (int)((double)num17 - (double)num19 * 0.666); (double)num8 <= (double)num17 - (double)num19 * 0.333; num8++)
		{
			if ((double)num8 < (double)num17 - (double)num19 * 0.4)
			{
				if (Main.tile[i - num18 - 2, num8].bottomSlope())
				{
					Main.tile[i - num18 - 2, num8].slope(0);
				}
			}
			else if ((double)num8 > (double)num17 - (double)num19 * 0.6)
			{
				if (Main.tile[i - num18 - 2, num8].topSlope())
				{
					Main.tile[i - num18 - 2, num8].slope(0);
				}
				Main.tile[i - num18 - 2, num8].halfBrick(halfBrick: false);
			}
			else
			{
				Main.tile[i - num18 - 2, num8].halfBrick(halfBrick: false);
				Main.tile[i - num18 - 2, num8].slope(0);
			}
			if (!Main.tile[i - num18 - 2, num8].active() || !Main.tileSolid[Main.tile[i - num18 - 2, num8].type])
			{
				Main.tile[i - num18 - 2, num8].active(active: true);
				Main.tile[i - num18 - 2, num8].type = 396;
			}
			if (!Main.tile[i + num18 + 2, num8].active() || !Main.tileSolid[Main.tile[i + num18 + 2, num8].type])
			{
				Main.tile[i + num18 + 2, num8].active(active: true);
				Main.tile[i + num18 + 2, num8].type = 396;
			}
		}
		for (int num9 = num17 - num19; num9 <= num17; num9++)
		{
			Main.tile[i - num18 - 2, num9].slope(0);
			Main.tile[i - num18 - 2, num9].halfBrick(halfBrick: false);
			Main.tile[i - num18 - 1, num9].slope(0);
			Main.tile[i - num18 - 1, num9].halfBrick(halfBrick: false);
			Main.tile[i - num18 + 1, num9].slope(0);
			Main.tile[i - num18 + 1, num9].halfBrick(halfBrick: false);
			Main.tile[i - num18 + 2, num9].slope(0);
			Main.tile[i - num18 + 2, num9].halfBrick(halfBrick: false);
		}
		for (int num10 = i - num18 - 1; num10 < i + num18 + 1; num10++)
		{
			int num11 = k - num19 - 1;
			if (Main.tile[num10, num11].bottomSlope())
			{
				Main.tile[num10, num11].slope(0);
			}
			Main.tile[num10, num11].halfBrick(halfBrick: false);
		}
		KillTile(i - 2, k);
		KillTile(i - 1, k);
		KillTile(i + 1, k);
		KillTile(i + 2, k);
		PlaceTile(i, k, 135, mute: true, forced: false, -1, 7);
		for (int num13 = i - num18; num13 <= i + num18; num13++)
		{
			int num14 = k;
			if ((double)num13 < (double)i - (double)num18 * 0.8 || (double)num13 > (double)i + (double)num18 * 0.8)
			{
				num14 = k - 3;
			}
			else if ((double)num13 < (double)i - (double)num18 * 0.6 || (double)num13 > (double)i + (double)num18 * 0.6)
			{
				num14 = k - 2;
			}
			else if ((double)num13 < (double)i - (double)num18 * 0.4 || (double)num13 > (double)i + (double)num18 * 0.4)
			{
				num14 = k - 1;
			}
			for (int num15 = num17; num15 <= k; num15++)
			{
				if (num13 == i && num15 <= k)
				{
					Main.tile[i, num15].wire(wire: true);
				}
				if (Main.tile[num13, num15].active() && Main.tileSolid[Main.tile[num13, num15].type])
				{
					if (num15 < num17 + num - 4)
					{
						Main.tile[num13, num15].actuator(actuator: true);
						Main.tile[num13, num15].wire(wire: true);
					}
					else if (num15 < num14)
					{
						KillTile(num13, num15);
					}
				}
			}
		}
		return true;
	}

	public static bool DungeonPitTrap(int i, int j, ushort tileType, int wallType)
	{
		int num = 30;
		int num7 = j;
		int num8 = num7;
		int num9 = genRand.Next(8, 19);
		int num10 = genRand.Next(19, 46);
		int num11 = num9 + genRand.Next(6, 10);
		int num12 = num10 + genRand.Next(6, 10);
		if (!Main.wallDungeon[Main.tile[i, num7].wall])
		{
			return false;
		}
		if (Main.tile[i, num7].active())
		{
			return false;
		}
		for (int k = num7; k < Main.maxTilesY; k++)
		{
			if (k > Main.maxTilesY - 300)
			{
				return false;
			}
			if (Main.tile[i, k].active() && SolidTile(i, k))
			{
				if (Main.tile[i, k].type == 48)
				{
					return false;
				}
				num7 = k;
				break;
			}
		}
		if (!Main.wallDungeon[Main.tile[i - num9, num7].wall] || !Main.wallDungeon[Main.tile[i + num9, num7].wall])
		{
			return false;
		}
		bool flag = true;
		for (int l = num7; l < num7 + num; l++)
		{
			flag = true;
			for (int m = i - num9; m <= i + num9; m++)
			{
				Tile tile = Main.tile[m, l];
				if (tile.active() && Main.tileDungeon[tile.type])
				{
					flag = false;
				}
			}
			if (flag)
			{
				num7 = l;
				break;
			}
		}
		for (int n = i - num9; n <= i + num9; n++)
		{
			for (int num13 = num7; num13 <= num7 + num10; num13++)
			{
				Tile tile2 = Main.tile[n, num13];
				if (tile2.active() && (Main.tileDungeon[tile2.type] || tile2.type == GenVars.crackedType))
				{
					return false;
				}
			}
		}
		bool flag2 = false;
		if (GenVars.dungeonLake)
		{
			flag2 = true;
			GenVars.dungeonLake = false;
		}
		else if (genRand.Next(8) == 0)
		{
			flag2 = true;
		}
		for (int num14 = i - num9; num14 <= i + num9; num14++)
		{
			for (int num2 = num8; num2 <= num7 + num10; num2++)
			{
				if (Main.tileDungeon[Main.tile[num14, num2].type])
				{
					Main.tile[num14, num2].type = GenVars.crackedType;
					Main.tile[num14, num2].wall = (ushort)wallType;
				}
			}
		}
		for (int num3 = i - num11; num3 <= i + num11; num3++)
		{
			for (int num4 = num8; num4 <= num7 + num12; num4++)
			{
				Main.tile[num3, num4].lava(lava: false);
				Main.tile[num3, num4].liquid = 0;
				if (!Main.wallDungeon[Main.tile[num3, num4].wall] && Main.tile[num3, num4].type != GenVars.crackedType)
				{
					Main.tile[num3, num4].Clear(TileDataType.Slope);
					Main.tile[num3, num4].type = tileType;
					Main.tile[num3, num4].active(active: true);
					if (num3 > i - num11 && num3 < i + num11 && num4 < num7 + num12)
					{
						Main.tile[num3, num4].wall = (ushort)wallType;
					}
				}
			}
		}
		for (int num5 = i - num9; num5 <= i + num9; num5++)
		{
			for (int num6 = num8; num6 <= num7 + num10; num6++)
			{
				if (Main.tile[num5, num6].type != GenVars.crackedType)
				{
					if (flag2)
					{
						Main.tile[num5, num6].liquid = byte.MaxValue;
					}
					if (num5 == i - num9 || num5 == i + num9 || num6 == num7 + num10)
					{
						Main.tile[num5, num6].type = 48;
					}
					else if ((num5 == i - num9 + 1 && num6 % 2 == 0) || (num5 == i + num9 - 1 && num6 % 2 == 0) || (num6 == num7 + num10 - 1 && num5 % 2 == 0))
					{
						Main.tile[num5, num6].type = 48;
					}
					else
					{
						Main.tile[num5, num6].active(active: false);
					}
				}
			}
		}
		return true;
	}

	public static void DungeonHalls(int i, int j, ushort tileType, int wallType, bool forceX = false)
	{
		Vector2D zero = Vector2D.Zero;
		double num = genRand.Next(4, 6);
		double num11 = num;
		Vector2D zero2 = Vector2D.Zero;
		Vector2D zero3 = Vector2D.Zero;
		int num12 = 1;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		int num13 = genRand.Next(35, 80);
		bool flag = false;
		if (genRand.Next(6) == 0)
		{
			flag = true;
		}
		if (forceX)
		{
			num13 += 20;
			GenVars.lastDungeonHall = Vector2D.Zero;
		}
		else if (genRand.Next(5) == 0)
		{
			num *= 2.0;
			num13 /= 2;
		}
		bool flag4 = false;
		bool flag5 = false;
		bool flag6 = true;
		bool flag7 = false;
		while (!flag4)
		{
			flag7 = false;
			if (flag6 && !forceX)
			{
				bool flag8 = true;
				bool flag9 = true;
				bool flag10 = true;
				bool flag11 = true;
				int num14 = num13;
				bool flag2 = false;
				for (int num15 = j; num15 > j - num14; num15--)
				{
					if (Main.tile[i, num15].wall == wallType)
					{
						if (flag2)
						{
							flag8 = false;
							break;
						}
					}
					else
					{
						flag2 = true;
					}
				}
				flag2 = false;
				for (int k = j; k < j + num14; k++)
				{
					if (Main.tile[i, k].wall == wallType)
					{
						if (flag2)
						{
							flag9 = false;
							break;
						}
					}
					else
					{
						flag2 = true;
					}
				}
				flag2 = false;
				for (int num16 = i; num16 > i - num14; num16--)
				{
					if (Main.tile[num16, j].wall == wallType)
					{
						if (flag2)
						{
							flag10 = false;
							break;
						}
					}
					else
					{
						flag2 = true;
					}
				}
				flag2 = false;
				for (int l = i; l < i + num14; l++)
				{
					if (Main.tile[l, j].wall == wallType)
					{
						if (flag2)
						{
							flag11 = false;
							break;
						}
					}
					else
					{
						flag2 = true;
					}
				}
				if (!flag10 && !flag11 && !flag8 && !flag9)
				{
					num12 = ((genRand.Next(2) != 0) ? 1 : (-1));
					if (genRand.Next(2) == 0)
					{
						flag7 = true;
					}
				}
				else
				{
					int num17 = genRand.Next(4);
					do
					{
						num17 = genRand.Next(4);
					}
					while (!(num17 == 0 && flag8) && !(num17 == 1 && flag9) && !(num17 == 2 && flag10) && !(num17 == 3 && flag11));
					switch (num17)
					{
					case 0:
						num12 = -1;
						break;
					case 1:
						num12 = 1;
						break;
					default:
						flag7 = true;
						num12 = ((num17 != 2) ? 1 : (-1));
						break;
					}
				}
			}
			else
			{
				num12 = ((genRand.Next(2) != 0) ? 1 : (-1));
				if (genRand.Next(2) == 0)
				{
					flag7 = true;
				}
			}
			flag6 = false;
			if (forceX)
			{
				flag7 = true;
			}
			if (flag7)
			{
				zero2.Y = 0.0;
				zero2.X = num12;
				zero3.Y = 0.0;
				zero3.X = -num12;
				zero.Y = 0.0;
				zero.X = num12;
				if (genRand.Next(3) == 0)
				{
					if (genRand.Next(2) == 0)
					{
						zero.Y = -0.2;
					}
					else
					{
						zero.Y = 0.2;
					}
				}
			}
			else
			{
				num += 1.0;
				zero.Y = num12;
				zero.X = 0.0;
				zero2.X = 0.0;
				zero2.Y = num12;
				zero3.X = 0.0;
				zero3.Y = -num12;
				if (genRand.Next(3) != 0)
				{
					flag5 = true;
					if (genRand.Next(2) == 0)
					{
						zero.X = (double)genRand.Next(10, 20) * 0.1;
					}
					else
					{
						zero.X = (double)(-genRand.Next(10, 20)) * 0.1;
					}
				}
				else if (genRand.Next(2) == 0)
				{
					if (genRand.Next(2) == 0)
					{
						zero.X = (double)genRand.Next(20, 40) * 0.01;
					}
					else
					{
						zero.X = (double)(-genRand.Next(20, 40)) * 0.01;
					}
				}
				else
				{
					num13 /= 2;
				}
			}
			if (GenVars.lastDungeonHall != zero3)
			{
				flag4 = true;
			}
		}
		int num18 = 0;
		bool flag3 = vector2D.Y < Main.rockLayer + 100.0;
		if (remixWorldGen)
		{
			flag3 = vector2D.Y < Main.worldSurface + 100.0;
		}
		if (!forceX)
		{
			if (vector2D.X > (double)(lastMaxTilesX - 200))
			{
				num12 = -1;
				zero2.Y = 0.0;
				zero2.X = num12;
				zero.Y = 0.0;
				zero.X = num12;
				if (genRand.Next(3) == 0)
				{
					if (genRand.Next(2) == 0)
					{
						zero.Y = -0.2;
					}
					else
					{
						zero.Y = 0.2;
					}
				}
			}
			else if (vector2D.X < 200.0)
			{
				num12 = 1;
				zero2.Y = 0.0;
				zero2.X = num12;
				zero.Y = 0.0;
				zero.X = num12;
				if (genRand.Next(3) == 0)
				{
					if (genRand.Next(2) == 0)
					{
						zero.Y = -0.2;
					}
					else
					{
						zero.Y = 0.2;
					}
				}
			}
			else if (vector2D.Y > (double)(lastMaxTilesY - 300))
			{
				num12 = -1;
				num += 1.0;
				zero.Y = num12;
				zero.X = 0.0;
				zero2.X = 0.0;
				zero2.Y = num12;
				if (genRand.Next(2) == 0)
				{
					if (genRand.Next(2) == 0)
					{
						zero.X = (double)genRand.Next(20, 50) * 0.01;
					}
					else
					{
						zero.X = (double)(-genRand.Next(20, 50)) * 0.01;
					}
				}
			}
			else if (flag3)
			{
				num12 = 1;
				num += 1.0;
				zero.Y = num12;
				zero.X = 0.0;
				zero2.X = 0.0;
				zero2.Y = num12;
				if (genRand.Next(3) != 0)
				{
					flag5 = true;
					if (genRand.Next(2) == 0)
					{
						zero.X = (double)genRand.Next(10, 20) * 0.1;
					}
					else
					{
						zero.X = (double)(-genRand.Next(10, 20)) * 0.1;
					}
				}
				else if (genRand.Next(2) == 0)
				{
					if (genRand.Next(2) == 0)
					{
						zero.X = (double)genRand.Next(20, 50) * 0.01;
					}
					else
					{
						zero.X = (double)genRand.Next(20, 50) * 0.01;
					}
				}
			}
			else if (vector2D.X < (double)(Main.maxTilesX / 2) && vector2D.X > (double)Main.maxTilesX * 0.25)
			{
				num12 = -1;
				zero2.Y = 0.0;
				zero2.X = num12;
				zero.Y = 0.0;
				zero.X = num12;
				if (genRand.Next(3) == 0)
				{
					if (genRand.Next(2) == 0)
					{
						zero.Y = -0.2;
					}
					else
					{
						zero.Y = 0.2;
					}
				}
			}
			else if (vector2D.X > (double)(Main.maxTilesX / 2) && vector2D.X < (double)Main.maxTilesX * 0.75)
			{
				num12 = 1;
				zero2.Y = 0.0;
				zero2.X = num12;
				zero.Y = 0.0;
				zero.X = num12;
				if (genRand.Next(3) == 0)
				{
					if (genRand.Next(2) == 0)
					{
						zero.Y = -0.2;
					}
					else
					{
						zero.Y = 0.2;
					}
				}
			}
		}
		if (zero2.Y == 0.0)
		{
			GenVars.DDoorX[GenVars.numDDoors] = (int)vector2D.X;
			GenVars.DDoorY[GenVars.numDDoors] = (int)vector2D.Y;
			GenVars.DDoorPos[GenVars.numDDoors] = 0;
			GenVars.numDDoors++;
		}
		else
		{
			GenVars.dungeonPlatformX[GenVars.numDungeonPlatforms] = (int)vector2D.X;
			GenVars.dungeonPlatformY[GenVars.numDungeonPlatforms] = (int)vector2D.Y;
			GenVars.numDungeonPlatforms++;
		}
		GenVars.lastDungeonHall = zero2;
		if (Math.Abs(zero.X) > Math.Abs(zero.Y) && genRand.Next(3) != 0)
		{
			num = (int)(num11 * ((double)genRand.Next(110, 150) * 0.01));
		}
		while (num13 > 0)
		{
			num18++;
			if (zero2.X > 0.0 && vector2D.X > (double)(Main.maxTilesX - 100))
			{
				num13 = 0;
			}
			else if (zero2.X < 0.0 && vector2D.X < 100.0)
			{
				num13 = 0;
			}
			else if (zero2.Y > 0.0 && vector2D.Y > (double)(Main.maxTilesY - 100))
			{
				num13 = 0;
			}
			else if (remixWorldGen && zero2.Y < 0.0 && vector2D.Y < (Main.rockLayer + Main.worldSurface) / 2.0)
			{
				num13 = 0;
			}
			else if (!remixWorldGen && zero2.Y < 0.0 && vector2D.Y < Main.rockLayer + 50.0)
			{
				num13 = 0;
			}
			num13--;
			int num2 = (int)(vector2D.X - num - 4.0 - (double)genRand.Next(6));
			int num3 = (int)(vector2D.X + num + 4.0 + (double)genRand.Next(6));
			int num4 = (int)(vector2D.Y - num - 4.0 - (double)genRand.Next(6));
			int num5 = (int)(vector2D.Y + num + 4.0 + (double)genRand.Next(6));
			if (num2 < 0)
			{
				num2 = 0;
			}
			if (num3 > Main.maxTilesX)
			{
				num3 = Main.maxTilesX;
			}
			if (num4 < 0)
			{
				num4 = 0;
			}
			if (num5 > Main.maxTilesY)
			{
				num5 = Main.maxTilesY;
			}
			for (int m = num2; m < num3; m++)
			{
				for (int n = num4; n < num5; n++)
				{
					if (m < GenVars.dMinX)
					{
						GenVars.dMinX = m;
					}
					if (m > GenVars.dMaxX)
					{
						GenVars.dMaxX = m;
					}
					if (n > GenVars.dMaxY)
					{
						GenVars.dMaxY = n;
					}
					Main.tile[m, n].liquid = 0;
					if (!Main.wallDungeon[Main.tile[m, n].wall])
					{
						Main.tile[m, n].active(active: true);
						Main.tile[m, n].type = tileType;
						Main.tile[m, n].Clear(TileDataType.Slope);
					}
				}
			}
			for (int num6 = num2 + 1; num6 < num3 - 1; num6++)
			{
				for (int num7 = num4 + 1; num7 < num5 - 1; num7++)
				{
					Main.tile[num6, num7].wall = (ushort)wallType;
				}
			}
			int num8 = 0;
			if (zero.Y == 0.0 && genRand.Next((int)num + 1) == 0)
			{
				num8 = genRand.Next(1, 3);
			}
			else if (zero.X == 0.0 && genRand.Next((int)num - 1) == 0)
			{
				num8 = genRand.Next(1, 3);
			}
			else if (genRand.Next((int)num * 3) == 0)
			{
				num8 = genRand.Next(1, 3);
			}
			num2 = (int)(vector2D.X - num * 0.5 - (double)num8);
			num3 = (int)(vector2D.X + num * 0.5 + (double)num8);
			num4 = (int)(vector2D.Y - num * 0.5 - (double)num8);
			num5 = (int)(vector2D.Y + num * 0.5 + (double)num8);
			if (num2 < 0)
			{
				num2 = 0;
			}
			if (num3 > Main.maxTilesX)
			{
				num3 = Main.maxTilesX;
			}
			if (num4 < 0)
			{
				num4 = 0;
			}
			if (num5 > Main.maxTilesY)
			{
				num5 = Main.maxTilesY;
			}
			for (int num9 = num2; num9 < num3; num9++)
			{
				for (int num10 = num4; num10 < num5; num10++)
				{
					Main.tile[num9, num10].Clear(TileDataType.Slope);
					if (flag)
					{
						if (Main.tile[num9, num10].active() || Main.tile[num9, num10].wall != wallType)
						{
							Main.tile[num9, num10].active(active: true);
							Main.tile[num9, num10].type = GenVars.crackedType;
						}
					}
					else
					{
						Main.tile[num9, num10].active(active: false);
					}
					Main.tile[num9, num10].Clear(TileDataType.Slope);
					Main.tile[num9, num10].wall = (ushort)wallType;
				}
			}
			vector2D += zero;
			if (flag5 && num18 > genRand.Next(10, 20))
			{
				num18 = 0;
				zero.X *= -1.0;
			}
		}
		GenVars.dungeonX = (int)vector2D.X;
		GenVars.dungeonY = (int)vector2D.Y;
		if (zero2.Y == 0.0)
		{
			GenVars.DDoorX[GenVars.numDDoors] = (int)vector2D.X;
			GenVars.DDoorY[GenVars.numDDoors] = (int)vector2D.Y;
			GenVars.DDoorPos[GenVars.numDDoors] = 0;
			GenVars.numDDoors++;
		}
		else
		{
			GenVars.dungeonPlatformX[GenVars.numDungeonPlatforms] = (int)vector2D.X;
			GenVars.dungeonPlatformY[GenVars.numDungeonPlatforms] = (int)vector2D.Y;
			GenVars.numDungeonPlatforms++;
		}
	}

	public static void DungeonRoom(int i, int j, ushort tileType, int wallType)
	{
		double num = genRand.Next(15, 30);
		Vector2D vector2D = default(Vector2D);
		vector2D.X = (double)genRand.Next(-10, 11) * 0.1;
		vector2D.Y = (double)genRand.Next(-10, 11) * 0.1;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = i;
		vector2D2.Y = (double)j - num / 2.0;
		int num5 = genRand.Next(10, 20);
		double num6 = vector2D2.X;
		double num7 = vector2D2.X;
		double num8 = vector2D2.Y;
		double num9 = vector2D2.Y;
		while (num5 > 0)
		{
			num5--;
			int num10 = (int)(vector2D2.X - num * 0.8 - 5.0);
			int num11 = (int)(vector2D2.X + num * 0.8 + 5.0);
			int num12 = (int)(vector2D2.Y - num * 0.8 - 5.0);
			int num2 = (int)(vector2D2.Y + num * 0.8 + 5.0);
			if (num10 < 0)
			{
				num10 = 0;
			}
			if (num11 > Main.maxTilesX)
			{
				num11 = Main.maxTilesX;
			}
			if (num12 < 0)
			{
				num12 = 0;
			}
			if (num2 > Main.maxTilesY)
			{
				num2 = Main.maxTilesY;
			}
			for (int k = num10; k < num11; k++)
			{
				for (int l = num12; l < num2; l++)
				{
					if (k < GenVars.dMinX)
					{
						GenVars.dMinX = k;
					}
					if (k > GenVars.dMaxX)
					{
						GenVars.dMaxX = k;
					}
					if (l > GenVars.dMaxY)
					{
						GenVars.dMaxY = l;
					}
					Main.tile[k, l].liquid = 0;
					if (!Main.wallDungeon[Main.tile[k, l].wall])
					{
						Main.tile[k, l].Clear(TileDataType.Slope);
						Main.tile[k, l].active(active: true);
						Main.tile[k, l].type = tileType;
					}
				}
			}
			for (int m = num10 + 1; m < num11 - 1; m++)
			{
				for (int n = num12 + 1; n < num2 - 1; n++)
				{
					Main.tile[m, n].wall = (ushort)wallType;
				}
			}
			num10 = (int)(vector2D2.X - num * 0.5);
			num11 = (int)(vector2D2.X + num * 0.5);
			num12 = (int)(vector2D2.Y - num * 0.5);
			num2 = (int)(vector2D2.Y + num * 0.5);
			if (num10 < 0)
			{
				num10 = 0;
			}
			if (num11 > Main.maxTilesX)
			{
				num11 = Main.maxTilesX;
			}
			if (num12 < 0)
			{
				num12 = 0;
			}
			if (num2 > Main.maxTilesY)
			{
				num2 = Main.maxTilesY;
			}
			if ((double)num10 < num6)
			{
				num6 = num10;
			}
			if ((double)num11 > num7)
			{
				num7 = num11;
			}
			if ((double)num12 < num8)
			{
				num8 = num12;
			}
			if ((double)num2 > num9)
			{
				num9 = num2;
			}
			for (int num3 = num10; num3 < num11; num3++)
			{
				for (int num4 = num12; num4 < num2; num4++)
				{
					Main.tile[num3, num4].active(active: false);
					Main.tile[num3, num4].wall = (ushort)wallType;
				}
			}
			vector2D2 += vector2D;
			vector2D.X += (double)genRand.Next(-10, 11) * 0.05;
			vector2D.Y += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D.X > 1.0)
			{
				vector2D.X = 1.0;
			}
			if (vector2D.X < -1.0)
			{
				vector2D.X = -1.0;
			}
			if (vector2D.Y > 1.0)
			{
				vector2D.Y = 1.0;
			}
			if (vector2D.Y < -1.0)
			{
				vector2D.Y = -1.0;
			}
		}
		GenVars.dRoomX[GenVars.numDRooms] = (int)vector2D2.X;
		GenVars.dRoomY[GenVars.numDRooms] = (int)vector2D2.Y;
		GenVars.dRoomSize[GenVars.numDRooms] = (int)num;
		GenVars.dRoomL[GenVars.numDRooms] = (int)num6;
		GenVars.dRoomR[GenVars.numDRooms] = (int)num7;
		GenVars.dRoomT[GenVars.numDRooms] = (int)num8;
		GenVars.dRoomB[GenVars.numDRooms] = (int)num9;
		GenVars.dRoomTreasure[GenVars.numDRooms] = false;
		GenVars.numDRooms++;
	}

	public static void DungeonEnt(int i, int j, ushort tileType, int wallType)
	{
		int num = 60;
		for (int k = i - num; k < i + num; k++)
		{
			for (int l = j - num; l < j + num; l++)
			{
				if (InWorld(k, l))
				{
					Main.tile[k, l].liquid = 0;
					Main.tile[k, l].lava(lava: false);
					Main.tile[k, l].Clear(TileDataType.Slope);
				}
			}
		}
		double dxStrength = GenVars.dxStrength1;
		double dyStrength = GenVars.dyStrength1;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = (double)j - dyStrength / 2.0;
		GenVars.dMinY = (int)vector2D.Y;
		int num12 = 1;
		if (i > Main.maxTilesX / 2)
		{
			num12 = -1;
		}
		if (drunkWorldGen || getGoodWorldGen)
		{
			num12 *= -1;
		}
		int num23 = (int)(vector2D.X - dxStrength * 0.6 - (double)genRand.Next(2, 5));
		int num34 = (int)(vector2D.X + dxStrength * 0.6 + (double)genRand.Next(2, 5));
		int num45 = (int)(vector2D.Y - dyStrength * 0.6 - (double)genRand.Next(2, 5));
		int num56 = (int)(vector2D.Y + dyStrength * 0.6 + (double)genRand.Next(8, 16));
		if (num23 < 0)
		{
			num23 = 0;
		}
		if (num34 > Main.maxTilesX)
		{
			num34 = Main.maxTilesX;
		}
		if (num45 < 0)
		{
			num45 = 0;
		}
		if (num56 > Main.maxTilesY)
		{
			num56 = Main.maxTilesY;
		}
		for (int m = num23; m < num34; m++)
		{
			for (int n = num45; n < num56; n++)
			{
				Main.tile[m, n].liquid = 0;
				if (Main.tile[m, n].wall != wallType)
				{
					Main.tile[m, n].wall = 0;
					if (m > num23 + 1 && m < num34 - 2 && n > num45 + 1 && n < num56 - 2)
					{
						Main.tile[m, n].wall = (ushort)wallType;
					}
					Main.tile[m, n].active(active: true);
					Main.tile[m, n].type = tileType;
					Main.tile[m, n].Clear(TileDataType.Slope);
				}
			}
		}
		int num57 = num23;
		int num58 = num23 + 5 + genRand.Next(4);
		int num59 = num45 - 3 - genRand.Next(3);
		int num2 = num45;
		for (int num3 = num57; num3 < num58; num3++)
		{
			for (int num4 = num59; num4 < num2; num4++)
			{
				Main.tile[num3, num4].liquid = 0;
				if (Main.tile[num3, num4].wall != wallType)
				{
					Main.tile[num3, num4].active(active: true);
					Main.tile[num3, num4].type = tileType;
					Main.tile[num3, num4].Clear(TileDataType.Slope);
				}
			}
		}
		num57 = num34 - 5 - genRand.Next(4);
		num58 = num34;
		num59 = num45 - 3 - genRand.Next(3);
		num2 = num45;
		for (int num5 = num57; num5 < num58; num5++)
		{
			for (int num6 = num59; num6 < num2; num6++)
			{
				Main.tile[num5, num6].liquid = 0;
				if (Main.tile[num5, num6].wall != wallType)
				{
					Main.tile[num5, num6].active(active: true);
					Main.tile[num5, num6].type = tileType;
					Main.tile[num5, num6].Clear(TileDataType.Slope);
				}
			}
		}
		int num7 = 1 + genRand.Next(2);
		int num8 = 2 + genRand.Next(4);
		int num9 = 0;
		for (int num10 = num23; num10 < num34; num10++)
		{
			for (int num11 = num45 - num7; num11 < num45; num11++)
			{
				Main.tile[num10, num11].liquid = 0;
				if (Main.tile[num10, num11].wall != wallType)
				{
					Main.tile[num10, num11].active(active: true);
					Main.tile[num10, num11].type = tileType;
					Main.tile[num10, num11].Clear(TileDataType.Slope);
				}
			}
			num9++;
			if (num9 >= num8)
			{
				num10 += num8;
				num9 = 0;
			}
		}
		for (int num13 = num23; num13 < num34; num13++)
		{
			for (int num14 = num56; (double)num14 < Main.worldSurface; num14++)
			{
				Main.tile[num13, num14].liquid = 0;
				if (!Main.wallDungeon[Main.tile[num13, num14].wall])
				{
					Main.tile[num13, num14].active(active: true);
					Main.tile[num13, num14].type = tileType;
				}
				if (num13 > num23 && num13 < num34 - 1)
				{
					Main.tile[num13, num14].wall = (ushort)wallType;
				}
				Main.tile[num13, num14].Clear(TileDataType.Slope);
			}
		}
		num23 = (int)(vector2D.X - dxStrength * 0.6);
		num34 = (int)(vector2D.X + dxStrength * 0.6);
		num45 = (int)(vector2D.Y - dyStrength * 0.6);
		num56 = (int)(vector2D.Y + dyStrength * 0.6);
		if (num23 < 0)
		{
			num23 = 0;
		}
		if (num34 > Main.maxTilesX)
		{
			num34 = Main.maxTilesX;
		}
		if (num45 < 0)
		{
			num45 = 0;
		}
		if (num56 > Main.maxTilesY)
		{
			num56 = Main.maxTilesY;
		}
		for (int num15 = num23; num15 < num34; num15++)
		{
			for (int num16 = num45; num16 < num56; num16++)
			{
				Main.tile[num15, num16].liquid = 0;
				Main.tile[num15, num16].wall = (ushort)wallType;
				Main.tile[num15, num16].Clear(TileDataType.Slope);
			}
		}
		num23 = (int)(vector2D.X - dxStrength * 0.6 - 1.0);
		num34 = (int)(vector2D.X + dxStrength * 0.6 + 1.0);
		num45 = (int)(vector2D.Y - dyStrength * 0.6 - 1.0);
		num56 = (int)(vector2D.Y + dyStrength * 0.6 + 1.0);
		if (num23 < 0)
		{
			num23 = 0;
		}
		if (num34 > Main.maxTilesX)
		{
			num34 = Main.maxTilesX;
		}
		if (num45 < 0)
		{
			num45 = 0;
		}
		if (num56 > Main.maxTilesY)
		{
			num56 = Main.maxTilesY;
		}
		if (drunkWorldGen)
		{
			num23 -= 4;
		}
		for (int num17 = num23; num17 < num34; num17++)
		{
			for (int num18 = num45; num18 < num56; num18++)
			{
				Main.tile[num17, num18].liquid = 0;
				Main.tile[num17, num18].wall = (ushort)wallType;
				Main.tile[num17, num18].Clear(TileDataType.Slope);
			}
		}
		num23 = (int)(vector2D.X - dxStrength * 0.5);
		num34 = (int)(vector2D.X + dxStrength * 0.5);
		num45 = (int)(vector2D.Y - dyStrength * 0.5);
		num56 = (int)(vector2D.Y + dyStrength * 0.5);
		if (num23 < 0)
		{
			num23 = 0;
		}
		if (num34 > Main.maxTilesX)
		{
			num34 = Main.maxTilesX;
		}
		if (num45 < 0)
		{
			num45 = 0;
		}
		if (num56 > Main.maxTilesY)
		{
			num56 = Main.maxTilesY;
		}
		for (int num19 = num23; num19 < num34; num19++)
		{
			for (int num20 = num45; num20 < num56; num20++)
			{
				Main.tile[num19, num20].liquid = 0;
				Main.tile[num19, num20].active(active: false);
				Main.tile[num19, num20].wall = (ushort)wallType;
			}
		}
		int num21 = (int)vector2D.X;
		int num22 = num56;
		for (int num24 = 0; num24 < 20; num24++)
		{
			num21 = (int)vector2D.X - num24;
			if (!Main.tile[num21, num22].active() && Main.wallDungeon[Main.tile[num21, num22].wall])
			{
				GenVars.dungeonPlatformX[GenVars.numDungeonPlatforms] = num21;
				GenVars.dungeonPlatformY[GenVars.numDungeonPlatforms] = num22;
				GenVars.numDungeonPlatforms++;
				break;
			}
			num21 = (int)vector2D.X + num24;
			if (!Main.tile[num21, num22].active() && Main.wallDungeon[Main.tile[num21, num22].wall])
			{
				GenVars.dungeonPlatformX[GenVars.numDungeonPlatforms] = num21;
				GenVars.dungeonPlatformY[GenVars.numDungeonPlatforms] = num22;
				GenVars.numDungeonPlatforms++;
				break;
			}
		}
		vector2D.X += dxStrength * 0.6 * (double)num12;
		vector2D.Y += dyStrength * 0.5;
		dxStrength = GenVars.dxStrength2;
		dyStrength = GenVars.dyStrength2;
		vector2D.X += dxStrength * 0.55 * (double)num12;
		vector2D.Y -= dyStrength * 0.5;
		num23 = (int)(vector2D.X - dxStrength * 0.6 - (double)genRand.Next(1, 3));
		num34 = (int)(vector2D.X + dxStrength * 0.6 + (double)genRand.Next(1, 3));
		num45 = (int)(vector2D.Y - dyStrength * 0.6 - (double)genRand.Next(1, 3));
		num56 = (int)(vector2D.Y + dyStrength * 0.6 + (double)genRand.Next(6, 16));
		if (num23 < 0)
		{
			num23 = 0;
		}
		if (num34 > Main.maxTilesX)
		{
			num34 = Main.maxTilesX;
		}
		if (num45 < 0)
		{
			num45 = 0;
		}
		if (num56 > Main.maxTilesY)
		{
			num56 = Main.maxTilesY;
		}
		for (int num25 = num23; num25 < num34; num25++)
		{
			for (int num26 = num45; num26 < num56; num26++)
			{
				Main.tile[num25, num26].liquid = 0;
				if (Main.tile[num25, num26].wall == wallType)
				{
					continue;
				}
				bool flag = true;
				if (num12 < 0)
				{
					if ((double)num25 < vector2D.X - dxStrength * 0.5)
					{
						flag = false;
					}
				}
				else if ((double)num25 > vector2D.X + dxStrength * 0.5 - 1.0)
				{
					flag = false;
				}
				if (flag)
				{
					Main.tile[num25, num26].wall = 0;
					Main.tile[num25, num26].active(active: true);
					Main.tile[num25, num26].type = tileType;
					Main.tile[num25, num26].Clear(TileDataType.Slope);
				}
			}
		}
		for (int num27 = num23; num27 < num34; num27++)
		{
			for (int num28 = num56; (double)num28 < Main.worldSurface; num28++)
			{
				Main.tile[num27, num28].liquid = 0;
				if (!Main.wallDungeon[Main.tile[num27, num28].wall])
				{
					Main.tile[num27, num28].active(active: true);
					Main.tile[num27, num28].type = tileType;
				}
				Main.tile[num27, num28].wall = (ushort)wallType;
				Main.tile[num27, num28].Clear(TileDataType.Slope);
			}
		}
		num23 = (int)(vector2D.X - dxStrength * 0.5);
		num34 = (int)(vector2D.X + dxStrength * 0.5);
		num57 = num23;
		if (num12 < 0)
		{
			num57++;
		}
		num58 = num57 + 5 + genRand.Next(4);
		num59 = num45 - 3 - genRand.Next(3);
		num2 = num45;
		for (int num29 = num57; num29 < num58; num29++)
		{
			for (int num30 = num59; num30 < num2; num30++)
			{
				Main.tile[num29, num30].liquid = 0;
				if (Main.tile[num29, num30].wall != wallType)
				{
					Main.tile[num29, num30].active(active: true);
					Main.tile[num29, num30].type = tileType;
					Main.tile[num29, num30].Clear(TileDataType.Slope);
				}
			}
		}
		num57 = num34 - 5 - genRand.Next(4);
		num58 = num34;
		num59 = num45 - 3 - genRand.Next(3);
		num2 = num45;
		for (int num31 = num57; num31 < num58; num31++)
		{
			for (int num32 = num59; num32 < num2; num32++)
			{
				Main.tile[num31, num32].liquid = 0;
				if (Main.tile[num31, num32].wall != wallType)
				{
					Main.tile[num31, num32].active(active: true);
					Main.tile[num31, num32].type = tileType;
					Main.tile[num31, num32].Clear(TileDataType.Slope);
				}
			}
		}
		num7 = 1 + genRand.Next(2);
		num8 = 2 + genRand.Next(4);
		num9 = 0;
		if (num12 < 0)
		{
			num34++;
		}
		for (int num33 = num23 + 1; num33 < num34 - 1; num33++)
		{
			for (int num35 = num45 - num7; num35 < num45; num35++)
			{
				Main.tile[num33, num35].liquid = 0;
				if (Main.tile[num33, num35].wall != wallType)
				{
					Main.tile[num33, num35].active(active: true);
					Main.tile[num33, num35].type = tileType;
					Main.tile[num33, num35].Clear(TileDataType.Slope);
				}
			}
			num9++;
			if (num9 >= num8)
			{
				num33 += num8;
				num9 = 0;
			}
		}
		if (!drunkWorldGen)
		{
			num23 = (int)(vector2D.X - dxStrength * 0.6);
			num34 = (int)(vector2D.X + dxStrength * 0.6);
			num45 = (int)(vector2D.Y - dyStrength * 0.6);
			num56 = (int)(vector2D.Y + dyStrength * 0.6);
			if (num23 < 0)
			{
				num23 = 0;
			}
			if (num34 > Main.maxTilesX)
			{
				num34 = Main.maxTilesX;
			}
			if (num45 < 0)
			{
				num45 = 0;
			}
			if (num56 > Main.maxTilesY)
			{
				num56 = Main.maxTilesY;
			}
			for (int num36 = num23; num36 < num34; num36++)
			{
				for (int num37 = num45; num37 < num56; num37++)
				{
					Main.tile[num36, num37].liquid = 0;
					Main.tile[num36, num37].wall = 0;
				}
			}
		}
		num23 = (int)(vector2D.X - dxStrength * 0.5);
		num34 = (int)(vector2D.X + dxStrength * 0.5);
		num45 = (int)(vector2D.Y - dyStrength * 0.5);
		num56 = (int)(vector2D.Y + dyStrength * 0.5);
		if (num23 < 0)
		{
			num23 = 0;
		}
		if (num34 > Main.maxTilesX)
		{
			num34 = Main.maxTilesX;
		}
		if (num45 < 0)
		{
			num45 = 0;
		}
		if (num56 > Main.maxTilesY)
		{
			num56 = Main.maxTilesY;
		}
		for (int num38 = num23; num38 < num34; num38++)
		{
			for (int num39 = num45; num39 < num56; num39++)
			{
				Main.tile[num38, num39].liquid = 0;
				Main.tile[num38, num39].active(active: false);
				Main.tile[num38, num39].wall = 0;
			}
		}
		Main.dungeonX = (int)vector2D.X;
		Main.dungeonY = num56;
		int num40 = NPC.NewNPC(new EntitySource_WorldGen(), Main.dungeonX * 16 + 8, Main.dungeonY * 16, 37);
		Main.npc[num40].homeless = false;
		Main.npc[num40].homeTileX = Main.dungeonX;
		Main.npc[num40].homeTileY = Main.dungeonY;
		if (drunkWorldGen)
		{
			int num41 = (int)Main.worldSurface;
			while (Main.tile[GenVars.dungeonX, num41].active() || Main.tile[GenVars.dungeonX, num41].wall > 0 || Main.tile[GenVars.dungeonX, num41 - 1].active() || Main.tile[GenVars.dungeonX, num41 - 1].wall > 0 || Main.tile[GenVars.dungeonX, num41 - 2].active() || Main.tile[GenVars.dungeonX, num41 - 2].wall > 0 || Main.tile[GenVars.dungeonX, num41 - 3].active() || Main.tile[GenVars.dungeonX, num41 - 3].wall > 0 || Main.tile[GenVars.dungeonX, num41 - 4].active() || Main.tile[GenVars.dungeonX, num41 - 4].wall > 0)
			{
				num41--;
				if (num41 < 50)
				{
					break;
				}
			}
			if (num41 > 50)
			{
				GrowDungeonTree(GenVars.dungeonX, num41);
			}
		}
		if (!drunkWorldGen)
		{
			int num42 = 100;
			if (num12 == 1)
			{
				int num43 = 0;
				for (int num44 = num34; num44 < num34 + num42; num44++)
				{
					num43++;
					for (int num46 = num56 + num43; num46 < num56 + num42; num46++)
					{
						Main.tile[num44, num46].liquid = 0;
						Main.tile[num44, num46 - 1].liquid = 0;
						Main.tile[num44, num46 - 2].liquid = 0;
						Main.tile[num44, num46 - 3].liquid = 0;
						if (!Main.wallDungeon[Main.tile[num44, num46].wall] && Main.tile[num44, num46].wall != 3 && Main.tile[num44, num46].wall != 83)
						{
							Main.tile[num44, num46].active(active: true);
							Main.tile[num44, num46].type = tileType;
							Main.tile[num44, num46].Clear(TileDataType.Slope);
						}
					}
				}
			}
			else
			{
				int num47 = 0;
				for (int num48 = num23; num48 > num23 - num42; num48--)
				{
					num47++;
					for (int num49 = num56 + num47; num49 < num56 + num42; num49++)
					{
						Main.tile[num48, num49].liquid = 0;
						Main.tile[num48, num49 - 1].liquid = 0;
						Main.tile[num48, num49 - 2].liquid = 0;
						Main.tile[num48, num49 - 3].liquid = 0;
						if (!Main.wallDungeon[Main.tile[num48, num49].wall] && Main.tile[num48, num49].wall != 3 && Main.tile[num48, num49].wall != 83)
						{
							Main.tile[num48, num49].active(active: true);
							Main.tile[num48, num49].type = tileType;
							Main.tile[num48, num49].Clear(TileDataType.Slope);
						}
					}
				}
			}
		}
		num7 = 1 + genRand.Next(2);
		num8 = 2 + genRand.Next(4);
		num9 = 0;
		num23 = (int)(vector2D.X - dxStrength * 0.5);
		num34 = (int)(vector2D.X + dxStrength * 0.5);
		if (drunkWorldGen)
		{
			if (num12 == 1)
			{
				num34--;
				num23--;
			}
			else
			{
				num23++;
				num34++;
			}
		}
		else
		{
			num23 += 2;
			num34 -= 2;
		}
		for (int num50 = num23; num50 < num34; num50++)
		{
			for (int num51 = num45; num51 < num56 + 1; num51++)
			{
				PlaceWall(num50, num51, wallType, mute: true);
			}
			if (!drunkWorldGen)
			{
				num9++;
				if (num9 >= num8)
				{
					num50 += num8 * 2;
					num9 = 0;
				}
			}
		}
		if (drunkWorldGen)
		{
			num23 = (int)(vector2D.X - dxStrength * 0.5);
			num34 = (int)(vector2D.X + dxStrength * 0.5);
			if (num12 == 1)
			{
				num23 = num34 - 3;
			}
			else
			{
				num34 = num23 + 3;
			}
			for (int num52 = num23; num52 < num34; num52++)
			{
				for (int num53 = num45; num53 < num56 + 1; num53++)
				{
					Main.tile[num52, num53].active(active: true);
					Main.tile[num52, num53].type = tileType;
					Main.tile[num52, num53].Clear(TileDataType.Slope);
				}
			}
		}
		vector2D.X -= dxStrength * 0.6 * (double)num12;
		vector2D.Y += dyStrength * 0.5;
		dxStrength = 15.0;
		dyStrength = 3.0;
		vector2D.Y -= dyStrength * 0.5;
		num23 = (int)(vector2D.X - dxStrength * 0.5);
		num34 = (int)(vector2D.X + dxStrength * 0.5);
		num45 = (int)(vector2D.Y - dyStrength * 0.5);
		num56 = (int)(vector2D.Y + dyStrength * 0.5);
		if (num23 < 0)
		{
			num23 = 0;
		}
		if (num34 > Main.maxTilesX)
		{
			num34 = Main.maxTilesX;
		}
		if (num45 < 0)
		{
			num45 = 0;
		}
		if (num56 > Main.maxTilesY)
		{
			num56 = Main.maxTilesY;
		}
		for (int num54 = num23; num54 < num34; num54++)
		{
			for (int num55 = num45; num55 < num56; num55++)
			{
				Main.tile[num54, num55].active(active: false);
			}
		}
		if (num12 < 0)
		{
			vector2D.X -= 1.0;
		}
		PlaceTile((int)vector2D.X, (int)vector2D.Y + 1, 10, mute: true, forced: false, -1, 13);
	}

	public static bool AddBuriedChest(Point point, int contain = 0, bool notNearOtherChests = false, int Style = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return AddBuriedChest(point.X, point.Y, contain, notNearOtherChests, Style, trySlope: false, 0);
	}

	public static bool IsChestRigged(int x, int y)
	{
		if (Main.tile[x, y].type == 467)
		{
			return Main.tile[x, y].frameX / 36 == 4;
		}
		return false;
	}

	private static bool IsUndergroundDesert(int x, int y)
	{
		if ((double)y < Main.worldSurface)
		{
			return false;
		}
		if ((double)x < (double)Main.maxTilesX * 0.15 || (double)x > (double)Main.maxTilesX * 0.85)
		{
			return false;
		}
		if (remixWorldGen && (double)y > Main.rockLayer)
		{
			return false;
		}
		int num = 15;
		for (int i = x - num; i <= x + num; i++)
		{
			for (int j = y - num; j <= y + num; j++)
			{
				if (Main.tile[i, j].wall == 187 || Main.tile[i, j].wall == 216)
				{
					return true;
				}
			}
		}
		return false;
	}

	private static bool IsDungeon(int x, int y)
	{
		if ((double)y < Main.worldSurface)
		{
			return false;
		}
		if (x < 0 || x > Main.maxTilesX)
		{
			return false;
		}
		if (Main.wallDungeon[Main.tile[x, y].wall])
		{
			return true;
		}
		return false;
	}

	public static bool AddBuriedChest(int i, int j, int contain = 0, bool notNearOtherChests = false, int Style = -1, bool trySlope = false, ushort chestTileType = 0)
	{
		if (chestTileType == 0)
		{
			chestTileType = 21;
		}
		bool flag = false;
		bool flag7 = false;
		bool flag8 = false;
		bool flag9 = false;
		bool flag10 = false;
		bool flag11 = false;
		bool flag12 = false;
		bool flag13 = false;
		bool flag14 = false;
		bool flag2 = false;
		int num = 15;
		if (tenthAnniversaryWorldGen)
		{
			num *= 3;
		}
		for (int k = j; k < Main.maxTilesY - 10; k++)
		{
			int num5 = -1;
			int num7 = -1;
			if (Main.tile[i, k].shimmer())
			{
				return false;
			}
			if (trySlope && Main.tile[i, k].active() && Main.tileSolid[Main.tile[i, k].type] && !Main.tileSolidTop[Main.tile[i, k].type])
			{
				if (Style == 17)
				{
					int num8 = 30;
					for (int l = i - num8; l <= i + num8; l++)
					{
						for (int m = k - num8; m <= k + num8; m++)
						{
							if (!InWorld(l, m, 5))
							{
								return false;
							}
							if (Main.tile[l, m].active() && (Main.tile[l, m].type == 21 || Main.tile[l, m].type == 467))
							{
								return false;
							}
						}
					}
				}
				if (Main.tile[i - 1, k].topSlope())
				{
					num5 = Main.tile[i - 1, k].slope();
					Main.tile[i - 1, k].slope(0);
				}
				if (Main.tile[i, k].topSlope())
				{
					num7 = Main.tile[i, k].slope();
					Main.tile[i, k].slope(0);
				}
			}
			if (remixWorldGen && (double)i > (double)Main.maxTilesX * 0.37 && (double)i < (double)Main.maxTilesX * 0.63 && k > Main.maxTilesY - 250)
			{
				return false;
			}
			int num9 = 2;
			for (int n = i - num9; n <= i + num9; n++)
			{
				for (int num10 = k - num9; num10 <= k + num9; num10++)
				{
					if (Main.tile[n, num10].active() && (TileID.Sets.Boulders[Main.tile[n, num10].type] || Main.tile[n, num10].type == 26 || Main.tile[n, num10].type == 237))
					{
						return false;
					}
				}
			}
			if (!SolidTile(i, k))
			{
				continue;
			}
			bool flag3 = false;
			int num11 = k;
			int num12 = -1;
			int num13 = 0;
			bool flag4 = (double)num11 >= Main.worldSurface + 25.0;
			if (remixWorldGen)
			{
				flag4 = num11 < Main.maxTilesY - 400;
			}
			if (flag4 || contain > 0)
			{
				num13 = 1;
			}
			if (Style >= 0)
			{
				num13 = Style;
			}
			if ((chestTileType == 467 && num13 == 10) || (contain == 0 && num11 <= Main.maxTilesY - 205 && IsUndergroundDesert(i, k)))
			{
				flag7 = true;
				num13 = 10;
				chestTileType = 467;
				contain = ((num11 <= (GenVars.desertHiveHigh * 3 + GenVars.desertHiveLow * 4) / 7) ? Utils.SelectRandom(genRand, new short[4] { 4056, 4055, 4262, 4263 }) : Utils.SelectRandom(genRand, new short[3] { 4061, 4062, 4276 }));
				if (getGoodWorldGen && genRand.Next(num) == 0)
				{
					contain = 52;
				}
			}
			if (chestTileType == 21 && (num13 == 11 || (contain == 0 && (double)num11 >= Main.worldSurface + 25.0 && num11 <= Main.maxTilesY - 205 && (Main.tile[i, k].type == 147 || Main.tile[i, k].type == 161 || Main.tile[i, k].type == 162))))
			{
				flag = true;
				num13 = 11;
				contain = genRand.Next(6) switch
				{
					0 => 670, 
					1 => 724, 
					2 => 950, 
					3 => (!remixWorldGen) ? 1319 : 725, 
					4 => 987, 
					_ => 1579, 
				};
				if (genRand.Next(20) == 0)
				{
					contain = 997;
				}
				if (genRand.Next(50) == 0)
				{
					contain = 669;
				}
				if (getGoodWorldGen && genRand.Next(num) == 0)
				{
					contain = 52;
				}
			}
			if (chestTileType == 21 && (Style == 10 || contain == 211 || contain == 212 || contain == 213 || contain == 753))
			{
				flag8 = true;
				num13 = 10;
				if (getGoodWorldGen && genRand.Next(num) == 0)
				{
					contain = 52;
				}
			}
			if (chestTileType == 21 && num11 > Main.maxTilesY - 205 && contain == 0)
			{
				flag12 = true;
				contain = GenVars.hellChestItem[GenVars.hellChest];
				num13 = 4;
				flag3 = true;
				if (getGoodWorldGen && genRand.Next(num) == 0)
				{
					contain = 52;
				}
			}
			if (chestTileType == 21 && num13 == 17)
			{
				flag9 = true;
				if (getGoodWorldGen && genRand.Next(num) == 0)
				{
					contain = 52;
				}
			}
			if (chestTileType == 21 && num13 == 12)
			{
				flag10 = true;
				if (getGoodWorldGen && genRand.Next(num) == 0)
				{
					contain = 52;
				}
			}
			if (chestTileType == 21 && num13 == 32)
			{
				flag11 = true;
				if (getGoodWorldGen && genRand.Next(num) == 0)
				{
					contain = 52;
				}
			}
			if (chestTileType == 21 && num13 != 0 && IsDungeon(i, k))
			{
				flag13 = true;
			}
			if (chestTileType == 21 && num13 != 0 && (contain == 848 || contain == 857 || contain == 934))
			{
				flag14 = true;
			}
			if (chestTileType == 21 && (num13 == 13 || contain == 159 || contain == 65 || contain == 158 || contain == 2219))
			{
				flag2 = true;
				if (remixWorldGen && !getGoodWorldGen)
				{
					if (crimson)
					{
						num13 = 43;
					}
					else
					{
						chestTileType = 467;
						num13 = 3;
					}
				}
			}
			if (noTrapsWorldGen && num13 == 1 && chestTileType == 21 && (!remixWorldGen || genRand.Next(3) == 0))
			{
				num13 = 4;
				chestTileType = 467;
			}
			num12 = ((chestTileType != 467) ? PlaceChest(i - 1, num11 - 1, chestTileType, notNearOtherChests, num13) : PlaceChest(i - 1, num11 - 1, chestTileType, notNearOtherChests, num13));
			if (num12 >= 0)
			{
				if (flag3)
				{
					GenVars.hellChest++;
					if (GenVars.hellChest >= GenVars.hellChestItem.Length)
					{
						GenVars.hellChest = 0;
					}
				}
				Chest chest = Main.chest[num12];
				int num2 = 0;
				while (num2 == 0)
				{
					bool flag5 = (double)num11 < Main.worldSurface + 25.0;
					if (remixWorldGen)
					{
						flag5 = (double)num11 >= (Main.rockLayer + (double)((Main.maxTilesY - 350) * 2)) / 3.0;
					}
					if ((num13 == 0 && flag5) || flag14)
					{
						if (contain > 0)
						{
							chest.item[num2].SetDefaults(contain);
							chest.item[num2].Prefix(-1);
							num2++;
							switch (contain)
							{
							case 848:
								chest.item[num2].SetDefaults(866);
								num2++;
								break;
							case 832:
								chest.item[num2].SetDefaults(933);
								num2++;
								if (genRand.Next(6) == 0)
								{
									int num3 = genRand.Next(2);
									switch (num3)
									{
									case 0:
										num3 = 4429;
										break;
									case 1:
										num3 = 4427;
										break;
									}
									chest.item[num2].SetDefaults(num3);
									num2++;
								}
								break;
							}
							if (Main.tenthAnniversaryWorld && flag14)
							{
								chest.item[num2++].SetDefaults(848);
								chest.item[num2++].SetDefaults(866);
							}
						}
						else
						{
							int num14 = genRand.Next(10);
							if (num14 == 0)
							{
								chest.item[num2].SetDefaults(280);
								chest.item[num2].Prefix(-1);
							}
							if (num14 == 1)
							{
								chest.item[num2].SetDefaults(281);
								chest.item[num2].Prefix(-1);
							}
							if (num14 == 2)
							{
								chest.item[num2].SetDefaults(284);
								chest.item[num2].Prefix(-1);
							}
							if (num14 == 3)
							{
								chest.item[num2].SetDefaults(285);
								chest.item[num2].Prefix(-1);
							}
							if (num14 == 4)
							{
								chest.item[num2].SetDefaults(953);
								chest.item[num2].Prefix(-1);
							}
							if (num14 == 5)
							{
								chest.item[num2].SetDefaults(946);
								chest.item[num2].Prefix(-1);
							}
							if (num14 == 6)
							{
								chest.item[num2].SetDefaults(3068);
								chest.item[num2].Prefix(-1);
							}
							if (num14 == 7)
							{
								if (remixWorldGen)
								{
									chest.item[num2].SetDefaults(517);
									chest.item[num2].Prefix(-1);
								}
								else
								{
									chest.item[num2].SetDefaults(3069);
									chest.item[num2].Prefix(-1);
								}
							}
							if (num14 == 8)
							{
								chest.item[num2].SetDefaults(3084);
								chest.item[num2].Prefix(-1);
							}
							if (num14 == 9)
							{
								chest.item[num2].SetDefaults(4341);
								chest.item[num2].Prefix(-1);
							}
							num2++;
						}
						if (genRand.Next(6) == 0)
						{
							int stack = genRand.Next(40, 76);
							chest.item[num2].SetDefaults(282);
							chest.item[num2].stack = stack;
							num2++;
						}
						if (genRand.Next(6) == 0)
						{
							int stack12 = genRand.Next(150, 301);
							chest.item[num2].SetDefaults(279);
							chest.item[num2].stack = stack12;
							num2++;
						}
						if (genRand.Next(6) == 0)
						{
							chest.item[num2].SetDefaults(3093);
							chest.item[num2].stack = 1;
							if (genRand.Next(5) == 0)
							{
								chest.item[num2].stack += genRand.Next(2);
							}
							if (genRand.Next(10) == 0)
							{
								chest.item[num2].stack += genRand.Next(3);
							}
							num2++;
						}
						if (genRand.Next(6) == 0)
						{
							chest.item[num2].SetDefaults(4345);
							chest.item[num2].stack = 1;
							if (genRand.Next(5) == 0)
							{
								chest.item[num2].stack += genRand.Next(2);
							}
							if (genRand.Next(10) == 0)
							{
								chest.item[num2].stack += genRand.Next(3);
							}
							num2++;
						}
						if (genRand.Next(3) == 0)
						{
							chest.item[num2].SetDefaults(168);
							chest.item[num2].stack = genRand.Next(3, 6);
							num2++;
						}
						if (genRand.Next(2) == 0)
						{
							int num15 = genRand.Next(2);
							int stack23 = genRand.Next(8) + 3;
							if (num15 == 0)
							{
								chest.item[num2].SetDefaults(GenVars.copperBar);
							}
							if (num15 == 1)
							{
								chest.item[num2].SetDefaults(GenVars.ironBar);
							}
							chest.item[num2].stack = stack23;
							num2++;
						}
						if (genRand.Next(2) == 0)
						{
							int stack24 = genRand.Next(50, 101);
							chest.item[num2].SetDefaults(965);
							chest.item[num2].stack = stack24;
							num2++;
						}
						if (genRand.Next(3) != 0)
						{
							int num16 = genRand.Next(2);
							int stack25 = genRand.Next(26) + 25;
							if (num16 == 0)
							{
								chest.item[num2].SetDefaults(40);
							}
							if (num16 == 1)
							{
								chest.item[num2].SetDefaults(42);
							}
							chest.item[num2].stack = stack25;
							num2++;
						}
						if (genRand.Next(2) == 0)
						{
							int stack26 = genRand.Next(3) + 3;
							chest.item[num2].SetDefaults(28);
							chest.item[num2].stack = stack26;
							num2++;
						}
						if (genRand.Next(3) != 0)
						{
							chest.item[num2].SetDefaults(2350);
							chest.item[num2].stack = genRand.Next(3, 6);
							num2++;
						}
						if (genRand.Next(3) > 0)
						{
							int num17 = genRand.Next(6);
							int stack27 = genRand.Next(1, 3);
							if (num17 == 0)
							{
								chest.item[num2].SetDefaults(292);
							}
							if (num17 == 1)
							{
								chest.item[num2].SetDefaults(298);
							}
							if (num17 == 2)
							{
								chest.item[num2].SetDefaults(299);
							}
							if (num17 == 3)
							{
								chest.item[num2].SetDefaults(290);
							}
							if (num17 == 4)
							{
								chest.item[num2].SetDefaults(2322);
							}
							if (num17 == 5)
							{
								chest.item[num2].SetDefaults(2325);
							}
							chest.item[num2].stack = stack27;
							num2++;
						}
						if (genRand.Next(2) == 0)
						{
							int num18 = genRand.Next(2);
							int stack28 = genRand.Next(11) + 10;
							if (num18 == 0)
							{
								chest.item[num2].SetDefaults(8);
							}
							if (num18 == 1)
							{
								chest.item[num2].SetDefaults(31);
							}
							chest.item[num2].stack = stack28;
							num2++;
						}
						if (genRand.Next(2) == 0)
						{
							chest.item[num2].SetDefaults(72);
							chest.item[num2].stack = genRand.Next(10, 30);
							num2++;
						}
						if (genRand.Next(2) == 0)
						{
							chest.item[num2].SetDefaults(9);
							chest.item[num2].stack = genRand.Next(50, 100);
							num2++;
						}
					}
					else if ((!remixWorldGen && (double)num11 < Main.rockLayer) || (remixWorldGen && (double)num11 > Main.rockLayer && num11 < Main.maxTilesY - 250))
					{
						if (contain > 0)
						{
							if (contain == 832)
							{
								chest.item[num2].SetDefaults(933);
								num2++;
							}
							chest.item[num2].SetDefaults(contain);
							chest.item[num2].Prefix(-1);
							num2++;
							if (flag9)
							{
								if (genRand.Next(2) == 0)
								{
									chest.item[num2++].SetDefaults(4425);
								}
								if (genRand.Next(2) == 0)
								{
									chest.item[num2++].SetDefaults(4460);
								}
							}
							if (flag2 && genRand.Next(40) == 0)
							{
								chest.item[num2++].SetDefaults(4978);
							}
							if (flag10 && genRand.Next(10) == 0)
							{
								int num4 = genRand.Next(2);
								switch (num4)
								{
								case 0:
									num4 = 4429;
									break;
								case 1:
									num4 = 4427;
									break;
								}
								chest.item[num2].SetDefaults(num4);
								num2++;
							}
							if (flag13 && (!GenVars.generatedShadowKey || genRand.Next(3) == 0))
							{
								GenVars.generatedShadowKey = true;
								chest.item[num2].SetDefaults(329);
								num2++;
							}
						}
						else
						{
							switch (genRand.Next(6))
							{
							case 0:
								chest.item[num2].SetDefaults(49);
								chest.item[num2].Prefix(-1);
								break;
							case 1:
								chest.item[num2].SetDefaults(50);
								chest.item[num2].Prefix(-1);
								break;
							case 2:
								chest.item[num2].SetDefaults(53);
								chest.item[num2].Prefix(-1);
								break;
							case 3:
								chest.item[num2].SetDefaults(54);
								chest.item[num2].Prefix(-1);
								break;
							case 4:
								chest.item[num2].SetDefaults(5011);
								chest.item[num2].Prefix(-1);
								break;
							default:
								chest.item[num2].SetDefaults(975);
								chest.item[num2].Prefix(-1);
								break;
							}
							num2++;
							if (genRand.Next(20) == 0)
							{
								chest.item[num2].SetDefaults(997);
								chest.item[num2].Prefix(-1);
								num2++;
							}
							else if (genRand.Next(20) == 0)
							{
								chest.item[num2].SetDefaults(930);
								chest.item[num2].Prefix(-1);
								num2++;
								chest.item[num2].SetDefaults(931);
								chest.item[num2].stack = genRand.Next(26) + 25;
								num2++;
							}
							if (flag11 && genRand.Next(2) == 0)
							{
								chest.item[num2].SetDefaults(4450);
								num2++;
							}
							if (flag11 && genRand.Next(3) == 0)
							{
								chest.item[num2].SetDefaults(4779);
								num2++;
								chest.item[num2].SetDefaults(4780);
								num2++;
								chest.item[num2].SetDefaults(4781);
								num2++;
							}
						}
						if (flag7)
						{
							if (genRand.Next(3) == 0)
							{
								chest.item[num2].SetDefaults(4423);
								chest.item[num2].stack = genRand.Next(10, 20);
								num2++;
							}
						}
						else if (genRand.Next(3) == 0)
						{
							chest.item[num2].SetDefaults(166);
							chest.item[num2].stack = genRand.Next(10, 20);
							num2++;
						}
						if (genRand.Next(5) == 0)
						{
							chest.item[num2].SetDefaults(52);
							num2++;
						}
						if (genRand.Next(3) == 0)
						{
							int stack29 = genRand.Next(50, 101);
							chest.item[num2].SetDefaults(965);
							chest.item[num2].stack = stack29;
							num2++;
						}
						if (genRand.Next(2) == 0)
						{
							int num19 = genRand.Next(2);
							int stack2 = genRand.Next(10) + 5;
							if (num19 == 0)
							{
								chest.item[num2].SetDefaults(GenVars.ironBar);
							}
							if (num19 == 1)
							{
								chest.item[num2].SetDefaults(GenVars.silverBar);
							}
							chest.item[num2].stack = stack2;
							num2++;
						}
						if (genRand.Next(2) == 0)
						{
							int num20 = genRand.Next(2);
							int stack3 = genRand.Next(25) + 25;
							if (num20 == 0)
							{
								chest.item[num2].SetDefaults(40);
							}
							if (num20 == 1)
							{
								chest.item[num2].SetDefaults(42);
							}
							chest.item[num2].stack = stack3;
							num2++;
						}
						if (genRand.Next(2) == 0)
						{
							int stack4 = genRand.Next(3) + 3;
							chest.item[num2].SetDefaults(28);
							chest.item[num2].stack = stack4;
							num2++;
						}
						if (genRand.Next(3) > 0)
						{
							int num21 = genRand.Next(9);
							int stack5 = genRand.Next(1, 3);
							if (num21 == 0)
							{
								chest.item[num2].SetDefaults(289);
							}
							if (num21 == 1)
							{
								chest.item[num2].SetDefaults(298);
							}
							if (num21 == 2)
							{
								chest.item[num2].SetDefaults(299);
							}
							if (num21 == 3)
							{
								chest.item[num2].SetDefaults(290);
							}
							if (num21 == 4)
							{
								chest.item[num2].SetDefaults(303);
							}
							if (num21 == 5)
							{
								chest.item[num2].SetDefaults(291);
							}
							if (num21 == 6)
							{
								chest.item[num2].SetDefaults(304);
							}
							if (num21 == 7)
							{
								chest.item[num2].SetDefaults(2322);
							}
							if (num21 == 8)
							{
								chest.item[num2].SetDefaults(2329);
							}
							chest.item[num2].stack = stack5;
							num2++;
						}
						if (genRand.Next(3) != 0)
						{
							int stack6 = genRand.Next(2, 5);
							chest.item[num2].SetDefaults(2350);
							chest.item[num2].stack = stack6;
							num2++;
						}
						if (genRand.Next(2) == 0)
						{
							int stack7 = genRand.Next(11) + 10;
							if (num13 == 11)
							{
								chest.item[num2].SetDefaults(974);
							}
							else
							{
								chest.item[num2].SetDefaults(8);
							}
							chest.item[num2].stack = stack7;
							num2++;
						}
						if (genRand.Next(2) == 0)
						{
							chest.item[num2].SetDefaults(72);
							chest.item[num2].stack = genRand.Next(50, 90);
							num2++;
						}
					}
					else if (num11 < Main.maxTilesY - 250 || (remixWorldGen && (Style == 7 || Style == 14)))
					{
						if (contain > 0)
						{
							chest.item[num2].SetDefaults(contain);
							chest.item[num2].Prefix(-1);
							num2++;
							if (flag && genRand.Next(5) == 0)
							{
								chest.item[num2].SetDefaults(3199);
								num2++;
							}
							if (flag7)
							{
								if (genRand.Next(7) == 0)
								{
									chest.item[num2].SetDefaults(4346);
									num2++;
								}
								if (genRand.Next(15) == 0)
								{
									chest.item[num2].SetDefaults(4066);
									num2++;
								}
							}
							if (flag8 && genRand.Next(6) == 0)
							{
								chest.item[num2++].SetDefaults(3360);
								chest.item[num2++].SetDefaults(3361);
							}
							if (flag8 && genRand.Next(10) == 0)
							{
								chest.item[num2++].SetDefaults(4426);
							}
							if (flag9)
							{
								if (genRand.Next(2) == 0)
								{
									chest.item[num2++].SetDefaults(4425);
								}
								if (genRand.Next(2) == 0)
								{
									chest.item[num2++].SetDefaults(4460);
								}
							}
							if (flag13 && (!GenVars.generatedShadowKey || genRand.Next(3) == 0))
							{
								GenVars.generatedShadowKey = true;
								chest.item[num2].SetDefaults(329);
								num2++;
							}
						}
						else
						{
							int num6 = genRand.Next(7);
							bool flag6 = num11 > GenVars.lavaLine;
							if (remixWorldGen)
							{
								flag6 = (double)num11 > Main.worldSurface && (double)num11 < Main.rockLayer;
							}
							int maxValue = 20;
							if (tenthAnniversaryWorldGen)
							{
								maxValue = 15;
							}
							if (genRand.Next(maxValue) == 0 && flag6)
							{
								chest.item[num2].SetDefaults(906);
								chest.item[num2].Prefix(-1);
							}
							else if (genRand.Next(15) == 0)
							{
								chest.item[num2].SetDefaults(997);
								chest.item[num2].Prefix(-1);
							}
							else
							{
								if (num6 == 0)
								{
									chest.item[num2].SetDefaults(49);
									chest.item[num2].Prefix(-1);
								}
								if (num6 == 1)
								{
									chest.item[num2].SetDefaults(50);
									chest.item[num2].Prefix(-1);
								}
								if (num6 == 2)
								{
									chest.item[num2].SetDefaults(53);
									chest.item[num2].Prefix(-1);
								}
								if (num6 == 3)
								{
									chest.item[num2].SetDefaults(54);
									chest.item[num2].Prefix(-1);
								}
								if (num6 == 4)
								{
									chest.item[num2].SetDefaults(5011);
									chest.item[num2].Prefix(-1);
								}
								if (num6 == 5)
								{
									chest.item[num2].SetDefaults(975);
									chest.item[num2].Prefix(-1);
								}
								if (num6 == 6)
								{
									chest.item[num2].SetDefaults(930);
									chest.item[num2].Prefix(-1);
									num2++;
									chest.item[num2].SetDefaults(931);
									chest.item[num2].stack = genRand.Next(26) + 25;
								}
							}
							num2++;
							if (flag11)
							{
								if (genRand.Next(2) == 0)
								{
									chest.item[num2].SetDefaults(4450);
									num2++;
								}
								else
								{
									chest.item[num2].SetDefaults(4779);
									num2++;
									chest.item[num2].SetDefaults(4780);
									num2++;
									chest.item[num2].SetDefaults(4781);
									num2++;
								}
							}
						}
						if (genRand.Next(5) == 0)
						{
							chest.item[num2].SetDefaults(43);
							num2++;
						}
						if (genRand.Next(3) == 0)
						{
							chest.item[num2].SetDefaults(167);
							num2++;
						}
						if (genRand.Next(4) == 0)
						{
							chest.item[num2].SetDefaults(51);
							chest.item[num2].stack = genRand.Next(26) + 25;
							num2++;
						}
						if (genRand.Next(2) == 0)
						{
							int num22 = genRand.Next(2);
							int stack8 = genRand.Next(8) + 3;
							if (num22 == 0)
							{
								chest.item[num2].SetDefaults(GenVars.goldBar);
							}
							if (num22 == 1)
							{
								chest.item[num2].SetDefaults(GenVars.silverBar);
							}
							chest.item[num2].stack = stack8;
							num2++;
						}
						if (genRand.Next(2) == 0)
						{
							int num23 = genRand.Next(2);
							int stack9 = genRand.Next(26) + 25;
							if (num23 == 0)
							{
								chest.item[num2].SetDefaults(41);
							}
							if (num23 == 1)
							{
								chest.item[num2].SetDefaults(279);
							}
							chest.item[num2].stack = stack9;
							num2++;
						}
						if (genRand.Next(2) == 0)
						{
							int stack10 = genRand.Next(3) + 3;
							chest.item[num2].SetDefaults(188);
							chest.item[num2].stack = stack10;
							num2++;
						}
						if (genRand.Next(3) > 0)
						{
							int num24 = genRand.Next(6);
							int stack11 = genRand.Next(1, 3);
							if (num24 == 0)
							{
								chest.item[num2].SetDefaults(296);
							}
							if (num24 == 1)
							{
								chest.item[num2].SetDefaults(295);
							}
							if (num24 == 2)
							{
								chest.item[num2].SetDefaults(299);
							}
							if (num24 == 3)
							{
								chest.item[num2].SetDefaults(302);
							}
							if (num24 == 4)
							{
								chest.item[num2].SetDefaults(303);
							}
							if (num24 == 5)
							{
								chest.item[num2].SetDefaults(305);
							}
							chest.item[num2].stack = stack11;
							num2++;
						}
						if (genRand.Next(3) > 1)
						{
							int num25 = genRand.Next(6);
							int stack13 = genRand.Next(1, 3);
							if (num25 == 0)
							{
								chest.item[num2].SetDefaults(301);
							}
							if (num25 == 1)
							{
								chest.item[num2].SetDefaults(297);
							}
							if (num25 == 2)
							{
								chest.item[num2].SetDefaults(304);
							}
							if (num25 == 3)
							{
								chest.item[num2].SetDefaults(2329);
							}
							if (num25 == 4)
							{
								chest.item[num2].SetDefaults(2351);
							}
							if (num25 == 5)
							{
								chest.item[num2].SetDefaults(2326);
							}
							chest.item[num2].stack = stack13;
							num2++;
						}
						if (genRand.Next(2) == 0)
						{
							int stack14 = genRand.Next(2, 5);
							chest.item[num2].SetDefaults(2350);
							chest.item[num2].stack = stack14;
							num2++;
						}
						if (genRand.Next(2) == 0)
						{
							int num26 = genRand.Next(2);
							int stack15 = genRand.Next(15) + 15;
							if (num26 == 0)
							{
								if (num13 == 11)
								{
									chest.item[num2].SetDefaults(974);
								}
								else
								{
									chest.item[num2].SetDefaults(8);
								}
							}
							if (num26 == 1)
							{
								chest.item[num2].SetDefaults(282);
							}
							chest.item[num2].stack = stack15;
							num2++;
						}
						if (genRand.Next(2) == 0)
						{
							chest.item[num2].SetDefaults(73);
							chest.item[num2].stack = genRand.Next(1, 3);
							num2++;
						}
					}
					else
					{
						if (contain > 0)
						{
							chest.item[num2].SetDefaults(contain);
							chest.item[num2].Prefix(-1);
							num2++;
							if (flag12 && genRand.Next(5) == 0)
							{
								chest.item[num2].SetDefaults(5010);
								num2++;
							}
							if (flag12 && genRand.Next(10) == 0)
							{
								chest.item[num2].SetDefaults(4443);
								num2++;
							}
							if (flag12 && genRand.Next(10) == 0)
							{
								chest.item[num2].SetDefaults(4737);
								num2++;
							}
							if (flag12 && genRand.Next(10) == 0)
							{
								chest.item[num2].SetDefaults(4551);
								num2++;
							}
						}
						else
						{
							int num27 = genRand.Next(4);
							if (num27 == 0)
							{
								chest.item[num2].SetDefaults(49);
								chest.item[num2].Prefix(-1);
							}
							if (num27 == 1)
							{
								chest.item[num2].SetDefaults(50);
								chest.item[num2].Prefix(-1);
							}
							if (num27 == 2)
							{
								chest.item[num2].SetDefaults(53);
								chest.item[num2].Prefix(-1);
							}
							if (num27 == 3)
							{
								chest.item[num2].SetDefaults(54);
								chest.item[num2].Prefix(-1);
							}
							num2++;
						}
						if (genRand.Next(3) == 0)
						{
							chest.item[num2].SetDefaults(167);
							num2++;
						}
						if (genRand.Next(2) == 0)
						{
							int num28 = genRand.Next(2);
							int stack16 = genRand.Next(15) + 15;
							if (num28 == 0)
							{
								chest.item[num2].SetDefaults(117);
							}
							if (num28 == 1)
							{
								chest.item[num2].SetDefaults(GenVars.goldBar);
							}
							chest.item[num2].stack = stack16;
							num2++;
						}
						if (genRand.Next(2) == 0)
						{
							int num29 = genRand.Next(2);
							int stack17 = genRand.Next(25) + 50;
							if (num29 == 0)
							{
								chest.item[num2].SetDefaults(265);
							}
							if (num29 == 1)
							{
								if (SavedOreTiers.Silver == 168)
								{
									chest.item[num2].SetDefaults(4915);
								}
								else
								{
									chest.item[num2].SetDefaults(278);
								}
							}
							chest.item[num2].stack = stack17;
							num2++;
						}
						if (genRand.Next(2) == 0)
						{
							int stack18 = genRand.Next(6) + 15;
							chest.item[num2].SetDefaults(227);
							chest.item[num2].stack = stack18;
							num2++;
						}
						if (genRand.Next(4) > 0)
						{
							int num30 = genRand.Next(8);
							int stack19 = genRand.Next(1, 3);
							if (num30 == 0)
							{
								chest.item[num2].SetDefaults(296);
							}
							if (num30 == 1)
							{
								chest.item[num2].SetDefaults(295);
							}
							if (num30 == 2)
							{
								chest.item[num2].SetDefaults(293);
							}
							if (num30 == 3)
							{
								chest.item[num2].SetDefaults(288);
							}
							if (num30 == 4)
							{
								chest.item[num2].SetDefaults(294);
							}
							if (num30 == 5)
							{
								chest.item[num2].SetDefaults(297);
							}
							if (num30 == 6)
							{
								chest.item[num2].SetDefaults(304);
							}
							if (num30 == 7)
							{
								chest.item[num2].SetDefaults(2323);
							}
							chest.item[num2].stack = stack19;
							num2++;
						}
						if (genRand.Next(3) > 0)
						{
							int num31 = genRand.Next(8);
							int stack20 = genRand.Next(1, 3);
							if (num31 == 0)
							{
								chest.item[num2].SetDefaults(305);
							}
							if (num31 == 1)
							{
								chest.item[num2].SetDefaults(301);
							}
							if (num31 == 2)
							{
								chest.item[num2].SetDefaults(302);
							}
							if (num31 == 3)
							{
								chest.item[num2].SetDefaults(288);
							}
							if (num31 == 4)
							{
								chest.item[num2].SetDefaults(300);
							}
							if (num31 == 5)
							{
								chest.item[num2].SetDefaults(2351);
							}
							if (num31 == 6)
							{
								chest.item[num2].SetDefaults(2348);
							}
							if (num31 == 7)
							{
								chest.item[num2].SetDefaults(2345);
							}
							chest.item[num2].stack = stack20;
							num2++;
						}
						if (genRand.Next(3) == 0)
						{
							int stack21 = genRand.Next(1, 3);
							if (genRand.Next(2) == 0)
							{
								chest.item[num2].SetDefaults(2350);
							}
							else
							{
								chest.item[num2].SetDefaults(4870);
							}
							chest.item[num2].stack = stack21;
							num2++;
						}
						if (genRand.Next(2) == 0)
						{
							int num32 = genRand.Next(2);
							int stack22 = genRand.Next(15) + 15;
							if (num32 == 0)
							{
								chest.item[num2].SetDefaults(8);
							}
							if (num32 == 1)
							{
								chest.item[num2].SetDefaults(282);
							}
							chest.item[num2].stack = stack22;
							num2++;
						}
						if (genRand.Next(2) == 0)
						{
							chest.item[num2].SetDefaults(73);
							chest.item[num2].stack = genRand.Next(2, 5);
							num2++;
						}
					}
					if (num2 > 0 && chestTileType == 21)
					{
						if (num13 == 10 && genRand.Next(4) == 0)
						{
							chest.item[num2].SetDefaults(2204);
							num2++;
						}
						if (num13 == 11 && genRand.Next(7) == 0)
						{
							chest.item[num2].SetDefaults(2198);
							num2++;
						}
						if (flag2 && genRand.Next(3) == 0)
						{
							chest.item[num2].SetDefaults(2197);
							num2++;
						}
						if (flag2)
						{
							int num33 = genRand.Next(6);
							if (num33 == 0)
							{
								chest.item[num2].SetDefaults(5258);
							}
							if (num33 == 1)
							{
								chest.item[num2].SetDefaults(5226);
							}
							if (num33 == 2)
							{
								chest.item[num2].SetDefaults(5254);
							}
							if (num33 == 3)
							{
								chest.item[num2].SetDefaults(5238);
							}
							if (num33 == 4)
							{
								chest.item[num2].SetDefaults(5255);
							}
							if (num33 == 5)
							{
								chest.item[num2].SetDefaults(5388);
							}
							num2++;
						}
						if (flag2)
						{
							chest.item[num2].SetDefaults(751);
							chest.item[num2].stack = genRand.Next(50, 101);
							num2++;
						}
						if (num13 == 16)
						{
							chest.item[num2].SetDefaults(2195);
							num2++;
						}
						if (Main.wallDungeon[Main.tile[i, k].wall] && genRand.Next(8) == 0)
						{
							chest.item[num2].SetDefaults(2192);
							num2++;
						}
						if ((num13 == 23 || num13 == 24 || num13 == 25 || num13 == 26 || num13 == 27) && genRand.Next(2) == 0)
						{
							chest.item[num2].SetDefaults(5234);
							num2++;
						}
						if (num13 == 16)
						{
							if (genRand.Next(5) == 0)
							{
								chest.item[num2].SetDefaults(2767);
								num2++;
							}
							else
							{
								chest.item[num2].SetDefaults(2766);
								chest.item[num2].stack = genRand.Next(3, 8);
								num2++;
							}
						}
					}
					if (num2 <= 0 || chestTileType != 467)
					{
						continue;
					}
					if (flag2 && genRand.Next(3) == 0)
					{
						chest.item[num2].SetDefaults(2197);
						num2++;
					}
					if (flag2)
					{
						int num34 = genRand.Next(5);
						if (num34 == 0)
						{
							chest.item[num2].SetDefaults(5258);
						}
						if (num34 == 1)
						{
							chest.item[num2].SetDefaults(5226);
						}
						if (num34 == 2)
						{
							chest.item[num2].SetDefaults(5254);
						}
						if (num34 == 3)
						{
							chest.item[num2].SetDefaults(5238);
						}
						if (num34 == 4)
						{
							chest.item[num2].SetDefaults(5255);
						}
						num2++;
					}
					if (flag2)
					{
						chest.item[num2].SetDefaults(751);
						chest.item[num2].stack = genRand.Next(50, 101);
						num2++;
					}
					if (num13 == 13 && genRand.Next(2) == 0)
					{
						chest.item[num2].SetDefaults(5234);
						num2++;
					}
				}
				return true;
			}
			if (trySlope)
			{
				if (num5 > -1)
				{
					Main.tile[i - 1, k].slope((byte)num5);
				}
				if (num7 > -1)
				{
					Main.tile[i, k].slope((byte)num7);
				}
			}
			return false;
		}
		return false;
	}

	public static void UnlockDoor(int i, int j)
	{
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		int num = j;
		if (Main.tile[i, num] == null)
		{
			return;
		}
		Tile tile;
		while (true)
		{
			tile = Main.tile[i, num];
			if (tile.frameY == 594)
			{
				break;
			}
			num--;
			tile = Main.tile[i, num];
			if (tile.frameY < 594 || num <= 0)
			{
				return;
			}
		}
		SoundEngine.PlaySound(22, i * 16, num * 16 + 16);
		for (int k = num; k <= num + 2; k++)
		{
			if (Main.tile[i, k] == null)
			{
				tile = (Main.tile[i, k] = default(Tile));
			}
			tile = Main.tile[i, k];
			tile.frameY += 54;
			for (int l = 0; l < 4; l++)
			{
				Dust.NewDust(new Vector2((float)(i * 16), (float)(k * 16)), 16, 16, 11);
			}
		}
		AchievementsHelper.NotifyProgressionEvent(22);
	}

	public static bool OpenDoor(int i, int j, int direction)
	{
		int num = 0;
		if (Main.tile[i, j - 1] == null)
		{
			Main.tile[i, j - 1] = default(Tile);
		}
		if (Main.tile[i, j - 2] == null)
		{
			Main.tile[i, j - 2] = default(Tile);
		}
		if (Main.tile[i, j + 1] == null)
		{
			Main.tile[i, j + 1] = default(Tile);
		}
		if (Main.tile[i, j] == null)
		{
			Main.tile[i, j] = default(Tile);
		}
		Tile tile = Main.tile[i, j];
		if (TileLoader.OpenDoorID(tile) < 0)
		{
			return false;
		}
		if (IsLockedDoor(tile))
		{
			return false;
		}
		short num2 = 0;
		int num3 = tile.frameY;
		int num4 = 0;
		while (num3 >= 54)
		{
			num3 -= 54;
			num4++;
		}
		if (tile.frameX >= 54)
		{
			int num5 = tile.frameX / 54;
			num4 += 36 * num5;
			num2 += (short)(72 * num5);
		}
		num = j - num3 / 18;
		int num6 = i;
		TileColorCache cache = Main.tile[num6, num].BlockColorAndCoating();
		if (Main.tile[num6, num + 1] == null)
		{
			Main.tile[num6, num + 1] = default(Tile);
		}
		TileColorCache cache2 = Main.tile[num6, num + 1].BlockColorAndCoating();
		if (Main.tile[num6, num + 2] == null)
		{
			Main.tile[num6, num + 2] = default(Tile);
		}
		TileColorCache cache3 = Main.tile[num6, num + 2].BlockColorAndCoating();
		int num7;
		if (direction == -1)
		{
			num6 = i - 1;
			num2 += 36;
			num7 = i - 1;
		}
		else
		{
			num6 = i;
			num7 = i + 1;
		}
		for (int k = num; k < num + 3; k++)
		{
			if (Main.tile[num7, k] == null)
			{
				Main.tile[num7, k] = default(Tile);
			}
			if (Main.tile[num7, k].active())
			{
				if (!Main.tileCut[Main.tile[num7, k].type] && Main.tile[num7, k].type != 3 && Main.tile[num7, k].type != 24 && Main.tile[num7, k].type != 52 && Main.tile[num7, k].type != 61 && Main.tile[num7, k].type != 62 && Main.tile[num7, k].type != 69 && Main.tile[num7, k].type != 655 && Main.tile[num7, k].type != 71 && Main.tile[num7, k].type != 73 && Main.tile[num7, k].type != 74 && Main.tile[num7, k].type != 110 && Main.tile[num7, k].type != 113 && Main.tile[num7, k].type != 115 && Main.tile[num7, k].type != 165)
				{
					return false;
				}
				KillTile(num7, k);
			}
		}
		if (Main.netMode != 1 && Wiring.running)
		{
			Wiring.SkipWire(num6, num);
			Wiring.SkipWire(num6, num + 1);
			Wiring.SkipWire(num6, num + 2);
			Wiring.SkipWire(num6 + 1, num);
			Wiring.SkipWire(num6 + 1, num + 1);
			Wiring.SkipWire(num6 + 1, num + 2);
		}
		int num8 = num4 % 36 * 54;
		SoundEngine.PlaySound(8, i * 16, j * 16);
		ushort openDoorID = (ushort)TileLoader.OpenDoorID(Main.tile[i, j]);
		Main.tile[num6, num].active(active: true);
		Main.tile[num6, num].type = openDoorID;
		Main.tile[num6, num].frameY = (short)num8;
		Main.tile[num6, num].frameX = num2;
		Main.tile[num6, num].UseBlockColors(cache);
		if (Main.tile[num6 + 1, num] == null)
		{
			Main.tile[num6 + 1, num] = default(Tile);
		}
		Main.tile[num6 + 1, num].active(active: true);
		Main.tile[num6 + 1, num].type = openDoorID;
		Main.tile[num6 + 1, num].frameY = (short)num8;
		Main.tile[num6 + 1, num].frameX = (short)(num2 + 18);
		Main.tile[num6 + 1, num].UseBlockColors(cache);
		if (Main.tile[num6, num + 1] == null)
		{
			Main.tile[num6, num + 1] = default(Tile);
		}
		Main.tile[num6, num + 1].active(active: true);
		Main.tile[num6, num + 1].type = openDoorID;
		Main.tile[num6, num + 1].frameY = (short)(num8 + 18);
		Main.tile[num6, num + 1].frameX = num2;
		Main.tile[num6, num + 1].UseBlockColors(cache2);
		if (Main.tile[num6 + 1, num + 1] == null)
		{
			Main.tile[num6 + 1, num + 1] = default(Tile);
		}
		Main.tile[num6 + 1, num + 1].active(active: true);
		Main.tile[num6 + 1, num + 1].type = openDoorID;
		Main.tile[num6 + 1, num + 1].frameY = (short)(num8 + 18);
		Main.tile[num6 + 1, num + 1].frameX = (short)(num2 + 18);
		Main.tile[num6 + 1, num + 1].UseBlockColors(cache2);
		if (Main.tile[num6, num + 2] == null)
		{
			Main.tile[num6, num + 2] = default(Tile);
		}
		Main.tile[num6, num + 2].active(active: true);
		Main.tile[num6, num + 2].type = openDoorID;
		Main.tile[num6, num + 2].frameY = (short)(num8 + 36);
		Main.tile[num6, num + 2].frameX = num2;
		Main.tile[num6, num + 2].UseBlockColors(cache3);
		if (Main.tile[num6 + 1, num + 2] == null)
		{
			Main.tile[num6 + 1, num + 2] = default(Tile);
		}
		Main.tile[num6 + 1, num + 2].active(active: true);
		Main.tile[num6 + 1, num + 2].type = openDoorID;
		Main.tile[num6 + 1, num + 2].frameY = (short)(num8 + 36);
		Main.tile[num6 + 1, num + 2].frameX = (short)(num2 + 18);
		Main.tile[num6 + 1, num + 2].UseBlockColors(cache3);
		for (int l = num6 - 1; l <= num6 + 2; l++)
		{
			for (int m = num - 1; m <= num + 2; m++)
			{
				TileFrame(l, m);
			}
		}
		return true;
	}

	public static void Check1xX(int x, int j, short type)
	{
		if (destroyObject)
		{
			return;
		}
		int frameX = Main.tile[x, j].frameX;
		int num = 3;
		if (type == 92)
		{
			num = 6;
		}
		int num2 = Main.tile[x, j].frameY;
		int num3 = 0;
		while (num2 >= 18 * num)
		{
			num2 -= 18 * num;
			num3++;
		}
		int num4 = Main.tile[x, j].frameX / 18;
		int num5 = j - num2 / 18;
		bool flag = false;
		for (int i = 0; i < num; i++)
		{
			if (Main.tile[x, num5 + i] == null)
			{
				Main.tile[x, num5 + i] = default(Tile);
			}
			if (!Main.tile[x, num5 + i].active())
			{
				flag = true;
			}
			else if (Main.tile[x, num5 + i].type != type)
			{
				flag = true;
			}
			else if (Main.tile[x, num5 + i].frameY != i * 18 + num3 * num * 18)
			{
				flag = true;
			}
			else if (Main.tile[x, num5 + i].frameX != frameX)
			{
				flag = true;
			}
		}
		if (Main.tile[x, num5 + num] == null)
		{
			Main.tile[x, num5 + num] = default(Tile);
		}
		if (!SolidTileAllowBottomSlope(x, num5 + num))
		{
			flag = true;
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(x, j, type);
		for (int k = 0; k < num; k++)
		{
			if (Main.tile[x, num5 + k].type == type)
			{
				KillTile(x, num5 + k);
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			if (type == 92)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, j), x * 16, j * 16, 32, 32, 341);
			}
			if (type == 453)
			{
				int num6 = 0;
				num6 = ((num4 < 2) ? 3744 : ((num4 >= 4) ? 3743 : 3745));
				Item.NewItem(GetItemSource_FromTileBreak(x, j), x * 16, j * 16, 16, 32, num6);
			}
			if (type == 93)
			{
				int type2 = 0;
				switch (num3)
				{
				case 0:
					type2 = 342;
					break;
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7:
				case 8:
				case 9:
				case 10:
					type2 = 2082 + num3 - 1;
					break;
				case 11:
				case 12:
				case 13:
				case 14:
				case 15:
				case 16:
					type2 = 2129 + num3 - 11;
					break;
				default:
					switch (num3)
					{
					case 17:
						type2 = 2225;
						break;
					case 18:
						type2 = 2533;
						break;
					case 19:
						type2 = 2547;
						break;
					case 20:
						type2 = 2563;
						break;
					case 21:
						type2 = 2578;
						break;
					case 22:
						type2 = 2643;
						break;
					case 23:
						type2 = 2644;
						break;
					case 24:
						type2 = 2645;
						break;
					case 25:
						type2 = 2646;
						break;
					case 26:
						type2 = 2647;
						break;
					case 27:
						type2 = 2819;
						break;
					case 28:
						type2 = 3135;
						break;
					case 29:
						type2 = 3137;
						break;
					case 30:
						type2 = 3136;
						break;
					case 31:
						type2 = 3892;
						break;
					case 32:
						type2 = 3942;
						break;
					case 33:
						type2 = 3969;
						break;
					case 34:
						type2 = 4156;
						break;
					case 35:
						type2 = 4177;
						break;
					case 36:
						type2 = 4198;
						break;
					case 37:
						type2 = 4219;
						break;
					case 38:
						type2 = 4308;
						break;
					case 39:
						type2 = 4577;
						break;
					case 40:
						type2 = 5159;
						break;
					case 41:
						type2 = 5180;
						break;
					case 42:
						type2 = 5201;
						break;
					}
					break;
				}
				Item.NewItem(GetItemSource_FromTileBreak(x, j), x * 16, j * 16, 32, 32, type2);
			}
			destroyObject = false;
		}
	}

	public static void Check2xX(int i, int j, ushort type)
	{
		if (destroyObject)
		{
			return;
		}
		int num = i;
		int num8;
		for (num8 = Main.tile[i, j].frameX; num8 >= 36; num8 -= 36)
		{
		}
		if (num8 == 18)
		{
			num--;
		}
		if (Main.tile[num, j] == null)
		{
			Main.tile[num, j] = default(Tile);
		}
		int num9 = Main.tile[num, j].frameY / 18;
		int num10 = 3;
		if (type == 104)
		{
			num10 = 5;
		}
		if (type == 207)
		{
			num10 = 4;
		}
		int num11 = 0;
		while (num9 >= num10)
		{
			num9 -= num10;
			num11 += num10 * 18;
		}
		int num12 = j - num9;
		if (type == 410 && num11 != 0)
		{
			num11 += 2;
		}
		if (Main.tile[num, num12] == null)
		{
			Main.tile[num, num12] = default(Tile);
		}
		int frameX = Main.tile[num, j].frameX;
		int frameY = Main.tile[num, j].frameY;
		bool flag = false;
		for (int k = 0; k < num10; k++)
		{
			if (Main.tile[num, num12 + k] == null)
			{
				Main.tile[num, num12 + k] = default(Tile);
			}
			if (!Main.tile[num, num12 + k].active())
			{
				flag = true;
			}
			else if (Main.tile[num, num12 + k].type != type)
			{
				flag = true;
			}
			else if (Main.tile[num, num12 + k].frameY != k * 18 + num11)
			{
				flag = true;
			}
			else if (Main.tile[num, num12 + k].frameX != frameX)
			{
				flag = true;
			}
			if (Main.tile[num + 1, num12 + k] == null)
			{
				Main.tile[num + 1, num12 + k] = default(Tile);
			}
			if (!Main.tile[num + 1, num12 + k].active())
			{
				flag = true;
			}
			else if (Main.tile[num + 1, num12 + k].type != type)
			{
				flag = true;
			}
			else if (Main.tile[num + 1, num12 + k].frameY != k * 18 + num11)
			{
				flag = true;
			}
			else if (Main.tile[num + 1, num12 + k].frameX != frameX + 18)
			{
				flag = true;
			}
		}
		if (type == 465 || type == 531 || type == 591 || type == 592)
		{
			bool flag2 = false;
			for (int l = 0; l < 2; l++)
			{
				bool flag3 = false;
				Tile tileSafely = Framing.GetTileSafely(num + l, num12 - 1);
				if (type != 531 && tileSafely.type == 380)
				{
					flag3 = true;
				}
				else if (type != 531 && TileID.Sets.Platforms[tileSafely.type])
				{
					if (l == 0)
					{
						flag2 = IsBelowANonHammeredPlatform(num + l, num12);
						flag3 = true;
					}
					else if (flag2 == IsBelowANonHammeredPlatform(num + l, num12))
					{
						flag3 = true;
					}
				}
				else
				{
					flag3 = SolidTileAllowTopSlope(num + l, num12 - 1);
				}
				if (!flag3)
				{
					flag = true;
					break;
				}
			}
		}
		else
		{
			if (!SolidTileAllowBottomSlope(num, num12 + num10))
			{
				flag = true;
			}
			if (!SolidTileAllowBottomSlope(num + 1, num12 + num10))
			{
				flag = true;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(i, j, type);
		for (int m = 0; m < num10; m++)
		{
			if (Main.tile[num, num12 + m].type == type)
			{
				KillTile(num, num12 + m);
			}
			if (Main.tile[num + 1, num12 + m].type == type)
			{
				KillTile(num + 1, num12 + m);
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			if (type == 104)
			{
				int num13 = frameX / 36;
				int num14 = 0;
				if (num13 >= 1 && num13 <= 5)
				{
					num14 = 2237 + num13 - 1;
				}
				else
				{
					switch (num13)
					{
					case 6:
						num14 = 2560;
						break;
					case 7:
						num14 = 2575;
						break;
					case 8:
					case 9:
					case 10:
					case 11:
					case 12:
					case 13:
					case 14:
					case 15:
					case 16:
					case 17:
					case 18:
					case 19:
					case 20:
					case 21:
					case 22:
					case 23:
						num14 = 2591 + num13 - 8;
						break;
					case 24:
						num14 = 2809;
						break;
					case 25:
						num14 = 3126;
						break;
					case 26:
						num14 = 3128;
						break;
					case 27:
						num14 = 3127;
						break;
					case 28:
						num14 = 3898;
						break;
					case 29:
						num14 = 3899;
						break;
					case 30:
						num14 = 3900;
						break;
					case 31:
						num14 = 3901;
						break;
					case 32:
						num14 = 3902;
						break;
					case 33:
						num14 = 3940;
						break;
					case 34:
						num14 = 3966;
						break;
					case 35:
						num14 = 4154;
						break;
					case 36:
						num14 = 4175;
						break;
					case 37:
						num14 = 4196;
						break;
					case 38:
						num14 = 4217;
						break;
					case 39:
						num14 = 4306;
						break;
					case 40:
						num14 = 4575;
						break;
					case 41:
						num14 = 5157;
						break;
					case 42:
						num14 = 5178;
						break;
					case 43:
						num14 = 5199;
						break;
					default:
						num14 = 359;
						break;
					}
				}
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, num14);
			}
			if (type == 105)
			{
				int num15 = frameX / 36;
				int num2 = frameY / 54;
				num2 %= 3;
				num15 += num2 * 55;
				switch (num15)
				{
				case 0:
					num15 = 360;
					break;
				case 1:
					num15 = 52;
					break;
				case 43:
					num15 = 1152;
					break;
				case 44:
					num15 = 1153;
					break;
				case 45:
					num15 = 1154;
					break;
				case 46:
					num15 = 1408;
					break;
				case 47:
					num15 = 1409;
					break;
				case 48:
					num15 = 1410;
					break;
				case 49:
					num15 = 1462;
					break;
				case 50:
					num15 = 2672;
					break;
				case 51:
				case 52:
				case 53:
				case 54:
				case 55:
				case 56:
				case 57:
				case 58:
				case 59:
				case 60:
				case 61:
				case 62:
					num15 = 3651 + num15 - 51;
					break;
				case 63:
				case 64:
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
				case 72:
				case 73:
				case 74:
				case 75:
					num15 = 3708 + num15 - 63;
					break;
				default:
					num15 = num15 switch
					{
						76 => 4397, 
						77 => 4360, 
						78 => 4342, 
						79 => 4466, 
						80 => 5317, 
						81 => 5318, 
						82 => 5319, 
						_ => 438 + num15 - 2, 
					};
					break;
				}
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, num15);
			}
			if (type == 356)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 3064);
			}
			if (type == 663)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 5381);
			}
			if (type == 456)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 3748);
			}
			if (type == 337)
			{
				int num3 = frameX / 36;
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 2702 + num3);
			}
			if (type == 207)
			{
				int num4 = frameX / 36;
				switch (num4)
				{
				case 0:
					num4 = 909;
					break;
				case 1:
					num4 = 910;
					break;
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7:
					num4 = 938 + num4;
					break;
				case 8:
					num4 = 4922;
					break;
				case 9:
					num4 = 4417;
					break;
				}
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, num4);
			}
			if (type == 410)
			{
				int num5 = frameX / 36;
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, num5 + 3536);
			}
			if (type == 480)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 4054);
			}
			if (type == 509)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 4318);
			}
			if (type == 657)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 5345);
			}
			if (type == 658)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 5347);
			}
			if (type == 489)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 4074);
			}
			if (type == 320)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 2496);
			}
			if (type == 349)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 470);
			}
			if (type == 506)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 4276);
			}
			if (type == 545)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 4420);
			}
			if (type == 465)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 3815);
			}
			if (type == 531)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 4355);
			}
			if (type == 378)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 48, 3202);
				TETrainingDummy.Kill(num, num12);
			}
			if (type == 560)
			{
				int num6 = frameX / 36;
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, num6 + 4599);
			}
			if (type == 591)
			{
				int num7 = frameX / 36;
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, num7 + 4858);
			}
			if (type == 592)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 4867);
			}
			destroyObject = false;
		}
	}

	public static bool IsBelowANonHammeredPlatform(int x, int y)
	{
		if (y < 1)
		{
			return false;
		}
		Tile tile = Main.tile[x, y - 1];
		if (tile == null || !tile.active() || !TileID.Sets.Platforms[tile.type] || tile.halfBrick() || tile.slope() != 0)
		{
			return false;
		}
		return true;
	}

	public static void PlaceTight(int x, int y, bool spiders = false)
	{
		if (Main.tile[x, y - 1] == null)
		{
			Main.tile[x, y - 1] = default(Tile);
		}
		if (Main.tile[x, y] == null)
		{
			Main.tile[x, y] = default(Tile);
		}
		if (Main.tile[x, y + 1] == null)
		{
			Main.tile[x, y + 1] = default(Tile);
		}
		if (!Main.tile[x, y].shimmer())
		{
			PlaceUncheckedStalactite(x, y, genRand.Next(2) == 0, genRand.Next(3), spiders);
			if (Main.tile[x, y].type == 165)
			{
				CheckTight(x, y);
			}
		}
	}

	public static void PlaceUncheckedStalactite(int x, int y, bool preferSmall, int variation, bool spiders)
	{
		ushort type = 165;
		variation = Utils.Clamp(variation, 0, 2);
		if (SolidTile(x, y - 1) && !Main.tile[x, y].active() && !Main.tile[x, y + 1].active())
		{
			if (spiders)
			{
				int num = 108 + variation * 18;
				Main.tile[x, y].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameX = (short)num;
				Main.tile[x, y].frameY = 0;
				Main.tile[x, y + 1].type = type;
				Main.tile[x, y + 1].active(active: true);
				Main.tile[x, y + 1].frameX = (short)num;
				Main.tile[x, y + 1].frameY = 18;
				return;
			}
			if (Main.tile[x, y - 1].type == 147 || Main.tile[x, y - 1].type == 161 || Main.tile[x, y - 1].type == 163 || Main.tile[x, y - 1].type == 164 || Main.tile[x, y - 1].type == 200)
			{
				if (preferSmall)
				{
					int num12 = variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num12;
					Main.tile[x, y].frameY = 72;
				}
				else
				{
					int num15 = variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num15;
					Main.tile[x, y].frameY = 0;
					Main.tile[x, y + 1].type = type;
					Main.tile[x, y + 1].active(active: true);
					Main.tile[x, y + 1].frameX = (short)num15;
					Main.tile[x, y + 1].frameY = 18;
				}
			}
			if (Main.tile[x, y - 1].type == 1 || Main.tileMoss[Main.tile[x, y - 1].type] || Main.tile[x, y - 1].type == 117 || Main.tile[x, y - 1].type == 25 || Main.tile[x, y - 1].type == 203)
			{
				if (preferSmall)
				{
					int num16 = 54 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num16;
					Main.tile[x, y].frameY = 72;
				}
				else
				{
					int num17 = 54 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num17;
					Main.tile[x, y].frameY = 0;
					Main.tile[x, y + 1].type = type;
					Main.tile[x, y + 1].active(active: true);
					Main.tile[x, y + 1].frameX = (short)num17;
					Main.tile[x, y + 1].frameY = 18;
				}
			}
			if (Main.tile[x, y - 1].type == 225)
			{
				int num18 = 162 + variation * 18;
				Main.tile[x, y].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameX = (short)num18;
				Main.tile[x, y].frameY = 72;
			}
			if (Main.tile[x, y - 1].type == 396 || Main.tile[x, y - 1].type == 397)
			{
				if (preferSmall)
				{
					int num19 = 378 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num19;
					Main.tile[x, y].frameY = 72;
				}
				else
				{
					int num20 = 378 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num20;
					Main.tile[x, y].frameY = 0;
					Main.tile[x, y + 1].type = type;
					Main.tile[x, y + 1].active(active: true);
					Main.tile[x, y + 1].frameX = (short)num20;
					Main.tile[x, y + 1].frameY = 18;
				}
			}
			if (Main.tile[x, y - 1].type == 368)
			{
				if (preferSmall)
				{
					int num21 = 432 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num21;
					Main.tile[x, y].frameY = 72;
				}
				else
				{
					int num2 = 432 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num2;
					Main.tile[x, y].frameY = 0;
					Main.tile[x, y + 1].type = type;
					Main.tile[x, y + 1].active(active: true);
					Main.tile[x, y + 1].frameX = (short)num2;
					Main.tile[x, y + 1].frameY = 18;
				}
			}
			if (Main.tile[x, y - 1].type == 367)
			{
				if (preferSmall)
				{
					int num3 = 486 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num3;
					Main.tile[x, y].frameY = 72;
				}
				else
				{
					int num4 = 486 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num4;
					Main.tile[x, y].frameY = 0;
					Main.tile[x, y + 1].type = type;
					Main.tile[x, y + 1].active(active: true);
					Main.tile[x, y + 1].frameX = (short)num4;
					Main.tile[x, y + 1].frameY = 18;
				}
			}
		}
		else
		{
			if (spiders || !SolidTile(x, y + 1) || Main.tile[x, y].active() || Main.tile[x, y - 1].active())
			{
				return;
			}
			if (Main.tile[x, y + 1].type == 1 || Main.tileMoss[Main.tile[x, y + 1].type] || Main.tile[x, y - 1].type == 117 || Main.tile[x, y - 1].type == 25 || Main.tile[x, y - 1].type == 203)
			{
				if (preferSmall)
				{
					int num5 = 54 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num5;
					Main.tile[x, y].frameY = 90;
				}
				else
				{
					int num6 = 54 + variation * 18;
					Main.tile[x, y - 1].type = type;
					Main.tile[x, y - 1].active(active: true);
					Main.tile[x, y - 1].frameX = (short)num6;
					Main.tile[x, y - 1].frameY = 36;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num6;
					Main.tile[x, y].frameY = 54;
				}
			}
			if (Main.tile[x, y + 1].type == 225)
			{
				int num7 = 162 + variation * 18;
				Main.tile[x, y].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameX = (short)num7;
				Main.tile[x, y].frameY = 90;
			}
			if (Main.tile[x, y + 1].type == 396 || Main.tile[x, y + 1].type == 397)
			{
				if (preferSmall)
				{
					int num8 = 378 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num8;
					Main.tile[x, y].frameY = 90;
				}
				else
				{
					int num9 = 378 + variation * 18;
					Main.tile[x, y - 1].type = type;
					Main.tile[x, y - 1].active(active: true);
					Main.tile[x, y - 1].frameX = (short)num9;
					Main.tile[x, y - 1].frameY = 36;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num9;
					Main.tile[x, y].frameY = 54;
				}
			}
			if (Main.tile[x, y + 1].type == 368)
			{
				if (preferSmall)
				{
					int num10 = 432 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num10;
					Main.tile[x, y].frameY = 90;
				}
				else
				{
					int num11 = 432 + variation * 18;
					Main.tile[x, y - 1].type = type;
					Main.tile[x, y - 1].active(active: true);
					Main.tile[x, y - 1].frameX = (short)num11;
					Main.tile[x, y - 1].frameY = 36;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num11;
					Main.tile[x, y].frameY = 54;
				}
			}
			if (Main.tile[x, y + 1].type == 367)
			{
				if (preferSmall)
				{
					int num13 = 486 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num13;
					Main.tile[x, y].frameY = 90;
				}
				else
				{
					int num14 = 486 + variation * 18;
					Main.tile[x, y - 1].type = type;
					Main.tile[x, y - 1].active(active: true);
					Main.tile[x, y - 1].frameX = (short)num14;
					Main.tile[x, y - 1].frameY = 36;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num14;
					Main.tile[x, y].frameY = 54;
				}
			}
		}
	}

	public static bool UpdateStalagtiteStyle(int x, int j)
	{
		if (Main.netMode == 1)
		{
			return true;
		}
		if (Main.tile[x, j] == null)
		{
			return true;
		}
		GetStalagtiteStyle(x, j, out var style, out var fail);
		if (fail)
		{
			return false;
		}
		GetDesiredStalagtiteStyle(x, j, out var fail2, out var desiredStyle, out var height, out var y);
		if (fail2)
		{
			return false;
		}
		if (style != desiredStyle)
		{
			int num = genRand.Next(3) * 18;
			switch (desiredStyle)
			{
			case 0:
				num += 54;
				break;
			case 1:
				num += 216;
				break;
			case 2:
				num += 270;
				break;
			case 3:
				num += 324;
				break;
			case 4:
				num += 378;
				break;
			case 5:
				num += 432;
				break;
			case 6:
				num += 486;
				break;
			case 7:
				num = num;
				break;
			case 8:
				num += 540;
				break;
			case 9:
				num += 594;
				break;
			case 10:
				num += 648;
				break;
			}
			for (int i = y; i < y + height; i++)
			{
				Main.tile[x, i].frameX = (short)num;
			}
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, x, y, 1, 2);
			}
		}
		return true;
	}

	private static void GetDesiredStalagtiteStyle(int x, int j, out bool fail, out int desiredStyle, out int height, out int y)
	{
		fail = false;
		desiredStyle = 0;
		height = 1;
		y = j;
		if (Main.tile[x, y].frameY == 72)
		{
			desiredStyle = Main.tile[x, y - 1].type;
		}
		else if (Main.tile[x, y].frameY == 90)
		{
			desiredStyle = Main.tile[x, y + 1].type;
		}
		else if (Main.tile[x, y].frameY >= 36)
		{
			if (Main.tile[x, y].frameY == 54)
			{
				y--;
			}
			height = 2;
			desiredStyle = Main.tile[x, y + 2].type;
		}
		else
		{
			if (Main.tile[x, y].frameY == 18)
			{
				y--;
			}
			height = 2;
			desiredStyle = Main.tile[x, y - 1].type;
		}
		if (desiredStyle == 1 || Main.tileMoss[desiredStyle])
		{
			desiredStyle = 0;
		}
		else if (desiredStyle == 200)
		{
			desiredStyle = 10;
		}
		else if (desiredStyle == 164)
		{
			desiredStyle = 8;
		}
		else if (desiredStyle == 163)
		{
			desiredStyle = 9;
		}
		else if (desiredStyle == 117 || desiredStyle == 402 || desiredStyle == 403)
		{
			desiredStyle = 1;
		}
		else if (desiredStyle == 25 || desiredStyle == 398 || desiredStyle == 400)
		{
			desiredStyle = 2;
		}
		else if (desiredStyle == 203 || desiredStyle == 399 || desiredStyle == 401)
		{
			desiredStyle = 3;
		}
		else if (desiredStyle == 396 || desiredStyle == 397)
		{
			desiredStyle = 4;
		}
		else if (desiredStyle == 367)
		{
			desiredStyle = 6;
		}
		else if (desiredStyle == 368)
		{
			desiredStyle = 5;
		}
		else if (desiredStyle == 161 || desiredStyle == 147)
		{
			desiredStyle = 7;
		}
		else
		{
			fail = true;
		}
	}

	private static void GetStalagtiteStyle(int x, int y, out int style, out bool fail)
	{
		style = 0;
		fail = false;
		switch (Main.tile[x, y].frameX / 54)
		{
		default:
			fail = true;
			break;
		case 0:
			style = 7;
			break;
		case 1:
			style = 0;
			break;
		case 4:
			style = 1;
			break;
		case 5:
			style = 2;
			break;
		case 6:
			style = 3;
			break;
		case 7:
			style = 4;
			break;
		case 8:
			style = 5;
			break;
		case 9:
			style = 6;
			break;
		case 10:
			style = 8;
			break;
		case 11:
			style = 9;
			break;
		case 12:
			style = 10;
			break;
		}
	}

	public static void CheckTight(int x, int j)
	{
		if (Main.tile[x, j] == null)
		{
			return;
		}
		int num = j;
		if (Main.tile[x, num].frameY == 72)
		{
			if (Main.tile[x, num - 1] == null)
			{
				Main.tile[x, num - 1] = default(Tile);
			}
			if (Main.tile[x, num] == null)
			{
				Main.tile[x, num] = default(Tile);
			}
			if (Main.tile[x, num + 1] == null)
			{
				Main.tile[x, num + 1] = default(Tile);
			}
			bool flag = false;
			if (!SolidTile(x, num - 1))
			{
				flag = true;
			}
			if (!flag && !UpdateStalagtiteStyle(x, num))
			{
				flag = true;
			}
			if (flag)
			{
				destroyObject = true;
				if (Main.tile[x, num].type == Main.tile[x, j].type)
				{
					KillTile(x, num);
				}
				destroyObject = false;
			}
			return;
		}
		if (Main.tile[x, num].frameY == 90)
		{
			if (Main.tile[x, num - 1] == null)
			{
				Main.tile[x, num - 1] = default(Tile);
			}
			if (Main.tile[x, num] == null)
			{
				Main.tile[x, num] = default(Tile);
			}
			if (Main.tile[x, num + 1] == null)
			{
				Main.tile[x, num + 1] = default(Tile);
			}
			bool flag2 = false;
			if (!SolidTile(x, num + 1))
			{
				flag2 = true;
			}
			if (!flag2 && !UpdateStalagtiteStyle(x, num))
			{
				flag2 = true;
			}
			if (flag2)
			{
				destroyObject = true;
				if (Main.tile[x, num].type == Main.tile[x, j].type)
				{
					KillTile(x, num);
				}
				destroyObject = false;
			}
			return;
		}
		if (Main.tile[x, num].frameY >= 36)
		{
			if (Main.tile[x, num].frameY == 54)
			{
				num--;
			}
			if (Main.tile[x, num] == null)
			{
				Main.tile[x, num] = default(Tile);
			}
			if (Main.tile[x, num + 1] == null)
			{
				Main.tile[x, num + 1] = default(Tile);
			}
			if (Main.tile[x, num + 2] == null)
			{
				Main.tile[x, num + 2] = default(Tile);
			}
			bool flag3 = false;
			if (!SolidTile(x, num + 2))
			{
				flag3 = true;
			}
			if (Main.tile[x, num + 1].type != Main.tile[x, num].type)
			{
				flag3 = true;
			}
			if (Main.tile[x, num + 1].frameX != Main.tile[x, num].frameX)
			{
				flag3 = true;
			}
			if (!flag3 && !UpdateStalagtiteStyle(x, num))
			{
				flag3 = true;
			}
			if (flag3)
			{
				destroyObject = true;
				if (Main.tile[x, num].type == Main.tile[x, j].type)
				{
					KillTile(x, num);
				}
				if (Main.tile[x, num + 1].type == Main.tile[x, j].type)
				{
					KillTile(x, num + 1);
				}
				destroyObject = false;
			}
			return;
		}
		if (Main.tile[x, num].frameY == 18)
		{
			num--;
		}
		if (Main.tile[x, num - 1] == null)
		{
			Main.tile[x, num - 1] = default(Tile);
		}
		if (Main.tile[x, num] == null)
		{
			Main.tile[x, num] = default(Tile);
		}
		if (Main.tile[x, num + 1] == null)
		{
			Main.tile[x, num + 1] = default(Tile);
		}
		bool flag4 = false;
		if (!SolidTile(x, num - 1))
		{
			flag4 = true;
		}
		if (Main.tile[x, num + 1].type != Main.tile[x, num].type)
		{
			flag4 = true;
		}
		if (Main.tile[x, num + 1].frameX != Main.tile[x, num].frameX)
		{
			flag4 = true;
		}
		if (!flag4 && !UpdateStalagtiteStyle(x, num))
		{
			flag4 = true;
		}
		if (flag4)
		{
			destroyObject = true;
			if (Main.tile[x, num].type == Main.tile[x, j].type)
			{
				KillTile(x, num);
			}
			if (Main.tile[x, num + 1].type == Main.tile[x, j].type)
			{
				KillTile(x, num + 1);
			}
			destroyObject = false;
		}
	}

	public static void Place1xX(int x, int y, ushort type, int style = 0)
	{
		int num = style * 18;
		int num2 = 3;
		if (type == 92)
		{
			num2 = 6;
		}
		bool flag = true;
		for (int i = y - num2 + 1; i < y + 1; i++)
		{
			if (Main.tile[x, i] == null)
			{
				Main.tile[x, i] = default(Tile);
			}
			if (Main.tile[x, i].active())
			{
				flag = false;
			}
			if (type == 93 && Main.tile[x, i].liquid > 0)
			{
				flag = false;
			}
		}
		if (flag && SolidTile2(x, y + 1))
		{
			for (int j = 0; j < num2; j++)
			{
				Main.tile[x, y - num2 + 1 + j].active(active: true);
				Main.tile[x, y - num2 + 1 + j].frameY = (short)(j * 18 + num2 * num);
				Main.tile[x, y - num2 + 1 + j].frameX = 0;
				Main.tile[x, y - num2 + 1 + j].type = type;
			}
		}
	}

	public static int checkXmasTreeDrop(int x, int y, int obj)
	{
		int num = x;
		int num2 = y;
		if (Main.tile[x, y].frameX < 10)
		{
			num -= Main.tile[x, y].frameX;
			num2 -= Main.tile[x, y].frameY;
		}
		int num3 = 0;
		if ((Main.tile[num, num2].frameY & 1) == 1)
		{
			num3++;
		}
		if ((Main.tile[num, num2].frameY & 2) == 2)
		{
			num3 += 2;
		}
		if ((Main.tile[num, num2].frameY & 4) == 4)
		{
			num3 += 4;
		}
		int num4 = 0;
		if ((Main.tile[num, num2].frameY & 8) == 8)
		{
			num4++;
		}
		if ((Main.tile[num, num2].frameY & 0x10) == 16)
		{
			num4 += 2;
		}
		if ((Main.tile[num, num2].frameY & 0x20) == 32)
		{
			num4 += 4;
		}
		int num5 = 0;
		if ((Main.tile[num, num2].frameY & 0x40) == 64)
		{
			num5++;
		}
		if ((Main.tile[num, num2].frameY & 0x80) == 128)
		{
			num5 += 2;
		}
		if ((Main.tile[num, num2].frameY & 0x100) == 256)
		{
			num5 += 4;
		}
		if ((Main.tile[num, num2].frameY & 0x200) == 512)
		{
			num5 += 8;
		}
		int num6 = 0;
		if ((Main.tile[num, num2].frameY & 0x400) == 1024)
		{
			num6++;
		}
		if ((Main.tile[num, num2].frameY & 0x800) == 2048)
		{
			num6 += 2;
		}
		if ((Main.tile[num, num2].frameY & 0x1000) == 4096)
		{
			num6 += 4;
		}
		if ((Main.tile[num, num2].frameY & 0x2000) == 8192)
		{
			num6 += 8;
		}
		if (obj == 0 && num3 > 0)
		{
			return num3;
		}
		if (obj == 1 && num4 > 0)
		{
			return num4;
		}
		if (obj == 2 && num5 > 0)
		{
			return num5;
		}
		if (obj == 3 && num6 > 0)
		{
			return num6;
		}
		return -1;
	}

	public static void dropXmasTree(int x, int y, int obj)
	{
		int num = x;
		int num2 = y;
		if (Main.tile[x, y].frameX < 10)
		{
			num -= Main.tile[x, y].frameX;
			num2 -= Main.tile[x, y].frameY;
		}
		int num3 = 0;
		if ((Main.tile[num, num2].frameY & 1) == 1)
		{
			num3++;
		}
		if ((Main.tile[num, num2].frameY & 2) == 2)
		{
			num3 += 2;
		}
		if ((Main.tile[num, num2].frameY & 4) == 4)
		{
			num3 += 4;
		}
		int num4 = 0;
		if ((Main.tile[num, num2].frameY & 8) == 8)
		{
			num4++;
		}
		if ((Main.tile[num, num2].frameY & 0x10) == 16)
		{
			num4 += 2;
		}
		if ((Main.tile[num, num2].frameY & 0x20) == 32)
		{
			num4 += 4;
		}
		int num5 = 0;
		if ((Main.tile[num, num2].frameY & 0x40) == 64)
		{
			num5++;
		}
		if ((Main.tile[num, num2].frameY & 0x80) == 128)
		{
			num5 += 2;
		}
		if ((Main.tile[num, num2].frameY & 0x100) == 256)
		{
			num5 += 4;
		}
		if ((Main.tile[num, num2].frameY & 0x200) == 512)
		{
			num5 += 8;
		}
		int num6 = 0;
		if ((Main.tile[num, num2].frameY & 0x400) == 1024)
		{
			num6++;
		}
		if ((Main.tile[num, num2].frameY & 0x800) == 2048)
		{
			num6 += 2;
		}
		if ((Main.tile[num, num2].frameY & 0x1000) == 4096)
		{
			num6 += 4;
		}
		if ((Main.tile[num, num2].frameY & 0x2000) == 8192)
		{
			num6 += 8;
		}
		if (obj == 0 && num3 > 0)
		{
			int number = Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, 1874 + num3 - 1);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(21, -1, -1, null, number, 1f);
			}
		}
		else if (obj == 1 && num4 > 0)
		{
			int number2 = Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, 1878 + num4 - 1);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(21, -1, -1, null, number2, 1f);
			}
		}
		else if (obj == 2 && num5 > 0)
		{
			int number3 = Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, 1884 + num5 - 1);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(21, -1, -1, null, number3, 1f);
			}
		}
		else if (obj == 3 && num6 > 0)
		{
			int number4 = Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, 1895 + num6 - 1);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(21, -1, -1, null, number4, 1f);
			}
		}
	}

	public static void setXmasTree(int x, int y, int obj, int style)
	{
		int num = x;
		int num2 = y;
		Tile tile = Main.tile[x, y];
		if (tile.frameX < 10)
		{
			int num3 = num;
			tile = Main.tile[x, y];
			num = num3 - tile.frameX;
			int num4 = num2;
			tile = Main.tile[x, y];
			num2 = num4 - tile.frameY;
		}
		if (obj == 0)
		{
			if ((style & 1) == 1)
			{
				tile = Main.tile[num, num2];
				tile.frameY |= 1;
			}
			else
			{
				tile = Main.tile[num, num2];
				ref short frameY = ref tile.frameY;
				tile = Main.tile[num, num2];
				frameY = (short)(tile.frameY & -2);
			}
			if ((style & 2) == 2)
			{
				tile = Main.tile[num, num2];
				tile.frameY |= 2;
			}
			else
			{
				tile = Main.tile[num, num2];
				ref short frameY2 = ref tile.frameY;
				tile = Main.tile[num, num2];
				frameY2 = (short)(tile.frameY & -3);
			}
			if ((style & 4) == 4)
			{
				tile = Main.tile[num, num2];
				tile.frameY |= 4;
			}
			else
			{
				tile = Main.tile[num, num2];
				ref short frameY3 = ref tile.frameY;
				tile = Main.tile[num, num2];
				frameY3 = (short)(tile.frameY & -5);
			}
		}
		if (obj == 1)
		{
			if ((style & 1) == 1)
			{
				tile = Main.tile[num, num2];
				tile.frameY |= 8;
			}
			else
			{
				tile = Main.tile[num, num2];
				ref short frameY4 = ref tile.frameY;
				tile = Main.tile[num, num2];
				frameY4 = (short)(tile.frameY & -9);
			}
			if ((style & 2) == 2)
			{
				tile = Main.tile[num, num2];
				tile.frameY |= 16;
			}
			else
			{
				tile = Main.tile[num, num2];
				ref short frameY5 = ref tile.frameY;
				tile = Main.tile[num, num2];
				frameY5 = (short)(tile.frameY & -17);
			}
			if ((style & 4) == 4)
			{
				tile = Main.tile[num, num2];
				tile.frameY |= 32;
			}
			else
			{
				tile = Main.tile[num, num2];
				ref short frameY6 = ref tile.frameY;
				tile = Main.tile[num, num2];
				frameY6 = (short)(tile.frameY & -33);
			}
		}
		if (obj == 2)
		{
			if ((style & 1) == 1)
			{
				tile = Main.tile[num, num2];
				tile.frameY |= 64;
			}
			else
			{
				tile = Main.tile[num, num2];
				ref short frameY7 = ref tile.frameY;
				tile = Main.tile[num, num2];
				frameY7 = (short)(tile.frameY & -65);
			}
			if ((style & 2) == 2)
			{
				tile = Main.tile[num, num2];
				tile.frameY |= 128;
			}
			else
			{
				tile = Main.tile[num, num2];
				ref short frameY8 = ref tile.frameY;
				tile = Main.tile[num, num2];
				frameY8 = (short)(tile.frameY & -129);
			}
			if ((style & 4) == 4)
			{
				tile = Main.tile[num, num2];
				tile.frameY |= 256;
			}
			else
			{
				tile = Main.tile[num, num2];
				ref short frameY9 = ref tile.frameY;
				tile = Main.tile[num, num2];
				frameY9 = (short)(tile.frameY & -257);
			}
			if ((style & 8) == 8)
			{
				tile = Main.tile[num, num2];
				tile.frameY |= 512;
			}
			else
			{
				tile = Main.tile[num, num2];
				ref short frameY10 = ref tile.frameY;
				tile = Main.tile[num, num2];
				frameY10 = (short)(tile.frameY & -513);
			}
		}
		if (obj == 3)
		{
			if ((style & 1) == 1)
			{
				tile = Main.tile[num, num2];
				tile.frameY |= 1024;
			}
			else
			{
				tile = Main.tile[num, num2];
				ref short frameY11 = ref tile.frameY;
				tile = Main.tile[num, num2];
				frameY11 = (short)(tile.frameY & -1025);
			}
			if ((style & 2) == 2)
			{
				tile = Main.tile[num, num2];
				tile.frameY |= 2048;
			}
			else
			{
				tile = Main.tile[num, num2];
				ref short frameY12 = ref tile.frameY;
				tile = Main.tile[num, num2];
				frameY12 = (short)(tile.frameY & -2049);
			}
			if ((style & 4) == 4)
			{
				tile = Main.tile[num, num2];
				tile.frameY |= 4096;
			}
			else
			{
				tile = Main.tile[num, num2];
				ref short frameY13 = ref tile.frameY;
				tile = Main.tile[num, num2];
				frameY13 = (short)(tile.frameY & -4097);
			}
			if ((style & 8) == 8)
			{
				tile = Main.tile[num, num2];
				tile.frameY |= 8192;
				return;
			}
			tile = Main.tile[num, num2];
			ref short frameY14 = ref tile.frameY;
			tile = Main.tile[num, num2];
			frameY14 = (short)(tile.frameY & -8193);
		}
	}

	public static int PlaceXmasTree_Direct(int x, int y, int type, int style, int dir, int alternate)
	{
		for (short num = 0; num < 4; num++)
		{
			for (short num2 = 0; num2 < 8; num2++)
			{
				Tile tile = Main.tile[x + num, y + num2];
				tile.active(active: true);
				tile.type = (ushort)type;
				if (num == 0 && num2 == 0)
				{
					tile.frameX = 10;
					tile.frameY = 0;
				}
				else
				{
					tile.frameX = num;
					tile.frameY = num2;
				}
			}
		}
		return 0;
	}

	public static void PlaceXmasTree(int x, int y, ushort type = 171)
	{
		bool flag = true;
		int num = x - 1;
		int num2 = y - 7;
		for (int i = num; i < num + 4; i++)
		{
			for (int j = num2; j < num2 + 8; j++)
			{
				if (Main.tile[i, j].active())
				{
					flag = false;
				}
			}
			if (i > num && i < num + 3 && !SolidTile(i, num2 + 8))
			{
				flag = false;
			}
		}
		if (!flag)
		{
			return;
		}
		int num3 = 0;
		for (int k = num; k < num + 4; k++)
		{
			int num4 = 0;
			for (int l = num2; l < num2 + 8; l++)
			{
				Main.tile[k, l].active(active: true);
				if (num3 == 0 && num4 == 0)
				{
					Main.tile[k, l].frameX = 10;
					Main.tile[k, l].frameY = 0;
				}
				else
				{
					Main.tile[k, l].frameX = (short)num3;
					Main.tile[k, l].frameY = (short)num4;
				}
				Main.tile[k, l].type = type;
				Main.tile[k, l].active(active: true);
				num4++;
			}
			num3++;
		}
	}

	public static void CheckXmasTree(int x, int y)
	{
		if (destroyObject)
		{
			return;
		}
		int num = x;
		int num2 = y;
		if (Main.tile[x, y].frameX < 10)
		{
			num -= Main.tile[x, y].frameX;
			num2 -= Main.tile[x, y].frameY;
		}
		bool flag = false;
		int num3 = 0;
		for (int i = num; i < num + 4; i++)
		{
			int num4 = 0;
			for (int j = num2; j < num2 + 8; j++)
			{
				if (Main.tile[i, j].active() && Main.tile[i, j].type == 171)
				{
					if (num3 != 0 && num4 != 0 && Main.tile[i, j].frameX != num3 && Main.tile[i, j].frameY != num4)
					{
						flag = true;
					}
				}
				else
				{
					flag = true;
				}
				num4++;
			}
			num3++;
			if (i > num && i < num + 3 && !SolidTile2(i, num2 + 8))
			{
				flag = true;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(x, y, 171);
		for (int k = num; k < num + 4; k++)
		{
			for (int l = num2; l < num2 + 8; l++)
			{
				if (Main.tile[k, l].type == 171)
				{
					KillTile(k, l);
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1873);
			destroyObject = false;
		}
	}

	public static void Place2xX(int x, int y, ushort type, int style = 0)
	{
		int num = style * 36;
		int num2 = 0;
		int num3 = 3;
		if (type == 105 && style == 34)
		{
			type = 349;
			style = 0;
			num = 0;
		}
		if (type == 105)
		{
			int num4 = style / 55;
			num -= 1980 * num4;
			num2 += 54 * num4;
		}
		if (type == 104)
		{
			num3 = 5;
		}
		if (type == 207)
		{
			num3 = 4;
		}
		bool flag = true;
		for (int i = y - num3 + 1; i < y + 1; i++)
		{
			if (Main.tile[x, i] == null)
			{
				Main.tile[x, i] = default(Tile);
			}
			if (Main.tile[x, i].active())
			{
				flag = false;
			}
			if (Main.tile[x + 1, i] == null)
			{
				Main.tile[x + 1, i] = default(Tile);
			}
			if (Main.tile[x + 1, i].active())
			{
				flag = false;
			}
		}
		if (flag && SolidTile2(x, y + 1) && SolidTile2(x + 1, y + 1))
		{
			for (int j = 0; j < num3; j++)
			{
				Main.tile[x, y - num3 + 1 + j].active(active: true);
				Main.tile[x, y - num3 + 1 + j].frameY = (short)(num2 + j * 18);
				Main.tile[x, y - num3 + 1 + j].frameX = (short)num;
				Main.tile[x, y - num3 + 1 + j].type = type;
				Main.tile[x + 1, y - num3 + 1 + j].active(active: true);
				Main.tile[x + 1, y - num3 + 1 + j].frameY = (short)(num2 + j * 18);
				Main.tile[x + 1, y - num3 + 1 + j].frameX = (short)(num + 18);
				Main.tile[x + 1, y - num3 + 1 + j].type = type;
			}
		}
	}

	public static int GetItemDrop_Benches(int style)
	{
		return style switch
		{
			1 => 2397, 
			2 => 2398, 
			3 => 2399, 
			4 => 2400, 
			5 => 2401, 
			6 => 2402, 
			7 => 2403, 
			8 => 2404, 
			9 => 2405, 
			10 => 2406, 
			11 => 2407, 
			12 => 2408, 
			13 => 2409, 
			14 => 2410, 
			15 => 2411, 
			16 => 2412, 
			17 => 2413, 
			18 => 2414, 
			19 => 2415, 
			20 => 2416, 
			21 => 2521, 
			22 => 2527, 
			23 => 2539, 
			24 => 858, 
			25 => 2582, 
			26 => 2634, 
			27 => 2635, 
			28 => 2636, 
			29 => 2823, 
			30 => 3150, 
			31 => 3152, 
			32 => 3151, 
			33 => 3918, 
			34 => 3919, 
			35 => 3947, 
			36 => 3973, 
			37 => 4161, 
			38 => 4182, 
			39 => 4203, 
			40 => 4224, 
			41 => 4313, 
			42 => 4582, 
			43 => 4993, 
			44 => 5164, 
			45 => 5185, 
			46 => 5206, 
			_ => 335, 
		};
	}

	public static int GetItemDrop_PicnicTables(int style)
	{
		if (style == 0 || style != 1)
		{
			return 4064;
		}
		return 4065;
	}

	public static int GetItemDrop_Chair(int style)
	{
		switch (style)
		{
		default:
			return 34;
		case 1:
			return 358;
		case 2:
			return 628;
		case 3:
			return 629;
		case 4:
			return 630;
		case 5:
			return 806;
		case 6:
			return 807;
		case 7:
			return 808;
		case 8:
			return 809;
		case 9:
			return 810;
		case 10:
			return 826;
		case 11:
			return 915;
		case 12:
			return 1143;
		case 13:
			return 1396;
		case 14:
			return 1399;
		case 15:
			return 1402;
		case 16:
			return 1459;
		case 17:
			return 1509;
		case 18:
		case 19:
		case 20:
		case 21:
		case 22:
		case 23:
			return 1703 + style - 18;
		case 24:
			return 1792;
		case 25:
			return 1814;
		case 26:
			return 1925;
		case 27:
			return 2228;
		case 28:
			return 2288;
		case 29:
			return 2524;
		case 30:
			return 2557;
		case 31:
			return 2572;
		case 32:
			return 2812;
		case 33:
			return 3174;
		case 34:
			return 3176;
		case 35:
			return 3175;
		case 36:
			return 3889;
		case 37:
			return 3937;
		case 38:
			return 3963;
		case 39:
			return 4151;
		case 40:
			return 4172;
		case 41:
			return 4193;
		case 42:
			return 4214;
		case 43:
			return 4304;
		case 44:
			return 4572;
		case 45:
			return 5154;
		case 46:
			return 5175;
		case 47:
			return 5196;
		}
	}

	public static int GetItemDrop_Toilet(int style)
	{
		int num = 4096 + style;
		switch (style)
		{
		case 32:
			num = 4141;
			break;
		case 33:
			num = 4165;
			break;
		case 34:
			num = 4186;
			break;
		case 35:
			num = 4207;
			break;
		case 36:
			num = 4228;
			break;
		case 37:
			num = 4316;
			break;
		case 38:
			num = 4586;
			break;
		case 39:
			num = 4731;
			break;
		case 40:
			num = 5168;
			break;
		case 41:
			num = 5189;
			break;
		case 42:
			num = 5210;
			break;
		}
		if (num > 5210)
		{
			num = 5210;
		}
		return num;
	}

	public static void Check1x2(int x, int j, ushort type)
	{
		if (destroyObject)
		{
			return;
		}
		int num = j;
		bool flag = true;
		if (Main.tile[x, num] == null)
		{
			Main.tile[x, num] = default(Tile);
		}
		if (Main.tile[x, num + 1] == null)
		{
			Main.tile[x, num + 1] = default(Tile);
		}
		int num2 = Main.tile[x, num].frameY;
		int num3 = 0;
		while (num2 >= 40)
		{
			num2 -= 40;
			num3++;
		}
		if (num2 == 18)
		{
			num--;
		}
		int num4 = Main.tile[x, num].frameX / 18;
		if (Main.tile[x, num].frameX == -1)
		{
			num4 = Main.tile[x, num + 1].frameX / 18;
		}
		if (Main.tile[x, num] == null)
		{
			Main.tile[x, num] = default(Tile);
		}
		if (Main.tile[x, num].frameY == 40 * num3 && Main.tile[x, num + 1].frameY == 40 * num3 + 18 && Main.tile[x, num].type == type && Main.tile[x, num + 1].type == type)
		{
			flag = false;
		}
		if (Main.tile[x, num + 2] == null)
		{
			Main.tile[x, num + 2] = default(Tile);
		}
		if (!SolidTileAllowBottomSlope(x, num + 2) && !TileID.Sets.Platforms[Main.tile[x, num + 2].type])
		{
			flag = true;
		}
		if (TileID.Sets.TreeSapling[Main.tile[x, num].type])
		{
			int originalType = Main.tile[x, num].type;
			int newType = 20;
			int num5 = Main.tile[x, num].frameX / 54;
			int type2 = Main.tile[x, num + 2].type;
			int num6 = -1;
			switch (type2)
			{
			case 2:
			case 477:
				num6 = 0;
				break;
			case 147:
				num6 = 1;
				break;
			case 60:
				num6 = 2;
				break;
			case 23:
			case 661:
				num6 = 3;
				break;
			case 199:
			case 662:
				num6 = 4;
				break;
			case 109:
			case 492:
				num6 = 5;
				break;
			case 53:
				num6 = 6;
				break;
			case 116:
				num6 = 7;
				break;
			case 234:
				num6 = 8;
				break;
			case 112:
				num6 = 9;
				break;
			case 633:
				num6 = 10;
				break;
			default:
				if (!TileLoader.SaplingGrowthType(type2, ref newType, ref num6))
				{
					flag = true;
				}
				break;
			}
			if (!flag && (originalType != newType || num5 != num6))
			{
				Main.tile[x, num].type = (ushort)newType;
				Main.tile[x, num + 1].type = (ushort)newType;
				int num7 = 54 * num6;
				num7 += genRand.Next(3) * 18;
				Main.tile[x, num].frameX = (short)num7;
				Main.tile[x, num + 1].frameX = (short)num7;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(x, j, type);
		if (Main.tile[x, num].type == type)
		{
			KillTile(x, num);
		}
		if (Main.tile[x, num + 1].type == type)
		{
			KillTile(x, num + 1);
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			if (type == 216)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 970 + num3);
			}
			if (type == 338)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 2738);
			}
			if (type == 390)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 16, 32, 3253);
			}
			if (type == 493)
			{
				int num8 = 0;
				switch (num4)
				{
				case 0:
					num8 = 4083;
					break;
				case 1:
					num8 = 4084;
					break;
				case 2:
					num8 = 4085;
					break;
				case 3:
					num8 = 4086;
					break;
				case 4:
					num8 = 4087;
					break;
				case 5:
					num8 = 4088;
					break;
				}
				if (num8 > 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, num8);
				}
			}
			if (type == 15)
			{
				int itemDrop_Chair = GetItemDrop_Chair(num3);
				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, itemDrop_Chair);
			}
			switch (type)
			{
			case 497:
			{
				int itemDrop_Toilet = GetItemDrop_Toilet(num3);
				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, itemDrop_Toilet);
				break;
			}
			case 134:
				if (num3 == 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 1220);
				}
				else
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 525);
				}
				break;
			}
			destroyObject = false;
		}
	}

	public static void CheckOnTable1x1(int x, int y, int type)
	{
		if (Main.tile[x, y + 1] == null)
		{
			return;
		}
		if (Main.tile[x, y + 1].topSlope())
		{
			if (TileID.Sets.Platforms[Main.tile[x, y + 1].type])
			{
				if ((Main.tile[x, y + 1].blockType() != 3 || !Main.tile[x - 1, y + 1].active() || Main.tile[x - 1, y + 1].blockType() != 0 || !TileID.Sets.Platforms[Main.tile[x - 1, y + 1].type]) && (Main.tile[x, y + 1].blockType() != 2 || !Main.tile[x + 1, y + 1].active() || Main.tile[x + 1, y + 1].blockType() != 0 || !TileID.Sets.Platforms[Main.tile[x + 1, y + 1].type]))
				{
					KillTile(x, y);
				}
			}
			else
			{
				KillTile(x, y);
			}
		}
		else
		{
			if (Main.tile[x, y + 1].active() && Main.tileTable[Main.tile[x, y + 1].type] && !Main.tile[x, y + 1].halfBrick())
			{
				return;
			}
			if (type == 78)
			{
				if (!SolidTileAllowBottomSlope(x, y + 1))
				{
					KillTile(x, y);
				}
			}
			else
			{
				KillTile(x, y);
			}
		}
	}

	public static void CheckSign(int x, int y, ushort type)
	{
		//IL_050d: Unknown result type (might be due to invalid IL or missing references)
		if (destroyObject)
		{
			return;
		}
		int num = x - 2;
		int num10 = x + 3;
		int num11 = y - 2;
		int num12 = y + 3;
		if (num < 0 || num10 > Main.maxTilesX || num11 < 0 || num12 > Main.maxTilesY)
		{
			return;
		}
		bool flag = false;
		for (int i = num; i < num10; i++)
		{
			for (int j = num11; j < num12; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = default(Tile);
				}
			}
		}
		int num13 = Main.tile[x, y].frameX / 18;
		int num14 = Main.tile[x, y].frameY / 18;
		num13 %= 2;
		num14 %= 2;
		int num15 = x - num13;
		int num16 = y - num14;
		int num17 = Main.tile[num15, num16].frameX / 18 / 2;
		int num2 = Main.tile[num15, num16].frameY / 18 / 2;
		int num3 = Main.tile[x, y].frameX / 18;
		int num4 = 0;
		while (num3 > 1)
		{
			num3 -= 2;
			num4++;
		}
		num = num15;
		num10 = num15 + 2;
		num11 = num16;
		num12 = num16 + 2;
		num13 = 0;
		for (int k = num; k < num10; k++)
		{
			num14 = 0;
			for (int l = num11; l < num12; l++)
			{
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type)
				{
					flag = true;
					break;
				}
				if (Main.tile[k, l].frameX / 18 != num13 + num17 * 2 || Main.tile[k, l].frameY / 18 != num14 + num2 * 2)
				{
					flag = true;
					break;
				}
				num14++;
			}
			num13++;
		}
		if (!flag)
		{
			if (type == 85)
			{
				if (SolidTileAllowBottomSlope(num15, num16 + 2) && SolidTileAllowBottomSlope(num15 + 1, num16 + 2))
				{
					num17 = num4;
				}
				else
				{
					flag = true;
				}
			}
			else if (TopEdgeCanBeAttachedTo(num15, num16 + 2) && TopEdgeCanBeAttachedTo(num15 + 1, num16 + 2))
			{
				num17 = 0;
			}
			else if (BottomEdgeCanBeAttachedTo(num15, num16 - 1) && BottomEdgeCanBeAttachedTo(num15 + 1, num16 - 1))
			{
				num17 = 1;
			}
			else if (RightEdgeCanBeAttachedTo(num15 - 1, num16) && RightEdgeCanBeAttachedTo(num15 - 1, num16 + 1))
			{
				num17 = 2;
			}
			else if (LeftEdgeCanBeAttachedTo(num15 + 2, num16) && LeftEdgeCanBeAttachedTo(num15 + 2, num16 + 1))
			{
				num17 = 3;
			}
			else if (Main.tile[num15, num16].wall > 0 && Main.tile[num15 + 1, num16].wall > 0 && Main.tile[num15, num16 + 1].wall > 0 && Main.tile[num15 + 1, num16 + 1].wall > 0)
			{
				num17 = 4;
			}
			else
			{
				flag = true;
			}
		}
		if (flag)
		{
			if (type == 395)
			{
				int num5 = TEItemFrame.Find(num15, num16);
				if (num5 != -1 && ((TEItemFrame)TileEntity.ByID[num5]).item.stack > 0)
				{
					((TEItemFrame)TileEntity.ByID[num5]).DropItem();
					if (Main.netMode != 2)
					{
						Main.LocalPlayer.InterruptItemUsageIfOverTile(395);
					}
				}
			}
			destroyObject = true;
			bool drop = TileLoader.Drop(x, y, type);
			for (int m = num; m < num10; m++)
			{
				for (int n = num11; n < num12; n++)
				{
					if (Main.tile[m, n].type == type)
					{
						KillTile(m, n);
					}
				}
			}
			if (type != 395)
			{
				Sign.KillSign(num15, num16);
			}
			using (new Item.DisableNewItemMethod(!drop))
			{
				switch (type)
				{
				case 85:
				{
					int type2 = 321;
					if (num4 >= 6 && num4 <= 10)
					{
						type2 = 3229 + num4 - 6;
					}
					else if (num4 >= 1 && num4 <= 5)
					{
						type2 = 1173 + num4 - 1;
					}
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, type2);
					if (Main.netMode != 1 && genRand.Next(2) == 0 && NPC.CountNPCS(316) < 2)
					{
						int num6 = Player.FindClosest(new Vector2((float)(x * 16), (float)(y * 16)), 16, 16);
						if (Main.player[num6].ZoneGraveyard || !Main.dayTime || (double)y > Main.worldSurface)
						{
							NPC.SpawnOnPlayer(num6, 316);
						}
					}
					break;
				}
				case 395:
					Item.NewItem(GetItemSource_FromTileBreak(num15, num16), num15 * 16, num16 * 16, 32, 32, 3270);
					TEItemFrame.Kill(num15, num16);
					break;
				case 425:
					Item.NewItem(GetItemSource_FromTileBreak(num15, num16), num15 * 16, num16 * 16, 32, 32, 3617);
					break;
				case 573:
					Item.NewItem(GetItemSource_FromTileBreak(num15, num16), num15 * 16, num16 * 16, 32, 32, 4710);
					break;
				case 511:
					Item.NewItem(GetItemSource_FromTileBreak(num15, num16), num15 * 16, num16 * 16, 32, 32, 4320);
					break;
				case 510:
					Item.NewItem(GetItemSource_FromTileBreak(num15, num16), num15 * 16, num16 * 16, 32, 32, 4319);
					break;
				default:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 171);
					break;
				}
				destroyObject = false;
				return;
			}
		}
		int num7 = 36 * num17;
		for (int num8 = 0; num8 < 2; num8++)
		{
			for (int num9 = 0; num9 < 2; num9++)
			{
				Main.tile[num15 + num8, num16 + num9].active(active: true);
				Main.tile[num15 + num8, num16 + num9].type = type;
				Main.tile[num15 + num8, num16 + num9].frameX = (short)(num7 + 18 * num8);
				Main.tile[num15 + num8, num16 + num9].frameY = (short)(18 * num9 + num2 * 36);
			}
		}
	}

	public static bool PlaceSign(int x, int y, ushort type, int Style = 0)
	{
		int num = x - 2;
		int num2 = x + 3;
		int num3 = y - 2;
		int num4 = y + 3;
		if (num < 0)
		{
			return false;
		}
		if (num2 > Main.maxTilesX)
		{
			return false;
		}
		if (num3 < 0)
		{
			return false;
		}
		if (num4 > Main.maxTilesY)
		{
			return false;
		}
		for (int i = num; i < num2; i++)
		{
			for (int j = num3; j < num4; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = default(Tile);
				}
			}
		}
		int num5 = x;
		int num6 = y;
		int num7 = 0;
		if (type == 55 || type == 425 || type == 510 || type == 511)
		{
			if (SolidTile2(x, y + 1) && SolidTile2(x + 1, y + 1))
			{
				num6--;
				num7 = 0;
			}
			else if (Main.tile[x, y - 1].nactive() && Main.tileSolid[Main.tile[x, y - 1].type] && !Main.tileSolidTop[Main.tile[x, y - 1].type] && Main.tile[x + 1, y - 1].nactive() && Main.tileSolid[Main.tile[x + 1, y - 1].type] && !Main.tileSolidTop[Main.tile[x + 1, y - 1].type])
			{
				num7 = 1;
			}
			else if (Main.tile[x - 1, y].nactive() && Main.tileSolid[Main.tile[x - 1, y].type] && !Main.tileSolidTop[Main.tile[x - 1, y].type] && !Main.tileNoAttach[Main.tile[x - 1, y].type] && Main.tile[x - 1, y + 1].nactive() && Main.tileSolid[Main.tile[x - 1, y + 1].type] && !Main.tileSolidTop[Main.tile[x - 1, y + 1].type] && !Main.tileNoAttach[Main.tile[x - 1, y + 1].type])
			{
				num7 = 2;
			}
			else if (Main.tile[x + 1, y].nactive() && Main.tileSolid[Main.tile[x + 1, y].type] && !Main.tileSolidTop[Main.tile[x + 1, y].type] && !Main.tileNoAttach[Main.tile[x + 1, y].type] && Main.tile[x + 1, y + 1].nactive() && Main.tileSolid[Main.tile[x + 1, y + 1].type] && !Main.tileSolidTop[Main.tile[x + 1, y + 1].type] && !Main.tileNoAttach[Main.tile[x + 1, y + 1].type])
			{
				num5--;
				num7 = 3;
			}
			else
			{
				if (Main.tile[num5, num6].wall <= 0 || Main.tile[num5 + 1, num6].wall <= 0 || Main.tile[num5, num6 + 1].wall <= 0 || Main.tile[num5 + 1, num6 + 1].wall <= 0)
				{
					return false;
				}
				num7 = 4;
			}
		}
		if (Main.tile[num5, num6].active() || Main.tile[num5 + 1, num6].active() || Main.tile[num5, num6 + 1].active() || Main.tile[num5 + 1, num6 + 1].active())
		{
			return false;
		}
		int num8 = 36 * num7;
		for (int k = 0; k < 2; k++)
		{
			for (int l = 0; l < 2; l++)
			{
				Main.tile[num5 + k, num6 + l].active(active: true);
				Main.tile[num5 + k, num6 + l].type = type;
				Main.tile[num5 + k, num6 + l].frameX = (short)(num8 + 18 * k);
				Main.tile[num5 + k, num6 + l].frameY = (short)(18 * l);
			}
		}
		return true;
	}

	public static bool Place2x2Horizontal(int x, int y, ushort type, int Style = 0)
	{
		int num = x - 2;
		int num2 = x + 3;
		int num3 = y - 2;
		int num4 = y + 3;
		if (num < 0)
		{
			return false;
		}
		if (num2 > Main.maxTilesX)
		{
			return false;
		}
		if (num3 < 0)
		{
			return false;
		}
		if (num4 > Main.maxTilesY)
		{
			return false;
		}
		for (int i = num; i < num2; i++)
		{
			for (int j = num3; j < num4; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = default(Tile);
				}
			}
		}
		int num5 = y;
		int num6 = 0;
		if (SolidTile2(x, y + 1) && SolidTile2(x + 1, y + 1))
		{
			num5--;
			num6 = Style;
			if (Main.tile[x, num5].active() || Main.tile[x + 1, num5].active() || Main.tile[x, num5 + 1].active() || Main.tile[x + 1, num5 + 1].active())
			{
				return false;
			}
			int num7 = 36 * num6;
			for (int k = 0; k < 2; k++)
			{
				for (int l = 0; l < 2; l++)
				{
					Main.tile[x + k, num5 + l].active(active: true);
					Main.tile[x + k, num5 + l].type = type;
					Main.tile[x + k, num5 + l].frameX = (short)(num7 + 18 * k);
					Main.tile[x + k, num5 + l].frameY = (short)(18 * l);
				}
			}
			return true;
		}
		return false;
	}

	public static Color paintColor(int color)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		Color white = Color.White;
		if (color == 1 || color == 13)
		{
			((Color)(ref white)).R = byte.MaxValue;
			((Color)(ref white)).G = 0;
			((Color)(ref white)).B = 0;
		}
		if (color == 2 || color == 14)
		{
			((Color)(ref white)).R = byte.MaxValue;
			((Color)(ref white)).G = 127;
			((Color)(ref white)).B = 0;
		}
		if (color == 3 || color == 15)
		{
			((Color)(ref white)).R = byte.MaxValue;
			((Color)(ref white)).G = byte.MaxValue;
			((Color)(ref white)).B = 0;
		}
		if (color == 4 || color == 16)
		{
			((Color)(ref white)).R = 127;
			((Color)(ref white)).G = byte.MaxValue;
			((Color)(ref white)).B = 0;
		}
		if (color == 5 || color == 17)
		{
			((Color)(ref white)).R = 0;
			((Color)(ref white)).G = byte.MaxValue;
			((Color)(ref white)).B = 0;
		}
		if (color == 6 || color == 18)
		{
			((Color)(ref white)).R = 0;
			((Color)(ref white)).G = byte.MaxValue;
			((Color)(ref white)).B = 127;
		}
		if (color == 7 || color == 19)
		{
			((Color)(ref white)).R = 0;
			((Color)(ref white)).G = byte.MaxValue;
			((Color)(ref white)).B = byte.MaxValue;
		}
		if (color == 8 || color == 20)
		{
			((Color)(ref white)).R = 0;
			((Color)(ref white)).G = 127;
			((Color)(ref white)).B = byte.MaxValue;
		}
		if (color == 9 || color == 21)
		{
			((Color)(ref white)).R = 0;
			((Color)(ref white)).G = 0;
			((Color)(ref white)).B = byte.MaxValue;
		}
		if (color == 10 || color == 22)
		{
			((Color)(ref white)).R = 127;
			((Color)(ref white)).G = 0;
			((Color)(ref white)).B = byte.MaxValue;
		}
		if (color == 11 || color == 23)
		{
			((Color)(ref white)).R = byte.MaxValue;
			((Color)(ref white)).G = 0;
			((Color)(ref white)).B = byte.MaxValue;
		}
		if (color == 12 || color == 24)
		{
			((Color)(ref white)).R = byte.MaxValue;
			((Color)(ref white)).G = 0;
			((Color)(ref white)).B = 127;
		}
		if (color == 25)
		{
			((Color)(ref white)).R = 75;
			((Color)(ref white)).G = 75;
			((Color)(ref white)).B = 75;
		}
		if (color == 26)
		{
			((Color)(ref white)).R = byte.MaxValue;
			((Color)(ref white)).G = byte.MaxValue;
			((Color)(ref white)).B = byte.MaxValue;
		}
		if (color == 27)
		{
			((Color)(ref white)).R = 175;
			((Color)(ref white)).G = 175;
			((Color)(ref white)).B = 175;
		}
		if (color == 28)
		{
			((Color)(ref white)).R = byte.MaxValue;
			((Color)(ref white)).G = 178;
			((Color)(ref white)).B = 125;
		}
		if (color == 29)
		{
			((Color)(ref white)).R = 25;
			((Color)(ref white)).G = 25;
			((Color)(ref white)).B = 25;
		}
		if (color == 30)
		{
			((Color)(ref white)).R = 200;
			((Color)(ref white)).G = 200;
			((Color)(ref white)).B = 200;
			((Color)(ref white)).A = 150;
		}
		return white;
	}

	public static Color coatingColor(int coating)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return (Color)(coating switch
		{
			1 => new Color(235, 170, 255, 255), 
			2 => new Color(180, 245, 255, 255), 
			_ => Color.Transparent, 
		});
	}

	public static List<Color> coatingColors(Tile tile, bool block)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		_coatingColors.Clear();
		if (tile == null)
		{
			return _coatingColors;
		}
		if ((block && tile.fullbrightBlock()) || (!block && tile.fullbrightWall()))
		{
			_coatingColors.Add(coatingColor(1));
		}
		if ((block && tile.invisibleBlock()) || (!block && tile.invisibleWall()))
		{
			_coatingColors.Add(coatingColor(2));
		}
		return _coatingColors;
	}

	public static void paintEffect(int x, int y, byte color, byte oldColor)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		int color2 = color;
		if (color == 0)
		{
			color2 = oldColor;
		}
		Color newColor = paintColor(color2);
		for (int i = 0; i < 10; i++)
		{
			int num = Dust.NewDust(new Vector2((float)(x * 16), (float)(y * 16)), 16, 16, 143, 0f, 0f, 50, newColor);
			if (genRand.Next(2) == 0)
			{
				Main.dust[num].noGravity = true;
				Main.dust[num].scale *= 1.2f;
			}
			else
			{
				Main.dust[num].scale *= 0.5f;
			}
		}
	}

	public static void paintCoatEffect(int x, int y, byte paintCoatId, List<Color> oldColors)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Color color = coatingColor(paintCoatId);
		for (int i = 0; i < 10; i++)
		{
			Color newColor = color;
			if (paintCoatId == 0 && oldColors.Count > 0)
			{
				newColor = oldColors[Main.rand.Next(oldColors.Count)];
			}
			int num = Dust.NewDust(new Vector2((float)(x * 16), (float)(y * 16)), 16, 16, 143, 0f, 0f, 50, newColor);
			if (genRand.Next(2) == 0)
			{
				Main.dust[num].noGravity = true;
				Main.dust[num].scale *= 1.2f;
			}
			else
			{
				Main.dust[num].scale *= 0.5f;
			}
		}
	}

	public static bool paintTile(int x, int y, byte color, bool broadCast = false)
	{
		Tile tile = Main.tile[x, y];
		if (tile == null || !tile.active())
		{
			return false;
		}
		byte b = tile.color();
		if (b == color)
		{
			return false;
		}
		paintEffect(x, y, color, b);
		tile.color(color);
		if (broadCast)
		{
			NetMessage.SendData(63, -1, -1, null, x, y, (int)color);
		}
		return true;
	}

	public static bool paintCoatTile(int x, int y, byte paintCoatId, bool broadcast = false)
	{
		Tile tile = Main.tile[x, y];
		if (tile == null || !tile.active())
		{
			return false;
		}
		List<Color> oldColors = coatingColors(tile, block: true);
		switch (paintCoatId)
		{
		default:
			return false;
		case 0:
			if (!tile.fullbrightBlock() && !tile.invisibleBlock())
			{
				return false;
			}
			tile.fullbrightBlock(fullbrightBlock: false);
			tile.invisibleBlock(invisibleBlock: false);
			SquareTileFrame(x, y, resetFrame: false);
			break;
		case 1:
			if (tile.fullbrightBlock())
			{
				return false;
			}
			tile.fullbrightBlock(fullbrightBlock: true);
			break;
		case 2:
			if (tile.invisibleBlock())
			{
				return false;
			}
			tile.invisibleBlock(invisibleBlock: true);
			SquareTileFrame(x, y, resetFrame: false);
			break;
		}
		if (broadcast)
		{
			NetMessage.SendData(63, -1, -1, null, x, y, (int)paintCoatId, 1f);
		}
		paintCoatEffect(x, y, paintCoatId, oldColors);
		return true;
	}

	public static bool paintCoatWall(int x, int y, byte paintCoatId, bool broadcast = false)
	{
		Tile tile = Main.tile[x, y];
		if (tile == null || tile.wall == 0)
		{
			return false;
		}
		List<Color> oldColors = coatingColors(tile, block: false);
		switch (paintCoatId)
		{
		default:
			return false;
		case 0:
			if (!tile.fullbrightWall() && !tile.invisibleWall())
			{
				return false;
			}
			tile.fullbrightWall(fullbrightWall: false);
			tile.invisibleWall(invisibleWall: false);
			SquareWallFrame(x, y, resetFrame: false);
			break;
		case 1:
			if (tile.fullbrightWall())
			{
				return false;
			}
			tile.fullbrightWall(fullbrightWall: true);
			break;
		case 2:
			if (tile.invisibleWall())
			{
				return false;
			}
			tile.invisibleWall(invisibleWall: true);
			SquareWallFrame(x, y, resetFrame: false);
			break;
		}
		if (broadcast)
		{
			NetMessage.SendData(64, -1, -1, null, x, y, (int)paintCoatId, 1f);
		}
		paintCoatEffect(x, y, paintCoatId, oldColors);
		return true;
	}

	public static bool paintWall(int x, int y, byte color, bool broadCast = false)
	{
		Tile tile = Main.tile[x, y];
		if (tile == null || tile.wall == 0)
		{
			return false;
		}
		byte b = tile.wallColor();
		if (b == color)
		{
			return false;
		}
		tile.wallColor(color);
		if (broadCast)
		{
			NetMessage.SendData(64, -1, -1, null, x, y, (int)color);
		}
		paintEffect(x, y, color, b);
		return true;
	}

	public static void Place3x3Wall(int x, int y, ushort type, int style)
	{
		int num = x - 1;
		int num2 = y - 1;
		bool flag = true;
		for (int i = num; i < num + 3; i++)
		{
			for (int j = num2; j < num2 + 3; j++)
			{
				if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0)
				{
					flag = false;
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		int num3 = 0;
		while (style > 35)
		{
			num3++;
			style -= 36;
		}
		int num4 = style * 54;
		int num5 = num3 * 54;
		for (int k = num; k < num + 3; k++)
		{
			for (int l = num2; l < num2 + 3; l++)
			{
				Main.tile[k, l].active(active: true);
				Main.tile[k, l].type = type;
				Main.tile[k, l].frameX = (short)(num4 + 18 * (k - num));
				Main.tile[k, l].frameY = (short)(num5 + 18 * (l - num2));
			}
		}
	}

	public static void Check3x3Wall(int x, int y)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		Tile tile = Main.tile[x, y];
		if (tile == null)
		{
			return;
		}
		int type = tile.type;
		int num = 0;
		int num2 = 0;
		int num3 = tile.frameX / 18;
		while (num3 >= 3)
		{
			num3 -= 3;
			num++;
		}
		int num4 = x - num3;
		int num5 = tile.frameY / 18;
		while (num5 >= 3)
		{
			num5 -= 3;
			num2++;
		}
		int num6 = y - num5;
		num5 = num2 * 54;
		num3 = num * 54;
		for (int i = num4; i < num4 + 3; i++)
		{
			for (int j = num6; j < num6 + 3; j++)
			{
				Tile tile2 = Main.tile[i, j];
				if (tile2 != null && (tile2.type != type || !tile2.active() || tile2.wall <= 0 || tile2.frameX != num3 + (i - num4) * 18 || tile2.frameY != num5 + (j - num6) * 18))
				{
					flag = true;
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(x, y, type);
		for (int k = num4; k < num4 + 3; k++)
		{
			for (int l = num6; l < num6 + 3; l++)
			{
				if (Main.tile[k, l] != null && Main.tile[k, l].type == type && Main.tile[k, l].active())
				{
					KillTile(k, l);
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			switch (type)
			{
			case 240:
				num += num2 * 36;
				switch (num)
				{
				case 37:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1856);
					break;
				case 36:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1855);
					break;
				case 38:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1960);
					break;
				case 39:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1961);
					break;
				case 40:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1962);
					break;
				case 33:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1574);
					break;
				case 34:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1575);
					break;
				case 35:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1576);
					break;
				case 18:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1419);
					break;
				case 19:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1420);
					break;
				case 20:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1427);
					break;
				case 21:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1428);
					break;
				case 54:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2489);
					break;
				case 55:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2589);
					break;
				case 56:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3357);
					break;
				case 57:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3358);
					break;
				case 58:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3359);
					break;
				case 59:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3595);
					break;
				case 60:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3867);
					break;
				case 61:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3866);
					break;
				case 62:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3868);
					break;
				case 69:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4660);
					break;
				case 70:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4723);
					break;
				case 71:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4724);
					break;
				case 72:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4783);
					break;
				case 73:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4958);
					break;
				case 74:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5087);
					break;
				case 75:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5108);
					break;
				case 92:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5388);
					break;
				case 76:
				case 77:
				case 78:
				case 79:
				case 80:
				case 81:
				case 82:
				case 83:
				case 84:
				case 85:
				case 86:
				case 87:
				case 88:
				case 89:
				case 90:
				case 91:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5218 + num - 76);
					break;
				case 63:
				case 64:
				case 65:
				case 66:
				case 67:
				case 68:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4626 + num - 63);
					break;
				default:
					if (num >= 41 && num <= 45)
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2114 + num - 41);
					}
					else if (num >= 46 && num <= 53)
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2442 + num - 46);
					}
					else if (num >= 22 && num <= 25)
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1440 + num - 22);
					}
					else if (num >= 26 && num <= 29)
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1496 + num - 26);
					}
					else if (num >= 30 && num <= 32)
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1538 + num - 30);
					}
					else
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1360 + num);
					}
					break;
				}
				break;
			case 440:
			{
				int num7 = -1;
				int num8 = -1;
				switch (num)
				{
				case 0:
					num7 = 3644;
					num8 = 1526;
					break;
				case 1:
					num7 = 3645;
					num8 = 1524;
					break;
				case 2:
					num7 = 3646;
					num8 = 1525;
					break;
				case 3:
					num7 = 3647;
					num8 = 1523;
					break;
				case 4:
					num7 = 3648;
					num8 = 1522;
					break;
				case 5:
					num7 = 3649;
					num8 = 1527;
					break;
				case 6:
					num7 = 3650;
					num8 = 3643;
					break;
				}
				if (num7 != -1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, num7);
				}
				if (num8 != -1 && num2 == 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, num8);
				}
				break;
			}
			}
			destroyObject = false;
		}
	}

	public static void Place2x3Wall(int x, int y, ushort type, int style)
	{
		int num = y - 1;
		bool flag = true;
		for (int i = x; i < x + 2; i++)
		{
			for (int j = num; j < num + 3; j++)
			{
				if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0)
				{
					flag = false;
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		int num2 = style * 36;
		int num3 = 0;
		for (int k = x; k < x + 2; k++)
		{
			for (int l = num; l < num + 3; l++)
			{
				Main.tile[k, l].active(active: true);
				Main.tile[k, l].type = type;
				Main.tile[k, l].frameX = (short)(num2 + 18 * (k - x));
				Main.tile[k, l].frameY = (short)(num3 + 18 * (l - num));
			}
		}
	}

	public static void Check2x3Wall(int x, int y)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int type = Main.tile[x, y].type;
		int num = 0;
		int num2 = Main.tile[x, y].frameX / 18;
		while (num2 >= 2)
		{
			num2 -= 2;
			num++;
		}
		int num3 = x - num2;
		int num4 = y - Main.tile[x, y].frameY / 18;
		num2 = num * 36;
		for (int i = num3; i < num3 + 2; i++)
		{
			for (int j = num4; j < num4 + 3; j++)
			{
				if (Main.tile[i, j].type != type || !Main.tile[i, j].active() || Main.tile[i, j].wall <= 0 || Main.tile[i, j].frameX != num2 + (i - num3) * 18 || Main.tile[i, j].frameY != (j - num4) * 18)
				{
					flag = true;
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(x, y, type);
		for (int k = num3; k < num3 + 2; k++)
		{
			for (int l = num4; l < num4 + 3; l++)
			{
				if (Main.tile[k, l].type == type && Main.tile[k, l].active())
				{
					KillTile(k, l);
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			if (type == 245)
			{
				if (num >= 19 && num <= 28)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5248 + num - 19);
				}
				else if (num >= 15 && num <= 18)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5247);
				}
				else
				{
					switch (num)
					{
					case 14:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5246);
						break;
					case 13:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5086);
						break;
					case 12:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4728);
						break;
					case 11:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4727);
						break;
					case 10:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4726);
						break;
					case 9:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4659);
						break;
					case 8:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4639);
						break;
					case 7:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4638);
						break;
					case 6:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1577);
						break;
					case 5:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1495);
						break;
					default:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1474 + num);
						break;
					}
				}
			}
			destroyObject = false;
		}
	}

	public static void Place3x2Wall(int x, int y, ushort type, int style)
	{
		int num = x - 1;
		bool flag = true;
		for (int i = num; i < num + 3; i++)
		{
			for (int j = y; j < y + 2; j++)
			{
				if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0)
				{
					flag = false;
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		int num2 = 0;
		int num3 = style * 36;
		for (int k = num; k < num + 3; k++)
		{
			for (int l = y; l < y + 2; l++)
			{
				Main.tile[k, l].active(active: true);
				Main.tile[k, l].type = type;
				Main.tile[k, l].frameX = (short)(num2 + 18 * (k - num));
				Main.tile[k, l].frameY = (short)(num3 + 18 * (l - y));
			}
		}
	}

	public static void Check3x2Wall(int x, int y)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int type = Main.tile[x, y].type;
		int num = 0;
		int num2 = Main.tile[x, y].frameY / 18;
		while (num2 >= 2)
		{
			num2 -= 2;
			num++;
		}
		int num3 = y - num2;
		int num4 = x - Main.tile[x, y].frameX / 18;
		num2 = num * 36;
		for (int i = num4; i < num4 + 3; i++)
		{
			for (int j = num3; j < num3 + 2; j++)
			{
				if (Main.tile[i, j].type != type || !Main.tile[i, j].active() || Main.tile[i, j].wall <= 0 || Main.tile[i, j].frameY != num2 + (j - num3) * 18 || Main.tile[i, j].frameX != (i - num4) * 18)
				{
					flag = true;
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(x, y, type);
		for (int k = num4; k < num4 + 3; k++)
		{
			for (int l = num3; l < num3 + 2; l++)
			{
				if (Main.tile[k, l].type == type && Main.tile[k, l].active())
				{
					KillTile(k, l);
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			if (type == 246)
			{
				switch (num)
				{
				case 16:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1541);
					break;
				case 17:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1542);
					break;
				case 18:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1908);
					break;
				case 19:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4661);
					break;
				case 20:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4729);
					break;
				case 21:
				case 22:
				case 23:
				case 24:
				case 25:
				case 26:
				case 27:
				case 28:
				case 29:
				case 30:
				case 31:
				case 32:
				case 33:
				case 34:
				case 35:
				case 36:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5258 + num - 21);
					break;
				default:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1479 + num);
					break;
				}
			}
			destroyObject = false;
		}
	}

	public static void Place4x3Wall(int x, int y, ushort type, int style)
	{
		int num = x - 1;
		int num2 = y - 1;
		bool flag = true;
		for (int i = num; i < num + 4; i++)
		{
			for (int j = num2; j < num2 + 3; j++)
			{
				if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0)
				{
					flag = false;
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		int num3 = 0;
		int num4 = style * 54;
		for (int k = num; k < num + 4; k++)
		{
			for (int l = num2; l < num2 + 3; l++)
			{
				Main.tile[k, l].active(active: true);
				Main.tile[k, l].type = type;
				Main.tile[k, l].frameX = (short)(num3 + 18 * (k - num));
				Main.tile[k, l].frameY = (short)(num4 + 18 * (l - num2));
			}
		}
	}

	public static void Check4x3Wall(int x, int y)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int type = Main.tile[x, y].type;
		int num = 0;
		int num2 = Main.tile[x, y].frameY / 18;
		while (num2 >= 3)
		{
			num2 -= 3;
			num++;
		}
		int num3 = y - num2;
		int num4 = x - Main.tile[x, y].frameX / 18;
		num2 = num * 54;
		for (int i = num4; i < num4 + 4; i++)
		{
			for (int j = num3; j < num3 + 3; j++)
			{
				if (Main.tile[i, j].type != type || !Main.tile[i, j].active() || Main.tile[i, j].wall <= 0 || Main.tile[i, j].frameY != num2 + (j - num3) * 18 || Main.tile[i, j].frameX != (i - num4) * 18)
				{
					flag = true;
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(x, y, type);
		for (int k = num4; k < num4 + 4; k++)
		{
			for (int l = num3; l < num3 + 3; l++)
			{
				if (Main.tile[k, l].type == type && Main.tile[k, l].active())
				{
					KillTile(k, l);
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			if (type == 241)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1417);
			}
			destroyObject = false;
		}
	}

	public static void Place6x4Wall(int x, int y, ushort type, int style)
	{
		int num = x - 2;
		int num2 = y - 2;
		bool flag = true;
		for (int i = num; i < num + 6; i++)
		{
			for (int j = num2; j < num2 + 4; j++)
			{
				if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0)
				{
					flag = false;
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		int num3 = 27;
		int num4 = style / num3 * 108;
		int num5 = style % num3 * 72;
		for (int k = num; k < num + 6; k++)
		{
			for (int l = num2; l < num2 + 4; l++)
			{
				Main.tile[k, l].active(active: true);
				Main.tile[k, l].type = type;
				Main.tile[k, l].frameX = (short)(num4 + 18 * (k - num));
				Main.tile[k, l].frameY = (short)(num5 + 18 * (l - num2));
			}
		}
	}

	public static void Check6x4Wall(int x, int y)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int type = Main.tile[x, y].type;
		int num = 0;
		int num2 = Main.tile[x, y].frameY / 18;
		int num3 = Main.tile[x, y].frameX / 18;
		num = 27 * (num3 / 6) + (num2 >> 2);
		num2 %= 4;
		num3 %= 6;
		int num4 = y - num2;
		int num5 = x - Main.tile[x, y].frameX / 18 % 6;
		num2 = num % 27 * 72;
		num3 = num / 27 * 108;
		for (int i = num5; i < num5 + 6; i++)
		{
			for (int j = num4; j < num4 + 4; j++)
			{
				if (Main.tile[i, j].type != type || !Main.tile[i, j].active() || Main.tile[i, j].wall <= 0 || Main.tile[i, j].frameY != num2 + (j - num4) * 18 || Main.tile[i, j].frameX != num3 + (i - num5) * 18)
				{
					flag = true;
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(x, y, type);
		for (int k = num5; k < num5 + 6; k++)
		{
			for (int l = num4; l < num4 + 4; l++)
			{
				if (Main.tile[k, l].type == type && Main.tile[k, l].active())
				{
					KillTile(k, l);
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			if (type == 242)
			{
				switch (num)
				{
				case 30:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2995);
					break;
				case 65:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5389);
					break;
				case 64:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5310);
					break;
				case 63:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5308);
					break;
				case 62:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5274);
					break;
				case 50:
				case 51:
				case 52:
				case 53:
				case 54:
				case 55:
				case 56:
				case 57:
				case 58:
				case 59:
				case 60:
				case 61:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5234 + num - 50);
					break;
				case 46:
				case 47:
				case 48:
				case 49:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5121 + num - 46);
					break;
				default:
					switch (num)
					{
					case 45:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5085);
						break;
					case 44:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4725);
						break;
					case 43:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4658);
						break;
					case 37:
					case 38:
					case 39:
					case 40:
					case 41:
					case 42:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4632 + num - 37);
						break;
					case 31:
					case 32:
					case 33:
					case 34:
					case 35:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3055 + num - 31);
						break;
					default:
						if (num >= 27 && num <= 29)
						{
							Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2865 + num - 27);
						}
						else if (num == 36)
						{
							Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3596);
						}
						else if (num == 26)
						{
							Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2497);
						}
						else if (num == 25)
						{
							Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2495);
						}
						else if (num >= 22)
						{
							Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2281 + num - 22);
						}
						else if (num >= 17)
						{
							Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1846 + num - 17);
						}
						else if (num == 16)
						{
							Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1573);
						}
						else if (num >= 13)
						{
							Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1500 + num - 13);
						}
						else if (num >= 6)
						{
							Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1433 + num - 6);
						}
						else
						{
							Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1421 + num);
						}
						break;
					}
					break;
				}
			}
			destroyObject = false;
		}
	}

	private static int RollRandomSeaShellStyle()
	{
		int result = genRand.Next(2);
		if (genRand.Next(10) == 0)
		{
			result = 2;
		}
		if (genRand.Next(10) == 0)
		{
			result = 3;
		}
		if (genRand.Next(50) == 0)
		{
			result = 4;
		}
		return result;
	}

	public static void Place1x1(int x, int y, int type, int style = 0)
	{
		Tile tile = Main.tile[x, y];
		if (Main.tile[x, y] == null)
		{
			tile = (Main.tile[x, y] = default(Tile));
		}
		if (Main.tile[x, y + 1] == null)
		{
			Main.tile[x, y + 1] = default(Tile);
		}
		if (type == 324)
		{
			if (SolidTile2(x, y + 1) || (Main.tile[x, y + 1].nactive() && Main.tileTable[Main.tile[x, y + 1].type]))
			{
				tile.active(active: true);
				tile.type = (ushort)type;
				tile.frameX = (short)(22 * genRand.Next(3));
				tile.frameY = (short)(22 * style);
			}
		}
		else if (SolidTile2(x, y + 1) && !tile.active())
		{
			tile.active(active: true);
			tile.type = (ushort)type;
			switch (type)
			{
			case 324:
				tile.frameX = (short)(22 * RollRandomSeaShellStyle());
				tile.frameY = (short)(22 * style);
				break;
			case 36:
			case 144:
			case 239:
				tile.frameX = (short)(style * 18);
				tile.frameY = 0;
				break;
			default:
				tile.frameY = (short)(style * 18);
				break;
			}
		}
	}

	public static void Check1x1(int x, int y, int type)
	{
		if (Main.tile[x, y + 1] != null)
		{
			if (!SolidTileAllowBottomSlope(x, y + 1))
			{
				KillTile(x, y);
			}
			if (type == 624 && !HasValidGroundForAbigailsFlowerBelowSpot(x, y))
			{
				KillTile(x, y);
			}
		}
	}

	public static void CheckGolf1x1(int x, int y, int type)
	{
		Tile tile = Main.tile[x, y];
		bool flag = false;
		if (tile.frameX % 18 != 0)
		{
			flag = true;
		}
		if (tile.frameY % 18 != 0)
		{
			flag = true;
		}
		if (!SolidTileAllowBottomSlope(x, y + 1))
		{
			flag = true;
		}
		if (flag)
		{
			KillTile(x, y);
		}
	}

	public static void CheckLogicTiles(int x, int y, int type)
	{
		if (type == 419)
		{
			Tile tile = Main.tile[x, y + 1];
			if (tile != null && (!tile.active() || (tile.type != 420 && tile.type != 419)))
			{
				KillTile(x, y);
				return;
			}
		}
		Tile tile2 = Main.tile[x, y];
		bool flag = false;
		if (tile2.frameX % 18 != 0)
		{
			flag = true;
		}
		if (tile2.frameY % 18 != 0)
		{
			flag = true;
		}
		if (flag)
		{
			KillTile(x, y);
		}
	}

	public static void PlaceLogicTiles(int x, int y, int type, int style = 0)
	{
		Tile tile = Main.tile[x, y];
		if (Main.tile[x, y] == null)
		{
			tile = (Main.tile[x, y] = default(Tile));
		}
		if (Main.tile[x, y + 1] == null)
		{
			Main.tile[x, y + 1] = default(Tile);
		}
		if (type == 419)
		{
			if (Main.tile[x, y + 1].active() && (Main.tile[x, y + 1].type == 419 || Main.tile[x, y + 1].type == 420))
			{
				tile.active(active: true);
				tile.type = (ushort)type;
				tile.frameX = (short)(style * 18);
				tile.frameY = 0;
			}
		}
		else if (!tile.active())
		{
			tile.active(active: true);
			tile.type = (ushort)type;
			tile.frameX = 0;
			tile.frameY = (short)(18 * style);
		}
	}

	public static void PlaceOnTable1x1(int x, int y, int type, int style = 0)
	{
		bool flag = false;
		if (Main.tile[x, y] == null)
		{
			Main.tile[x, y] = default(Tile);
		}
		if (Main.tile[x, y + 1] == null)
		{
			Main.tile[x, y + 1] = default(Tile);
		}
		if (!Main.tile[x, y].active() && Main.tile[x, y + 1].nactive() && Main.tileTable[Main.tile[x, y + 1].type])
		{
			flag = true;
		}
		if (type == 78 && !Main.tile[x, y].active() && Main.tile[x, y + 1].nactive() && Main.tileSolid[Main.tile[x, y + 1].type] && !Main.tile[x, y + 1].halfBrick() && Main.tile[x, y + 1].slope() == 0)
		{
			flag = true;
		}
		if (flag)
		{
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].type = (ushort)type;
			if (type == 33)
			{
				Main.tile[x, y].frameX = 0;
				Main.tile[x, y].frameY = (short)(style * 22);
			}
			else
			{
				Main.tile[x, y].frameX = (short)(style * 18);
				Main.tile[x, y].frameY = 0;
			}
			if (type == 50)
			{
				Main.tile[x, y].frameX = (short)(18 * genRand.Next(5));
			}
		}
	}

	public static bool PlaceAlch(int x, int y, int style)
	{
		if (Main.tile[x, y] == null)
		{
			Main.tile[x, y] = default(Tile);
		}
		if (Main.tile[x, y + 1] == null)
		{
			Main.tile[x, y + 1] = default(Tile);
		}
		if (!Main.tile[x, y].active() && Main.tile[x, y + 1].nactive() && !Main.tile[x, y + 1].halfBrick() && Main.tile[x, y + 1].slope() == 0)
		{
			bool flag = false;
			switch (style)
			{
			case 0:
				if (Main.tile[x, y + 1].type != 2 && Main.tile[x, y + 1].type != 477 && Main.tile[x, y + 1].type != 492 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 109)
				{
					flag = true;
				}
				if (Main.tile[x, y].liquid > 0)
				{
					flag = true;
				}
				break;
			case 1:
				if (Main.tile[x, y + 1].type != 60 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
				{
					flag = true;
				}
				if (Main.tile[x, y].liquid > 0)
				{
					flag = true;
				}
				break;
			case 2:
				if (Main.tile[x, y + 1].type != 0 && Main.tile[x, y + 1].type != 59 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
				{
					flag = true;
				}
				if (Main.tile[x, y].liquid > 0)
				{
					flag = true;
				}
				break;
			case 3:
				if (Main.tile[x, y + 1].type != 661 && Main.tile[x, y + 1].type != 662 && Main.tile[x, y + 1].type != 203 && Main.tile[x, y + 1].type != 199 && Main.tile[x, y + 1].type != 23 && Main.tile[x, y + 1].type != 25 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
				{
					flag = true;
				}
				if (Main.tile[x, y].liquid > 0)
				{
					flag = true;
				}
				break;
			case 4:
				if (Main.tile[x, y + 1].type != 53 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 116)
				{
					flag = true;
				}
				if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
				{
					flag = true;
				}
				break;
			case 5:
				if (Main.tile[x, y + 1].type != 57 && Main.tile[x, y + 1].type != 633 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
				{
					flag = true;
				}
				if (Main.tile[x, y].liquid > 0 && !Main.tile[x, y].lava())
				{
					flag = true;
				}
				break;
			case 6:
				if (Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 147 && Main.tile[x, y + 1].type != 161 && Main.tile[x, y + 1].type != 163 && Main.tile[x, y + 1].type != 164 && Main.tile[x, y + 1].type != 200)
				{
					flag = true;
				}
				if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
				{
					flag = true;
				}
				break;
			}
			if (!flag)
			{
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].type = 82;
				Main.tile[x, y].frameX = (short)(18 * style);
				Main.tile[x, y].frameY = 0;
				return true;
			}
		}
		return false;
	}

	public static void GrowSpike(int i, int j, ushort spikeType, ushort landType)
	{
		int num = -1;
		switch (landType)
		{
		case 23:
			num = 661;
			break;
		case 199:
			num = 662;
			break;
		}
		int num2 = i;
		int num3 = j;
		int num4 = 0;
		if (Main.tile[num2 + 1, num3].active() && Main.tile[num2 + 1, num3].type == spikeType)
		{
			num4++;
		}
		if (Main.tile[num2 - 1, num3].active() && Main.tile[num2 - 1, num3].type == spikeType)
		{
			num4++;
		}
		if (Main.tile[num2, num3 + 1].active() && Main.tile[num2, num3 + 1].type == spikeType)
		{
			num4++;
		}
		if (Main.tile[num2, num3 - 1].active() && Main.tile[num2, num3 - 1].type == spikeType)
		{
			num4++;
		}
		if (num4 >= 3 && Main.tile[i, j].type != landType && Main.tile[i, j].type != num)
		{
			return;
		}
		switch (genRand.Next(4))
		{
		case 0:
			num3--;
			break;
		case 1:
			num3++;
			break;
		case 2:
			num2--;
			break;
		case 3:
			num2++;
			break;
		}
		if (Main.tile[num2, num3].active())
		{
			return;
		}
		num4 = 0;
		if (Main.tile[num2 + 1, num3].active() && Main.tile[num2 + 1, num3].type == spikeType)
		{
			num4++;
		}
		if (Main.tile[num2 - 1, num3].active() && Main.tile[num2 - 1, num3].type == spikeType)
		{
			num4++;
		}
		if (Main.tile[num2, num3 + 1].active() && Main.tile[num2, num3 + 1].type == spikeType)
		{
			num4++;
		}
		if (Main.tile[num2, num3 - 1].active() && Main.tile[num2, num3 - 1].type == spikeType)
		{
			num4++;
		}
		if (num4 >= 2)
		{
			return;
		}
		int num5 = 7;
		int num9 = num2 - num5;
		int num6 = num2 + num5;
		int num7 = num3 - num5;
		int num8 = num3 + num5;
		bool flag = false;
		for (int k = num9; k < num6; k++)
		{
			for (int l = num7; l < num8; l++)
			{
				if (Math.Abs(k - num2) * 2 + Math.Abs(l - num3) < 9 && Main.tile[k, l].active() && (Main.tile[k, l].type == landType || Main.tile[k, l].type == num) && Main.tile[k, l - 1].active() && Main.tile[k, l - 1].type == spikeType && Main.tile[k, l - 1].liquid == 0)
				{
					flag = true;
					break;
				}
			}
		}
		if (flag)
		{
			Main.tile[num2, num3].type = spikeType;
			Main.tile[num2, num3].active(active: true);
			Main.tile[num2, num3].CopyPaintAndCoating(Main.tile[i, j]);
			SquareTileFrame(num2, num3);
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, num2, num3, 1);
			}
		}
	}

	private static bool GrowMoreVines(int x, int y)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (!InWorld(x, y, 30))
		{
			return false;
		}
		int num = 4;
		int num2 = 6;
		int num3 = 10;
		int num4 = 60;
		int num5 = 0;
		if (Main.tile[x, y].type == 528)
		{
			num4 /= 5;
		}
		for (int i = x - num; i <= x + num; i++)
		{
			for (int j = y - num2; j <= y + num3; j++)
			{
				if (TileID.Sets.IsVine[Main.tile[i, j].type])
				{
					num5++;
					if (j > y && Collision.CanHitLine(new Vector2((float)(x * 16), (float)(y * 16)), 1, 1, new Vector2((float)(i * 16), (float)(j * 16)), 1, 1))
					{
						num5 = ((Main.tile[i, j].type != 528) ? (num5 + (j - y) * 2) : (num5 + (j - y) * 20));
					}
					if (num5 > num4)
					{
						return false;
					}
				}
			}
		}
		return true;
	}

	private static void GrowGlowTulips()
	{
		int num = ((Main.maxTilesX > 4200) ? ((Main.maxTilesX <= 6400) ? 1 : 2) : 0);
		int num2 = 100;
		int num3 = 300;
		int num4 = 2;
		num4 = num switch
		{
			1 => 4, 
			2 => 6, 
			_ => 2, 
		};
		int num5 = 0;
		int num6 = 10000;
		int num7 = (int)((double)num6 * 0.75);
		while (num5 < num4)
		{
			num6--;
			if (num6 <= 0)
			{
				break;
			}
			int i2 = ((num5 >= num4 / 2 && (num6 <= num7 || genRand.Next(2) != 0)) ? genRand.Next(Main.maxTilesX - num3, Main.maxTilesX - num2) : genRand.Next(num2, num3));
			int i = ((!remixWorldGen) ? genRand.Next((int)Main.worldSurface, Main.maxTilesY - 200) : genRand.Next((int)Main.worldSurface, Main.maxTilesY - 350));
			if (TryGrowingGlowTulip(i2, i))
			{
				num5++;
			}
		}
	}

	private static void MatureTheHerbPlants()
	{
		for (int i = 10; i < Main.maxTilesX - 10; i++)
		{
			for (int j = 10; j < Main.maxTilesY - 10; j++)
			{
				if ((double)j > Main.rockLayer && (Main.tile[i, j + 1].type == 59 || Main.tile[i, j + 1].type == 0) && SolidTile(i, j + 1) && !Main.tile[i, j].active() && Main.tile[i, j].liquid == 0 && genRand.Next(25) == 0)
				{
					Main.tile[i, j].active(active: true);
					Main.tile[i, j].type = 82;
					Main.tile[i, j].frameX = 36;
					Main.tile[i, j].frameY = 0;
				}
				if (Main.tile[i, j].type == 82 && genRand.Next(3) == 0)
				{
					Main.tile[i, j].type = 83;
					if (Main.tile[i, j].frameX == 36 && genRand.Next(2) == 0)
					{
						Main.tile[i, j].type = 84;
					}
					if (Main.tile[i, j].frameX == 108 && genRand.Next(3) == 0)
					{
						Main.tile[i, j].type = 84;
					}
				}
			}
		}
	}

	public static void GrowAlch(int x, int y)
	{
		if (!Main.tile[x, y].active())
		{
			return;
		}
		if (Main.tile[x, y].liquid > 0)
		{
			int num = Main.tile[x, y].frameX / 18;
			if ((!Main.tile[x, y].lava() || num != 5) && (Main.tile[x, y].liquidType() != 0 || (num != 1 && num != 4)))
			{
				KillTile(x, y);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
				SquareTileFrame(x, y);
			}
		}
		if (Main.tile[x, y].type == 82)
		{
			if (genRand.Next(50) == 0)
			{
				bool flag = false;
				if (Main.tile[x, y].frameX == 108)
				{
					if (genRand.Next(2) == 0)
					{
						flag = true;
					}
				}
				else
				{
					flag = true;
				}
				if (flag)
				{
					Main.tile[x, y].type = 83;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y);
					}
					SquareTileFrame(x, y);
				}
			}
			else if (Main.dayTime && Main.tile[x, y].type == 82 && Main.tile[x, y].frameX == 0 && genRand.Next(50) == 0)
			{
				Main.tile[x, y].type = 83;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
				SquareTileFrame(x, y);
			}
			else if (!Main.dayTime && Main.tile[x, y].type == 82 && Main.tile[x, y].frameX == 18 && genRand.Next(50) == 0)
			{
				Main.tile[x, y].type = 83;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
				SquareTileFrame(x, y);
			}
			else if (Main.raining && Main.tile[x, y].type == 82 && Main.tile[x, y].frameX == 72 && genRand.Next(50) == 0)
			{
				Main.tile[x, y].type = 83;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
				SquareTileFrame(x, y);
			}
			else if ((double)y > Main.worldSurface && Main.tile[x, y].type == 82 && Main.tile[x, y].frameX == 36 && genRand.Next(50) == 0)
			{
				Main.tile[x, y].type = 83;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
				SquareTileFrame(x, y);
			}
			else if (y > Main.maxTilesY - 200 && Main.tile[x, y].type == 82 && Main.tile[x, y].frameX == 90 && genRand.Next(50) == 0)
			{
				Main.tile[x, y].type = 83;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
				SquareTileFrame(x, y);
			}
		}
		else if (Main.tile[x, y].frameX == 36 && genRand.Next(3) != 0)
		{
			if (Main.tile[x, y].type == 83)
			{
				if (genRand.Next(2) == 0)
				{
					Main.tile[x, y].type = 84;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y);
					}
				}
			}
			else if (Main.tile[x, y].type == 84 || genRand.Next(5) == 0)
			{
				Main.tile[x, y].type = 83;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
			}
		}
		else if (Main.tile[x, y].frameX == 108 && Main.tile[x, y].type == 83 && genRand.Next(30) == 0)
		{
			Main.tile[x, y].type = 84;
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, x, y);
			}
			SquareTileFrame(x, y);
		}
	}

	public static void PlantAlch()
	{
		int num = genRand.Next(20, Main.maxTilesX - 20);
		int num2 = 0;
		for (num2 = (Main.remixWorld ? genRand.Next(20, Main.maxTilesY - 20) : ((genRand.Next(40) == 0) ? genRand.Next((int)(Main.rockLayer + (double)Main.maxTilesY) / 2, Main.maxTilesY - 20) : ((genRand.Next(10) != 0) ? genRand.Next((int)Main.worldSurface, Main.maxTilesY - 20) : genRand.Next(20, Main.maxTilesY - 20)))); num2 < Main.maxTilesY - 20 && !Main.tile[num, num2].active(); num2++)
		{
		}
		if (!Main.tile[num, num2].nactive() || Main.tile[num, num2 - 1].active() || Main.tile[num, num2 - 1].liquid != 0)
		{
			return;
		}
		int num3 = 15;
		int num4 = 5;
		int num5 = 0;
		num3 = (int)((double)num3 * ((double)Main.maxTilesX / 4200.0));
		int num9 = Utils.Clamp(num - num3, 4, Main.maxTilesX - 4);
		int num6 = Utils.Clamp(num + num3, 4, Main.maxTilesX - 4);
		int num7 = Utils.Clamp(num2 - num3, 4, Main.maxTilesY - 4);
		int num8 = Utils.Clamp(num2 + num3, 4, Main.maxTilesY - 4);
		for (int i = num9; i <= num6; i++)
		{
			for (int j = num7; j <= num8; j++)
			{
				if (Main.tileAlch[Main.tile[i, j].type])
				{
					num5++;
				}
			}
		}
		if (num5 < num4)
		{
			if (Main.tile[num, num2].type == 2 || Main.tile[num, num2].type == 109)
			{
				PlaceAlch(num, num2 - 1, 0);
			}
			if (Main.tile[num, num2].type == 60)
			{
				PlaceAlch(num, num2 - 1, 1);
			}
			if (Main.tile[num, num2].type == 0 || Main.tile[num, num2].type == 59)
			{
				PlaceAlch(num, num2 - 1, 2);
			}
			if (Main.tile[num, num2].type == 23 || Main.tile[num, num2].type == 661 || Main.tile[num, num2].type == 25 || Main.tile[num, num2].type == 203 || Main.tile[num, num2].type == 199 || Main.tile[num, num2].type == 662)
			{
				PlaceAlch(num, num2 - 1, 3);
			}
			if ((Main.tile[num, num2].type == 53 || Main.tile[num, num2].type == 116) && num >= beachDistance && num <= Main.maxTilesX - beachDistance)
			{
				PlaceAlch(num, num2 - 1, 4);
			}
			if (Main.tile[num, num2].type == 57 || Main.tile[num, num2].type == 633)
			{
				PlaceAlch(num, num2 - 1, 5);
			}
			if (Main.tile[num, num2].type == 147 || Main.tile[num, num2].type == 163 || Main.tile[num, num2].type == 164 || Main.tile[num, num2].type == 161 || Main.tile[num, num2].type == 200)
			{
				PlaceAlch(num, num2 - 1, 6);
			}
			if (Main.tile[num, num2 - 1].active() && Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, num, num2 - 1);
			}
		}
	}

	public static void CheckAlch(int x, int y)
	{
		if (Main.tile[x, y] == null)
		{
			Main.tile[x, y] = default(Tile);
		}
		if (Main.tile[x, y + 1] == null)
		{
			Main.tile[x, y + 1] = default(Tile);
		}
		bool flag = false;
		if (!Main.tile[x, y + 1].nactive())
		{
			flag = true;
		}
		if (Main.tile[x, y + 1].halfBrick())
		{
			flag = true;
		}
		int num = Main.tile[x, y].frameX / 18;
		Main.tile[x, y].frameY = 0;
		if (!flag)
		{
			switch (num)
			{
			case 0:
				if (Main.tile[x, y + 1].type != 109 && Main.tile[x, y + 1].type != 2 && Main.tile[x, y + 1].type != 477 && Main.tile[x, y + 1].type != 492 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
				{
					flag = true;
				}
				if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
				{
					flag = true;
				}
				break;
			case 1:
				if (Main.tile[x, y + 1].type != 60 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
				{
					flag = true;
				}
				if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
				{
					flag = true;
				}
				break;
			case 2:
				if (Main.tile[x, y + 1].type != 0 && Main.tile[x, y + 1].type != 59 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
				{
					flag = true;
				}
				if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
				{
					flag = true;
				}
				break;
			case 3:
				if (Main.tile[x, y + 1].type != 661 && Main.tile[x, y + 1].type != 662 && Main.tile[x, y + 1].type != 199 && Main.tile[x, y + 1].type != 203 && Main.tile[x, y + 1].type != 23 && Main.tile[x, y + 1].type != 25 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
				{
					flag = true;
				}
				if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
				{
					flag = true;
				}
				break;
			case 4:
				if (Main.tile[x, y + 1].type != 53 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 116)
				{
					flag = true;
				}
				if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
				{
					flag = true;
				}
				break;
			case 5:
				if (Main.tile[x, y + 1].type != 57 && Main.tile[x, y + 1].type != 633 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
				{
					flag = true;
				}
				if (Main.tile[x, y].type == 82 || !Main.tile[x, y].lava() || Main.netMode == 1)
				{
					break;
				}
				if (Main.tile[x, y].liquid > 16)
				{
					if (Main.tile[x, y].type == 83)
					{
						Main.tile[x, y].type = 84;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, x, y);
						}
					}
				}
				else if (Main.tile[x, y].type == 84)
				{
					Main.tile[x, y].type = 83;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y);
					}
				}
				break;
			case 6:
				if (Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 147 && Main.tile[x, y + 1].type != 161 && Main.tile[x, y + 1].type != 163 && Main.tile[x, y + 1].type != 164 && Main.tile[x, y + 1].type != 200)
				{
					flag = true;
				}
				if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
				{
					flag = true;
				}
				break;
			}
		}
		if (flag)
		{
			KillTile(x, y);
		}
	}

	public static void CheckBanner(int x, int j, byte type)
	{
		if (destroyObject)
		{
			return;
		}
		int num = Main.tile[x, j].frameY / 18;
		int num2 = 0;
		while (num >= 3)
		{
			num -= 3;
			num2++;
		}
		num = j - num;
		int frameX = Main.tile[x, j].frameX;
		bool flag = false;
		for (int i = 0; i < 3; i++)
		{
			if (Main.tile[x, num + i] == null)
			{
				Main.tile[x, num + i] = default(Tile);
			}
			if (!Main.tile[x, num + i].active())
			{
				flag = true;
			}
			else if (Main.tile[x, num + i].type != type)
			{
				flag = true;
			}
			else if (Main.tile[x, num + i].frameY != i * 18 + num2 * 18 * 3)
			{
				flag = true;
			}
			else if (Main.tile[x, num + i].frameX != frameX)
			{
				flag = true;
			}
		}
		if (Main.tile[x, num - 1] == null)
		{
			Main.tile[x, num - 1] = default(Tile);
		}
		Tile tile = Main.tile[x, num - 1];
		if (!tile.nactive())
		{
			flag = true;
		}
		bool num4 = tile.topSlope() || tile.halfBrick() || Main.tileSolid[tile.type];
		bool flag2 = !Main.tileSolidTop[tile.type] || (TileID.Sets.Platforms[tile.type] && (tile.halfBrick() || tile.topSlope()));
		bool flag3 = num4 && flag2 && !TileID.Sets.NotReallySolid[tile.type] && !tile.bottomSlope();
		if (TileID.Sets.Platforms[tile.type] || tile.type == 380)
		{
			flag3 = true;
		}
		if (!flag3)
		{
			flag = true;
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(x, j, type);
		for (int k = 0; k < 3; k++)
		{
			if (Main.tile[x, num + k].type == type)
			{
				KillTile(x, num + k);
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			if (type == 91)
			{
				int num3 = frameX / 18;
				num3 += num2 * 111;
				if (num3 == 310)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 5352);
				}
				else if (num3 >= 297)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 4668 + num3);
				}
				else if (num3 >= 295)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 4392 + num3);
				}
				else if (num3 >= 294)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 4602);
				}
				else if (num3 >= 288)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 4253 + num3);
				}
				else if (num3 >= 278)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 3559 + num3);
				}
				else if (num3 >= 273)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 3516 + num3);
				}
				else if (num3 >= 272)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 3780);
				}
				else if (num3 >= 270)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 3323 + num3);
				}
				else if (num3 >= 207)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 3183 + num3);
				}
				else if (num3 >= 109)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 2788 + num3);
				}
				else if (num3 >= 22)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 1593 + num3);
				}
				else if (num3 >= 10 && num3 <= 15)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 1441 + num3);
				}
				else if (num3 >= 16 && num3 <= 21)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 1448 + num3);
				}
				else if (num3 >= 7 && num3 <= 9)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 838 + num3);
				}
				else if (num3 >= 4 && num3 <= 6)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 785 + num3);
				}
				else
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 337 + num3);
				}
			}
			destroyObject = false;
		}
	}

	public static void PlaceBanner(int x, int y, ushort type, int style = 0)
	{
		int num = style * 18;
		int num2 = 0;
		if (style >= 90)
		{
			num -= 1620;
			num2 += 54;
		}
		if (Main.tile[x, y - 1] == null)
		{
			Main.tile[x, y - 1] = default(Tile);
		}
		if (Main.tile[x, y] == null)
		{
			Main.tile[x, y] = default(Tile);
		}
		if (Main.tile[x, y + 1] == null)
		{
			Main.tile[x, y + 1] = default(Tile);
		}
		if (Main.tile[x, y + 2] == null)
		{
			Main.tile[x, y + 2] = default(Tile);
		}
		if (Main.tile[x, y - 1].nactive() && Main.tileSolid[Main.tile[x, y - 1].type] && !Main.tileSolidTop[Main.tile[x, y - 1].type] && !Main.tile[x, y].active() && !Main.tile[x, y + 1].active() && !Main.tile[x, y + 2].active())
		{
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = (short)num2;
			Main.tile[x, y].frameX = (short)num;
			Main.tile[x, y].type = type;
			Main.tile[x, y + 1].active(active: true);
			Main.tile[x, y + 1].frameY = (short)(num2 + 18);
			Main.tile[x, y + 1].frameX = (short)num;
			Main.tile[x, y + 1].type = type;
			Main.tile[x, y + 2].active(active: true);
			Main.tile[x, y + 2].frameY = (short)(num2 + 36);
			Main.tile[x, y + 2].frameX = (short)num;
			Main.tile[x, y + 2].type = type;
		}
	}

	public static void PlaceMan(int i, int j, int dir)
	{
		for (int k = i; k <= i + 1; k++)
		{
			for (int l = j - 2; l <= j; l++)
			{
				if (Main.tile[k, l].active())
				{
					return;
				}
			}
		}
		if (SolidTile2(i, j + 1) && SolidTile2(i + 1, j + 1))
		{
			byte b = 0;
			if (dir == 1)
			{
				b = 36;
			}
			Main.tile[i, j - 2].active(active: true);
			Main.tile[i, j - 2].frameY = 0;
			Main.tile[i, j - 2].frameX = b;
			Main.tile[i, j - 2].type = 128;
			Main.tile[i, j - 1].active(active: true);
			Main.tile[i, j - 1].frameY = 18;
			Main.tile[i, j - 1].frameX = b;
			Main.tile[i, j - 1].type = 128;
			Main.tile[i, j].active(active: true);
			Main.tile[i, j].frameY = 36;
			Main.tile[i, j].frameX = b;
			Main.tile[i, j].type = 128;
			Main.tile[i + 1, j - 2].active(active: true);
			Main.tile[i + 1, j - 2].frameY = 0;
			Main.tile[i + 1, j - 2].frameX = (byte)(18 + b);
			Main.tile[i + 1, j - 2].type = 128;
			Main.tile[i + 1, j - 1].active(active: true);
			Main.tile[i + 1, j - 1].frameY = 18;
			Main.tile[i + 1, j - 1].frameX = (byte)(18 + b);
			Main.tile[i + 1, j - 1].type = 128;
			Main.tile[i + 1, j].active(active: true);
			Main.tile[i + 1, j].frameY = 36;
			Main.tile[i + 1, j].frameX = (byte)(18 + b);
			Main.tile[i + 1, j].type = 128;
		}
	}

	public static void PlaceWoman(int i, int j, int dir)
	{
		for (int k = i; k <= i + 1; k++)
		{
			for (int l = j - 2; l <= j; l++)
			{
				if (Main.tile[k, l].active())
				{
					return;
				}
			}
		}
		if (SolidTile2(i, j + 1) && SolidTile2(i + 1, j + 1))
		{
			byte b = 0;
			if (dir == 1)
			{
				b = 36;
			}
			Main.tile[i, j - 2].active(active: true);
			Main.tile[i, j - 2].frameY = 0;
			Main.tile[i, j - 2].frameX = b;
			Main.tile[i, j - 2].type = 269;
			Main.tile[i, j - 1].active(active: true);
			Main.tile[i, j - 1].frameY = 18;
			Main.tile[i, j - 1].frameX = b;
			Main.tile[i, j - 1].type = 269;
			Main.tile[i, j].active(active: true);
			Main.tile[i, j].frameY = 36;
			Main.tile[i, j].frameX = b;
			Main.tile[i, j].type = 269;
			Main.tile[i + 1, j - 2].active(active: true);
			Main.tile[i + 1, j - 2].frameY = 0;
			Main.tile[i + 1, j - 2].frameX = (byte)(18 + b);
			Main.tile[i + 1, j - 2].type = 269;
			Main.tile[i + 1, j - 1].active(active: true);
			Main.tile[i + 1, j - 1].frameY = 18;
			Main.tile[i + 1, j - 1].frameX = (byte)(18 + b);
			Main.tile[i + 1, j - 1].type = 269;
			Main.tile[i + 1, j].active(active: true);
			Main.tile[i + 1, j].frameY = 36;
			Main.tile[i + 1, j].frameX = (byte)(18 + b);
			Main.tile[i + 1, j].type = 269;
		}
	}

	public static void CheckWeaponsRack(int i, int j)
	{
		if (destroyObject)
		{
			return;
		}
		int num = i;
		int num4 = j - Main.tile[i, j].frameY / 18;
		int num5 = Main.tile[i, j].frameX;
		int num6 = 0;
		while (num5 >= 5000)
		{
			num5 -= 5000;
			num6++;
		}
		if (num6 != 0)
		{
			num5 = (num6 - 1) * 18;
		}
		num5 %= 54;
		num -= num5 / 18;
		bool flag = false;
		for (int k = 0; k < 3; k++)
		{
			for (int l = 0; l < 3; l++)
			{
				int num7 = num + k;
				int num8 = num4 + l;
				int num9 = Main.tile[num7, num8].frameX;
				int num10 = 0;
				while (num9 >= 5000)
				{
					num9 -= 5000;
					num10++;
				}
				if (num10 != 0)
				{
					num9 = (num10 - 1) * 18;
				}
				num9 %= 54;
				if (!Main.tile[num7, num8].active() || Main.tile[num7, num8].type != 334 || Main.tile[num7, num8].wall <= 0 || Main.tile[num7, num8].frameY != l * 18 || num9 != k * 18)
				{
					flag = true;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		int num11 = TEWeaponsRack.Find(num, num4);
		if (num11 != -1 && ((TEWeaponsRack)TileEntity.ByID[num11]).item.stack > 0)
		{
			((TEWeaponsRack)TileEntity.ByID[num11]).DropItem();
			if (Main.netMode != 2)
			{
				Main.LocalPlayer.InterruptItemUsageIfOverTile(471);
			}
		}
		destroyObject = true;
		using (new Item.DisableNewItemMethod(!TileLoader.Drop(i, j, Main.tile[i, j].type)))
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 48, 48, 2699);
			TEWeaponsRack.Kill(num, num4);
			for (int m = 0; m < 3; m++)
			{
				for (int n = 0; n < 3; n++)
				{
					int num2 = num + m;
					int num3 = num4 + n;
					if (Main.tile[num2, num3].active() && Main.tile[num2, num3].type == 334)
					{
						KillTile(num2, num3);
					}
				}
			}
			destroyObject = false;
		}
	}

	public static void ToggleGemLock(int i, int j, bool on)
	{
		Tile tileSafely = Framing.GetTileSafely(i, j);
		if (!tileSafely.active() || tileSafely.type != 440 || (tileSafely.frameY < 54 && !on))
		{
			return;
		}
		bool flag = false;
		int num = -1;
		if (tileSafely.frameY >= 54)
		{
			flag = true;
		}
		Tile tile = Main.tile[i, j];
		int num2 = tile.frameX / 54;
		tile = Main.tile[i, j];
		int num3 = tile.frameX % 54 / 18;
		tile = Main.tile[i, j];
		int num4 = tile.frameY % 54 / 18;
		switch (num2)
		{
		case 0:
			num = 1526;
			break;
		case 1:
			num = 1524;
			break;
		case 2:
			num = 1525;
			break;
		case 3:
			num = 1523;
			break;
		case 4:
			num = 1522;
			break;
		case 5:
			num = 1527;
			break;
		case 6:
			num = 3643;
			break;
		}
		for (int k = i - num3; k < i - num3 + 3; k++)
		{
			for (int l = j - num4; l < j - num4 + 3; l++)
			{
				tile = Main.tile[k, l];
				tile.frameY = (short)((on ? 54 : 0) + (l - j + num4) * 18);
			}
		}
		if (num != -1 && flag)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, num);
		}
		SquareTileFrame(i, j);
		NetMessage.SendTileSquare(-1, i - num3, j - num4, 3, 3);
		Wiring.HitSwitch(i - num3, j - num4);
		NetMessage.SendData(59, -1, -1, null, i - num3, j - num4);
	}

	public static void CheckMan(int i, int j)
	{
		if (destroyObject)
		{
			return;
		}
		int num = i;
		int num2 = j - Main.tile[i, j].frameY / 18;
		int num3;
		for (num3 = Main.tile[i, j].frameX; num3 >= 100; num3 -= 100)
		{
		}
		while (num3 >= 36)
		{
			num3 -= 36;
		}
		num -= num3 / 18;
		bool flag = false;
		for (int k = 0; k <= 1; k++)
		{
			for (int l = 0; l <= 2; l++)
			{
				int num4 = num + k;
				int num5 = num2 + l;
				int num6;
				for (num6 = Main.tile[num4, num5].frameX; num6 >= 100; num6 -= 100)
				{
				}
				if (num6 >= 36)
				{
					num6 -= 36;
				}
				if (!Main.tile[num4, num5].active() || Main.tile[num4, num5].type != 128 || Main.tile[num4, num5].frameY != l * 18 || num6 != k * 18)
				{
					flag = true;
				}
			}
		}
		if (!SolidTileAllowBottomSlope(num, num2 + 3) || !SolidTileAllowBottomSlope(num + 1, num2 + 3))
		{
			flag = true;
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		using (new Item.DisableNewItemMethod(!TileLoader.Drop(i, j, Main.tile[i, j].type)))
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 498);
			for (int m = 0; m <= 1; m++)
			{
				for (int n = 0; n <= 2; n++)
				{
					int num7 = num + m;
					int num8 = num2 + n;
					if (Main.tile[num7, num8].active() && Main.tile[num7, num8].type == 128)
					{
						KillTile(num7, num8);
					}
				}
			}
			destroyObject = false;
		}
	}

	public static void CheckWoman(int i, int j)
	{
		if (destroyObject)
		{
			return;
		}
		int num = i;
		int num2 = j - Main.tile[i, j].frameY / 18;
		int num3;
		for (num3 = Main.tile[i, j].frameX; num3 >= 100; num3 -= 100)
		{
		}
		while (num3 >= 36)
		{
			num3 -= 36;
		}
		num -= num3 / 18;
		bool flag = false;
		for (int k = 0; k <= 1; k++)
		{
			for (int l = 0; l <= 2; l++)
			{
				int num4 = num + k;
				int num5 = num2 + l;
				int num6;
				for (num6 = Main.tile[num4, num5].frameX; num6 >= 100; num6 -= 100)
				{
				}
				if (num6 >= 36)
				{
					num6 -= 36;
				}
				if (!Main.tile[num4, num5].active() || Main.tile[num4, num5].type != 269 || Main.tile[num4, num5].frameY != l * 18 || num6 != k * 18)
				{
					flag = true;
				}
			}
		}
		if (!SolidTileAllowBottomSlope(num, num2 + 3) || !SolidTileAllowBottomSlope(num + 1, num2 + 3))
		{
			flag = true;
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		using (new Item.DisableNewItemMethod(!TileLoader.Drop(i, j, Main.tile[i, j].type)))
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1989);
			for (int m = 0; m <= 1; m++)
			{
				for (int n = 0; n <= 2; n++)
				{
					int num7 = num + m;
					int num8 = num2 + n;
					if (Main.tile[num7, num8].active() && Main.tile[num7, num8].type == 269)
					{
						KillTile(num7, num8);
					}
				}
			}
			destroyObject = false;
		}
	}

	public static void Place1x2(int x, int y, ushort type, int style)
	{
		short frameX = 0;
		if (TileID.Sets.TreeSapling[type])
		{
			frameX = (short)(genRand.Next(3) * 18);
		}
		if (Main.tile[x, y - 1] == null)
		{
			Main.tile[x, y - 1] = default(Tile);
		}
		if (Main.tile[x, y + 1] == null)
		{
			Main.tile[x, y + 1] = default(Tile);
		}
		if (SolidTile2(x, y + 1) & !Main.tile[x, y - 1].active())
		{
			short num = (short)(style * 40);
			Main.tile[x, y - 1].active(active: true);
			Main.tile[x, y - 1].frameY = num;
			Main.tile[x, y - 1].frameX = frameX;
			Main.tile[x, y - 1].type = type;
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = (short)(num + 18);
			Main.tile[x, y].frameX = frameX;
			Main.tile[x, y].type = type;
		}
	}

	public static void Place1x2Top(int x, int y, ushort type, int style)
	{
		short frameX = 0;
		if (Main.tile[x, y - 1] == null)
		{
			Main.tile[x, y - 1] = default(Tile);
		}
		if (Main.tile[x, y + 1] == null)
		{
			Main.tile[x, y + 1] = default(Tile);
		}
		if (Main.tile[x, y - 1].nactive() && Main.tileSolid[Main.tile[x, y - 1].type] && !Main.tileSolidTop[Main.tile[x, y - 1].type] && !Main.tile[x, y + 1].active())
		{
			short num = (short)(style * 36);
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = num;
			Main.tile[x, y].frameX = frameX;
			Main.tile[x, y].type = type;
			Main.tile[x, y + 1].active(active: true);
			Main.tile[x, y + 1].frameY = (short)(num + 18);
			Main.tile[x, y + 1].frameX = frameX;
			Main.tile[x, y + 1].type = type;
		}
	}

	public static void Check1x2Top(int x, int j, ushort type)
	{
		if (destroyObject)
		{
			return;
		}
		int num = j;
		bool flag = true;
		int num2 = Main.tile[x, num].frameY / 18;
		int num3 = 0;
		while (num2 >= 2)
		{
			num2 -= 2;
			num3++;
		}
		num -= num2;
		num2 = num3 * 36;
		if (Main.tile[x, num] == null)
		{
			Main.tile[x, num] = default(Tile);
		}
		if (Main.tile[x, num + 1] == null)
		{
			Main.tile[x, num + 1] = default(Tile);
		}
		if (Main.tile[x, num] == null)
		{
			Main.tile[x, num] = default(Tile);
		}
		if (Main.tile[x, num].frameY == num2 && Main.tile[x, num + 1].frameY == num2 + 18 && Main.tile[x, num].type == type && Main.tile[x, num + 1].type == type)
		{
			flag = false;
		}
		if (Main.tile[x, num - 1] == null)
		{
			Main.tile[x, num - 1] = default(Tile);
		}
		bool flag2 = false;
		switch (type)
		{
		case 42:
		case 270:
		case 271:
		case 572:
		case 581:
		case 660:
			flag2 = true;
			break;
		}
		bool flag3 = Main.tile[x, num - 1].active() && (TileID.Sets.Platforms[Main.tile[x, num - 1].type] || Main.tile[x, num - 1].type == 380);
		if ((!flag2 || !flag3) && (!Main.tile[x, num - 1].nactive() || !Main.tileSolid[Main.tile[x, num - 1].type] || Main.tileSolidTop[Main.tile[x, num - 1].type]))
		{
			flag = true;
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(x, j, type);
		if (Main.tile[x, num].type == type)
		{
			KillTile(x, num);
		}
		if (Main.tile[x, num + 1].type == type)
		{
			KillTile(x, num + 1);
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			switch (type)
			{
			case 42:
			{
				int type2 = 0;
				if (num3 == 0)
				{
					type2 = 136;
				}
				else if (num3 == 7)
				{
					type2 = 1431;
				}
				else if (num3 == 8)
				{
					type2 = 1808;
				}
				else if (num3 == 9)
				{
					type2 = 1859;
				}
				else if (num3 < 10)
				{
					type2 = 1389 + num3;
				}
				else
				{
					switch (num3)
					{
					case 10:
						type2 = 2032;
						break;
					case 11:
						type2 = 2033;
						break;
					case 12:
						type2 = 2034;
						break;
					case 13:
						type2 = 2035;
						break;
					case 14:
						type2 = 2036;
						break;
					case 15:
						type2 = 2037;
						break;
					case 16:
						type2 = 2038;
						break;
					case 17:
						type2 = 2039;
						break;
					case 18:
						type2 = 2040;
						break;
					case 19:
						type2 = 2041;
						break;
					case 20:
						type2 = 2042;
						break;
					case 21:
						type2 = 2043;
						break;
					case 22:
					case 23:
					case 24:
					case 25:
						type2 = 2145 + num3 - 22;
						break;
					case 26:
						type2 = 2226;
						break;
					case 27:
						type2 = 2530;
						break;
					case 28:
						type2 = 2546;
						break;
					case 29:
						type2 = 2564;
						break;
					case 30:
						type2 = 2579;
						break;
					case 31:
						type2 = 2641;
						break;
					case 32:
						type2 = 2642;
						break;
					case 33:
						type2 = 2820;
						break;
					case 34:
						type2 = 3138;
						break;
					case 35:
						type2 = 3140;
						break;
					case 36:
						type2 = 3139;
						break;
					case 37:
						type2 = 3891;
						break;
					case 38:
						type2 = 3943;
						break;
					case 39:
						type2 = 3970;
						break;
					case 40:
						type2 = 4157;
						break;
					case 41:
						type2 = 4178;
						break;
					case 42:
						type2 = 4199;
						break;
					case 43:
						type2 = 4220;
						break;
					case 44:
						type2 = 4309;
						break;
					case 45:
						type2 = 4578;
						break;
					case 46:
						type2 = 5160;
						break;
					case 47:
						type2 = 5181;
						break;
					case 48:
						type2 = 5202;
						break;
					}
				}
				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, type2);
				break;
			}
			case 270:
				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 1993);
				break;
			case 271:
				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 2005);
				break;
			case 581:
				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 4848);
				break;
			case 660:
				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 5351);
				break;
			case 572:
				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 4695 + num3);
				break;
			}
			destroyObject = false;
		}
	}

	public static bool PlaceSmallPile(int i, int j, int X, int Y, ushort type = 185)
	{
		short frameY = (short)(Y * 18);
		short frameX = (short)(X * 18);
		if (Main.tile[i, j] == null)
		{
			Main.tile[i, j] = default(Tile);
		}
		if (Main.tile[i + 1, j] == null)
		{
			Main.tile[i + 1, j] = default(Tile);
		}
		if (Main.tile[i, j + 1] == null)
		{
			Main.tile[i, j + 1] = default(Tile);
		}
		if (Main.tile[i + 1, j + 1] == null)
		{
			Main.tile[i + 1, j + 1] = default(Tile);
		}
		if (Main.tile[i, j].lava())
		{
			return false;
		}
		if (Y == 1)
		{
			frameX = (short)(X * 36);
			bool flag = false;
			if (SolidTile2(i, j + 1) && SolidTile2(i + 1, j + 1) && !Main.tile[i, j].active() && !Main.tile[i + 1, j].active())
			{
				flag = true;
			}
			if (flag)
			{
				Main.tile[i, j].active(active: true);
				Main.tile[i, j].frameY = frameY;
				Main.tile[i, j].frameX = frameX;
				Main.tile[i, j].type = type;
				Main.tile[i + 1, j].active(active: true);
				Main.tile[i + 1, j].frameY = frameY;
				Main.tile[i + 1, j].frameX = (short)(frameX + 18);
				Main.tile[i + 1, j].type = type;
				return true;
			}
		}
		else if (SolidTile2(i, j + 1) && !Main.tile[i, j].active())
		{
			Main.tile[i, j].active(active: true);
			Main.tile[i, j].frameY = frameY;
			Main.tile[i, j].frameX = frameX;
			Main.tile[i, j].type = type;
			return true;
		}
		return false;
	}

	public static void CheckPile(int i, int y)
	{
		if (Main.tile[i, y] == null)
		{
			Main.tile[i, y] = default(Tile);
		}
		if (Main.tile[i + 1, y] == null)
		{
			Main.tile[i + 1, y] = default(Tile);
		}
		if (Main.tile[i, y + 1] == null)
		{
			Main.tile[i, y + 1] = default(Tile);
		}
		if (Main.tile[i + 1, y + 1] == null)
		{
			Main.tile[i + 1, y + 1] = default(Tile);
		}
		Tile tile = Main.tile[i, y];
		if (tile.frameY == 18 || tile.type == 649)
		{
			Check2x1(i, y, tile.type);
		}
		else if (!SolidTileAllowBottomSlope(i, y + 1))
		{
			KillTile(i, y);
		}
		else
		{
			if (tile.type != 185)
			{
				return;
			}
			int num = tile.frameX / 18;
			Tile tile2 = Main.tile[i, y + 1];
			if (tile2 == null || !tile2.active() || tile2.type < 0)
			{
				return;
			}
			ushort type = tile2.type;
			switch (num)
			{
			case 36:
			case 37:
			case 38:
			case 39:
			case 40:
			case 41:
			case 42:
			case 43:
			case 44:
			case 45:
			case 46:
			case 47:
				if (!TileID.Sets.Snow[type] && !TileID.Sets.Conversion.Ice[type] && type != 162 && type != 224)
				{
					KillTile(i, y);
				}
				break;
			case 54:
			case 55:
			case 56:
			case 57:
			case 58:
			case 59:
			case 73:
			case 74:
			case 75:
			case 76:
				if (!TileID.Sets.Conversion.Sand[type] && !TileID.Sets.Conversion.HardenedSand[type] && !TileID.Sets.Conversion.Sandstone[type])
				{
					KillTile(i, y);
				}
				break;
			case 48:
			case 49:
			case 50:
			case 51:
			case 52:
			case 53:
			case 60:
			case 61:
			case 62:
			case 63:
			case 64:
			case 65:
			case 66:
			case 67:
			case 68:
			case 69:
			case 70:
			case 71:
			case 72:
				break;
			}
		}
	}

	public static void Check2x1(int i, int y, ushort type)
	{
		if (destroyObject)
		{
			return;
		}
		int num = i;
		bool flag = true;
		Tile tile4;
		if (Main.tile[num, y] == null)
		{
			tile4 = (Main.tile[num, y] = default(Tile));
		}
		tile4 = Main.tile[num, y];
		int num2 = tile4.frameX / 18;
		int num3 = num2 >> 1;
		tile4 = Main.tile[num, y];
		int num4 = tile4.frameY / 18;
		num2 %= 2;
		num -= num2;
		if (Main.tile[num, y] == null)
		{
			tile4 = (Main.tile[num, y] = default(Tile));
		}
		if (Main.tile[num + 1, y] == null)
		{
			tile4 = (Main.tile[num + 1, y] = default(Tile));
		}
		if (Main.tile[num, y + 1] == null)
		{
			tile4 = (Main.tile[num, y + 1] = default(Tile));
		}
		if (Main.tile[num + 1, y + 1] == null)
		{
			tile4 = (Main.tile[num + 1, y + 1] = default(Tile));
		}
		tile4 = Main.tile[num + 1, y];
		short frameX2 = tile4.frameX;
		tile4 = Main.tile[num, y];
		if (frameX2 == tile4.frameX + 18)
		{
			tile4 = Main.tile[num, y];
			if (tile4.type == type)
			{
				tile4 = Main.tile[num + 1, y];
				if (tile4.type == type)
				{
					flag = false;
				}
			}
		}
		if (type == 29 || type == 103 || type == 462)
		{
			tile4 = Main.tile[num, y + 1];
			if (tile4.active())
			{
				bool[] tileTable = Main.tileTable;
				tile4 = Main.tile[num, y + 1];
				if (tileTable[tile4.type])
				{
					tile4 = Main.tile[num, y + 1];
					if (!tile4.halfBrick())
					{
						tile4 = Main.tile[num, y + 1];
						if (!tile4.topSlope())
						{
							goto IL_021a;
						}
					}
				}
			}
			flag = true;
			goto IL_021a;
		}
		if (!SolidTileAllowBottomSlope(num, y + 1))
		{
			flag = true;
		}
		if (!SolidTileAllowBottomSlope(num + 1, y + 1))
		{
			flag = true;
		}
		goto IL_02ad;
		IL_021a:
		tile4 = Main.tile[num + 1, y + 1];
		if (tile4.active())
		{
			bool[] tileTable2 = Main.tileTable;
			tile4 = Main.tile[num + 1, y + 1];
			if (tileTable2[tile4.type])
			{
				tile4 = Main.tile[num + 1, y + 1];
				if (!tile4.halfBrick())
				{
					tile4 = Main.tile[num + 1, y + 1];
					if (!tile4.topSlope())
					{
						goto IL_02ad;
					}
				}
			}
		}
		flag = true;
		goto IL_02ad;
		IL_02ad:
		if (type == 185)
		{
			tile4 = Main.tile[num, y];
			if (tile4.frameX >= 1368)
			{
				tile4 = Main.tile[num, y];
				if (tile4.frameX <= 1458)
				{
					tile4 = Main.tile[num, y + 1];
					if (tile4.type != 2)
					{
						tile4 = Main.tile[num + 1, y + 1];
						if (tile4.type != 2)
						{
							tile4 = Main.tile[num, y + 1];
							if (tile4.type != 477)
							{
								tile4 = Main.tile[num + 1, y + 1];
								if (tile4.type != 477)
								{
									tile4 = Main.tile[num, y + 1];
									if (tile4.type != 492)
									{
										tile4 = Main.tile[num + 1, y + 1];
										if (tile4.type != 492)
										{
											tile4 = Main.tile[num, y];
											tile4.frameX -= 1368;
											tile4 = Main.tile[num + 1, y];
											tile4.frameX -= 1368;
										}
									}
								}
							}
						}
					}
				}
			}
			Tile tile = Main.tile[num, y];
			int num5 = tile.frameX / 36;
			num5 += (tile.frameY / 18 - 1) * 52;
			for (int j = num; j < num + 2; j++)
			{
				Tile tile2 = Main.tile[j, y + 1];
				if (tile2 == null || !tile2.active() || tile2.type < 0)
				{
					continue;
				}
				ushort type2 = tile2.type;
				switch (num5)
				{
				case 25:
				case 26:
				case 27:
				case 28:
				case 29:
				case 30:
					if (!TileID.Sets.Snow[type2] && !TileID.Sets.Conversion.Ice[type2] && type2 != 162 && type2 != 224)
					{
						flag = true;
					}
					break;
				case 41:
				case 42:
				case 43:
				case 44:
				case 45:
				case 46:
				case 62:
				case 63:
				case 64:
					if (!TileID.Sets.Conversion.Sand[type2] && !TileID.Sets.Conversion.HardenedSand[type2] && !TileID.Sets.Conversion.Sandstone[type2])
					{
						flag = true;
					}
					break;
				}
			}
		}
		if (!flag)
		{
			return;
		}
		tile4 = Main.tile[num, y];
		int frameX = tile4.frameX;
		tile4 = Main.tile[num, y];
		if (!tile4.active())
		{
			tile4 = Main.tile[num + 1, y];
			frameX = tile4.frameX;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(i, y, type);
		tile4 = Main.tile[num, y];
		if (tile4.type == type)
		{
			KillTile(num, y);
		}
		tile4 = Main.tile[num + 1, y];
		if (tile4.type == type)
		{
			KillTile(num + 1, y);
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			if (type == 16)
			{
				if (num3 == 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 716);
				}
				else
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 35);
				}
			}
			if (type == 18)
			{
				int type3 = 36;
				if (num3 >= 1 && num3 <= 3)
				{
					type3 = 634 + num3;
				}
				else if (num3 >= 4 && num3 <= 8)
				{
					type3 = 807 + num3;
				}
				else
				{
					switch (num3)
					{
					case 9:
						type3 = 916;
						break;
					case 10:
						type3 = 1145;
						break;
					case 11:
						type3 = 1398;
						break;
					case 12:
						type3 = 1401;
						break;
					case 13:
						type3 = 1404;
						break;
					case 14:
						type3 = 1461;
						break;
					case 15:
						type3 = 1511;
						break;
					case 16:
						type3 = 1795;
						break;
					case 17:
						type3 = 1817;
						break;
					case 18:
						type3 = 2229;
						break;
					case 19:
						type3 = 2251;
						break;
					case 20:
						type3 = 2252;
						break;
					case 21:
						type3 = 2253;
						break;
					case 22:
						type3 = 2534;
						break;
					case 23:
						type3 = 673;
						break;
					case 24:
						type3 = 2631;
						break;
					case 25:
						type3 = 2632;
						break;
					case 26:
						type3 = 2633;
						break;
					case 27:
						type3 = 2826;
						break;
					case 28:
						type3 = 3156;
						break;
					case 29:
						type3 = 3158;
						break;
					case 30:
						type3 = 3157;
						break;
					case 31:
						type3 = 3909;
						break;
					case 32:
						type3 = 3910;
						break;
					case 33:
						type3 = 3949;
						break;
					case 34:
						type3 = 3975;
						break;
					case 35:
						type3 = 4163;
						break;
					case 36:
						type3 = 4184;
						break;
					case 37:
						type3 = 4205;
						break;
					case 38:
						type3 = 4226;
						break;
					case 39:
						type3 = 4315;
						break;
					case 40:
						type3 = 4584;
						break;
					case 41:
						type3 = 5166;
						break;
					case 42:
						type3 = 5187;
						break;
					case 43:
						type3 = 5208;
						break;
					}
				}
				Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, type3);
			}
			if (type == 185)
			{
				if (frameX >= 576 && frameX <= 610)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
					if (genRand.Next(3) != 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
					}
					if (genRand.Next(3) != 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
					}
					if (genRand.Next(2) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
					}
					if (genRand.Next(2) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
					}
					if (genRand.Next(3) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
					}
					if (genRand.Next(3) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
					}
					if (genRand.Next(4) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
					}
					if (genRand.Next(4) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
					}
					if (genRand.Next(5) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
					}
					if (genRand.Next(5) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
					}
				}
				if (frameX >= 612 && frameX <= 646)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 72, genRand.Next(10, 100));
					if (genRand.Next(2) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 72, genRand.Next(20, 100));
					}
					if (genRand.Next(3) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 72, genRand.Next(30, 100));
					}
				}
				if (frameX >= 648 && frameX <= 682)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 73, genRand.Next(1, 6));
					if (genRand.Next(2) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 73, genRand.Next(2, 6));
					}
					if (genRand.Next(3) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 73, genRand.Next(3, 6));
					}
				}
				if (frameX >= 684 && frameX <= 718)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 181, genRand.Next(1, 4));
				}
				if (frameX >= 720 && frameX <= 754)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 180, genRand.Next(1, 4));
				}
				if (frameX >= 756 && frameX <= 790)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 177, genRand.Next(1, 4));
				}
				if (frameX >= 792 && frameX <= 826)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 179, genRand.Next(1, 4));
				}
				if (frameX >= 828 && frameX <= 862)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 178, genRand.Next(1, 4));
				}
				if (frameX >= 864 && frameX <= 898)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 182, genRand.Next(1, 4));
				}
			}
			if (type == 462)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 3795);
			}
			if (type == 29)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 87);
				SoundEngine.PlaySound(13, i * 16, y * 16);
			}
			switch (type)
			{
			case 103:
			{
				int type4 = 356;
				if (num3 == 1)
				{
					type4 = 2235;
				}
				if (num3 == 2)
				{
					type4 = 2242;
				}
				if (num3 == 3)
				{
					type4 = 2243;
				}
				Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, type4);
				SoundEngine.PlaySound(13, i * 16, y * 16);
				break;
			}
			case 134:
				if (num3 == 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 1220);
				}
				else
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 525);
				}
				break;
			case 649:
			{
				num3 += num4 * 53;
				int num6 = 0;
				if (num3 < 6)
				{
					num6 = 3;
				}
				else if (num3 < 16)
				{
					num6 = 154;
				}
				else if (num3 < 17)
				{
					num6 = 71;
				}
				else if (num3 < 18)
				{
					num6 = 72;
				}
				else if (num3 < 19)
				{
					num6 = 73;
				}
				else if (num3 < 20)
				{
					num6 = 181;
				}
				else if (num3 < 21)
				{
					num6 = 180;
				}
				else if (num3 < 22)
				{
					num6 = 177;
				}
				else if (num3 < 23)
				{
					num6 = 179;
				}
				else if (num3 < 24)
				{
					num6 = 178;
				}
				else if (num3 < 25)
				{
					num6 = 182;
				}
				else if (num3 < 31)
				{
					num6 = 593;
				}
				else if (num3 < 34)
				{
					num6 = 9;
				}
				else if (num3 < 38)
				{
					num6 = 150;
				}
				else if (num3 < 41)
				{
					num6 = 3;
				}
				else if (num3 < 47)
				{
					num6 = 3271;
				}
				else if (num3 < 53)
				{
					num6 = 3086;
				}
				else if (num3 < 59)
				{
					num6 = 3081;
				}
				else if (num3 < 62)
				{
					num6 = 62;
				}
				else if (num3 < 65)
				{
					num6 = 169;
				}
				if (num6 != 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, num6);
				}
				break;
			}
			}
			destroyObject = false;
			SquareTileFrame(num, y);
			SquareTileFrame(num + 1, y);
		}
	}

	public static void Place2x1(int x, int y, ushort type, int style = 0)
	{
		if (Main.tile[x, y] == null)
		{
			Main.tile[x, y] = default(Tile);
		}
		if (Main.tile[x + 1, y] == null)
		{
			Main.tile[x + 1, y] = default(Tile);
		}
		if (Main.tile[x, y + 1] == null)
		{
			Main.tile[x, y + 1] = default(Tile);
		}
		if (Main.tile[x + 1, y + 1] == null)
		{
			Main.tile[x + 1, y + 1] = default(Tile);
		}
		bool flag = false;
		if (type != 29 && type != 103 && SolidTile2(x, y + 1) && SolidTile2(x + 1, y + 1) && !Main.tile[x, y].active() && !Main.tile[x + 1, y].active())
		{
			flag = true;
		}
		else if ((type == 29 || type == 103) && Main.tile[x, y + 1].active() && Main.tile[x + 1, y + 1].active() && Main.tileTable[Main.tile[x, y + 1].type] && Main.tileTable[Main.tile[x + 1, y + 1].type] && !Main.tile[x, y].active() && !Main.tile[x + 1, y].active())
		{
			flag = true;
		}
		if (flag)
		{
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = 0;
			Main.tile[x, y].frameX = (short)(36 * style);
			Main.tile[x, y].type = type;
			Main.tile[x + 1, y].active(active: true);
			Main.tile[x + 1, y].frameY = 0;
			Main.tile[x + 1, y].frameX = (short)(36 * style + 18);
			Main.tile[x + 1, y].type = type;
		}
	}

	public static void Check4x2(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = i;
		num = ((type != 487) ? (num + Main.tile[i, j].frameX / 18 * -1) : (num + Main.tile[i, j].frameX / 18 % 4 * -1));
		if ((type == 79 || type == 90) && Main.tile[i, j].frameX >= 72)
		{
			num += 4;
		}
		int num2 = Main.tile[i, j].frameY / 18;
		int num3 = 0;
		while (num2 > 1)
		{
			num2 -= 2;
			num3++;
		}
		num2 = j - num2;
		if (type == 487)
		{
			num3 = Main.tile[i, j].frameX / 72;
		}
		for (int k = num; k < num + 4; k++)
		{
			for (int l = num2; l < num2 + 2; l++)
			{
				int num4 = (k - num) * 18;
				int num5 = (l - num2) * 18;
				if ((type == 79 || type == 90) && Main.tile[i, j].frameX >= 72)
				{
					num4 = (k - num + 4) * 18;
				}
				if (type == 487)
				{
					num4 += num3 * 72;
				}
				else
				{
					num5 += num3 * 36;
				}
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = default(Tile);
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num4 || Main.tile[k, l].frameY != num5)
				{
					flag = true;
				}
			}
			if (Main.tile[k, num2 + 2] == null)
			{
				Main.tile[k, num2 + 2] = default(Tile);
			}
			if (!SolidTileAllowBottomSlope(k, num2 + 2) && (!Main.tile[k, num2 + 2].active() || !TileID.Sets.Platforms[Main.tile[k, num2 + 2].type]))
			{
				flag = true;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(i, j, type);
		for (int m = num; m < num + 4; m++)
		{
			for (int n = num2; n < num2 + 3; n++)
			{
				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
				{
					KillTile(m, n);
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			if (type == 79)
			{
				int num6 = 0;
				switch (num3)
				{
				case 0:
					num6 = 224;
					break;
				case 4:
					num6 = 920;
					break;
				case 9:
				case 10:
				case 11:
				case 12:
					num6 = 1710 + num3;
					break;
				case 5:
				case 6:
				case 7:
				case 8:
					num6 = 1465 + num3;
					break;
				default:
					num6 = ((num3 >= 13 && num3 <= 18) ? (2066 + num3 - 13) : (num3 switch
					{
						19 => 2139, 
						20 => 2140, 
						21 => 2231, 
						22 => 2520, 
						23 => 2538, 
						24 => 2553, 
						25 => 2568, 
						26 => 2669, 
						27 => 2811, 
						28 => 3162, 
						29 => 3164, 
						30 => 3163, 
						31 => 3897, 
						32 => 3932, 
						33 => 3959, 
						34 => 4146, 
						35 => 4167, 
						36 => 4188, 
						37 => 4209, 
						38 => 4299, 
						39 => 4567, 
						40 => 5149, 
						41 => 5170, 
						42 => 5191, 
						_ => num3 + 643, 
					}));
					break;
				}
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, num6);
			}
			if (type == 487)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, GetItemDrop_PicnicTables(num3));
			}
			if (type == 90)
			{
				int type2 = 0;
				switch (num3)
				{
				case 0:
					type2 = 336;
					break;
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7:
				case 8:
				case 9:
				case 10:
					type2 = 2072 + num3 - 1;
					break;
				case 11:
				case 12:
				case 13:
				case 14:
				case 15:
					type2 = 2124 + num3 - 11;
					break;
				default:
					switch (num3)
					{
					case 16:
						type2 = 2232;
						break;
					case 17:
						type2 = 2519;
						break;
					case 18:
						type2 = 2537;
						break;
					case 19:
						type2 = 2552;
						break;
					case 20:
						type2 = 2567;
						break;
					case 21:
						type2 = 2658;
						break;
					case 22:
						type2 = 2659;
						break;
					case 23:
						type2 = 2660;
						break;
					case 24:
						type2 = 2661;
						break;
					case 25:
						type2 = 2662;
						break;
					case 26:
						type2 = 2663;
						break;
					case 27:
						type2 = 2810;
						break;
					case 28:
						type2 = 3159;
						break;
					case 29:
						type2 = 3161;
						break;
					case 30:
						type2 = 3160;
						break;
					case 31:
						type2 = 3895;
						break;
					case 32:
						type2 = 3931;
						break;
					case 33:
						type2 = 3958;
						break;
					case 34:
						type2 = 4145;
						break;
					case 35:
						type2 = 4166;
						break;
					case 36:
						type2 = 4187;
						break;
					case 37:
						type2 = 4208;
						break;
					case 38:
						type2 = 4298;
						break;
					case 39:
						type2 = 4566;
						break;
					case 40:
						type2 = 5148;
						break;
					case 41:
						type2 = 5169;
						break;
					case 42:
						type2 = 5190;
						break;
					}
					break;
				}
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type2);
			}
			destroyObject = false;
			for (int num7 = num - 1; num7 < num + 4; num7++)
			{
				for (int num8 = num2 - 1; num8 < num2 + 4; num8++)
				{
					TileFrame(num7, num8);
				}
			}
		}
	}

	private static bool OasisPlantWaterCheck(int x, int y, bool boost = false)
	{
		int num = 45;
		int num2 = 20;
		if (boost)
		{
			num += 4;
			num2 += 3;
		}
		int num3 = 20;
		int num4 = 0;
		for (int i = x - num; i <= x + num; i++)
		{
			if (x <= beachDistance || x >= Main.maxTilesX - beachDistance)
			{
				continue;
			}
			for (int j = y - num2; j <= y + num2; j++)
			{
				if (InWorld(i, j) && !SolidTile(i, j))
				{
					num4 += Main.tile[i, j].liquid;
				}
			}
		}
		if (num4 / 255 >= num3)
		{
			return true;
		}
		return false;
	}

	public static void PlaceOasisPlant(int X, int Y, ushort type = 530)
	{
		int num = genRand.Next(9);
		int num2 = 0;
		if (X < beachDistance || X > Main.maxTilesX - beachDistance || Y < 5 || Y > Main.maxTilesY - 5)
		{
			return;
		}
		bool flag = true;
		for (int i = X - 1; i < X + 2; i++)
		{
			for (int j = Y - 1; j < Y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = default(Tile);
				}
				if (Main.tile[i, j].active() && Main.tile[i, j].type != 529)
				{
					flag = false;
				}
				if (Main.tile[i, j].liquid > 0)
				{
					flag = false;
				}
			}
			if (Main.tile[i, Y + 1] == null)
			{
				Main.tile[i, Y + 1] = default(Tile);
			}
			if (!SolidTile(i, Y + 1) || !TileID.Sets.Conversion.Sand[Main.tile[i, Y + 1].type])
			{
				flag = false;
			}
		}
		if (flag && OasisPlantWaterCheck(X, Y))
		{
			short num3 = (short)(54 * num);
			short num4 = (short)(36 * num2);
			Main.tile[X - 1, Y - 1].active(active: true);
			Main.tile[X - 1, Y - 1].frameY = num4;
			Main.tile[X - 1, Y - 1].frameX = num3;
			Main.tile[X - 1, Y - 1].type = type;
			Main.tile[X, Y - 1].active(active: true);
			Main.tile[X, Y - 1].frameY = num4;
			Main.tile[X, Y - 1].frameX = (short)(num3 + 18);
			Main.tile[X, Y - 1].type = type;
			Main.tile[X + 1, Y - 1].active(active: true);
			Main.tile[X + 1, Y - 1].frameY = num4;
			Main.tile[X + 1, Y - 1].frameX = (short)(num3 + 36);
			Main.tile[X + 1, Y - 1].type = type;
			Main.tile[X - 1, Y].active(active: true);
			Main.tile[X - 1, Y].frameY = (short)(num4 + 18);
			Main.tile[X - 1, Y].frameX = num3;
			Main.tile[X - 1, Y].type = type;
			Main.tile[X, Y].active(active: true);
			Main.tile[X, Y].frameY = (short)(num4 + 18);
			Main.tile[X, Y].frameX = (short)(num3 + 18);
			Main.tile[X, Y].type = type;
			Main.tile[X + 1, Y].active(active: true);
			Main.tile[X + 1, Y].frameY = (short)(num4 + 18);
			Main.tile[X + 1, Y].frameX = (short)(num3 + 36);
			Main.tile[X + 1, Y].type = type;
		}
	}

	public static void CheckOasisPlant(int i, int j, int type = 530)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = j;
		Tile tileSafely = Framing.GetTileSafely(i, j);
		int num2 = tileSafely.frameY % 36;
		num += num2 / 18 * -1;
		int num3 = tileSafely.frameX / 18;
		int num4 = 0;
		Tile tile = Framing.GetTileSafely(num3, num);
		_ = tile.frameY / 36;
		while (num3 > 2)
		{
			num3 -= 3;
			num4++;
		}
		num3 = i - num3;
		int num5 = num4 * 54;
		for (int k = num3; k < num3 + 3; k++)
		{
			for (int l = num; l < num + 2; l++)
			{
				if (Main.tile[k, l] == null)
				{
					tile = (Main.tile[k, l] = default(Tile));
				}
				tile = Main.tile[k, l];
				if (tile.active())
				{
					tile = Main.tile[k, l];
					if (tile.type == type)
					{
						tile = Main.tile[k, l];
						if (tile.frameX == (k - num3) * 18 + num5)
						{
							tile = Main.tile[k, l];
							if (tile.frameY == (l - num) * 18)
							{
								continue;
							}
						}
					}
				}
				flag = true;
			}
			if (Main.tile[k, num + 2] == null)
			{
				tile = (Main.tile[k, num + 2] = default(Tile));
			}
			if (SolidTile(k, num + 2))
			{
				bool[] sand = TileID.Sets.Conversion.Sand;
				tile = Main.tile[k, num + 2];
				if (sand[tile.type])
				{
					continue;
				}
			}
			flag = true;
		}
		if (!flag)
		{
			return;
		}
		tile = Main.tile[i, j];
		_ = ref tile.frameX;
		destroyObject = true;
		for (int m = num3; m < num3 + 3; m++)
		{
			for (int n = num; n < num + 2; n++)
			{
				if (Main.tile[m, n] == null)
				{
					tile = (Main.tile[m, n] = default(Tile));
				}
				tile = Main.tile[m, n];
				if (tile.type == type)
				{
					tile = Main.tile[m, n];
					if (tile.active())
					{
						KillTile(m, n);
					}
				}
			}
		}
		destroyObject = false;
		for (int num6 = num3 - 1; num6 < num3 + 4; num6++)
		{
			for (int num7 = num - 1; num7 < num + 3; num7++)
			{
				TileFrame(num6, num7);
			}
		}
	}

	public static void GetCactusType(int tileX, int tileY, int frameX, int frameY, out int type)
	{
		GetCactusType(tileX, tileY, frameX, frameY, out var _, out var _, out var _, out type);
	}

	public static void GetCactusType(int tileX, int tileY, int frameX, int frameY, out bool evil, out bool good, out bool crimson)
	{
		GetCactusType(tileX, tileY, frameX, frameY, out evil, out good, out crimson, out var _);
	}

	public static void GetCactusType(int tileX, int tileY, int frameX, int frameY, out bool evil, out bool good, out bool crimson, out int type)
	{
		type = 0;
		evil = false;
		good = false;
		crimson = false;
		int num = tileX;
		if (frameX == 36)
		{
			num--;
		}
		if (frameX == 54)
		{
			num++;
		}
		if (frameX == 108)
		{
			num = ((frameY != 18) ? (num + 1) : (num - 1));
		}
		int num2 = tileY;
		bool flag = false;
		Tile tile = Main.tile[num, num2];
		if (tile == null)
		{
			return;
		}
		if (tile.type == 80 && tile.active())
		{
			flag = true;
		}
		while (tile != null && (!tile.active() || !Main.tileSolid[tile.type] || !flag))
		{
			if (tile.type == 80 && tile.active())
			{
				flag = true;
			}
			num2++;
			if (num2 > tileY + 20)
			{
				break;
			}
			tile = Main.tile[num, num2];
		}
		type = tile.type;
		if (tile.type == 112)
		{
			evil = true;
		}
		if (tile.type == 116)
		{
			good = true;
		}
		if (tile.type == 234)
		{
			crimson = true;
		}
	}

	public static void GetBiomeInfluence(int startX, int endX, int startY, int endY, out int corruptCount, out int crimsonCount, out int hallowedCount)
	{
		corruptCount = 0;
		crimsonCount = 0;
		hallowedCount = 0;
		for (int i = startX; i <= endX; i++)
		{
			for (int j = startY; j <= endY; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile != null)
				{
					if (TileID.Sets.Corrupt[tile.type])
					{
						corruptCount++;
					}
					if (TileID.Sets.Crimson[tile.type])
					{
						crimsonCount++;
					}
					if (TileID.Sets.Hallow[tile.type])
					{
						hallowedCount++;
					}
				}
			}
		}
	}

	public static void PlaceJunglePlant(int X2, int Y2, ushort type, int styleX, int styleY)
	{
		if (styleY > 0 || type == 236 || type == 238)
		{
			int num = Y2;
			if (type == 95 || type == 126)
			{
				num++;
			}
			if (X2 < 5 || X2 > Main.maxTilesX - 5 || num < 5 || num > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag = true;
			for (int i = X2 - 1; i < X2 + 1; i++)
			{
				for (int j = num - 1; j < num + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = default(Tile);
					}
					Tile tile = Main.tile[i, j];
					if (tile.active() && tile.type != 61 && tile.type != 62 && tile.type != 655 && tile.type != 69 && tile.type != 74 && (type != 236 || tile.type != 233) && (type != 238 || tile.type != 233) && (tile.type != 185 || tile.frameY != 0))
					{
						flag = false;
					}
					if (type == 98 && tile.liquid > 0)
					{
						flag = false;
					}
				}
				if (Main.tile[i, num + 1] == null)
				{
					Main.tile[i, num + 1] = default(Tile);
				}
				if (!SolidTile(i, num + 1) || Main.tile[i, num + 1].type != 60)
				{
					flag = false;
				}
			}
			if (!flag)
			{
				return;
			}
			for (int k = X2 - 1; k < X2 + 1; k++)
			{
				for (int l = num - 1; l < num + 1; l++)
				{
					if (Main.tile[k, l] != null && Main.tile[k, l].active())
					{
						KillTile(k, l, fail: false, effectOnly: false, noItem: true);
					}
				}
			}
			short num2 = 36;
			if (type == 236 || type == 238)
			{
				num2 = 0;
			}
			short num3 = (short)(36 * styleX);
			Main.tile[X2 - 1, num - 1].active(active: true);
			Main.tile[X2 - 1, num - 1].frameY = num2;
			Main.tile[X2 - 1, num - 1].frameX = num3;
			Main.tile[X2 - 1, num - 1].type = type;
			Main.tile[X2, num - 1].active(active: true);
			Main.tile[X2, num - 1].frameY = num2;
			Main.tile[X2, num - 1].frameX = (short)(18 + num3);
			Main.tile[X2, num - 1].type = type;
			Main.tile[X2 - 1, num].active(active: true);
			Main.tile[X2 - 1, num].frameY = (short)(num2 + 18);
			Main.tile[X2 - 1, num].frameX = num3;
			Main.tile[X2 - 1, num].type = type;
			Main.tile[X2, num].active(active: true);
			Main.tile[X2, num].frameY = (short)(num2 + 18);
			Main.tile[X2, num].frameX = (short)(18 + num3);
			Main.tile[X2, num].type = type;
		}
		else
		{
			if (X2 < 5 || X2 > Main.maxTilesX - 5 || Y2 < 5 || Y2 > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag2 = true;
			for (int m = X2 - 1; m < X2 + 2; m++)
			{
				for (int n = Y2 - 1; n < Y2 + 1; n++)
				{
					if (Main.tile[m, n] == null)
					{
						Main.tile[m, n] = default(Tile);
					}
					if (Main.tile[m, n].active() && Main.tile[m, n].type != 61 && Main.tile[m, n].type != 62 && Main.tile[m, n].type != 69 && Main.tile[m, n].type != 655 && Main.tile[m, n].type != 74 && (Main.tile[m, n].type != 185 || Main.tile[m, n].frameY != 0))
					{
						flag2 = false;
					}
				}
				if (Main.tile[m, Y2 + 1] == null)
				{
					Main.tile[m, Y2 + 1] = default(Tile);
				}
				if (!SolidTile(m, Y2 + 1) || Main.tile[m, Y2 + 1].type != 60)
				{
					flag2 = false;
				}
			}
			if (!flag2)
			{
				return;
			}
			for (int num4 = X2 - 1; num4 < X2 + 2; num4++)
			{
				for (int num5 = Y2 - 1; num5 < Y2 + 1; num5++)
				{
					if (Main.tile[num4, num5] != null && Main.tile[num4, num5].active())
					{
						KillTile(num4, num5, fail: false, effectOnly: false, noItem: true);
					}
				}
			}
			short num6 = (short)(54 * styleX);
			Main.tile[X2 - 1, Y2 - 1].active(active: true);
			Main.tile[X2 - 1, Y2 - 1].frameY = 0;
			Main.tile[X2 - 1, Y2 - 1].frameX = num6;
			Main.tile[X2 - 1, Y2 - 1].type = type;
			Main.tile[X2, Y2 - 1].active(active: true);
			Main.tile[X2, Y2 - 1].frameY = 0;
			Main.tile[X2, Y2 - 1].frameX = (short)(num6 + 18);
			Main.tile[X2, Y2 - 1].type = type;
			Main.tile[X2 + 1, Y2 - 1].active(active: true);
			Main.tile[X2 + 1, Y2 - 1].frameY = 0;
			Main.tile[X2 + 1, Y2 - 1].frameX = (short)(num6 + 36);
			Main.tile[X2 + 1, Y2 - 1].type = type;
			Main.tile[X2 - 1, Y2].active(active: true);
			Main.tile[X2 - 1, Y2].frameY = 18;
			Main.tile[X2 - 1, Y2].frameX = num6;
			Main.tile[X2 - 1, Y2].type = type;
			Main.tile[X2, Y2].active(active: true);
			Main.tile[X2, Y2].frameY = 18;
			Main.tile[X2, Y2].frameX = (short)(num6 + 18);
			Main.tile[X2, Y2].type = type;
			Main.tile[X2 + 1, Y2].active(active: true);
			Main.tile[X2 + 1, Y2].frameY = 18;
			Main.tile[X2 + 1, Y2].frameX = (short)(num6 + 36);
			Main.tile[X2 + 1, Y2].type = type;
		}
	}

	public static void CheckJunglePlant(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		Tile tile = Main.tile[i, j];
		if (tile.frameY < 36)
		{
			tile = Main.tile[i, j];
			if (tile.type != 236)
			{
				tile = Main.tile[i, j];
				if (tile.type != 238)
				{
					bool flag2 = false;
					int num3 = j;
					int num19 = num3;
					tile = Main.tile[i, j];
					num3 = num19 + tile.frameY / 18 * -1;
					tile = Main.tile[i, j];
					int num4 = tile.frameX / 18;
					int num5 = 0;
					while (num4 > 2)
					{
						num4 -= 3;
						num5++;
					}
					num4 = i - num4;
					int num6 = num5 * 54;
					for (int num7 = num4; num7 < num4 + 3; num7++)
					{
						for (int num8 = num3; num8 < num3 + 2; num8++)
						{
							if (Main.tile[num7, num8] == null)
							{
								tile = (Main.tile[num7, num8] = default(Tile));
							}
							tile = Main.tile[num7, num8];
							if (tile.active())
							{
								tile = Main.tile[num7, num8];
								if (tile.type == type)
								{
									tile = Main.tile[num7, num8];
									if (tile.frameX == (num7 - num4) * 18 + num6)
									{
										tile = Main.tile[num7, num8];
										if (tile.frameY == (num8 - num3) * 18)
										{
											continue;
										}
									}
								}
							}
							flag2 = true;
						}
						if (Main.tile[num7, num3 + 2] == null)
						{
							tile = (Main.tile[num7, num3 + 2] = default(Tile));
						}
						if (SolidTile(num7, num3 + 2))
						{
							tile = Main.tile[num7, num3 + 2];
							if (tile.type == 60)
							{
								continue;
							}
						}
						flag2 = true;
					}
					if (!flag2)
					{
						return;
					}
					tile = Main.tile[i, j];
					_ = ref tile.frameX;
					destroyObject = true;
					TileLoader.Drop(i, j, type);
					for (int num9 = num4; num9 < num4 + 3; num9++)
					{
						for (int num10 = num3; num10 < num3 + 3; num10++)
						{
							if (Main.tile[num9, num10] == null)
							{
								tile = (Main.tile[num9, num10] = default(Tile));
							}
							tile = Main.tile[num9, num10];
							if (tile.type == type)
							{
								tile = Main.tile[num9, num10];
								if (tile.active())
								{
									KillTile(num9, num10);
								}
							}
						}
					}
					destroyObject = false;
					return;
				}
			}
		}
		bool flag = false;
		tile = Main.tile[i, j];
		int num = tile.frameX / 18;
		int num11 = 0;
		while (num > 1)
		{
			num -= 2;
			num11++;
		}
		num = i - num;
		int num12 = 36;
		if (type == 236 || type == 238)
		{
			num12 = 0;
		}
		tile = Main.tile[i, j];
		int num13;
		for (num13 = tile.frameY / 18; num13 > 1; num13 -= 2)
		{
		}
		num13 = j - num13;
		int num14 = num11 * 36;
		for (int k = num; k < num + 2; k++)
		{
			for (int l = num13; l < num13 + 2; l++)
			{
				if (Main.tile[k, l] == null)
				{
					tile = (Main.tile[k, l] = default(Tile));
				}
				tile = Main.tile[k, l];
				if (tile.active())
				{
					tile = Main.tile[k, l];
					if (tile.type == type)
					{
						tile = Main.tile[k, l];
						if (tile.frameX == (k - num) * 18 + num14)
						{
							tile = Main.tile[k, l];
							if (tile.frameY == (l - num13) * 18 + num12)
							{
								continue;
							}
						}
					}
				}
				flag = true;
			}
			if (Main.tile[k, num13 + 2] == null)
			{
				tile = (Main.tile[k, num13 + 2] = default(Tile));
			}
			if (SolidTile(k, num13 + 2))
			{
				tile = Main.tile[k, num13 + 2];
				if (tile.type == 60)
				{
					continue;
				}
			}
			flag = true;
		}
		if (!flag)
		{
			return;
		}
		if (type == 238)
		{
			float num15 = i * 16;
			float num16 = j * 16;
			float num17 = -1f;
			int plr = 0;
			for (int m = 0; m < 255; m++)
			{
				float num18 = Math.Abs(Main.player[m].position.X - num15) + Math.Abs(Main.player[m].position.Y - num16);
				if (num18 < num17 || num17 == -1f)
				{
					plr = m;
					num17 = num18;
				}
			}
			if (num17 / 16f < 50f)
			{
				NPC.SpawnOnPlayer(plr, 262);
			}
		}
		using (new Item.DisableNewItemMethod(!TileLoader.Drop(i, j, type)))
		{
			if (type == 236)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1291);
			}
			tile = Main.tile[i, j];
			_ = ref tile.frameX;
			destroyObject = true;
			for (int n = num; n < num + 2; n++)
			{
				for (int num2 = num13; num2 < num13 + 2; num2++)
				{
					if (Main.tile[n, num2] == null)
					{
						tile = (Main.tile[n, num2] = default(Tile));
					}
					tile = Main.tile[n, num2];
					if (tile.type == type)
					{
						tile = Main.tile[n, num2];
						if (tile.active())
						{
							KillTile(n, num2);
						}
					}
				}
			}
			destroyObject = false;
		}
	}

	public static void CheckSuper(int x, int y, int type)
	{
		//IL_0659: Unknown result type (might be due to invalid IL or missing references)
		//IL_065e: Unknown result type (might be due to invalid IL or missing references)
		if (destroyObject)
		{
			return;
		}
		Tile tile = Main.tile[x, y];
		int num = 0;
		if (type == 376)
		{
			num = tile.frameX / 36;
		}
		if (type == 443)
		{
			num = tile.frameX / 36;
		}
		if (type == 485)
		{
			num = tile.frameX / 36;
		}
		bool flag = type == 376;
		bool flag3 = type == 443;
		bool flag4 = type == 444;
		bool flag5 = type == 485;
		TileObjectData tileData = TileObjectData.GetTileData(type, num);
		bool styleHorizontal = tileData.StyleHorizontal;
		int width = tileData.Width;
		int height = tileData.Height;
		int num12 = x;
		int num13 = y;
		num12 -= tile.frameX / 18 % width;
		num13 -= tile.frameY / 18 % height;
		int num14 = 0;
		int num15 = 0;
		if (styleHorizontal)
		{
			num14 = tile.frameX / tileData.CoordinateFullWidth;
		}
		else
		{
			num15 = tile.frameY / tileData.CoordinateFullHeight;
		}
		bool flag6 = false;
		bool flag7 = false;
		for (int i = 0; i < width; i++)
		{
			for (int j = 0; j < height; j++)
			{
				Tile tileSafely2 = Framing.GetTileSafely(num12 + i, num13 + j);
				if (!tileSafely2.active() || tileSafely2.type != type || tileSafely2.frameX != num14 * tileData.CoordinateFullWidth + i * (tileData.CoordinateWidth + 2) || tileSafely2.frameY != num15 * tileData.CoordinateFullHeight + j * (tileData.CoordinateHeights[0] + 2))
				{
					flag6 = true;
				}
			}
		}
		if (flag)
		{
			for (int k = 0; k < width; k++)
			{
				Tile tileSafely = Framing.GetTileSafely(num12 + k, num13 + height);
				if (!tileSafely.active() || (!Main.tileSolid[tileSafely.type] && !Main.tileTable[tileSafely.type]))
				{
					flag6 = true;
				}
				if (tileSafely.halfBrick())
				{
					flag6 = true;
				}
			}
		}
		if (flag3)
		{
			bool flag8 = true;
			bool flag9 = true;
			for (int l = 0; l < width; l++)
			{
				if (!AnchorValid(Framing.GetTileSafely(num12 + l, num13 + height), AnchorType.SolidTile | AnchorType.SolidWithTop | AnchorType.SolidSide))
				{
					flag9 = false;
				}
				if (!AnchorValid(Framing.GetTileSafely(num12 + l, num13 - 1), AnchorType.SolidBottom))
				{
					flag8 = false;
				}
			}
			if (!flag8 && !flag9)
			{
				flag6 = true;
			}
			if (!flag6)
			{
				int num16 = 0;
				if (flag9)
				{
					for (int m = 0; m < width; m++)
					{
						Framing.GetTileSafely(num12 + m, num13).frameX = (short)(m * 18 + num / 2 * 36 + num16 * 36);
					}
				}
				else
				{
					for (int n = 0; n < width; n++)
					{
						Framing.GetTileSafely(num12 + n, num13).frameX = (short)(n * 18 + (num - 2) / 2 * 36 + 72 + num16 * 36);
					}
				}
			}
		}
		if (flag4)
		{
			bool flag10 = true;
			for (int num17 = 0; num17 < width; num17++)
			{
				if (!AnchorValid(Framing.GetTileSafely(num12 + num17, num13 - 1), AnchorType.SolidTile))
				{
					flag10 = false;
				}
			}
			if (!flag10)
			{
				flag6 = true;
			}
			for (int num18 = 0; num18 < width; num18++)
			{
				for (int num19 = 0; num19 < height; num19++)
				{
					if (Framing.GetTileSafely(num12 + num18, num13 + num19).liquid > 0)
					{
						flag6 = true;
						flag7 = true;
					}
				}
			}
		}
		if (flag5)
		{
			bool flag2 = true;
			for (int num2 = 0; num2 < width; num2++)
			{
				if (!AnchorValid(Framing.GetTileSafely(num12 + num2, num13 + height), AnchorType.SolidTile))
				{
					flag2 = false;
				}
			}
			if (!flag2)
			{
				flag6 = true;
			}
		}
		if (!flag6)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(x, y, type);
		for (int num3 = 0; num3 < width; num3++)
		{
			for (int num4 = 0; num4 < height; num4++)
			{
				if (Main.tile[num12 + num3, num13 + num4].type == type && Main.tile[num12 + num3, num13 + num4].active())
				{
					KillTile(num12 + num3, num13 + num4);
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			int num5 = 0;
			if (type == 376)
			{
				switch (num)
				{
				case 0:
					num5 = 2334;
					break;
				case 1:
					num5 = 2335;
					break;
				case 2:
					num5 = 2336;
					break;
				case 3:
					num5 = 3203;
					break;
				case 4:
					num5 = 3204;
					break;
				case 5:
					num5 = 3205;
					break;
				case 6:
					num5 = 3206;
					break;
				case 7:
					num5 = 3207;
					break;
				case 8:
					num5 = 3208;
					break;
				case 9:
					num5 = 3979;
					break;
				case 10:
					num5 = 3980;
					break;
				case 11:
					num5 = 3981;
					break;
				case 12:
					num5 = 3982;
					break;
				case 13:
					num5 = 3983;
					break;
				case 14:
					num5 = 3984;
					break;
				case 15:
					num5 = 3985;
					break;
				case 16:
					num5 = 3986;
					break;
				case 17:
					num5 = 3987;
					break;
				case 18:
					num5 = 4405;
					break;
				case 19:
					num5 = 4406;
					break;
				case 20:
					num5 = 4407;
					break;
				case 21:
					num5 = 4408;
					break;
				case 22:
					num5 = 4877;
					break;
				case 23:
					num5 = 4878;
					break;
				case 24:
					num5 = 5002;
					break;
				case 25:
					num5 = 5003;
					break;
				}
			}
			if (type == 443)
			{
				num5 = 3722;
			}
			if (type == 485 && !gen && Main.netMode != 1)
			{
				int availableAmountOfNPCsToSpawnUpToSlot = NPC.GetAvailableAmountOfNPCsToSpawnUpToSlot(1);
				for (int num6 = 0; num6 < availableAmountOfNPCsToSpawnUpToSlot; num6++)
				{
					int num7 = NPC.NewNPC(GetNPCSource_TileBreak(num12, num13), num12 * 16, num13 * 16 + 32, 582);
					Main.npc[num7].TargetClosest();
					Main.npc[num7].velocity = new Vector2((float)Main.npc[num7].direction * 1.5f, -5f);
					NetMessage.SendData(23, -1, -1, null, num7);
					int num8 = 20;
					int num9 = -1;
					Main.npc[num7].GetImmuneTime(num9, num8);
					NetMessage.SendData(131, -1, -1, null, num7, 1f, num9, num8);
				}
			}
			if (type == 444 && Main.netMode != 1 && !flag7)
			{
				Projectile.NewProjectile(GetProjectileSource_TileBreak(num12, num13), num12 * 16 + 16, num13 * 16 + 16, 0f, 0f, 655, 0, 0f, Main.myPlayer);
			}
			if (num5 != 0)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num12, num13), num12 * 16, num13 * 16, tileData.CoordinateFullWidth, tileData.CoordinateFullHeight, num5);
			}
			destroyObject = false;
			for (int num10 = -1; num10 < width + 1; num10++)
			{
				for (int num11 = -1; num11 < height + 1; num11++)
				{
					TileFrame(num12 + num10, num13 + num11);
				}
			}
		}
	}

	public static void Check2x2(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = 0;
		Tile tile = Main.tile[i, j];
		int num9 = tile.frameX / 18 * -1;
		if (num9 < -1)
		{
			num9 += 2;
			num = 36;
		}
		num9 += i;
		int num10 = ((type == 172) ? 38 : 36);
		tile = Main.tile[i, j];
		int num11 = tile.frameY;
		int num12 = 0;
		while (num11 >= num10)
		{
			num11 -= num10;
			num12++;
		}
		int num13 = j - num11 / 18;
		int num14 = 0;
		if (type == 652)
		{
			tile = Main.tile[i, j];
			num14 = tile.frameX / 36;
			tile = Main.tile[i, j];
			num9 = tile.frameX % 36 / 18 * -1 + i;
			num = num14 * 36;
		}
		for (int k = num9; k < num9 + 2; k++)
		{
			for (int l = num13; l < num13 + 2; l++)
			{
				Tile tileSafely = Framing.GetTileSafely(k, l);
				if (!tileSafely.active() || tileSafely.type != type || tileSafely.frameX != (k - num9) * 18 + num || tileSafely.frameY != (l - num13) * 18 + num12 * num10)
				{
					flag = true;
					break;
				}
			}
			if (type == 95 || type == 126)
			{
				Framing.GetTileSafely(k, num13 - 1);
				tile = Main.tile[k, num13 - 1];
				if (tile.active())
				{
					bool[] tileSolid = Main.tileSolid;
					tile = Main.tile[k, num13 - 1];
					if (tileSolid[tile.type])
					{
						bool[] tileSolidTop = Main.tileSolidTop;
						tile = Main.tile[k, num13 - 1];
						if (!tileSolidTop[tile.type])
						{
							continue;
						}
					}
				}
				flag = true;
			}
			else if (!TileID.Sets.Boulders[type] && type != 132)
			{
				Tile tileSafely2 = Framing.GetTileSafely(k, num13 + 2);
				if (!tileSafely2.active() || (!Main.tileSolid[tileSafely2.type] && !Main.tileTable[tileSafely2.type]))
				{
					flag = true;
				}
				if (tileSafely2.halfBrick())
				{
					flag = true;
				}
			}
		}
		bool flag2;
		ushort type5;
		if (TileID.Sets.Boulders[type])
		{
			if (Main.tile[num9, num13 - 1] == null)
			{
				tile = (Main.tile[num9, num13 - 1] = default(Tile));
			}
			if (Main.tile[num9 + 1, num13 - 1] == null)
			{
				tile = (Main.tile[num9 + 1, num13 - 1] = default(Tile));
			}
			tile = Main.tile[num9, num13 - 1];
			ushort type2 = tile.type;
			tile = Main.tile[num9 + 1, num13 - 1];
			ushort type3 = tile.type;
			if (!TileID.Sets.BasicChest[type2] && !TileID.Sets.BasicChest[type3] && !TileID.Sets.BasicDresser[type2] && !TileID.Sets.BasicDresser[type3] && !TileID.Sets.BasicChestFake[type2] && !TileID.Sets.BasicChestFake[type3] && type2 != 470 && type3 != 470 && type2 != 475 && type3 != 475 && !SolidTileAllowBottomSlope(num9, num13 + 2) && !SolidTileAllowBottomSlope(num9 + 1, num13 + 2))
			{
				flag = true;
			}
		}
		else if (type == 132)
		{
			flag = false;
			tile = Main.tile[i, j];
			num13 = tile.frameY / 18 * -1;
			num13 += j;
			num = 0;
			tile = Main.tile[i, j];
			num9 = tile.frameX / 18 * -1;
			while (num9 < -1)
			{
				num9 += 2;
				num += 36;
			}
			num9 += i;
			for (int m = num9; m < num9 + 2; m++)
			{
				for (int n = num13; n < num13 + 2; n++)
				{
					if (Main.tile[m, n] == null)
					{
						tile = (Main.tile[m, n] = default(Tile));
					}
					tile = Main.tile[m, n];
					if (tile.active())
					{
						tile = Main.tile[m, n];
						if (tile.type == type)
						{
							tile = Main.tile[m, n];
							if (tile.frameX == (m - num9) * 18 + num)
							{
								tile = Main.tile[m, n];
								if (tile.frameY == (n - num13) * 18)
								{
									continue;
								}
							}
						}
					}
					flag = true;
				}
			}
			if (Main.tile[num9, num13 + 2] == null)
			{
				tile = (Main.tile[num9, num13 + 2] = default(Tile));
			}
			if (Main.tile[num9 + 1, num13 + 2] == null)
			{
				tile = (Main.tile[num9 + 1, num13 + 2] = default(Tile));
			}
			flag2 = false;
			tile = Main.tile[num9, num13 + 2];
			ushort type4 = tile.type;
			tile = Main.tile[num9 + 1, num13 + 2];
			type5 = tile.type;
			tile = Main.tile[num9, num13 + 2];
			if (tile.active() && (Main.tileSolid[type4] || Main.tileSolidTop[type4]))
			{
				tile = Main.tile[num9, num13 + 2];
				if (!tile.halfBrick())
				{
					tile = Main.tile[num9, num13 + 2];
					if (tile.slope() != 0)
					{
						tile = Main.tile[num9, num13 + 2];
						if (!tile.bottomSlope())
						{
							goto IL_05b4;
						}
					}
					goto IL_05b7;
				}
			}
			goto IL_05b4;
		}
		goto IL_0753;
		IL_05b4:
		flag2 = true;
		goto IL_05b7;
		IL_063e:
		if (flag2)
		{
			tile = Main.tile[num9, num13];
			if (tile.wall >= 1)
			{
				tile = Main.tile[num9 + 1, num13];
				if (tile.wall >= 1)
				{
					tile = Main.tile[num9, num13 + 1];
					if (tile.wall >= 1)
					{
						tile = Main.tile[num9 + 1, num13 + 1];
						if (tile.wall >= 1)
						{
							if (num < 72)
							{
								for (int num15 = num9; num15 < num9 + 2; num15++)
								{
									for (int num16 = num13; num16 < num13 + 2; num16++)
									{
										tile = Main.tile[num15, num16];
										tile.frameX += 72;
									}
								}
							}
							goto IL_0753;
						}
					}
				}
			}
			flag = true;
		}
		else if (num >= 72)
		{
			for (int num2 = num9; num2 < num9 + 2; num2++)
			{
				for (int num3 = num13; num3 < num13 + 2; num3++)
				{
					tile = Main.tile[num2, num3];
					tile.frameX -= 72;
				}
			}
		}
		goto IL_0753;
		IL_063b:
		flag2 = true;
		goto IL_063e;
		IL_05b7:
		tile = Main.tile[num9 + 1, num13 + 2];
		if (tile.active() && (Main.tileSolid[type5] || Main.tileSolidTop[type5]))
		{
			tile = Main.tile[num9 + 1, num13 + 2];
			if (!tile.halfBrick())
			{
				tile = Main.tile[num9 + 1, num13 + 2];
				if (tile.slope() != 0)
				{
					tile = Main.tile[num9 + 1, num13 + 2];
					if (!tile.bottomSlope())
					{
						goto IL_063b;
					}
				}
				goto IL_063e;
			}
		}
		goto IL_063b;
		IL_0753:
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(i, j, type);
		for (int num4 = num9; num4 < num9 + 2; num4++)
		{
			for (int num5 = num13; num5 < num13 + 2; num5++)
			{
				tile = Main.tile[num4, num5];
				if (tile.type == type)
				{
					tile = Main.tile[num4, num5];
					if (tile.active())
					{
						KillTile(num4, num5);
					}
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			int num6 = 0;
			switch (type)
			{
			case 521:
				num6 = 4327;
				break;
			case 522:
				num6 = 4328;
				break;
			case 523:
				num6 = 4329;
				break;
			case 524:
				num6 = 4330;
				break;
			case 525:
				num6 = 4331;
				break;
			case 526:
				num6 = 4332;
				break;
			case 527:
				num6 = 4333;
				break;
			case 564:
				num6 = 4553;
				break;
			case 565:
				num6 = 4552;
				break;
			case 594:
				num6 = 4869;
				break;
			case 621:
				num6 = 3750;
				break;
			case 622:
				num6 = 5008;
				break;
			}
			if (type == 598)
			{
				num6 = 4880;
			}
			if (type == 360)
			{
				num6 = 3072;
			}
			if (type == 580)
			{
				num6 = 4846;
			}
			if (type == 620)
			{
				num6 = 4964;
			}
			if (type == 505)
			{
				num6 = 4275;
			}
			if (type == 543)
			{
				num6 = 4398;
			}
			if (type == 568)
			{
				num6 = 4655;
			}
			if (type == 569)
			{
				num6 = 4656;
			}
			if (type == 570)
			{
				num6 = 4657;
			}
			if (type >= 288 && type <= 295)
			{
				num6 = 2178 + type - 288;
			}
			if (type >= 316 && type <= 318)
			{
				num6 = 2439 + type - 316;
			}
			if (type == 85)
			{
				num6 = 321;
			}
			if (type == 94)
			{
				num6 = 352;
			}
			if (type == 95)
			{
				num6 = 344;
			}
			if (type == 96)
			{
				num6 = 345;
			}
			if (type == 97)
			{
				num6 = 346;
			}
			if (type == 98)
			{
				num6 = 347;
			}
			if (type == 99)
			{
				num6 = 348;
			}
			if (type == 335)
			{
				num6 = 2700;
			}
			if (type == 411)
			{
				num6 = 3545;
			}
			if (type == 652)
			{
				num6 = ((num14 < 3) ? 195 : ((num14 >= 6) ? 331 : 62));
			}
			if (type == 100)
			{
				switch (num12)
				{
				case 0:
					num6 = 349;
					break;
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7:
				case 8:
				case 9:
				case 10:
				case 11:
				case 12:
					num6 = 2092 + num12 - 1;
					break;
				case 13:
				case 14:
				case 15:
				case 16:
					num6 = 2149 + num12 - 13;
					break;
				default:
					switch (num12)
					{
					case 17:
						num6 = 2227;
						break;
					case 18:
						num6 = 2522;
						break;
					case 19:
						num6 = 2541;
						break;
					case 20:
						num6 = 2555;
						break;
					case 21:
						num6 = 2570;
						break;
					case 22:
						num6 = 2664;
						break;
					case 23:
						num6 = 2665;
						break;
					case 24:
						num6 = 2666;
						break;
					case 25:
						num6 = 2667;
						break;
					case 26:
						num6 = 2668;
						break;
					case 27:
						num6 = 2825;
						break;
					case 28:
						num6 = 3168;
						break;
					case 29:
						num6 = 3170;
						break;
					case 30:
						num6 = 3169;
						break;
					case 31:
						num6 = 3893;
						break;
					case 32:
						num6 = 3935;
						break;
					case 33:
						num6 = 3961;
						break;
					case 34:
						num6 = 4149;
						break;
					case 35:
						num6 = 4170;
						break;
					case 36:
						num6 = 4191;
						break;
					case 37:
						num6 = 4212;
						break;
					case 38:
						num6 = 4302;
						break;
					case 39:
						num6 = 4570;
						break;
					case 40:
						num6 = 5152;
						break;
					case 41:
						num6 = 5173;
						break;
					case 42:
						num6 = 5194;
						break;
					}
					break;
				}
			}
			if (type == 173)
			{
				num6 = 714;
			}
			if (type == 125)
			{
				num6 = 487;
			}
			if (type == 287)
			{
				num6 = 2177;
			}
			if (type == 126)
			{
				num6 = 488;
			}
			if (type == 132)
			{
				num6 = 513;
			}
			if (type == 142)
			{
				num6 = 581;
			}
			if (type == 143)
			{
				num6 = 582;
			}
			if (type == 282)
			{
				num6 = 250;
			}
			if (type == 319)
			{
				num6 = 2490;
			}
			if (type == 490)
			{
				num6 = 4075;
			}
			if (type == 172)
			{
				num6 = 2827 + num12;
				switch (num12)
				{
				case 29:
					num6 = 3147;
					break;
				case 30:
					num6 = 3149;
					break;
				case 31:
					num6 = 3148;
					break;
				case 32:
					num6 = 3896;
					break;
				case 33:
					num6 = 3946;
					break;
				case 34:
					num6 = 3972;
					break;
				case 35:
					num6 = 4160;
					break;
				case 36:
					num6 = 4181;
					break;
				case 37:
					num6 = 4202;
					break;
				case 38:
					num6 = 4223;
					break;
				case 39:
					num6 = 4312;
					break;
				case 40:
					num6 = 4581;
					break;
				case 41:
					num6 = 5163;
					break;
				case 42:
					num6 = 5184;
					break;
				case 43:
					num6 = 5205;
					break;
				}
			}
			if (num6 != 0)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, num6);
			}
			if (!gen && Main.netMode != 1)
			{
				switch (type)
				{
				case 138:
					Projectile.NewProjectile(GetProjectileSource_TileBreak(num9, num13), (float)(num9 * 16) + 15.5f, num13 * 16 + 16, 0f, 0f, 99, 70, 10f, Main.myPlayer);
					break;
				case 484:
					Projectile.NewProjectile(GetProjectileSource_TileBreak(num9, num13), (float)(num9 * 16) + 15.5f, num13 * 16 + 16, 0f, 0f, 727, 35, 10f, Main.myPlayer);
					break;
				case 654:
					Projectile.NewProjectile(GetProjectileSource_TileBreak(num9, num13), num9 * 16 + 8, num13 * 16 + 8, 0f, 0f, 1002, 400, 10f, Main.myPlayer);
					break;
				case 664:
					Projectile.NewProjectile(GetProjectileSource_TileBreak(num9, num13), (float)(num9 * 16) + 15.5f, num13 * 16 + 16, 0f, 0f, 1013, 70, 10f, Main.myPlayer);
					break;
				case 665:
					Projectile.NewProjectile(GetProjectileSource_TileBreak(num9, num13), (float)(num9 * 16) + 15.5f, num13 * 16 + 16, 0f, 0f, 1014, 70, 10f, Main.myPlayer);
					break;
				}
			}
			destroyObject = false;
			for (int num7 = num9 - 1; num7 < num9 + 3; num7++)
			{
				for (int num8 = num13 - 1; num8 < num13 + 3; num8++)
				{
					TileFrame(num7, num8);
				}
			}
		}
	}

	public static bool CheckBoulderChest(int i, int j)
	{
		int num = Main.tile[i, j].frameX / 18 * -1;
		if (num < -1)
		{
			num += 2;
		}
		num += i;
		int num2;
		for (num2 = Main.tile[i, j].frameY; num2 >= 36; num2 -= 36)
		{
		}
		num2 = j - num2 / 18;
		if (IsAContainer(Main.tile[num, num2 - 1]) || IsAContainer(Main.tile[num + 1, num2 - 1]))
		{
			return true;
		}
		return false;
	}

	public static bool IsAContainer(Tile t)
	{
		if (!TileID.Sets.BasicDresser[t.type] && t.type != 470 && t.type != 475 && !TileID.Sets.BasicChest[t.type])
		{
			return TileID.Sets.BasicChestFake[t.type];
		}
		return true;
	}

	public static void OreRunner(int i, int j, double strength, int steps, ushort type)
	{
		double num = strength;
		double num2 = steps;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-10, 11) * 0.1;
		vector2D2.Y = (double)genRand.Next(-10, 11) * 0.1;
		while (num > 0.0 && num2 > 0.0)
		{
			if (vector2D.Y < 0.0 && num2 > 0.0 && type == 59)
			{
				num2 = 0.0;
			}
			num = strength * (num2 / (double)steps);
			num2 -= 1.0;
			int num3 = (int)(vector2D.X - num * 0.5);
			int num4 = (int)(vector2D.X + num * 0.5);
			int num5 = (int)(vector2D.Y - num * 0.5);
			int num6 = (int)(vector2D.Y + num * 0.5);
			if (num3 < 0)
			{
				num3 = 0;
			}
			if (num4 > Main.maxTilesX)
			{
				num4 = Main.maxTilesX;
			}
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesY)
			{
				num6 = Main.maxTilesY;
			}
			for (int k = num3; k < num4; k++)
			{
				for (int l = num5; l < num6; l++)
				{
					if (Math.Abs((double)k - vector2D.X) + Math.Abs((double)l - vector2D.Y) < strength * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].active() && (TileID.Sets.CanBeClearedDuringOreRunner[Main.tile[k, l].type] || (Main.remixWorld && Main.tile[k, l].type == 230) || (Main.tile[k, l].type == 225 && Main.tile[k, l].wall != 108)))
					{
						Main.tile[k, l].type = type;
						Main.tile[k, l].ClearBlockPaintAndCoating();
						SquareTileFrame(k, l);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, k, l);
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
		}
	}

	public static void SmashAltar(int i, int j)
	{
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_04dc: Unknown result type (might be due to invalid IL or missing references)
		if (Main.netMode == 1 || !Main.hardMode || noTileActions || gen)
		{
			return;
		}
		int num = altarCount % 3;
		int num3 = altarCount / 3 + 1;
		double num4 = (double)Main.maxTilesX / 4200.0;
		int num5 = 1 - num;
		num4 = num4 * 310.0 - (double)(85 * num);
		num4 *= 0.85;
		num4 /= (double)num3;
		bool flag = false;
		if (Main.drunkWorld)
		{
			if (SavedOreTiers.Adamantite == 111)
			{
				SavedOreTiers.Adamantite = 223;
			}
			else if (SavedOreTiers.Adamantite == 223)
			{
				SavedOreTiers.Adamantite = 111;
			}
		}
		switch (num)
		{
		case 0:
		{
			if (SavedOreTiers.Cobalt == -1)
			{
				flag = true;
				SavedOreTiers.Cobalt = 107;
				if (genRand.Next(2) == 0)
				{
					SavedOreTiers.Cobalt = 221;
				}
			}
			int num7 = 12;
			if (SavedOreTiers.Cobalt == 221)
			{
				num7 += 9;
				num4 *= 0.8999999761581421;
			}
			if (Main.netMode == 0)
			{
				Main.NewText(Lang.misc[num7].Value, 50, byte.MaxValue, 130);
			}
			else if (Main.netMode == 2)
			{
				ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[num7].Key), new Color(50, 255, 130));
			}
			num = SavedOreTiers.Cobalt;
			num4 *= 1.0499999523162842;
			break;
		}
		case 1:
		{
			if (Main.drunkWorld)
			{
				if (SavedOreTiers.Mythril == 108)
				{
					SavedOreTiers.Mythril = 222;
				}
				else if (SavedOreTiers.Mythril == 222)
				{
					SavedOreTiers.Mythril = 108;
				}
			}
			if (SavedOreTiers.Mythril == -1)
			{
				flag = true;
				SavedOreTiers.Mythril = 108;
				if (genRand.Next(2) == 0)
				{
					SavedOreTiers.Mythril = 222;
				}
			}
			int num8 = 13;
			if (SavedOreTiers.Mythril == 222)
			{
				num8 += 9;
				num4 *= 0.8999999761581421;
			}
			if (Main.netMode == 0)
			{
				Main.NewText(Lang.misc[num8].Value, 50, byte.MaxValue, 130);
			}
			else if (Main.netMode == 2)
			{
				ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[num8].Key), new Color(50, 255, 130));
			}
			num = SavedOreTiers.Mythril;
			break;
		}
		default:
		{
			if (Main.drunkWorld)
			{
				if (SavedOreTiers.Cobalt == 107)
				{
					SavedOreTiers.Cobalt = 221;
				}
				else if (SavedOreTiers.Cobalt == 221)
				{
					SavedOreTiers.Cobalt = 107;
				}
			}
			if (SavedOreTiers.Adamantite == -1)
			{
				flag = true;
				SavedOreTiers.Adamantite = 111;
				if (genRand.Next(2) == 0)
				{
					SavedOreTiers.Adamantite = 223;
				}
			}
			int num6 = 14;
			if (SavedOreTiers.Adamantite == 223)
			{
				num6 += 9;
				num4 *= 0.8999999761581421;
			}
			if (Main.netMode == 0)
			{
				Main.NewText(Lang.misc[num6].Value, 50, byte.MaxValue, 130);
			}
			else if (Main.netMode == 2)
			{
				ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[num6].Key), new Color(50, 255, 130));
			}
			num = SavedOreTiers.Adamantite;
			break;
		}
		}
		if (flag)
		{
			NetMessage.SendData(7);
		}
		for (int k = 0; (double)k < num4; k++)
		{
			int i2 = genRand.Next(100, Main.maxTilesX - 100);
			double num9 = Main.worldSurface;
			if (num == 108 || num == 222)
			{
				num9 = Main.rockLayer;
			}
			if (num == 111 || num == 223)
			{
				num9 = (Main.rockLayer + Main.rockLayer + (double)Main.maxTilesY) / 3.0;
			}
			int j2 = genRand.Next((int)num9, Main.maxTilesY - 150);
			if (Main.remixWorld)
			{
				double num10 = Main.maxTilesX - 350;
				if (num == 108 || num == 222)
				{
					num10 = (Main.rockLayer + Main.rockLayer + (double)Main.maxTilesY - 350.0) / 3.0;
				}
				if (num == 111 || num == 223)
				{
					num10 = Main.rockLayer - 25.0;
				}
				j2 = genRand.Next((int)Main.worldSurface + 15, (int)num10);
			}
			if (Main.tenthAnniversaryWorld)
			{
				OreRunner(i2, j2, genRand.Next(5, 11 + num5), genRand.Next(5, 11 + num5), (ushort)num);
			}
			else
			{
				OreRunner(i2, j2, genRand.Next(5, 9 + num5), genRand.Next(5, 9 + num5), (ushort)num);
			}
		}
		if (Main.netMode != 1)
		{
			int num2 = Main.rand.Next(2) + 1;
			for (int l = 0; l < num2; l++)
			{
				NPC.SpawnOnPlayer(Player.FindClosest(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16), 82);
			}
		}
		altarCount++;
		AchievementsHelper.NotifyProgressionEvent(6);
	}

	public static void Check3x1(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		Tile tile2;
		if (Main.tile[i, j] == null)
		{
			tile2 = (Main.tile[i, j] = default(Tile));
		}
		tile2 = Main.tile[i, j];
		int num = tile2.frameX / 18;
		int num2 = 0;
		while (num > 2)
		{
			num -= 3;
			num2++;
		}
		num = i - num;
		int num3 = num2 * 54;
		for (int k = num; k < num + 3; k++)
		{
			if (Main.tile[k, j] == null)
			{
				tile2 = (Main.tile[k, j] = default(Tile));
			}
			tile2 = Main.tile[k, j];
			if (tile2.active())
			{
				tile2 = Main.tile[k, j];
				if (tile2.type == type)
				{
					tile2 = Main.tile[k, j];
					if (tile2.frameX == (k - num) * 18 + num3)
					{
						tile2 = Main.tile[k, j];
						if (tile2.frameY == 0)
						{
							goto IL_010a;
						}
					}
				}
			}
			flag = true;
			goto IL_010a;
			IL_010a:
			if (Main.tile[k, j - 1] == null)
			{
				tile2 = (Main.tile[k, j - 1] = default(Tile));
			}
			tile2 = Main.tile[k, j - 1];
			if (tile2.active())
			{
				bool[] basicChest = TileID.Sets.BasicChest;
				tile2 = Main.tile[k, j - 1];
				if (basicChest[tile2.type])
				{
					return;
				}
				bool[] basicChestFake = TileID.Sets.BasicChestFake;
				tile2 = Main.tile[k, j - 1];
				if (basicChestFake[tile2.type])
				{
					return;
				}
				bool[] basicDresser = TileID.Sets.BasicDresser;
				tile2 = Main.tile[k, j - 1];
				if (basicDresser[tile2.type])
				{
					return;
				}
				tile2 = Main.tile[k, j - 1];
				if (tile2.type == 470)
				{
					return;
				}
				tile2 = Main.tile[k, j - 1];
				if (tile2.type == 475)
				{
					return;
				}
				tile2 = Main.tile[k, j - 1];
				if (tile2.type == 597)
				{
					return;
				}
			}
			if (!SolidTileAllowBottomSlope(k, j + 1))
			{
				flag = true;
			}
		}
		if (!flag)
		{
			return;
		}
		tile2 = Main.tile[i, j];
		_ = ref tile2.frameX;
		destroyObject = true;
		using (new Item.DisableNewItemMethod(!TileLoader.Drop(i, j, type)))
		{
			if (type == 235)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1263);
			}
			for (int l = num; l < num + 3; l++)
			{
				if (Main.tile[l, j] == null)
				{
					tile2 = (Main.tile[l, j] = default(Tile));
				}
				tile2 = Main.tile[l, j];
				if (tile2.type == type)
				{
					tile2 = Main.tile[l, j];
					if (tile2.active())
					{
						KillTile(l, j);
					}
				}
			}
			destroyObject = false;
			for (int m = num - 1; m < num + 4; m++)
			{
				TileFrame(m, j);
			}
		}
	}

	public static void Check3x2(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		bool flag2 = false;
		int num = j;
		Tile tile5;
		if (Main.tile[i, j] == null)
		{
			tile5 = (Main.tile[i, j] = default(Tile));
		}
		int num9 = 36;
		tile5 = Main.tile[i, j];
		int num10 = tile5.frameY / num9;
		tile5 = Main.tile[i, j];
		int num11 = tile5.frameY % num9;
		num -= num11 / 18;
		tile5 = Main.tile[i, j];
		int num12 = tile5.frameX / 18;
		int num13 = 0;
		while (num12 > 2)
		{
			num12 -= 3;
			num13++;
		}
		num12 = i - num12;
		int num14 = num13 * 54;
		if (type == 14 && num13 == 25)
		{
			flag2 = true;
		}
		int num15 = num + 2;
		if (flag2)
		{
			num15--;
		}
		for (int k = num12; k < num12 + 3; k++)
		{
			for (int l = num; l < num15; l++)
			{
				if (Main.tile[k, l] == null)
				{
					tile5 = (Main.tile[k, l] = default(Tile));
				}
				tile5 = Main.tile[k, l];
				if (tile5.active())
				{
					tile5 = Main.tile[k, l];
					if (tile5.type == type)
					{
						tile5 = Main.tile[k, l];
						if (tile5.frameX == (k - num12) * 18 + num14)
						{
							tile5 = Main.tile[k, l];
							if (tile5.frameY == (l - num) * 18 + num10 * 36)
							{
								continue;
							}
						}
					}
				}
				flag = true;
			}
			if (type == 285 || type == 286 || type == 298 || type == 299 || type == 310 || type == 339 || type == 538 || (type >= 361 && type <= 364) || type == 532 || type == 544 || type == 533 || type == 555 || type == 556 || type == 582 || type == 619 || type == 629)
			{
				if (!SolidTileAllowBottomSlope(k, num15))
				{
					if (!(Main.tile[k, num15] == null))
					{
						tile5 = Main.tile[k, num15];
						if (tile5.nactive())
						{
							bool[] tileSolidTop = Main.tileSolidTop;
							tile5 = Main.tile[k, num15];
							if (tileSolidTop[tile5.type])
							{
								tile5 = Main.tile[k, num15];
								if (tile5.frameY == 0)
								{
									goto IL_0490;
								}
							}
						}
					}
					if (!(Main.tile[k, num15] == null))
					{
						tile5 = Main.tile[k, num15];
						if (tile5.active())
						{
							bool[] platforms = TileID.Sets.Platforms;
							tile5 = Main.tile[k, num15];
							if (platforms[tile5.type])
							{
								goto IL_0490;
							}
						}
					}
					flag = true;
				}
			}
			else
			{
				switch (type)
				{
				case 488:
				{
					int num16 = 0;
					if (Main.tile[k, num15] != null)
					{
						tile5 = Main.tile[k, num15];
						if (tile5.active())
						{
							tile5 = Main.tile[k, num15];
							num16 = tile5.type;
						}
					}
					if (num16 != 2 && num16 != 477 && num16 != 109 && num16 != 492)
					{
						flag = true;
					}
					break;
				}
				case 26:
				{
					Tile tile2 = Main.tile[k, num15];
					if (!SolidTileAllowBottomSlope(k, num15) || (tile2 != null && tile2.active() && TileID.Sets.Boulders[tile2.type]))
					{
						flag = true;
					}
					break;
				}
				case 186:
				{
					if (!SolidTileAllowBottomSlope(k, num15))
					{
						flag = true;
						break;
					}
					Tile tile = Main.tile[k, num15];
					if (tile == null || !tile.active())
					{
						break;
					}
					switch (num13)
					{
					case 26:
					case 27:
					case 28:
					case 29:
					case 30:
					case 31:
						if (!TileID.Sets.Snow[tile.type] && !TileID.Sets.Conversion.Ice[tile.type] && tile.type != 162 && tile.type != 224)
						{
							flag = true;
						}
						break;
					case 32:
					case 33:
					case 34:
						if (!TileID.Sets.Mud[tile.type] && tile.type != 70)
						{
							flag = true;
						}
						break;
					}
					break;
				}
				}
			}
			goto IL_0490;
			IL_0490:
			if (type == 187)
			{
				if (!SolidTileAllowBottomSlope(k, num15))
				{
					flag = true;
				}
				else
				{
					Tile tile3 = Main.tile[k, num15];
					if (!(tile3 == null) && tile3.active())
					{
						switch (num13)
						{
						case 0:
						case 1:
						case 2:
						case 3:
						case 4:
						case 5:
							if (!TileID.Sets.Mud[tile3.type] && tile3.type != 60 && tile3.type != 226)
							{
								flag = true;
							}
							break;
						case 6:
						case 7:
						case 8:
							if (tile3.type != 57 && tile3.type != 58 && tile3.type != 75 && tile3.type != 76)
							{
								flag = true;
							}
							break;
						case 29:
						case 30:
						case 31:
						case 32:
						case 33:
						case 34:
							if (!TileID.Sets.Conversion.Sand[tile3.type] && !TileID.Sets.Conversion.HardenedSand[tile3.type] && !TileID.Sets.Conversion.Sandstone[tile3.type])
							{
								flag = true;
							}
							break;
						}
					}
				}
			}
			else if (!SolidTileAllowBottomSlope(k, num15))
			{
				flag = true;
			}
		}
		if (type == 187 && Main.tile[num12, num] != null)
		{
			tile5 = Main.tile[num12, num];
			if (tile5.frameX >= 756)
			{
				tile5 = Main.tile[num12, num];
				if (tile5.frameX <= 900)
				{
					tile5 = Main.tile[num12, num + 2];
					if (tile5.type != 2)
					{
						tile5 = Main.tile[num12 + 1, num + 2];
						if (tile5.type != 2)
						{
							tile5 = Main.tile[num12 + 2, num + 2];
							if (tile5.type != 2)
							{
								tile5 = Main.tile[num12, num + 2];
								if (tile5.type != 477)
								{
									tile5 = Main.tile[num12 + 1, num + 2];
									if (tile5.type != 477)
									{
										tile5 = Main.tile[num12 + 2, num + 2];
										if (tile5.type != 477)
										{
											tile5 = Main.tile[num12, num + 2];
											if (tile5.type != 492)
											{
												tile5 = Main.tile[num12 + 1, num + 2];
												if (tile5.type != 492)
												{
													tile5 = Main.tile[num12 + 2, num + 2];
													if (tile5.type != 492)
													{
														tile5 = Main.tile[num12, num];
														tile5.frameX -= 378;
														tile5 = Main.tile[num12 + 1, num];
														tile5.frameX -= 378;
														tile5 = Main.tile[num12 + 2, num];
														tile5.frameX -= 378;
														tile5 = Main.tile[num12, num + 1];
														tile5.frameX -= 378;
														tile5 = Main.tile[num12 + 1, num + 1];
														tile5.frameX -= 378;
														tile5 = Main.tile[num12 + 2, num + 1];
														tile5.frameX -= 378;
														tile5 = Main.tile[num12, num];
														tile5.type = 186;
														tile5 = Main.tile[num12 + 1, num];
														tile5.type = 186;
														tile5 = Main.tile[num12 + 2, num];
														tile5.type = 186;
														tile5 = Main.tile[num12, num + 1];
														tile5.type = 186;
														tile5 = Main.tile[num12 + 1, num + 1];
														tile5.type = 186;
														tile5 = Main.tile[num12 + 2, num + 1];
														tile5.type = 186;
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if (flag && type == 488 && gen)
		{
			for (int m = num12; m < num12 + 3; m++)
			{
				for (int n = num; n < num + 2; n++)
				{
					tile5 = Main.tile[m, n];
					tile5.active(active: true);
					tile5 = Main.tile[m, n];
					tile5.type = 488;
					tile5 = Main.tile[m, n];
					tile5.frameX = (short)((m - num12) * 18);
					tile5 = Main.tile[m, n];
					tile5.frameY = (short)((n - num) * 18);
				}
				tile5 = Main.tile[m, num + 2];
				tile5.active(active: true);
				tile5 = Main.tile[m, num + 2];
				tile5.type = 2;
				tile5 = Main.tile[m, num + 2];
				tile5.slope(0);
				tile5 = Main.tile[m, num + 2];
				tile5.halfBrick(halfBrick: false);
			}
			flag = false;
		}
		if (!flag)
		{
			return;
		}
		tile5 = Main.tile[i, j];
		int frameX = tile5.frameX;
		destroyObject = true;
		num15 = num + 3;
		if (flag2)
		{
			num15--;
		}
		bool drop = TileLoader.Drop(i, j, type);
		for (int num2 = num12; num2 < num12 + 3; num2++)
		{
			for (int num3 = num; num3 < num + 3; num3++)
			{
				if (Main.tile[num2, num3] == null)
				{
					tile5 = (Main.tile[num2, num3] = default(Tile));
				}
				tile5 = Main.tile[num2, num3];
				if (tile5.type == type)
				{
					tile5 = Main.tile[num2, num3];
					if (tile5.active())
					{
						KillTile(num2, num3);
					}
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			if (type == 14)
			{
				int type2 = ((num13 >= 1 && num13 <= 3) ? (637 + num13) : ((num13 >= 15 && num13 <= 20) ? (1698 + num13) : ((num13 >= 4 && num13 <= 7) ? (823 + num13) : (num13 switch
				{
					8 => 917, 
					9 => 1144, 
					10 => 1397, 
					11 => 1400, 
					12 => 1403, 
					13 => 1460, 
					14 => 1510, 
					23 => 1926, 
					21 => 1794, 
					22 => 1816, 
					24 => 2248, 
					25 => 2259, 
					26 => 2532, 
					27 => 2550, 
					28 => 677, 
					29 => 2583, 
					30 => 2743, 
					31 => 2824, 
					32 => 3153, 
					33 => 3155, 
					34 => 3154, 
					_ => 32, 
				}))));
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type2);
			}
			switch (type)
			{
			case 469:
			{
				int type4 = 3920;
				if (num13 == 1)
				{
					type4 = 3948;
				}
				if (num13 == 2)
				{
					type4 = 3974;
				}
				if (num13 == 3)
				{
					type4 = 4162;
				}
				if (num13 == 4)
				{
					type4 = 4183;
				}
				if (num13 == 5)
				{
					type4 = 4204;
				}
				if (num13 == 6)
				{
					type4 = 4225;
				}
				if (num13 == 7)
				{
					type4 = 4314;
				}
				if (num13 == 8)
				{
					type4 = 4583;
				}
				if (num13 == 9)
				{
					type4 = 5165;
				}
				if (num13 == 10)
				{
					type4 = 5186;
				}
				if (num13 == 11)
				{
					type4 = 5207;
				}
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type4);
				break;
			}
			case 114:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 398);
				break;
			case 26:
				if (!noTileActions && !IsGeneratingHardMode)
				{
					SmashAltar(i, j);
				}
				break;
			case 298:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2190);
				break;
			case 299:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2191);
				break;
			case 361:
			case 362:
			case 363:
			case 364:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3073 + type - 361);
				break;
			default:
				if (type >= 391 && type <= 394)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 48, 32, 3254 + type - 391);
					break;
				}
				switch (type)
				{
				case 285:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2174);
					break;
				case 286:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2175);
					break;
				case 582:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4850);
					break;
				case 619:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4963);
					break;
				case 310:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2207);
					break;
				case 339:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2741);
					break;
				case 538:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4380);
					break;
				case 544:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4399);
					break;
				case 532:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4364);
					break;
				case 533:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4376);
					break;
				case 555:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4475);
					break;
				case 556:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4476);
					break;
				case 629:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5133);
					break;
				case 217:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 995);
					break;
				case 218:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 996);
					break;
				case 219:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 997);
					break;
				case 642:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5296);
					break;
				case 220:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 998);
					break;
				case 377:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3198);
					break;
				case 228:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1120);
					break;
				case 405:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3364);
					break;
				case 486:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4063);
					break;
				case 488:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 9, genRand.Next(10, 21));
					break;
				case 215:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, GetCampfireItemDrop(num13));
					break;
				case 244:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1449);
					break;
				case 647:
				{
					int num5 = 0;
					if (num13 < 7)
					{
						num5 = 154;
					}
					else if (num13 < 13)
					{
						num5 = 3;
					}
					else if (num13 < 16)
					{
						num5 = 3;
					}
					else if (num13 < 18)
					{
						num5 = 71;
					}
					else if (num13 < 20)
					{
						num5 = 72;
					}
					else if (num13 < 22)
					{
						num5 = 73;
					}
					else if (num13 < 26)
					{
						num5 = 9;
					}
					else if (num13 < 32)
					{
						num5 = 593;
					}
					else if (num13 < 35)
					{
						num5 = 183;
					}
					if (num5 != 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, num5);
					}
					break;
				}
				case 648:
				{
					num13 += num10 * 35;
					int num4 = 0;
					if (num13 < 6)
					{
						num4 = 195;
					}
					else if (num13 < 9)
					{
						num4 = 174;
					}
					else if (num13 < 14)
					{
						num4 = 150;
					}
					else if (num13 < 17)
					{
						num4 = 3;
					}
					else if (num13 < 18)
					{
						num4 = 989;
					}
					else if (num13 < 21)
					{
						num4 = 1101;
					}
					else if (num13 < 29)
					{
						num4 = 9;
					}
					else if (num13 < 35)
					{
						num4 = 3271;
					}
					else if (num13 < 41)
					{
						num4 = 3086;
					}
					else if (num13 < 47)
					{
						num4 = 3081;
					}
					else if (num13 < 52)
					{
						num4 = 62;
					}
					else if (num13 < 55)
					{
						num4 = 154;
					}
					if (num4 != 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, num4);
					}
					break;
				}
				case 651:
				{
					int num6 = 0;
					num6 = ((num13 < 3) ? 195 : ((num13 >= 6) ? 331 : 62));
					if (num6 != 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, num6);
					}
					break;
				}
				case 17:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 33);
					break;
				case 77:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 221);
					break;
				case 86:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 332);
					break;
				case 237:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1292);
					break;
				case 87:
				{
					int type3;
					if (num13 >= 1 && num13 <= 3)
					{
						type3 = 640 + num13;
					}
					else
					{
						switch (num13)
						{
						case 4:
							type3 = 919;
							break;
						case 5:
						case 6:
						case 7:
							type3 = 2245 + num13 - 5;
							break;
						case 8:
						case 9:
						case 10:
							type3 = 2254 + num13 - 8;
							break;
						default:
							type3 = ((num13 >= 11 && num13 <= 20) ? (2376 + num13 - 11) : (num13 switch
							{
								21 => 2531, 
								22 => 2548, 
								23 => 2565, 
								24 => 2580, 
								25 => 2671, 
								26 => 2821, 
								27 => 3141, 
								28 => 3143, 
								29 => 3142, 
								30 => 3915, 
								31 => 3916, 
								32 => 3944, 
								33 => 3971, 
								34 => 4158, 
								35 => 4179, 
								36 => 4200, 
								37 => 4221, 
								38 => 4310, 
								39 => 4579, 
								40 => 5161, 
								41 => 5182, 
								42 => 5203, 
								_ => 333, 
							}));
							break;
						}
					}
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type3);
					break;
				}
				case 88:
				{
					int dresserItemDrop = GetDresserItemDrop(num13);
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, dresserItemDrop);
					break;
				}
				case 89:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, GetItemDrop_Benches(num13));
					break;
				case 133:
					if (frameX >= 54)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1221);
					}
					else
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 524);
					}
					break;
				case 186:
					if (frameX < 864)
					{
						break;
					}
					if (frameX <= 954)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						if (genRand.Next(3) != 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						}
						if (genRand.Next(3) != 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						}
						if (genRand.Next(3) != 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						}
						if (genRand.Next(2) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						}
						if (genRand.Next(2) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						}
						if (genRand.Next(2) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						}
						if (genRand.Next(3) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						}
						if (genRand.Next(3) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						}
						if (genRand.Next(3) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						}
						if (genRand.Next(4) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						}
						if (genRand.Next(4) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						}
						if (genRand.Next(4) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						}
						if (genRand.Next(5) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						}
						if (genRand.Next(5) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						}
						if (genRand.Next(5) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						}
					}
					else if (frameX <= 1062)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, genRand.Next(10, 100));
						if (genRand.Next(2) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, genRand.Next(20, 100));
						}
						if (genRand.Next(3) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, genRand.Next(30, 100));
						}
						if (genRand.Next(4) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, genRand.Next(40, 100));
						}
						if (genRand.Next(5) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, genRand.Next(50, 100));
						}
					}
					else if (frameX <= 1170)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73, genRand.Next(1, 7));
						if (genRand.Next(2) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73, genRand.Next(2, 7));
						}
						if (genRand.Next(3) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73, genRand.Next(3, 7));
						}
						if (genRand.Next(4) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73, genRand.Next(4, 7));
						}
						if (genRand.Next(5) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73, genRand.Next(5, 7));
						}
					}
					break;
				case 187:
					if (frameX >= 918 && frameX <= 970)
					{
						if (Main.rand.Next(50) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4144);
						}
						else
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 989);
						}
					}
					break;
				}
				break;
			}
			destroyObject = false;
			for (int num7 = num12 - 1; num7 < num12 + 4; num7++)
			{
				for (int num8 = num - 1; num8 < num + 4; num8++)
				{
					TileFrame(num7, num8);
				}
			}
			if (type == 488)
			{
				mysticLogsEvent.FallenLogDestroyed();
			}
		}
	}

	private static int GetDresserItemDrop(int style)
	{
		if (style >= 1 && style <= 3)
		{
			return 646 + style;
		}
		switch (style)
		{
		case 4:
			return 918;
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
		case 12:
		case 13:
		case 14:
		case 15:
			return 2386 + style - 5;
		case 16:
			return 2529;
		case 17:
			return 2545;
		case 18:
			return 2562;
		case 19:
			return 2577;
		case 20:
			return 2637;
		case 21:
			return 2638;
		case 22:
			return 2639;
		case 23:
			return 2640;
		case 24:
			return 2816;
		case 25:
			return 3132;
		case 26:
			return 3134;
		case 27:
			return 3133;
		case 28:
			return 3911;
		case 29:
			return 3912;
		case 30:
			return 3913;
		case 31:
			return 3914;
		case 32:
			return 3934;
		case 33:
			return 3968;
		case 34:
			return 4148;
		case 35:
			return 4169;
		case 36:
			return 4190;
		case 37:
			return 4211;
		case 38:
			return 4301;
		case 39:
			return 4569;
		case 40:
			return 5151;
		case 41:
			return 5172;
		case 42:
			return 5193;
		default:
			return 334;
		}
	}

	private static int GetCampfireItemDrop(int style)
	{
		switch (style)
		{
		case 0:
			return 966;
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
			return 3046 + style - 1;
		case 6:
			return 3723;
		case 7:
			return 3724;
		case 8:
		case 9:
		case 10:
		case 11:
		case 12:
		case 13:
			return 4689 + style - 8;
		case 14:
			return 5299;
		case 15:
			return 5357;
		default:
			return 966;
		}
	}

	public static void Check3x4(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = i;
		int num2 = j;
		int num3 = 0;
		int num4 = 0;
		int num5 = Main.tile[i, j].frameX / 18;
		int num6 = Main.tile[i, j].frameY / 18;
		while (num5 >= 3)
		{
			num3++;
			num5 -= 3;
		}
		while (num6 >= 4)
		{
			num4++;
			num6 -= 4;
		}
		num -= num5;
		num2 -= num6;
		for (int k = num; k < num + 3; k++)
		{
			for (int l = num2; l < num2 + 4; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = default(Tile);
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num3 * 54 + (k - num) * 18 || Main.tile[k, l].frameY != num4 * 72 + (l - num2) * 18)
				{
					flag = true;
				}
			}
			if (Main.tile[k, num2 + 4] == null)
			{
				Main.tile[k, num2 + 4] = default(Tile);
			}
			if (!SolidTileAllowBottomSlope(k, num2 + 4))
			{
				flag = true;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(i, j, type);
		for (int m = num; m < num + 3; m++)
		{
			for (int n = num2; n < num2 + 4; n++)
			{
				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
				{
					KillTile(m, n);
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			switch (type)
			{
			case 101:
			{
				int type4;
				switch (num3)
				{
				case 1:
					type4 = 1414;
					break;
				case 2:
					type4 = 1415;
					break;
				case 3:
					type4 = 1416;
					break;
				case 4:
					type4 = 1463;
					break;
				case 5:
					type4 = 1512;
					break;
				case 6:
					type4 = 2020;
					break;
				case 7:
					type4 = 2021;
					break;
				case 8:
					type4 = 2022;
					break;
				case 9:
					type4 = 2023;
					break;
				case 10:
					type4 = 2024;
					break;
				case 11:
					type4 = 2025;
					break;
				case 12:
					type4 = 2026;
					break;
				case 13:
					type4 = 2027;
					break;
				case 14:
					type4 = 2028;
					break;
				case 15:
					type4 = 2029;
					break;
				case 16:
					type4 = 2030;
					break;
				case 17:
					type4 = 2031;
					break;
				case 18:
				case 19:
				case 20:
				case 21:
					type4 = 2135 + num3 - 18;
					break;
				case 22:
					type4 = 2233;
					break;
				case 23:
					type4 = 2536;
					break;
				case 24:
					type4 = 2540;
					break;
				case 25:
					type4 = 2554;
					break;
				case 26:
					type4 = 2569;
					break;
				case 27:
					type4 = 2670;
					break;
				case 28:
					type4 = 2817;
					break;
				case 29:
					type4 = 3165;
					break;
				case 30:
					type4 = 3167;
					break;
				case 31:
					type4 = 3166;
					break;
				case 32:
					type4 = 3917;
					break;
				case 33:
					type4 = 3933;
					break;
				case 34:
					type4 = 3960;
					break;
				case 35:
					type4 = 4147;
					break;
				case 36:
					type4 = 4168;
					break;
				case 37:
					type4 = 4189;
					break;
				case 38:
					type4 = 4210;
					break;
				case 39:
					type4 = 4300;
					break;
				case 40:
					type4 = 4568;
					break;
				case 41:
					type4 = 5150;
					break;
				case 42:
					type4 = 5171;
					break;
				case 43:
					type4 = 5192;
					break;
				default:
					type4 = 354;
					break;
				}
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type4);
				break;
			}
			case 102:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 355);
				break;
			case 463:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3813);
				break;
			case 617:
				if (num3 == 27)
				{
					short type2 = 5110;
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type2);
				}
				else
				{
					int type3 = 4924 + num3;
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type3);
				}
				break;
			}
			destroyObject = false;
			for (int num7 = num - 1; num7 < num + 4; num7++)
			{
				for (int num8 = num2 - 1; num8 < num2 + 4; num8++)
				{
					TileFrame(num7, num8);
				}
			}
		}
	}

	public static void Check5x4(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = i;
		int num2 = j;
		int num3 = 0;
		int num4;
		for (num4 = Main.tile[i, j].frameX / 18; num4 >= 5; num4 -= 5)
		{
			num3++;
		}
		num -= num4;
		num2 += Main.tile[i, j].frameY / 18 * -1;
		for (int k = num; k < num + 5; k++)
		{
			for (int l = num2; l < num2 + 4; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = default(Tile);
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num3 * 90 + (k - num) * 18 || Main.tile[k, l].frameY != (l - num2) * 18)
				{
					flag = true;
				}
			}
			if (Main.tile[k, num2 + 4] == null)
			{
				Main.tile[k, num2 + 4] = default(Tile);
			}
			if (!SolidTileAllowBottomSlope(k, num2 + 4))
			{
				flag = true;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(i, j, type);
		for (int m = num; m < num + 5; m++)
		{
			for (int n = num2; n < num2 + 4; n++)
			{
				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
				{
					KillTile(m, n);
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			if (type == 464)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3814);
			}
			if (type == 466)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3816);
			}
			destroyObject = false;
			for (int num5 = num - 1; num5 < num + 6; num5++)
			{
				for (int num6 = num2 - 1; num6 < num2 + 5; num6++)
				{
					TileFrame(num5, num6);
				}
			}
		}
	}

	public static void Check6x3(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = i;
		int num2 = j;
		num += Main.tile[i, j].frameX / 18 * -1;
		num2 += Main.tile[i, j].frameY / 18 * -1;
		for (int k = num; k < num + 6; k++)
		{
			for (int l = num2; l < num2 + 3; l++)
			{
				int num3 = (k - num) * 18;
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = default(Tile);
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num3 || Main.tile[k, l].frameY != (l - num2) * 18)
				{
					flag = true;
				}
			}
			if (Main.tile[k, num2 + 3] == null)
			{
				Main.tile[k, num2 + 3] = default(Tile);
			}
			if (!SolidTileAllowBottomSlope(k, num2 + 3) && (!Main.tile[k, num2 + 3].nactive() || !Main.tileSolidTop[Main.tile[k, num2 + 3].type] || Main.tile[k, num2 + 3].frameY != 0))
			{
				flag = true;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(i, j, type);
		for (int m = num; m < num + 6; m++)
		{
			for (int n = num2; n < num2 + 3; n++)
			{
				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
				{
					KillTile(m, n);
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			if (type == 275)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2162);
			}
			if (type == 413)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3565);
			}
			if (type == 414)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3566);
			}
			if (type == 276)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2163);
			}
			if (type == 277)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2164);
			}
			if (type == 278)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2165);
			}
			if (type == 279)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2166);
			}
			if (type == 280)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2167);
			}
			if (type == 281)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2168);
			}
			if (type == 296)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2186);
			}
			if (type == 297)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2187);
			}
			if (type == 309)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2206);
			}
			if (type == 358)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3070);
			}
			if (type == 359)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3071);
			}
			if (type == 542)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4396);
			}
			if (type == 550)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4461);
			}
			if (type == 551)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4462);
			}
			if (type == 553)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4473);
			}
			if (type == 554)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4474);
			}
			if (type == 558)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4481);
			}
			if (type == 559)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4483);
			}
			if (type == 599)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4882);
			}
			if (type == 600)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4883);
			}
			if (type == 601)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4884);
			}
			if (type == 602)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4885);
			}
			if (type == 603)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4886);
			}
			if (type == 604)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4887);
			}
			if (type == 605)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4888);
			}
			if (type == 606)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4889);
			}
			if (type == 607)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4890);
			}
			if (type == 608)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4891);
			}
			if (type == 609)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4892);
			}
			if (type == 610)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4893);
			}
			if (type == 611)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4894);
			}
			if (type == 612)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4895);
			}
			if (type == 632)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5213);
			}
			if (type == 640)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5301);
			}
			if (type == 643)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5314);
			}
			if (type == 644)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5315);
			}
			if (type == 645)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5316);
			}
			destroyObject = false;
			for (int num4 = num - 1; num4 < num + 7; num4++)
			{
				for (int num5 = num2 - 1; num5 < num2 + 4; num5++)
				{
					TileFrame(num4, num5);
				}
			}
		}
	}

	public static void Place6x3(int x, int y, ushort type, int direction = -1, int style = 0)
	{
		if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
		{
			return;
		}
		bool flag = true;
		for (int i = x - 3; i < x + 3; i++)
		{
			for (int j = y - 2; j <= y; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = default(Tile);
				}
				if (Main.tile[i, j].active())
				{
					flag = false;
				}
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = default(Tile);
			}
			if (!SolidTile2(i, y + 1) && (!Main.tile[i, y + 1].nactive() || !Main.tileSolidTop[Main.tile[i, y + 1].type] || Main.tile[i, y + 1].frameY != 0))
			{
				flag = false;
			}
		}
		if (!flag)
		{
			return;
		}
		int num = 0;
		for (int k = x - 3; k < x + 3; k++)
		{
			int num2 = 0;
			for (int l = y - 2; l <= y; l++)
			{
				Main.tile[k, l].active(active: true);
				Main.tile[k, l].frameY = (short)num2;
				Main.tile[k, l].frameX = (short)num;
				Main.tile[k, l].type = type;
				num2 += 18;
			}
			num += 18;
		}
	}

	public static void Place4x2(int x, int y, ushort type, int direction = -1, int style = 0)
	{
		if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
		{
			return;
		}
		bool flag = true;
		for (int i = x - 1; i < x + 3; i++)
		{
			for (int j = y - 1; j < y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = default(Tile);
				}
				if (Main.tile[i, j].active())
				{
					flag = false;
				}
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = default(Tile);
			}
			if (!SolidTile2(i, y + 1))
			{
				flag = false;
			}
		}
		short num = 0;
		if (direction == 1)
		{
			num = 72;
		}
		int num2 = 36 * style;
		if (flag)
		{
			Main.tile[x - 1, y - 1].active(active: true);
			Main.tile[x - 1, y - 1].frameY = (short)num2;
			Main.tile[x - 1, y - 1].frameX = num;
			Main.tile[x - 1, y - 1].type = type;
			Main.tile[x, y - 1].active(active: true);
			Main.tile[x, y - 1].frameY = (short)num2;
			Main.tile[x, y - 1].frameX = (short)(18 + num);
			Main.tile[x, y - 1].type = type;
			Main.tile[x + 1, y - 1].active(active: true);
			Main.tile[x + 1, y - 1].frameY = (short)num2;
			Main.tile[x + 1, y - 1].frameX = (short)(36 + num);
			Main.tile[x + 1, y - 1].type = type;
			Main.tile[x + 2, y - 1].active(active: true);
			Main.tile[x + 2, y - 1].frameY = (short)num2;
			Main.tile[x + 2, y - 1].frameX = (short)(54 + num);
			Main.tile[x + 2, y - 1].type = type;
			Main.tile[x - 1, y].active(active: true);
			Main.tile[x - 1, y].frameY = (short)(num2 + 18);
			Main.tile[x - 1, y].frameX = num;
			Main.tile[x - 1, y].type = type;
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = (short)(num2 + 18);
			Main.tile[x, y].frameX = (short)(18 + num);
			Main.tile[x, y].type = type;
			Main.tile[x + 1, y].active(active: true);
			Main.tile[x + 1, y].frameY = (short)(num2 + 18);
			Main.tile[x + 1, y].frameX = (short)(36 + num);
			Main.tile[x + 1, y].type = type;
			Main.tile[x + 2, y].active(active: true);
			Main.tile[x + 2, y].frameY = (short)(num2 + 18);
			Main.tile[x + 2, y].frameX = (short)(54 + num);
			Main.tile[x + 2, y].type = type;
		}
	}

	public static void ShootFromCannon(int x, int y, int angle, int ammo, int Damage, float KnockBack, int owner, bool fromWire)
	{
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		float num = 14f;
		float num2 = 0f;
		float num3 = 0f;
		int type = 162;
		if (ammo == 2)
		{
			type = 281;
		}
		if (ammo == 3)
		{
			type = 178;
		}
		if (ammo == 4)
		{
			type = 601;
			num = 3f;
		}
		if (ammo == 5)
		{
			type = 601;
			num = 3f;
		}
		int num4 = 0;
		int num5 = 0;
		if (ammo == 5)
		{
			num4 = 1;
		}
		if (ammo == 2)
		{
			num5 = owner + 1;
		}
		if (angle == 0)
		{
			num2 = 10f;
			num3 = 0f;
		}
		if (angle == 1)
		{
			num2 = 7.5f;
			num3 = -2.5f;
		}
		if (angle == 2)
		{
			num2 = 5f;
			num3 = -5f;
		}
		if (angle == 3)
		{
			num2 = 2.75f;
			num3 = -6f;
		}
		if (angle == 4)
		{
			num2 = 0f;
			num3 = -10f;
		}
		if (angle == 5)
		{
			num2 = -2.75f;
			num3 = -6f;
		}
		if (angle == 6)
		{
			num2 = -5f;
			num3 = -5f;
		}
		if (angle == 7)
		{
			num2 = -7.5f;
			num3 = -2.5f;
		}
		if (angle == 8)
		{
			num2 = -10f;
			num3 = 0f;
		}
		Vector2 vector = default(Vector2);
		((Vector2)(ref vector))._002Ector((float)((x + 2) * 16), (float)((y + 2) * 16));
		float num6 = num2;
		float num7 = num3;
		float num8 = (float)Math.Sqrt(num6 * num6 + num7 * num7);
		if (ammo == 4 || ammo == 5)
		{
			if (angle == 4)
			{
				vector.X += 5f;
			}
			vector.Y += 5f;
		}
		bool flag = true;
		if (ammo == 2 && !BunnyCannonCanFire())
		{
			flag = false;
		}
		if (!flag)
		{
			return;
		}
		num8 = num / num8;
		num6 *= num8;
		num7 *= num8;
		if (Main.myPlayer != owner && Main.netMode == 2 && (ammo == 4 || ammo == 5))
		{
			NetMessage.SendData(108, owner, -1, null, Damage, KnockBack, x, y, angle, ammo, owner);
			return;
		}
		if (Main.netMode == 2)
		{
			owner = Main.myPlayer;
		}
		int num9 = Projectile.NewProjectile(GetProjectileSource_PlayerOrWires(x, y, fromWire, Main.player[owner]), vector.X, vector.Y, num6, num7, type, Damage, KnockBack, owner, num4, num5);
		Main.projectile[num9].originatedFromActivableTile = true;
	}

	public static bool BunnyCannonCanFire()
	{
		int num = 1;
		int num2 = 0;
		int num3 = 100;
		for (int i = 0; i < num3; i++)
		{
			NPC nPC = Main.npc[i];
			if (nPC == null || !nPC.active)
			{
				num2++;
			}
		}
		for (int j = 0; j < Main.projectile.Length; j++)
		{
			Projectile projectile = Main.projectile[j];
			if (projectile != null && projectile.active && projectile.type == 281)
			{
				num2--;
				if (num2 <= 0)
				{
					return false;
				}
			}
		}
		return num2 >= num;
	}

	public static void SwitchCannon(int i, int j)
	{
		Tile tile = Main.tile[i, j];
		int num;
		for (num = tile.frameX / 18; num >= 4; num -= 4)
		{
		}
		tile = Main.tile[i, j];
		int num2;
		for (num2 = tile.frameY / 18; num2 >= 3; num2 -= 3)
		{
		}
		int num3 = 1;
		if (num < 2)
		{
			num3 = -1;
		}
		num = i - num;
		num2 = j - num2;
		if (num3 == 1)
		{
			tile = Main.tile[num, num2];
			if (tile.frameY <= 52)
			{
				return;
			}
		}
		if (num3 == -1)
		{
			tile = Main.tile[num, num2];
			if (tile.frameY >= 432)
			{
				return;
			}
		}
		num3 *= -54;
		for (int k = num; k < num + 4; k++)
		{
			for (int l = num2; l < num2 + 3; l++)
			{
				if (Main.tile[k, l] == null)
				{
					tile = (Main.tile[k, l] = default(Tile));
				}
				tile = Main.tile[k, l];
				if (tile.active())
				{
					tile = Main.tile[k, l];
					if (tile.type == 209)
					{
						tile = Main.tile[k, l];
						ref short frameY = ref tile.frameY;
						tile = Main.tile[k, l];
						frameY = (short)(tile.frameY + num3);
					}
				}
			}
		}
		NetMessage.SendTileSquare(-1, num, num2, 4, 3);
	}

	public static void CheckCannon(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = Main.tile[i, j].frameX / 18;
		int num2 = 0;
		while (num >= 4)
		{
			num2++;
			num -= 4;
		}
		num = i - num;
		int num3 = Main.tile[i, j].frameY / 18;
		int num4 = 0;
		while (num3 >= 3)
		{
			num4 += 54;
			num3 -= 3;
		}
		num3 = j - num3;
		int num5 = 72 * num2;
		for (int k = num; k < num + 4; k++)
		{
			int num6 = num4;
			for (int l = num3; l < num3 + 3; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = default(Tile);
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num5 || Main.tile[k, l].frameY != num6)
				{
					flag = true;
				}
				num6 += 18;
			}
			if (Main.tile[k, num3 + 3] == null)
			{
				Main.tile[k, num3 + 3] = default(Tile);
			}
			if (!SolidTileAllowBottomSlope(k, num3 + 3) && k != num && k != num + 3)
			{
				flag = true;
			}
			num5 += 18;
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(i, j, type);
		for (int m = num; m < num + 4; m++)
		{
			for (int n = num3; n < num3 + 3; n++)
			{
				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
				{
					KillTile(m, n);
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			int type2 = 928;
			switch (num2)
			{
			case 1:
				type2 = 1337;
				break;
			case 2:
				type2 = 3369;
				break;
			case 3:
			case 4:
				type2 = 3664;
				break;
			}
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type2);
			destroyObject = false;
			for (int num7 = num; num7 < num + 4; num7++)
			{
				for (int num8 = num3; num8 < num3 + 3; num8++)
				{
					TileFrame(num7, num8);
				}
			}
		}
	}

	public static void PlaceCannon(int x, int y, ushort type, int style = 0)
	{
		if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
		{
			return;
		}
		bool flag = true;
		for (int i = x - 1; i < x + 3; i++)
		{
			for (int j = y - 2; j < y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = default(Tile);
				}
				if (Main.tile[i, j].active())
				{
					flag = false;
				}
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = default(Tile);
			}
			if (!SolidTile2(i, y + 1) && i != x - 1 && i != x + 2)
			{
				flag = false;
			}
		}
		int num = 72 * style;
		int num2 = 0;
		if (flag)
		{
			Main.tile[x - 1, y - 2].active(active: true);
			Main.tile[x - 1, y - 2].frameY = (short)num2;
			Main.tile[x - 1, y - 2].frameX = (short)num;
			Main.tile[x - 1, y - 2].type = type;
			Main.tile[x, y - 2].active(active: true);
			Main.tile[x, y - 2].frameY = (short)num2;
			Main.tile[x, y - 2].frameX = (short)(18 + num);
			Main.tile[x, y - 2].type = type;
			Main.tile[x + 1, y - 2].active(active: true);
			Main.tile[x + 1, y - 2].frameY = (short)num2;
			Main.tile[x + 1, y - 2].frameX = (short)(36 + num);
			Main.tile[x + 1, y - 2].type = type;
			Main.tile[x + 2, y - 2].active(active: true);
			Main.tile[x + 2, y - 2].frameY = (short)num2;
			Main.tile[x + 2, y - 2].frameX = (short)(54 + num);
			Main.tile[x + 2, y - 2].type = type;
			Main.tile[x - 1, y - 1].active(active: true);
			Main.tile[x - 1, y - 1].frameY = (short)(num2 + 18);
			Main.tile[x - 1, y - 1].frameX = (short)num;
			Main.tile[x - 1, y - 1].type = type;
			Main.tile[x, y - 1].active(active: true);
			Main.tile[x, y - 1].frameY = (short)(num2 + 18);
			Main.tile[x, y - 1].frameX = (short)(18 + num);
			Main.tile[x, y - 1].type = type;
			Main.tile[x + 1, y - 1].active(active: true);
			Main.tile[x + 1, y - 1].frameY = (short)(num2 + 18);
			Main.tile[x + 1, y - 1].frameX = (short)(36 + num);
			Main.tile[x + 1, y - 1].type = type;
			Main.tile[x + 2, y - 1].active(active: true);
			Main.tile[x + 2, y - 1].frameY = (short)(num2 + 18);
			Main.tile[x + 2, y - 1].frameX = (short)(54 + num);
			Main.tile[x + 2, y - 1].type = type;
			Main.tile[x - 1, y].active(active: true);
			Main.tile[x - 1, y].frameY = (short)(num2 + 36);
			Main.tile[x - 1, y].frameX = (short)num;
			Main.tile[x - 1, y].type = type;
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = (short)(num2 + 36);
			Main.tile[x, y].frameX = (short)(18 + num);
			Main.tile[x, y].type = type;
			Main.tile[x + 1, y].active(active: true);
			Main.tile[x + 1, y].frameY = (short)(num2 + 36);
			Main.tile[x + 1, y].frameX = (short)(36 + num);
			Main.tile[x + 1, y].type = type;
			Main.tile[x + 2, y].active(active: true);
			Main.tile[x + 2, y].frameY = (short)(num2 + 36);
			Main.tile[x + 2, y].frameX = (short)(54 + num);
			Main.tile[x + 2, y].type = type;
		}
	}

	public static void SwitchMB(int i, int j)
	{
		int num = i;
		int num2 = j;
		Tile tile = Main.tile[i, j];
		int num3;
		for (num3 = tile.frameY / 18; num3 >= 2; num3 -= 2)
		{
		}
		tile = Main.tile[i, j];
		int num4 = tile.frameX / 18;
		if (num4 >= 2)
		{
			num4 -= 2;
		}
		num = i - num4;
		num2 = j - num3;
		for (int k = num; k < num + 2; k++)
		{
			for (int l = num2; l < num2 + 2; l++)
			{
				if (Main.tile[k, l] == null)
				{
					tile = (Main.tile[k, l] = default(Tile));
				}
				tile = Main.tile[k, l];
				if (!tile.active())
				{
					continue;
				}
				tile = Main.tile[k, l];
				if (tile.type != 139)
				{
					tile = Main.tile[k, l];
					if (tile.type != 35 && !TileLoader.IsModMusicBox(Main.tile[k, l]))
					{
						continue;
					}
				}
				tile = Main.tile[k, l];
				if (tile.frameX < 36)
				{
					tile = Main.tile[k, l];
					tile.frameX += 36;
				}
				else
				{
					tile = Main.tile[k, l];
					tile.frameX -= 36;
				}
			}
		}
		if (Wiring.running)
		{
			Wiring.SkipWire(num, num2);
			Wiring.SkipWire(num + 1, num2);
			Wiring.SkipWire(num, num2 + 1);
			Wiring.SkipWire(num + 1, num2 + 1);
		}
		NetMessage.SendTileSquare(-1, num, num2, 2, 2);
	}

	public static void SwitchMonolith(int i, int j)
	{
		int num = i;
		int num2 = j;
		int num3;
		for (num3 = Main.tile[i, j].frameX / 18; num3 >= 2; num3 -= 2)
		{
		}
		int num4;
		for (num4 = Main.tile[i, j].frameY / 18; num4 >= 3; num4 -= 3)
		{
		}
		num = i - num3;
		num2 = j - num4;
		for (int k = num; k < num + 2; k++)
		{
			for (int l = num2; l < num2 + 3; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = default(Tile);
				}
				Tile tile = Main.tile[k, l];
				if (!tile.active())
				{
					continue;
				}
				if (tile.type == 410)
				{
					if (tile.frameY < 56)
					{
						tile.frameY += 56;
					}
					else
					{
						tile.frameY -= 56;
					}
				}
				else if (tile.type == 480)
				{
					if (tile.frameY < 54)
					{
						tile.frameY += 54;
					}
					else
					{
						tile.frameY -= 54;
					}
				}
				else if (tile.type == 509)
				{
					if (tile.frameY < 54)
					{
						tile.frameY += 54;
					}
					else
					{
						tile.frameY -= 54;
					}
				}
				else if (tile.type == 657)
				{
					if (tile.frameY < 54)
					{
						tile.frameY += 54;
					}
					else
					{
						tile.frameY -= 54;
					}
				}
				else if (tile.type == 658)
				{
					short num5 = 54;
					short num6 = 3;
					short num7 = (short)(num5 * num6);
					tile.frameY += num5;
					if (tile.frameY >= num7)
					{
						tile.frameY -= num7;
					}
				}
			}
		}
		if (Wiring.running)
		{
			Wiring.SkipWire(num, num2);
			Wiring.SkipWire(num, num2 + 1);
			Wiring.SkipWire(num, num2 + 2);
			Wiring.SkipWire(num + 1, num2);
			Wiring.SkipWire(num + 1, num2 + 1);
			Wiring.SkipWire(num + 1, num2 + 2);
		}
		NetMessage.SendTileSquare(-1, num, num2, 2, 3);
	}

	public static void SwitchFountain(int i, int j)
	{
		int num = i;
		int num2 = j;
		Tile tile = Main.tile[i, j];
		int num3;
		for (num3 = tile.frameX / 18; num3 >= 2; num3 -= 2)
		{
		}
		tile = Main.tile[i, j];
		int num4 = tile.frameY / 18;
		if (num4 >= 4)
		{
			num4 -= 4;
		}
		num = i - num3;
		num2 = j - num4;
		for (int k = num; k < num + 2; k++)
		{
			for (int l = num2; l < num2 + 4; l++)
			{
				if (Main.tile[k, l] == null)
				{
					tile = (Main.tile[k, l] = default(Tile));
				}
				tile = Main.tile[k, l];
				if (!tile.active())
				{
					continue;
				}
				tile = Main.tile[k, l];
				if (tile.type == 207)
				{
					tile = Main.tile[k, l];
					if (tile.frameY < 72)
					{
						tile = Main.tile[k, l];
						tile.frameY += 72;
					}
					else
					{
						tile = Main.tile[k, l];
						tile.frameY -= 72;
					}
				}
			}
		}
		if (Wiring.running)
		{
			Wiring.SkipWire(num, num2);
			Wiring.SkipWire(num, num2 + 1);
			Wiring.SkipWire(num, num2 + 2);
			Wiring.SkipWire(num, num2 + 3);
			Wiring.SkipWire(num + 1, num2);
			Wiring.SkipWire(num + 1, num2 + 1);
			Wiring.SkipWire(num + 1, num2 + 2);
			Wiring.SkipWire(num + 1, num2 + 3);
		}
		NetMessage.SendTileSquare(-1, num, num2, 2, 4);
	}

	public static void CheckMB(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = i;
		int num2 = j;
		int num3 = 0;
		int num4;
		for (num4 = Main.tile[i, j].frameY / 18; num4 >= 2; num4 -= 2)
		{
			num3++;
		}
		int num5 = Main.tile[i, j].frameX / 18;
		int num6 = 0;
		if (num5 >= 2)
		{
			num5 -= 2;
			num6++;
		}
		num = i - num5;
		num2 = j - num4;
		for (int k = num; k < num + 2; k++)
		{
			for (int l = num2; l < num2 + 2; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = default(Tile);
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num) * 18 + num6 * 36 || Main.tile[k, l].frameY != (l - num2) * 18 + num3 * 36)
				{
					flag = true;
				}
			}
			if (!Main.tile[k, num2 + 2].nactive())
			{
				flag = true;
			}
			else if (!Main.tileSolid[Main.tile[k, num2 + 2].type] && !Main.tileTable[Main.tile[k, num2 + 2].type])
			{
				flag = true;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(i, j, type);
		for (int m = num; m < num + 2; m++)
		{
			for (int n = num2; n < num2 + 3; n++)
			{
				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
				{
					KillTile(m, n);
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			if (type == 35)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1813);
			}
			else if (num3 == 28)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1963);
			}
			else if (num3 == 29)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1964);
			}
			else if (num3 == 30)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1965);
			}
			else if (num3 == 31)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2742);
			}
			else if (num3 == 32)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3044);
			}
			else if (num3 == 33)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3235);
			}
			else if (num3 == 34)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3236);
			}
			else if (num3 == 35)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3237);
			}
			else if (num3 == 36)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3370);
			}
			else if (num3 == 37)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3371);
			}
			else if (num3 == 38)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3796);
			}
			else if (num3 == 39)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3869);
			}
			else if (num3 == 43)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4077);
			}
			else if (num3 == 41)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4078);
			}
			else if (num3 == 42)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4079);
			}
			else if (num3 == 44)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4080);
			}
			else if (num3 == 45)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4081);
			}
			else if (num3 == 40)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4082);
			}
			else if (num3 == 46)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4237);
			}
			else if (num3 == 47)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4356);
			}
			else if (num3 == 48)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4357);
			}
			else if (num3 == 49)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4358);
			}
			else if (num3 == 50)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4421);
			}
			else if (num3 == 51)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4606);
			}
			else if (num3 == 52)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4979);
			}
			else if (num3 == 53)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4985);
			}
			else if (num3 == 54)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4990);
			}
			else if (num3 == 55)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4991);
			}
			else if (num3 == 56)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4992);
			}
			else if (num3 == 57)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5006);
			}
			else if (num3 == 58)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5014);
			}
			else if (num3 == 59)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5015);
			}
			else if (num3 == 60)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5016);
			}
			else if (num3 == 61)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5017);
			}
			else if (num3 == 62)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5018);
			}
			else if (num3 == 63)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5019);
			}
			else if (num3 == 64)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5020);
			}
			else if (num3 == 65)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5021);
			}
			else if (num3 == 66)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5022);
			}
			else if (num3 == 67)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5023);
			}
			else if (num3 == 68)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5024);
			}
			else if (num3 == 69)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5025);
			}
			else if (num3 == 70)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5026);
			}
			else if (num3 == 71)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5027);
			}
			else if (num3 == 72)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5028);
			}
			else if (num3 == 73)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5029);
			}
			else if (num3 == 74)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5030);
			}
			else if (num3 == 75)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5031);
			}
			else if (num3 == 76)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5032);
			}
			else if (num3 == 77)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5033);
			}
			else if (num3 == 78)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5034);
			}
			else if (num3 == 79)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5035);
			}
			else if (num3 == 80)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5036);
			}
			else if (num3 == 81)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5037);
			}
			else if (num3 == 82)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5038);
			}
			else if (num3 == 83)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5039);
			}
			else if (num3 == 84)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5040);
			}
			else if (num3 == 85)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5044);
			}
			else if (num3 == 86)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5112);
			}
			else if (num3 == 87)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5362);
			}
			else if (num3 >= 13)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1596 + num3 - 13);
			}
			else
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 562 + num3);
			}
			for (int num7 = num - 1; num7 < num + 3; num7++)
			{
				for (int num8 = num2 - 1; num8 < num2 + 3; num8++)
				{
					TileFrame(num7, num8);
				}
			}
			destroyObject = false;
		}
	}

	public static void PlaceMB(int X, int y, ushort type, int style)
	{
		int num = X + 1;
		if (num < 5 || num > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
		{
			return;
		}
		bool flag = true;
		for (int i = num - 1; i < num + 1; i++)
		{
			for (int j = y - 1; j < y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = default(Tile);
				}
				if (Main.tile[i, j].active())
				{
					flag = false;
				}
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = default(Tile);
			}
			if (!Main.tile[i, y + 1].active() || Main.tile[i, y + 1].halfBrick() || (!Main.tileSolid[Main.tile[i, y + 1].type] && !Main.tileTable[Main.tile[i, y + 1].type]))
			{
				flag = false;
			}
		}
		if (flag)
		{
			Main.tile[num - 1, y - 1].active(active: true);
			Main.tile[num - 1, y - 1].frameY = (short)(style * 36);
			Main.tile[num - 1, y - 1].frameX = 0;
			Main.tile[num - 1, y - 1].type = type;
			Main.tile[num, y - 1].active(active: true);
			Main.tile[num, y - 1].frameY = (short)(style * 36);
			Main.tile[num, y - 1].frameX = 18;
			Main.tile[num, y - 1].type = type;
			Main.tile[num - 1, y].active(active: true);
			Main.tile[num - 1, y].frameY = (short)(style * 36 + 18);
			Main.tile[num - 1, y].frameX = 0;
			Main.tile[num - 1, y].type = type;
			Main.tile[num, y].active(active: true);
			Main.tile[num, y].frameY = (short)(style * 36 + 18);
			Main.tile[num, y].frameX = 18;
			Main.tile[num, y].type = type;
		}
	}

	public static void Place2x2(int x, int y, ushort type, int style)
	{
		if (type == 95 || type == 126)
		{
			y++;
		}
		if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
		{
			return;
		}
		if (type == 172)
		{
			if (!CanPlaceSink(x, y, type, style))
			{
				return;
			}
		}
		else
		{
			for (int i = x - 1; i < x + 1; i++)
			{
				for (int j = y - 1; j < y + 1; j++)
				{
					Tile tileSafely2 = Framing.GetTileSafely(i, j);
					if (tileSafely2.active() || (type == 98 && tileSafely2.liquid > 0))
					{
						return;
					}
				}
				switch (type)
				{
				case 95:
				case 126:
				{
					Tile tileSafely3 = Framing.GetTileSafely(i, y - 2);
					if (!tileSafely3.nactive() || !Main.tileSolid[tileSafely3.type] || Main.tileSolidTop[tileSafely3.type])
					{
						return;
					}
					break;
				}
				default:
				{
					Tile tileSafely4 = Framing.GetTileSafely(i, y + 1);
					if (!tileSafely4.nactive() || (!SolidTile2(tileSafely4) && !Main.tileTable[tileSafely4.type]))
					{
						return;
					}
					break;
				}
				case 132:
					break;
				}
			}
		}
		if (type == 132)
		{
			bool flag = true;
			if (Main.tile[x - 1, y + 1] == null)
			{
				Main.tile[x - 1, y + 1] = default(Tile);
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = default(Tile);
			}
			if (!Main.tile[x - 1, y + 1].nactive() || (!SolidTile2(x - 1, y + 1) && !Main.tileTable[Main.tile[x - 1, y + 1].type]))
			{
				flag = false;
			}
			if (!Main.tile[x, y + 1].nactive() || (!SolidTile2(x, y + 1) && !Main.tileTable[Main.tile[x, y + 1].type]))
			{
				flag = false;
			}
			if (!flag && (Main.tile[x - 1, y - 1].wall < 1 || Main.tile[x, y - 1].wall < 1 || Main.tile[x - 1, y].wall < 1 || Main.tile[x - 1, y].wall < 1))
			{
				return;
			}
		}
		x--;
		y--;
		int num = ((type == 172) ? 38 : 36);
		for (int k = 0; k < 2; k++)
		{
			for (int l = 0; l < 2; l++)
			{
				Tile tileSafely = Main.tile[x + k, y + l];
				tileSafely.active(active: true);
				tileSafely.frameX = (short)(k * 18);
				tileSafely.frameY = (short)(style * num + l * 18);
				tileSafely.type = type;
			}
		}
	}

	public static bool PlaceObject(int x, int y, int type, bool mute = false, int style = 0, int alternate = 0, int random = -1, int direction = -1)
	{
		if (!TileObject.CanPlace(x, y, type, style, direction, out var objectData))
		{
			return false;
		}
		objectData.random = random;
		if (TileObject.Place(objectData))
		{
			SquareTileFrame(x, y);
			if (!mute)
			{
				SoundEngine.PlaySound(0, x * 16, y * 16);
			}
		}
		return true;
	}

	public static bool ShiftTrapdoor(int x, int y, bool playerAbove, int onlyCloseOrOpen = -1)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		Tile tileSafely = Framing.GetTileSafely(x, y);
		if (tileSafely.type == 386 && onlyCloseOrOpen != 1)
		{
			Point topLeftAndStyles = GetTopLeftAndStyles(ref x, ref y, 2, 2, 18, 18);
			if (topLeftAndStyles.X == 0)
			{
				if (Main.netMode != 1 && Wiring.running)
				{
					Wiring.SkipWire(x, y);
					Wiring.SkipWire(x, y + 1);
					Wiring.SkipWire(x + 1, y);
					Wiring.SkipWire(x + 1, y + 1);
				}
				if (!Collision.EmptyTile(x, y + 1, ignoreTiles: true) || !Collision.EmptyTile(x + 1, y + 1, ignoreTiles: true))
				{
					return false;
				}
				SoundEngine.PlaySound(8, x * 16 + 16, y * 16 + 16);
				for (int i = 0; i < 2; i++)
				{
					Framing.GetTileSafely(x + i, y).ClearTile();
				}
				for (int j = 0; j < 2; j++)
				{
					tileSafely = Framing.GetTileSafely(x + j, y + 1);
					tileSafely.type = 387;
					tileSafely.frameX = (short)(j * 18);
					tileSafely.frameY = (short)(topLeftAndStyles.Y * 18);
				}
				for (int k = -1; k < 3; k++)
				{
					for (int l = 0; l < 3; l++)
					{
						TileFrame(x + k, y + l);
					}
				}
				return true;
			}
			if (topLeftAndStyles.X == 1)
			{
				if (Main.netMode != 1 && Wiring.running)
				{
					Wiring.SkipWire(x, y - 1);
					Wiring.SkipWire(x, y);
					Wiring.SkipWire(x + 1, y - 1);
					Wiring.SkipWire(x + 1, y);
				}
				if (!Collision.EmptyTile(x, y, ignoreTiles: true) || !Collision.EmptyTile(x + 1, y, ignoreTiles: true))
				{
					return false;
				}
				SoundEngine.PlaySound(8, x * 16 + 16, y * 16);
				for (int m = 0; m < 2; m++)
				{
					Framing.GetTileSafely(x + m, y + 1).ClearTile();
				}
				for (int n = 0; n < 2; n++)
				{
					tileSafely = Framing.GetTileSafely(x + n, y);
					tileSafely.type = 387;
					tileSafely.frameX = (short)(n * 18);
					tileSafely.frameY = (short)(topLeftAndStyles.Y * 18);
				}
				for (int num = -1; num < 3; num++)
				{
					for (int num2 = -1; num2 < 2; num2++)
					{
						TileFrame(x + num, y + num2);
					}
				}
				return true;
			}
		}
		if (tileSafely.type == 387 && onlyCloseOrOpen != 0)
		{
			GetTopLeftAndStyles(ref x, ref y, 2, 1, 18, 18);
			int num3 = playerAbove.ToDirectionInt();
			for (int num4 = 0; num4 < 2; num4++)
			{
				tileSafely = Framing.GetTileSafely(x + num4, y + num3);
				if (tileSafely.active() && !Main.tileCut[tileSafely.type])
				{
					return false;
				}
			}
			if (Main.netMode != 1 && Wiring.running)
			{
				Wiring.SkipWire(x, y);
				Wiring.SkipWire(x, y + num3);
				Wiring.SkipWire(x + 1, y);
				Wiring.SkipWire(x + 1, y + num3);
			}
			SoundEngine.PlaySound(8, x * 16 + 16, y * 16);
			for (int num5 = 0; num5 < 2; num5++)
			{
				tileSafely = Framing.GetTileSafely(x + num5, y + num3);
				if (tileSafely.active() && Main.tileCut[tileSafely.type])
				{
					KillTile(x + num5, y + num3);
				}
			}
			for (int num6 = 0; num6 < 2; num6++)
			{
				TileColorCache cache = Framing.GetTileSafely(x + num6, y).BlockColorAndCoating();
				for (int num7 = 0; num7 < 2; num7++)
				{
					tileSafely = Framing.GetTileSafely(x + num6, y + num7 - (!playerAbove).ToInt());
					tileSafely.type = 386;
					tileSafely.frameX = (short)(num6 * 18 + playerAbove.ToInt() * 36);
					tileSafely.frameY = (short)(num7 * 18);
					tileSafely.UseBlockColors(cache);
					tileSafely.active(active: true);
				}
			}
			for (int num8 = -1; num8 < 3; num8++)
			{
				for (int num9 = -1; num9 < 3; num9++)
				{
					TileFrame(x + num8, y + num9 - (!playerAbove).ToInt() * 2);
				}
			}
			return true;
		}
		SoundEngine.PlaySound(9, x * 16, y * 16);
		return false;
	}

	public static void CheckTrapDoor(int x, int y, int type)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = 0;
		int num2 = 0;
		Point point = default(Point);
		if (type == 387)
		{
			num = 2;
			num2 = 1;
			point = GetTopLeftAndStyles(ref x, ref y, num, num2, 18, 18);
			flag = flag || !CheckTileFrames(type, x, y, num, num2, point.X, 18, point.Y, 18) || !CheckTileAnchors(x, y, num, num2, 1, AnchorType.SolidTile);
		}
		if (type == 386)
		{
			num = 2;
			num2 = 2;
			point = GetTopLeftAndStyles(ref x, ref y, num, num2, 18, 18);
			flag = flag || !CheckTileFrames(type, x, y, num, num2, point.X, 18, point.Y, 18);
			if (point.X == 0)
			{
				flag = flag || !CheckTileAnchors(x, y + 1, num, 1, 1, AnchorType.SolidTile);
			}
			else if (point.X == 1)
			{
				flag = flag || !CheckTileAnchors(x, y, num, 1, 1, AnchorType.SolidTile);
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(x, y, type);
		for (int i = x; i < x + num; i++)
		{
			for (int j = y; j < y + num2; j++)
			{
				KillTile(i, j);
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			int type2 = 3239;
			if (point.Y == 0)
			{
				type2 = 3239;
			}
			Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, num * 16, num2 * 16, type2);
			for (int k = x - 1; k < x + num + 1; k++)
			{
				for (int l = y - 1; l < y + num2 + 1; l++)
				{
					TileFrame(k, l);
				}
			}
			destroyObject = false;
		}
	}

	public static void CheckTallGate(int x, int y, int type)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		Tile tileSafely = Framing.GetTileSafely(x, y);
		Point point = default(Point);
		((Point)(ref point))._002Ector(tileSafely.frameX / 18, 0);
		TileObjectData tileData = TileObjectData.GetTileData(type, point.X);
		point.Y = tileSafely.frameY / tileData.CoordinateFullHeight;
		int width = tileData.Width;
		int height = tileData.Height;
		int i = 0;
		for (int num = tileSafely.frameY % tileData.CoordinateFullHeight; i < height && num - tileData.CoordinateHeights[i] >= 0; i++)
		{
			num -= tileData.CoordinateHeights[i];
		}
		_ = tileData.CoordinateFullHeight;
		y -= i;
		int num2 = point.Y * tileData.CoordinateFullHeight;
		for (int j = 0; j < height; j++)
		{
			tileSafely = Framing.GetTileSafely(x, y + j);
			if (tileSafely.frameX != point.X * tileData.CoordinateFullWidth || tileSafely.frameY != num2)
			{
				flag = true;
				break;
			}
			num2 += tileData.CoordinateHeights[j] + tileData.CoordinatePadding;
		}
		if (!flag && CheckTileAnchors(x, y, width, height, 2, AnchorType.SolidTile))
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(x, y, type);
		for (int k = x; k < x + width; k++)
		{
			for (int l = y; l < y + height; l++)
			{
				KillTile(k, l);
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			int type2 = 3240;
			if (point.Y == 0)
			{
				type2 = 3240;
			}
			Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, width * 16, height * 16, type2);
			for (int m = x - 1; m < x + width + 1; m++)
			{
				for (int n = y - 1; n < y + height + 1; n++)
				{
					TileFrame(m, n);
				}
			}
			destroyObject = false;
		}
	}

	public static bool ShiftTallGate(int x, int y, bool closing, bool forced = false)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		ushort type = (ushort)(closing ? 388u : 389u);
		ushort num = (ushort)(closing ? 389u : 388u);
		Tile tileSafely = Framing.GetTileSafely(x, y);
		if (tileSafely.type != num)
		{
			return false;
		}
		Point point = default(Point);
		((Point)(ref point))._002Ector(tileSafely.frameX / 18, 0);
		TileObjectData tileData = TileObjectData.GetTileData(388, point.X);
		point.Y = tileSafely.frameY / tileData.CoordinateFullHeight;
		_ = tileData.Width;
		int height = tileData.Height;
		int i = 0;
		for (int num2 = tileSafely.frameY % tileData.CoordinateFullHeight; i < height && num2 - tileData.CoordinateHeights[i] >= 0; i++)
		{
			num2 -= tileData.CoordinateHeights[i];
		}
		_ = tileData.CoordinateFullHeight;
		y -= i;
		if (Main.netMode != 1 && Wiring.running)
		{
			for (int j = 0; j < height; j++)
			{
				Wiring.SkipWire(x, y + j);
			}
		}
		for (int k = 0; k < height; k++)
		{
			if (!forced && !Collision.EmptyTile(x, y + k, ignoreTiles: true))
			{
				return false;
			}
		}
		SoundEngine.PlaySound(8, x * 16 + 16, y * 16 + 16);
		for (int l = 0; l < height; l++)
		{
			Framing.GetTileSafely(x, y + l).type = type;
		}
		for (int m = -1; m < 2; m++)
		{
			for (int n = -1; n < height + 1; n++)
			{
				TileFrame(x + m, y + n);
			}
		}
		return true;
	}

	public static Point GetTopLeftAndStyles(ref int x, ref int y, int w, int h, int frameXinc, int frameYinc)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Tile tileSafely = Framing.GetTileSafely(x, y);
		Point result = new Point(tileSafely.frameX / (w * frameXinc), tileSafely.frameY / (h * frameYinc));
		if (frameXinc != 0)
		{
			x -= tileSafely.frameX / frameXinc % w;
		}
		if (frameYinc != 0)
		{
			y -= tileSafely.frameY / frameYinc % h;
		}
		return result;
	}

	public static bool CheckTileFrames(int type, int sx, int sy, int w, int h, int styleX, int frameXinc, int styleY, int frameYinc)
	{
		for (int i = 0; i < w; i++)
		{
			for (int j = 0; j < h; j++)
			{
				Tile tileSafely = Framing.GetTileSafely(sx + i, sy + j);
				if (!tileSafely.active() || tileSafely.type != type || tileSafely.frameX != styleX * w * frameXinc + i * frameXinc || tileSafely.frameY != styleY * h * frameYinc + j * frameYinc)
				{
					return false;
				}
			}
		}
		return true;
	}

	public static bool CheckTileAnchors(int sx, int sy, int w, int h, int mode, AnchorType anchor)
	{
		if ((mode & 1) == 1)
		{
			for (int i = sy; i < sy + h; i++)
			{
				if (!AnchorValid(Framing.GetTileSafely(sx - 1, i), anchor))
				{
					return false;
				}
				if (!AnchorValid(Framing.GetTileSafely(sx + w, i), anchor))
				{
					return false;
				}
			}
		}
		if ((mode & 2) == 2)
		{
			for (int j = sx; j < sx + w; j++)
			{
				if (!AnchorValid(Framing.GetTileSafely(j, sy - 1), anchor))
				{
					return false;
				}
				if (!AnchorValid(Framing.GetTileSafely(j, sy + h), anchor))
				{
					return false;
				}
			}
		}
		return true;
	}

	public static bool AnchorValid(Tile tileCache, AnchorType anchor)
	{
		bool flag = false;
		if (tileCache.nactive())
		{
			if ((anchor & AnchorType.SolidTile) == AnchorType.SolidTile && Main.tileSolid[tileCache.type] && !Main.tileSolidTop[tileCache.type] && !Main.tileNoAttach[tileCache.type] && tileCache.blockType() == 0)
			{
				flag = true;
			}
			if ((anchor & AnchorType.SolidBottom) == AnchorType.SolidBottom && ((Main.tileSolid[tileCache.type] && (!Main.tileSolidTop[tileCache.type] || (TileID.Sets.Platforms[tileCache.type] && (tileCache.halfBrick() || tileCache.topSlope())))) || tileCache.topSlope() || tileCache.halfBrick()) && !TileID.Sets.NotReallySolid[tileCache.type] && !tileCache.bottomSlope())
			{
				flag = true;
			}
			if (!flag && ((anchor & AnchorType.SolidWithTop) == AnchorType.SolidWithTop || (anchor & AnchorType.Table) == AnchorType.Table))
			{
				if (TileID.Sets.Platforms[tileCache.type])
				{
					int num = tileCache.frameX / TileObjectData.PlatformFrameWidth();
					if ((!tileCache.halfBrick() && num >= 0 && num <= 7) || (num >= 12 && num <= 16) || (num >= 25 && num <= 26))
					{
						flag = true;
					}
				}
				else if (Main.tileSolid[tileCache.type] && Main.tileSolidTop[tileCache.type])
				{
					flag = true;
				}
			}
			if (!flag && (anchor & AnchorType.Table) == AnchorType.Table && !TileID.Sets.Platforms[tileCache.type] && Main.tileTable[tileCache.type] && tileCache.blockType() == 0)
			{
				flag = true;
			}
			if (!flag && (anchor & AnchorType.SolidSide) == AnchorType.SolidSide && Main.tileSolid[tileCache.type] && !Main.tileSolidTop[tileCache.type] && (uint)(tileCache.blockType() - 4) <= 1u)
			{
				flag = true;
			}
		}
		else if (!flag && (anchor & AnchorType.EmptyTile) == AnchorType.EmptyTile)
		{
			flag = true;
		}
		return flag;
	}

	public static bool CanPlaceSink(int x, int y, ushort type, int style)
	{
		if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
		{
			return false;
		}
		bool result = true;
		x--;
		y--;
		for (int i = 0; i < 2; i++)
		{
			for (int j = 0; j < 2; j++)
			{
				if (Framing.GetTileSafely(x + i, y + j).active())
				{
					result = false;
				}
			}
			Tile tileSafely = Framing.GetTileSafely(x + i, y + 2);
			if (!tileSafely.nactive() || !SolidTile(tileSafely))
			{
				result = false;
			}
		}
		return result;
	}

	public static void Place3x4(int x, int y, ushort type, int style)
	{
		if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
		{
			return;
		}
		bool flag = true;
		for (int i = x - 1; i < x + 2; i++)
		{
			for (int j = y - 3; j < y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = default(Tile);
				}
				if (Main.tile[i, j].active())
				{
					flag = false;
				}
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = default(Tile);
			}
			if (!SolidTile2(i, y + 1))
			{
				flag = false;
			}
		}
		if (flag)
		{
			int num = style * 54;
			for (int k = -3; k <= 0; k++)
			{
				short frameY = (short)((3 + k) * 18);
				Main.tile[x - 1, y + k].active(active: true);
				Main.tile[x - 1, y + k].frameY = frameY;
				Main.tile[x - 1, y + k].frameX = (short)num;
				Main.tile[x - 1, y + k].type = type;
				Main.tile[x, y + k].active(active: true);
				Main.tile[x, y + k].frameY = frameY;
				Main.tile[x, y + k].frameX = (short)(num + 18);
				Main.tile[x, y + k].type = type;
				Main.tile[x + 1, y + k].active(active: true);
				Main.tile[x + 1, y + k].frameY = frameY;
				Main.tile[x + 1, y + k].frameX = (short)(num + 36);
				Main.tile[x + 1, y + k].type = type;
			}
		}
	}

	public static void Place5x4(int x, int y, ushort type, int style)
	{
		if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
		{
			return;
		}
		bool flag = true;
		for (int i = x - 2; i < x + 3; i++)
		{
			for (int j = y - 3; j < y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = default(Tile);
				}
				if (Main.tile[i, j].active())
				{
					flag = false;
				}
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = default(Tile);
			}
			if (!SolidTile2(i, y + 1))
			{
				flag = false;
			}
		}
		if (flag)
		{
			int num = style * 54;
			for (int k = -3; k <= 0; k++)
			{
				short frameY = (short)((3 + k) * 18);
				Main.tile[x - 2, y + k].active(active: true);
				Main.tile[x - 2, y + k].frameY = frameY;
				Main.tile[x - 2, y + k].frameX = (short)(num - 36);
				Main.tile[x - 2, y + k].type = type;
				Main.tile[x - 1, y + k].active(active: true);
				Main.tile[x - 1, y + k].frameY = frameY;
				Main.tile[x - 1, y + k].frameX = (short)(num - 18);
				Main.tile[x - 1, y + k].type = type;
				Main.tile[x, y + k].active(active: true);
				Main.tile[x, y + k].frameY = frameY;
				Main.tile[x, y + k].frameX = (short)num;
				Main.tile[x, y + k].type = type;
				Main.tile[x + 1, y + k].active(active: true);
				Main.tile[x + 1, y + k].frameY = frameY;
				Main.tile[x + 1, y + k].frameX = (short)(num + 18);
				Main.tile[x + 1, y + k].type = type;
				Main.tile[x + 1, y + k].active(active: true);
				Main.tile[x + 1, y + k].frameY = frameY;
				Main.tile[x + 1, y + k].frameX = (short)(num + 36);
				Main.tile[x + 1, y + k].type = type;
			}
		}
	}

	public static void Place3x1(int x, int y, ushort type, int style = 0)
	{
		if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
		{
			return;
		}
		bool flag = true;
		for (int i = x - 1; i < x + 2; i++)
		{
			if (Main.tile[i, y] == null)
			{
				Main.tile[i, y] = default(Tile);
			}
			if (Main.tile[i, y].active())
			{
				flag = false;
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = default(Tile);
			}
			if (!SolidTile2(i, y + 1))
			{
				flag = false;
			}
		}
		if (flag)
		{
			short num = (short)(54 * style);
			Main.tile[x - 1, y].active(active: true);
			Main.tile[x - 1, y].frameY = 0;
			Main.tile[x - 1, y].frameX = num;
			Main.tile[x - 1, y].type = type;
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = 0;
			Main.tile[x, y].frameX = (short)(num + 18);
			Main.tile[x, y].type = type;
			Main.tile[x + 1, y].active(active: true);
			Main.tile[x + 1, y].frameY = 0;
			Main.tile[x + 1, y].frameX = (short)(num + 36);
			Main.tile[x + 1, y].type = type;
		}
	}

	public static void Place3x2(int x, int y, ushort type, int style = 0)
	{
		if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
		{
			return;
		}
		bool flag = false;
		bool flag2 = true;
		if (type == 14 && style == 25)
		{
			flag = true;
		}
		int num = y - 1;
		if (flag)
		{
			num = y;
		}
		for (int i = x - 1; i < x + 2; i++)
		{
			for (int j = num; j < y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = default(Tile);
				}
				if (Main.tile[i, j].active())
				{
					flag2 = false;
				}
				if (type == 215 && Main.tile[i, j].liquid > 0)
				{
					flag2 = false;
				}
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = default(Tile);
			}
			switch (type)
			{
			default:
				if (type != 582 && type != 619)
				{
					if (type == 26 && TileID.Sets.Boulders[Main.tile[i, y + 1].type])
					{
						flag2 = false;
					}
					if (!SolidTile2(i, y + 1))
					{
						flag2 = false;
					}
					continue;
				}
				break;
			case 285:
			case 286:
			case 298:
			case 299:
			case 310:
			case 361:
			case 362:
			case 363:
			case 364:
				break;
			}
			if (!SolidTile2(i, y + 1) && (!Main.tile[i, y + 1].nactive() || !Main.tileSolidTop[Main.tile[i, y + 1].type] || Main.tile[i, y + 1].frameY != 0))
			{
				flag2 = false;
			}
		}
		if (TileID.Sets.BasicDresser[type])
		{
			if (Chest.CreateChest(x - 1, y - 1) == -1)
			{
				flag2 = false;
			}
			else if (Main.netMode == 1)
			{
				NetMessage.SendData(34, -1, -1, null, 2, x, y, style);
			}
		}
		if (flag2)
		{
			short num2 = (short)(54 * style);
			if (flag)
			{
				Main.tile[x - 1, y].active(active: true);
				Main.tile[x - 1, y].frameY = 0;
				Main.tile[x - 1, y].frameX = num2;
				Main.tile[x - 1, y].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = 0;
				Main.tile[x, y].frameX = (short)(num2 + 18);
				Main.tile[x, y].type = type;
				Main.tile[x + 1, y].active(active: true);
				Main.tile[x + 1, y].frameY = 0;
				Main.tile[x + 1, y].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y].type = type;
				return;
			}
			Main.tile[x - 1, y - 1].active(active: true);
			Main.tile[x - 1, y - 1].frameY = 0;
			Main.tile[x - 1, y - 1].frameX = num2;
			Main.tile[x - 1, y - 1].type = type;
			Main.tile[x, y - 1].active(active: true);
			Main.tile[x, y - 1].frameY = 0;
			Main.tile[x, y - 1].frameX = (short)(num2 + 18);
			Main.tile[x, y - 1].type = type;
			Main.tile[x + 1, y - 1].active(active: true);
			Main.tile[x + 1, y - 1].frameY = 0;
			Main.tile[x + 1, y - 1].frameX = (short)(num2 + 36);
			Main.tile[x + 1, y - 1].type = type;
			Main.tile[x - 1, y].active(active: true);
			Main.tile[x - 1, y].frameY = 18;
			Main.tile[x - 1, y].frameX = num2;
			Main.tile[x - 1, y].type = type;
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = 18;
			Main.tile[x, y].frameX = (short)(num2 + 18);
			Main.tile[x, y].type = type;
			Main.tile[x + 1, y].active(active: true);
			Main.tile[x + 1, y].frameY = 18;
			Main.tile[x + 1, y].frameX = (short)(num2 + 36);
			Main.tile[x + 1, y].type = type;
		}
	}

	public static void Place2x2Style(int x, int y, ushort type, int style = 0)
	{
		if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
		{
			return;
		}
		short num = 0;
		if (type == 254)
		{
			num = (short)(x % 12 / 2);
			num *= 36;
		}
		bool flag = true;
		for (int i = x - 1; i < x + 1; i++)
		{
			for (int j = y - 1; j < y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = default(Tile);
				}
				if (Main.tile[i, j].active())
				{
					flag = false;
				}
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = default(Tile);
			}
			if (!SolidTile(i, y + 1))
			{
				flag = false;
			}
			if (type == 254 && Main.tile[i, y + 1].type != 2 && Main.tile[i, y + 1].type != 477 && Main.tile[i, y + 1].type != 492 && Main.tile[i, y + 1].type != 109)
			{
				flag = false;
			}
		}
		if (flag)
		{
			short num2 = (short)(36 * style);
			Main.tile[x - 1, y - 1].active(active: true);
			Main.tile[x - 1, y - 1].frameY = num;
			Main.tile[x - 1, y - 1].frameX = num2;
			Main.tile[x - 1, y - 1].type = type;
			Main.tile[x, y - 1].active(active: true);
			Main.tile[x, y - 1].frameY = num;
			Main.tile[x, y - 1].frameX = (short)(num2 + 18);
			Main.tile[x, y - 1].type = type;
			Main.tile[x - 1, y].active(active: true);
			Main.tile[x - 1, y].frameY = (short)(num + 18);
			Main.tile[x - 1, y].frameX = num2;
			Main.tile[x - 1, y].type = type;
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = (short)(num + 18);
			Main.tile[x, y].frameX = (short)(num2 + 18);
			Main.tile[x, y].type = type;
		}
	}

	public static bool NearFriendlyWall(int x, int y)
	{
		try
		{
			if (x < 2 || x >= Main.maxTilesX - 2 || y < 2 || y >= Main.maxTilesY - 2)
			{
				return true;
			}
			if (Main.tile[x, y].wall == 0 || Main.wallHouse[Main.tile[x, y].wall])
			{
				return true;
			}
			if (Main.tile[x - 1, y].wall == 0 || Main.wallHouse[Main.tile[x - 1, y].wall])
			{
				return true;
			}
			if (Main.tile[x + 1, y].wall == 0 || Main.wallHouse[Main.tile[x + 1, y].wall])
			{
				return true;
			}
			if (Main.tile[x, y - 1].wall == 0 || Main.wallHouse[Main.tile[x, y - 1].wall])
			{
				return true;
			}
			if (Main.tile[x, y + 1].wall == 0 || Main.wallHouse[Main.tile[x, y + 1].wall])
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static void Check2x2Style(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = j;
		int num2;
		for (num2 = Main.tile[i, j].frameY / 18; num2 > 1; num2 -= 2)
		{
		}
		num -= num2;
		int num3 = Main.tile[i, j].frameX / 18;
		int num4 = 0;
		while (num3 > 1)
		{
			num3 -= 2;
			num4++;
		}
		num3 = i - num3;
		int num5 = num4 * 36;
		for (int k = num3; k < num3 + 2; k++)
		{
			for (int l = num; l < num + 2; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = default(Tile);
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num3) * 18 + num5)
				{
					flag = true;
				}
			}
			if (!SolidTileAllowBottomSlope(k, num + 2))
			{
				flag = true;
			}
			else
			{
				if (type != 254)
				{
					continue;
				}
				Tile tile = Main.tile[k, num + 2];
				if (tile != null && tile.active() && tile.type >= 0 && tile.type < TileID.Count)
				{
					ushort type2 = tile.type;
					if (type2 != 2 && type2 != 109 && type2 != 477 && type2 != 492)
					{
						flag = true;
					}
				}
			}
		}
		if (!flag)
		{
			return;
		}
		int frameX = Main.tile[i, j].frameX;
		destroyObject = true;
		bool drop = TileLoader.Drop(i, j, type);
		for (int m = num3; m < num3 + 2; m++)
		{
			for (int n = num; n < num + 2; n++)
			{
				if (Main.tile[m, n] == null)
				{
					Main.tile[m, n] = default(Tile);
				}
				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
				{
					KillTile(m, n);
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			switch (type)
			{
			case 254:
				if (frameX < 72)
				{
					break;
				}
				if (frameX < 108)
				{
					if (genRand.Next(2) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1725, genRand.Next(1, 3));
					}
					break;
				}
				if (frameX < 144)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1725, genRand.Next(2, 6));
					break;
				}
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1725, genRand.Next(5, 11));
				if (Main.halloween && genRand.Next(200) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1799);
				}
				break;
			case 457:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3749);
				break;
			case 96:
				if (num4 == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 345);
				}
				if (num4 == 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1791);
				}
				break;
			case 441:
			{
				int num7 = -1;
				switch (num4)
				{
				case 0:
					num7 = 3665;
					break;
				case 1:
					num7 = 3666;
					break;
				case 3:
					num7 = 3667;
					break;
				case 7:
					num7 = 3668;
					break;
				case 8:
					num7 = 3669;
					break;
				case 9:
					num7 = 3670;
					break;
				case 10:
					num7 = 3671;
					break;
				case 11:
					num7 = 3672;
					break;
				case 12:
					num7 = 3673;
					break;
				case 13:
					num7 = 3674;
					break;
				case 14:
					num7 = 3675;
					break;
				case 15:
					num7 = 3676;
					break;
				case 16:
					num7 = 3677;
					break;
				case 17:
					num7 = 3678;
					break;
				case 18:
					num7 = 3679;
					break;
				case 19:
					num7 = 3680;
					break;
				case 20:
					num7 = 3681;
					break;
				case 21:
					num7 = 3682;
					break;
				case 22:
					num7 = 3683;
					break;
				case 28:
					num7 = 3684;
					break;
				case 29:
					num7 = 3685;
					break;
				case 30:
					num7 = 3686;
					break;
				case 31:
					num7 = 3687;
					break;
				case 32:
					num7 = 3688;
					break;
				case 33:
					num7 = 3689;
					break;
				case 34:
					num7 = 3690;
					break;
				case 35:
					num7 = 3691;
					break;
				case 37:
					num7 = 3692;
					break;
				case 39:
					num7 = 3693;
					break;
				case 41:
					num7 = 3694;
					break;
				case 42:
					num7 = 3695;
					break;
				case 43:
					num7 = 3696;
					break;
				case 44:
					num7 = 3697;
					break;
				case 45:
					num7 = 3698;
					break;
				case 46:
					num7 = 3699;
					break;
				case 47:
					num7 = 3700;
					break;
				case 48:
					num7 = 3701;
					break;
				case 49:
					num7 = 3702;
					break;
				case 50:
					num7 = 3703;
					break;
				case 51:
					num7 = 3704;
					break;
				}
				if (num7 != -1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, num7);
				}
				break;
			}
			case 468:
			{
				int num6 = -1;
				switch (num4)
				{
				case 0:
					num6 = 3886;
					break;
				case 1:
					num6 = 3887;
					break;
				case 2:
					num6 = 3950;
					break;
				case 3:
					num6 = 3976;
					break;
				case 4:
					num6 = -1;
					break;
				case 5:
					num6 = 4164;
					break;
				case 6:
					num6 = 4185;
					break;
				case 7:
					num6 = 4206;
					break;
				case 8:
					num6 = 4227;
					break;
				case 9:
					num6 = 4266;
					break;
				case 10:
					num6 = 4268;
					break;
				case 11:
					num6 = 4585;
					break;
				case 12:
					num6 = 4713;
					break;
				case 13:
					num6 = -1;
					break;
				case 14:
					num6 = 5167;
					break;
				case 15:
					num6 = 5188;
					break;
				case 16:
					num6 = 5209;
					break;
				}
				if (num6 != -1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, num6);
				}
				break;
			}
			}
			destroyObject = false;
			for (int num8 = num3 - 1; num8 < num3 + 3; num8++)
			{
				for (int num9 = num - 1; num9 < num + 3; num9++)
				{
					TileFrame(num8, num9);
				}
			}
		}
	}

	public static void PlacePumpkin(int x, int superY)
	{
		ushort type = 254;
		int num = genRand.Next(6) * 36;
		if (x < 5 || x > Main.maxTilesX - 5 || superY < 5 || superY > Main.maxTilesY - 5)
		{
			return;
		}
		bool flag = true;
		for (int i = x - 1; i < x + 1; i++)
		{
			for (int j = superY - 1; j < superY + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = default(Tile);
				}
				if (Main.tile[i, j].active() && Main.tile[i, j].type != 3 && Main.tile[i, j].type != 73 && Main.tile[i, j].type != 113 && Main.tile[i, j].type != 110 && (Main.tile[i, j].type != 185 || Main.tile[i, j].frameY != 0))
				{
					flag = false;
				}
				if (Main.tile[i, j].liquid > 0)
				{
					flag = false;
				}
			}
			if (!SolidTile(i, superY + 1) || (Main.tile[i, superY + 1].type != 2 && Main.tile[i, superY + 1].type != 109))
			{
				flag = false;
			}
		}
		if (flag)
		{
			Main.tile[x - 1, superY - 1].active(active: true);
			Main.tile[x - 1, superY - 1].frameY = (short)num;
			Main.tile[x - 1, superY - 1].frameX = 0;
			Main.tile[x - 1, superY - 1].type = type;
			Main.tile[x, superY - 1].active(active: true);
			Main.tile[x, superY - 1].frameY = (short)num;
			Main.tile[x, superY - 1].frameX = 18;
			Main.tile[x, superY - 1].type = type;
			Main.tile[x - 1, superY].active(active: true);
			Main.tile[x - 1, superY].frameY = (short)(num + 18);
			Main.tile[x - 1, superY].frameX = 0;
			Main.tile[x - 1, superY].type = type;
			Main.tile[x, superY].active(active: true);
			Main.tile[x, superY].frameY = (short)(num + 18);
			Main.tile[x, superY].frameX = 18;
			Main.tile[x, superY].type = type;
		}
	}

	public static void GrowPumpkin(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = j;
		Tile tile = Main.tile[i, j];
		int num2;
		for (num2 = tile.frameY / 18; num2 > 1; num2 -= 2)
		{
		}
		num -= num2;
		tile = Main.tile[i, j];
		int num3 = tile.frameX / 18;
		int num4 = 0;
		while (num3 > 1)
		{
			num3 -= 2;
			num4++;
		}
		num3 = i - num3;
		int num5 = num4 * 36;
		if (num4 >= 4)
		{
			return;
		}
		for (int k = num3; k < num3 + 2; k++)
		{
			for (int l = num; l < num + 2; l++)
			{
				if (Main.tile[k, l] == null)
				{
					tile = (Main.tile[k, l] = default(Tile));
				}
				tile = Main.tile[k, l];
				if (tile.active())
				{
					tile = Main.tile[k, l];
					if (tile.type == type)
					{
						tile = Main.tile[k, l];
						if (tile.frameX == (k - num3) * 18 + num5)
						{
							continue;
						}
					}
				}
				flag = true;
			}
			if (SolidTile(k, num + 2))
			{
				tile = Main.tile[k, num + 2];
				if (tile.type == 2)
				{
					continue;
				}
				tile = Main.tile[k, num + 2];
				if (tile.type == 477)
				{
					continue;
				}
				tile = Main.tile[k, num + 2];
				if (tile.type == 492)
				{
					continue;
				}
				tile = Main.tile[k, num + 2];
				if (tile.type == 109)
				{
					continue;
				}
			}
			flag = true;
		}
		if (!flag)
		{
			for (int m = num3; m < num3 + 2; m++)
			{
				for (int n = num; n < num + 2; n++)
				{
					if (Main.tile[m, n] == null)
					{
						tile = (Main.tile[m, n] = default(Tile));
					}
					tile = Main.tile[m, n];
					if (tile.type == type)
					{
						tile = Main.tile[m, n];
						if (tile.active())
						{
							tile = Main.tile[m, n];
							tile.frameX += 36;
						}
					}
				}
			}
		}
		if (Main.netMode == 2)
		{
			NetMessage.SendTileSquare(-1, num3, num, 2, 2);
		}
	}

	public static void FixHearts()
	{
		for (int i = 0; i < Main.maxTilesX; i++)
		{
			for (int j = 0; j < Main.maxTilesY; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile.active() && tile.type == 12 && tile.frameX == 0 && tile.frameY == 0)
				{
					FixHeart(i, j);
				}
			}
		}
	}

	public static void DestroyHeart(int i, int j)
	{
		destroyObject = true;
		for (int k = i; k < i + 2; k++)
		{
			for (int l = j; l < j + 2; l++)
			{
				if (k < Main.maxTilesX && l < Main.maxTilesY)
				{
					Tile tile = Main.tile[k, l];
					if (tile.active() && tile.type == 12)
					{
						KillTile(k, l);
					}
				}
			}
		}
		destroyObject = false;
	}

	public static void FixHeart(int i, int j)
	{
		if (i < Main.offLimitBorderTiles || i >= Main.maxTilesX - Main.offLimitBorderTiles || j < Main.offLimitBorderTiles || j >= Main.maxTilesY - Main.offLimitBorderTiles)
		{
			DestroyHeart(i, j);
			return;
		}
		Tile tile = Main.tile[i, j + 2];
		Tile tile2 = Main.tile[i + 1, j + 2];
		if (tile.active() && !Main.tileSolid[tile.type] && Main.tileCut[tile.type])
		{
			KillTile(i, j + 2);
		}
		if (tile2.active() && !Main.tileSolid[tile2.type] && Main.tileCut[tile2.type])
		{
			KillTile(i + 1, j + 2);
		}
		if (!tile.active())
		{
			if (!tile2.active())
			{
				DestroyHeart(i, j);
				return;
			}
			if (Main.tileSolid[tile2.type])
			{
				tile.type = tile2.type;
				tile.active(active: true);
			}
		}
		if (!tile2.active() && Main.tileSolid[tile.type])
		{
			tile2.type = tile.type;
			tile2.active(active: true);
		}
		if (!tile.nactive() || !Main.tileSolid[tile.type] || !tile2.nactive() || !Main.tileSolid[tile2.type])
		{
			DestroyHeart(i, j);
			return;
		}
		if (tile.blockType() != 0)
		{
			tile.slope(0);
			tile.halfBrick(halfBrick: false);
		}
		if (tile2.blockType() != 0)
		{
			tile2.slope(0);
			tile2.halfBrick(halfBrick: false);
		}
	}

	public static void FixChands()
	{
		for (int i = 5; i < Main.maxTilesX - 5; i++)
		{
			for (int j = 5; j < Main.maxTilesY - 5; j++)
			{
				if (Main.tile[i, j].active())
				{
					int type = Main.tile[i, j].type;
					if (Main.tile[i, j].active() && (type == 35 || type == 36 || type == 170 || type == 171 || type == 172))
					{
						FixChand(i, j);
					}
				}
			}
		}
	}

	public static void FixChand(int i, int j)
	{
		int num = 0;
		Tile tile = Main.tile[i, j];
		int type = tile.type;
		tile = Main.tile[i, j];
		if (tile.active())
		{
			if (type == 35)
			{
				num = 1;
			}
			if (type == 36)
			{
				num = 2;
			}
			if (type == 170)
			{
				num = 3;
			}
			if (type == 171)
			{
				num = 4;
			}
			if (type == 172)
			{
				num = 5;
			}
		}
		if (num <= 0)
		{
			return;
		}
		int num2 = i;
		int num3 = j;
		tile = Main.tile[i, j];
		for (num2 = tile.frameX / 18; num2 >= 3; num2 -= 3)
		{
		}
		if (num2 >= 3)
		{
			num2 -= 3;
		}
		num2 = i - num2;
		int num4 = num3;
		tile = Main.tile[i, j];
		num3 = num4 + tile.frameY / 18 * -1;
		for (int k = num2; k < num2 + 3; k++)
		{
			for (int l = num3; l < num3 + 3; l++)
			{
				if (Main.tile[k, l] == null)
				{
					tile = (Main.tile[k, l] = default(Tile));
				}
				tile = Main.tile[k, l];
				if (tile.active())
				{
					tile = Main.tile[k, l];
					if (tile.type == type)
					{
						tile = Main.tile[k, l];
						tile.type = 34;
						tile = Main.tile[k, l];
						ref short frameY = ref tile.frameY;
						tile = Main.tile[k, l];
						frameY = (short)(tile.frameY + num * 54);
					}
				}
			}
		}
	}

	public static void PlaceChand(int x, int y, ushort type, int style = 0)
	{
		bool flag = true;
		int num = 0;
		for (int i = x - 1; i < x + 2; i++)
		{
			for (int j = y; j < y + 3; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = default(Tile);
				}
				if (Main.tile[i, j].active())
				{
					flag = false;
				}
			}
		}
		if (Main.tile[x, y - 1] == null)
		{
			Main.tile[x, y - 1] = default(Tile);
		}
		if (!Main.tile[x, y - 1].nactive() || !Main.tileSolid[Main.tile[x, y - 1].type] || Main.tileSolidTop[Main.tile[x, y - 1].type])
		{
			flag = false;
		}
		if (flag)
		{
			int num2 = style / 36 * 18 * 6;
			int num3 = style * 18 * 3;
			Main.tile[x - 1, y + num].active(active: true);
			Main.tile[x - 1, y + num].frameY = (short)num3;
			Main.tile[x - 1, y + num].frameX = (short)num2;
			Main.tile[x - 1, y + num].type = type;
			Main.tile[x, y + num].active(active: true);
			Main.tile[x, y + num].frameY = (short)num3;
			Main.tile[x, y + num].frameX = (short)(num2 + 18);
			Main.tile[x, y + num].type = type;
			Main.tile[x + 1, y + num].active(active: true);
			Main.tile[x + 1, y + num].frameY = (short)num3;
			Main.tile[x + 1, y + num].frameX = (short)(num2 + 36);
			Main.tile[x + 1, y + num].type = type;
			Main.tile[x - 1, y + 1 + num].active(active: true);
			Main.tile[x - 1, y + 1 + num].frameY = (short)(num3 + 18);
			Main.tile[x - 1, y + 1 + num].frameX = (short)num2;
			Main.tile[x - 1, y + 1 + num].type = type;
			Main.tile[x, y + 1 + num].active(active: true);
			Main.tile[x, y + 1 + num].frameY = (short)(num3 + 18);
			Main.tile[x, y + 1 + num].frameX = (short)(num2 + 18);
			Main.tile[x, y + 1 + num].type = type;
			Main.tile[x + 1, y + 1 + num].active(active: true);
			Main.tile[x + 1, y + 1 + num].frameY = (short)(num3 + 18);
			Main.tile[x + 1, y + 1 + num].frameX = (short)(num2 + 36);
			Main.tile[x + 1, y + 1 + num].type = type;
			Main.tile[x - 1, y + 2 + num].active(active: true);
			Main.tile[x - 1, y + 2 + num].frameY = (short)(num3 + 36);
			Main.tile[x - 1, y + 2 + num].frameX = (short)num2;
			Main.tile[x - 1, y + 2 + num].type = type;
			Main.tile[x, y + 2 + num].active(active: true);
			Main.tile[x, y + 2 + num].frameY = (short)(num3 + 36);
			Main.tile[x, y + 2 + num].frameX = (short)(num2 + 18);
			Main.tile[x, y + 2 + num].type = type;
			Main.tile[x + 1, y + 2 + num].active(active: true);
			Main.tile[x + 1, y + 2 + num].frameY = (short)(num3 + 36);
			Main.tile[x + 1, y + 2 + num].frameX = (short)(num2 + 36);
			Main.tile[x + 1, y + 2 + num].type = type;
		}
	}

	public static void CheckChand(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = i;
		int num12 = j;
		int num14 = 3;
		if (type == 454)
		{
			num14 = 4;
		}
		num = Main.tile[i, j].frameX / 18;
		int num15 = 0;
		while (num >= num14)
		{
			num15++;
			num -= num14;
		}
		int num16 = i - num;
		int num17 = 18 * num14 * num15;
		if (num >= num14)
		{
			num -= num14;
		}
		num = i - num;
		num12 = Main.tile[i, j].frameY / 18;
		int num18 = 0;
		while (num12 >= 3)
		{
			num18++;
			num12 -= 3;
		}
		if (num17 >= 108)
		{
			num18 += 37 * (num17 / 108);
		}
		int num19 = 54 * num18;
		if (num17 >= 108)
		{
			num19 -= 54 * (num17 / 108) * 37;
		}
		if (num12 >= 3)
		{
			num12 -= 3;
		}
		num12 = j - num12;
		for (int k = num; k < num + num14; k++)
		{
			for (int l = num12; l < num12 + 3; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = default(Tile);
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num16) * 18 + num17 || Main.tile[k, l].frameY != (l - num12) * 18 + num19)
				{
					flag = true;
				}
			}
		}
		if (Main.tile[num + 1, num12 - 1] == null)
		{
			Main.tile[num + 1, num12 - 1] = default(Tile);
		}
		if (!Main.tile[num + 1, num12 - 1].nactive() || !Main.tileSolid[Main.tile[num + 1, num12 - 1].type] || Main.tileSolidTop[Main.tile[num + 1, num12 - 1].type])
		{
			flag = true;
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(i, j, type);
		for (int m = num; m < num + num14; m++)
		{
			for (int n = num12; n < num12 + 3; n++)
			{
				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
				{
					KillTile(m, n);
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			if (type == 454)
			{
				switch (Main.rand.Next(9))
				{
				case 2:
				case 3:
				case 4:
				{
					int num5 = Main.rand.Next(10, 31);
					while (num5 > 0)
					{
						int num6 = Main.rand.Next(2, 11);
						if (num6 > num5)
						{
							num6 = num5;
						}
						num5 -= num6;
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, num6);
					}
					break;
				}
				case 5:
				case 6:
				{
					int num9 = Main.rand.Next(60, 80);
					while (num9 > 0)
					{
						int num10 = Main.rand.Next(3, 16);
						if (num10 > num9)
						{
							num10 = num9;
						}
						num9 -= num10;
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16 - 10, j * 16 - 10, 52, 52, 72, num10);
					}
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1358);
					break;
				}
				case 7:
				{
					int num7 = Main.rand.Next(10, 31);
					while (num7 > 0)
					{
						int num8 = Main.rand.Next(2, 9);
						if (num8 > num7)
						{
							num8 = num7;
						}
						num7 -= num8;
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16 - 10, j * 16 - 10, 52, 52, 72, num8);
					}
					if (Main.rand.Next(8) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3532);
					}
					if (Main.rand.Next(8) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3532);
					}
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73);
					break;
				}
				case 8:
				{
					int num20 = 100;
					while (num20 > 0)
					{
						int num2 = Main.rand.Next(3, 16);
						if (num2 > num20)
						{
							num2 = num20;
						}
						num20 -= num2;
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16 - 10, j * 16 - 10, 52, 52, 72, num2);
					}
					int num3 = Main.rand.Next(30, 91);
					while (num3 > 0)
					{
						int num4 = Main.rand.Next(7, 14);
						if (num4 > num3)
						{
							num4 = num3;
						}
						num3 -= num4;
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16 - 10, j * 16 - 10, 52, 52, 1349, num4);
					}
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1358);
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73);
					break;
				}
				}
			}
			if (type == 34)
			{
				int type2;
				switch (num18)
				{
				case 1:
					type2 = 107;
					break;
				case 2:
					type2 = 108;
					break;
				case 3:
					type2 = 710;
					break;
				case 4:
					type2 = 711;
					break;
				case 5:
					type2 = 712;
					break;
				case 6:
					type2 = 1812;
					break;
				case 7:
				case 8:
				case 9:
				case 10:
				case 11:
				case 12:
				case 13:
				case 14:
				case 15:
				case 16:
				case 17:
					type2 = 2055 + num18 - 7;
					break;
				case 18:
				case 19:
				case 20:
				case 21:
					type2 = 2141 + num18 - 18;
					break;
				default:
					type2 = num18 switch
					{
						22 => 2224, 
						23 => 2525, 
						24 => 2543, 
						25 => 2558, 
						26 => 2573, 
						27 => 2652, 
						28 => 2653, 
						29 => 2654, 
						30 => 2655, 
						31 => 2656, 
						32 => 2657, 
						33 => 2813, 
						34 => 3177, 
						35 => 3179, 
						36 => 3178, 
						37 => 3894, 
						38 => 3938, 
						39 => 3964, 
						40 => 4152, 
						41 => 4173, 
						42 => 4194, 
						43 => 4215, 
						44 => 4305, 
						45 => 4573, 
						46 => 5155, 
						47 => 5176, 
						48 => 5197, 
						_ => 106, 
					};
					break;
				}
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type2);
			}
			destroyObject = false;
			for (int num11 = num - 1; num11 < num + num14 + 1; num11++)
			{
				for (int num13 = num12 - 1; num13 < num12 + 4; num13++)
				{
					TileFrame(num11, num13);
				}
			}
		}
	}

	public static void Check3x3(int i, int j, int type)
	{
		//IL_07f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0805: Unknown result type (might be due to invalid IL or missing references)
		//IL_081e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0825: Unknown result type (might be due to invalid IL or missing references)
		//IL_082b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0844: Unknown result type (might be due to invalid IL or missing references)
		//IL_084b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0851: Unknown result type (might be due to invalid IL or missing references)
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = i;
		int num10 = j;
		num = Main.tile[i, j].frameX / 18;
		int num11 = 0;
		while (num >= 3)
		{
			num11++;
			num -= 3;
		}
		int num12 = i - num;
		int num13 = 54 * num11;
		int num14 = Main.tile[i, j].frameY / 54;
		int num15 = Main.tile[i, j].frameY % 54 / 18;
		if (num >= 3)
		{
			num -= 3;
		}
		num = i - num;
		num10 -= num15;
		for (int k = num; k < num + 3; k++)
		{
			for (int l = num10; l < num10 + 3; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = default(Tile);
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num12) * 18 + num13 || Main.tile[k, l].frameY != (l - num10) * 18 + num14 * 54)
				{
					flag = true;
				}
			}
		}
		if (type == 106 || type == 212 || type == 219 || type == 220 || type == 228 || type == 231 || type == 243 || type == 247 || type == 283 || (type >= 300 && type <= 308) || type == 354 || type == 355 || type == 499 || type == 406 || type == 412 || type == 452 || type == 455 || type == 491 || type == 642)
		{
			for (int m = num; m < num + 3; m++)
			{
				if (Main.tile[m, num10 + 3] == null)
				{
					Main.tile[m, num10 + 3] = default(Tile);
				}
				if (!SolidTileAllowBottomSlope(m, num10 + 3))
				{
					flag = true;
					break;
				}
			}
		}
		else
		{
			if (Main.tile[num + 1, num10 - 1] == null)
			{
				Main.tile[num + 1, num10 - 1] = default(Tile);
			}
			if (!Main.tile[num + 1, num10 - 1].nactive() || !Main.tileSolid[Main.tile[num + 1, num10 - 1].type] || Main.tileSolidTop[Main.tile[num + 1, num10 - 1].type])
			{
				flag = true;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(i, j, type);
		for (int n = num; n < num + 3; n++)
		{
			for (int num16 = num10; num16 < num10 + 3; num16++)
			{
				if (Main.tile[n, num16].type == type && Main.tile[n, num16].active())
				{
					KillTile(n, num16);
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			switch (type)
			{
			case 106:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 363);
				break;
			case 243:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1430);
				break;
			case 212:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 951);
				break;
			case 219:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 997);
				break;
			case 642:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5296);
				break;
			case 220:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 998);
				break;
			case 228:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1120);
				break;
			case 247:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1551);
				break;
			case 283:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2172);
				break;
			case 300:
			case 301:
			case 302:
			case 303:
			case 304:
			case 305:
			case 306:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2192 + type - 300);
				break;
			default:
				switch (type)
				{
				case 307:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2203);
					break;
				case 308:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2204);
					break;
				case 406:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3365);
					break;
				case 452:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3742);
					break;
				case 354:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2999);
					break;
				case 355:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3000);
					break;
				case 499:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4142);
					break;
				case 412:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3549);
					break;
				case 455:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3747);
					break;
				case 491:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4076);
					break;
				case 231:
				{
					int num17 = (i + 1) * 16 + 8;
					int num2 = j * 16;
					Gore.NewGore(new Vector2((float)num17, (float)num2), default(Vector2), 300);
					Gore.NewGore(new Vector2((float)num17, (float)(num2 + 8)), default(Vector2), 301);
					Gore.NewGore(new Vector2((float)num17, (float)(num2 + 16)), default(Vector2), 302);
					float num3 = i * 16;
					float num4 = j * 16;
					float num5 = -1f;
					int plr = 0;
					for (int num6 = 0; num6 < 255; num6++)
					{
						if (Main.player[num6].active && !Main.player[num6].dead)
						{
							float num7 = Math.Abs(Main.player[num6].position.X - num3) + Math.Abs(Main.player[num6].position.Y - num4);
							if (num7 < num5 || num5 == -1f)
							{
								plr = num6;
								num5 = num7;
							}
						}
					}
					if (num5 < 4800f && !Main.gameMenu)
					{
						NPC.SpawnOnPlayer(plr, 222);
					}
					break;
				}
				}
				break;
			}
			destroyObject = false;
			for (int num8 = num - 1; num8 < num + 4; num8++)
			{
				for (int num9 = num10 - 1; num9 < num10 + 4; num9++)
				{
					TileFrame(num8, num9);
				}
			}
		}
	}

	public static void Check2x5(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = i;
		int num2 = j;
		num = Main.tile[i, j].frameX / 18;
		int num3 = 0;
		while (num >= 2)
		{
			num3++;
			num -= 2;
		}
		int num4 = i - num;
		int num5 = 36 * num3;
		int num6 = Main.tile[i, j].frameY % 80 / 18;
		if (num >= 3)
		{
			num -= 2;
		}
		num = i - num;
		num2 -= num6;
		for (int k = num; k < num + 2; k++)
		{
			for (int l = num2; l < num2 + 5; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = default(Tile);
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num4) * 18 + num5 || Main.tile[k, l].frameY != (l - num2) * 18)
				{
					flag = true;
				}
			}
		}
		for (int m = num; m < num + 2; m++)
		{
			if (Main.tile[m, num2 + 5] == null)
			{
				Main.tile[m, num2 + 5] = default(Tile);
			}
			if (!SolidTileAllowBottomSlope(m, num2 + 5))
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(i, j, type);
		for (int n = num; n < num + 2; n++)
		{
			for (int num7 = num2; num7 < num2 + 5; num7++)
			{
				if (Main.tile[n, num7].type == type && Main.tile[n, num7].active())
				{
					KillTile(n, num7);
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			switch (type)
			{
			case 547:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4430 + num3);
				break;
			case 623:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5081 + num3);
				break;
			}
			destroyObject = false;
			for (int num8 = num - 1; num8 < num + 3; num8++)
			{
				for (int num9 = num2 - 1; num9 < num2 + 6; num9++)
				{
					TileFrame(num8, num9);
				}
			}
		}
	}

	public static void Check3x5(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = i;
		int num2 = j;
		num = Main.tile[i, j].frameX / 18;
		int num3 = 0;
		while (num >= 3)
		{
			num3++;
			num -= 3;
		}
		int num4 = i - num;
		int num5 = 54 * num3;
		int num6 = Main.tile[i, j].frameY % 90 / 18;
		if (num >= 4)
		{
			num -= 3;
		}
		num = i - num;
		num2 -= num6;
		for (int k = num; k < num + 3; k++)
		{
			for (int l = num2; l < num2 + 5; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = default(Tile);
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num4) * 18 + num5 || Main.tile[k, l].frameY != (l - num2) * 18)
				{
					flag = true;
				}
			}
		}
		for (int m = num; m < num + 3; m++)
		{
			if (Main.tile[m, num2 + 5] == null)
			{
				Main.tile[m, num2 + 5] = default(Tile);
			}
			if (!SolidTileAllowBottomSlope(m, num2 + 5))
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(i, j, type);
		for (int n = num; n < num + 3; n++)
		{
			for (int num7 = num2; num7 < num2 + 5; num7++)
			{
				if (Main.tile[n, num7].type == type && Main.tile[n, num7].active())
				{
					KillTile(n, num7);
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			if (type == 613)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4904 + num3);
			}
			destroyObject = false;
			for (int num8 = num - 1; num8 < num + 4; num8++)
			{
				for (int num9 = num2 - 1; num9 < num2 + 6; num9++)
				{
					TileFrame(num8, num9);
				}
			}
		}
	}

	public static void Check3x6(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = i;
		int num2 = j;
		num = Main.tile[i, j].frameX / 18;
		int num3 = 0;
		while (num >= 3)
		{
			num3++;
			num -= 3;
		}
		int num4 = i - num;
		int num5 = 54 * num3;
		int num6 = Main.tile[i, j].frameY % 96 / 18;
		if (num >= 4)
		{
			num -= 3;
		}
		num = i - num;
		num2 -= num6;
		for (int k = num; k < num + 3; k++)
		{
			for (int l = num2; l < num2 + 6; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = default(Tile);
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num4) * 18 + num5 || Main.tile[k, l].frameY != (l - num2) * 18)
				{
					flag = true;
				}
			}
		}
		for (int m = num; m < num + 3; m++)
		{
			if (Main.tile[m, num2 + 6] == null)
			{
				Main.tile[m, num2 + 6] = default(Tile);
			}
			if (!SolidTileAllowBottomSlope(m, num2 + 6))
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(i, j, type);
		for (int n = num; n < num + 3; n++)
		{
			for (int num7 = num2; num7 < num2 + 6; num7++)
			{
				if (Main.tile[n, num7].type == type && Main.tile[n, num7].active())
				{
					KillTile(n, num7);
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			if (type == 548)
			{
				if (num3 >= 7)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4902 + num3 - 7);
				}
				else
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4435 + num3);
				}
			}
			if (type == 614)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4906);
			}
			destroyObject = false;
			for (int num8 = num - 1; num8 < num + 4; num8++)
			{
				for (int num9 = num2 - 1; num9 < num2 + 7; num9++)
				{
					TileFrame(num8, num9);
				}
			}
		}
	}

	public static void Place3x3(int x, int y, ushort type, int style = 0)
	{
		bool flag = true;
		int num = 0;
		if (type == 106 || type == 212 || type == 219 || type == 220 || type == 228 || type == 231 || type == 243 || type == 247 || type == 283 || (type >= 300 && type <= 308) || type == 354 || type == 355 || type == 642)
		{
			num = -2;
			for (int i = x - 1; i < x + 2; i++)
			{
				for (int j = y - 2; j < y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = default(Tile);
					}
					if (Main.tile[i, j].active())
					{
						flag = false;
					}
				}
			}
			for (int k = x - 1; k < x + 2; k++)
			{
				if (Main.tile[k, y + 1] == null)
				{
					Main.tile[k, y + 1] = default(Tile);
				}
				if (!SolidTile2(k, y + 1))
				{
					flag = false;
					break;
				}
			}
		}
		else
		{
			for (int l = x - 1; l < x + 2; l++)
			{
				for (int m = y; m < y + 3; m++)
				{
					if (Main.tile[l, m] == null)
					{
						Main.tile[l, m] = default(Tile);
					}
					if (Main.tile[l, m].active())
					{
						flag = false;
					}
				}
			}
			if (Main.tile[x, y - 1] == null)
			{
				Main.tile[x, y - 1] = default(Tile);
			}
			if (!Main.tile[x, y - 1].nactive() || !Main.tileSolid[Main.tile[x, y - 1].type] || Main.tileSolidTop[Main.tile[x, y - 1].type])
			{
				flag = false;
			}
		}
		if (flag)
		{
			int num2 = style * 18 * 3;
			Main.tile[x - 1, y + num].active(active: true);
			Main.tile[x - 1, y + num].frameY = 0;
			Main.tile[x - 1, y + num].frameX = (short)num2;
			Main.tile[x - 1, y + num].type = type;
			Main.tile[x, y + num].active(active: true);
			Main.tile[x, y + num].frameY = 0;
			Main.tile[x, y + num].frameX = (short)(num2 + 18);
			Main.tile[x, y + num].type = type;
			Main.tile[x + 1, y + num].active(active: true);
			Main.tile[x + 1, y + num].frameY = 0;
			Main.tile[x + 1, y + num].frameX = (short)(num2 + 36);
			Main.tile[x + 1, y + num].type = type;
			Main.tile[x - 1, y + 1 + num].active(active: true);
			Main.tile[x - 1, y + 1 + num].frameY = 18;
			Main.tile[x - 1, y + 1 + num].frameX = (short)num2;
			Main.tile[x - 1, y + 1 + num].type = type;
			Main.tile[x, y + 1 + num].active(active: true);
			Main.tile[x, y + 1 + num].frameY = 18;
			Main.tile[x, y + 1 + num].frameX = (short)(num2 + 18);
			Main.tile[x, y + 1 + num].type = type;
			Main.tile[x + 1, y + 1 + num].active(active: true);
			Main.tile[x + 1, y + 1 + num].frameY = 18;
			Main.tile[x + 1, y + 1 + num].frameX = (short)(num2 + 36);
			Main.tile[x + 1, y + 1 + num].type = type;
			Main.tile[x - 1, y + 2 + num].active(active: true);
			Main.tile[x - 1, y + 2 + num].frameY = 36;
			Main.tile[x - 1, y + 2 + num].frameX = (short)num2;
			Main.tile[x - 1, y + 2 + num].type = type;
			Main.tile[x, y + 2 + num].active(active: true);
			Main.tile[x, y + 2 + num].frameY = 36;
			Main.tile[x, y + 2 + num].frameX = (short)(num2 + 18);
			Main.tile[x, y + 2 + num].type = type;
			Main.tile[x + 1, y + 2 + num].active(active: true);
			Main.tile[x + 1, y + 2 + num].frameY = 36;
			Main.tile[x + 1, y + 2 + num].frameX = (short)(num2 + 36);
			Main.tile[x + 1, y + 2 + num].type = type;
		}
	}

	public static void PlaceSunflower(int x, int y, ushort type = 27)
	{
		if ((double)y > Main.worldSurface - 1.0 && !Main.remixWorld)
		{
			return;
		}
		bool flag = true;
		for (int i = x; i < x + 2; i++)
		{
			for (int j = y - 3; j < y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = default(Tile);
				}
				if (Main.tile[i, j].active() || Main.tile[i, j].wall > 0)
				{
					flag = false;
				}
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = default(Tile);
			}
			if (!Main.tile[i, y + 1].nactive() || Main.tile[i, y + 1].halfBrick() || Main.tile[i, y + 1].slope() != 0 || (Main.tile[i, y + 1].type != 2 && Main.tile[i, y + 1].type != 109))
			{
				flag = false;
			}
		}
		if (!flag)
		{
			return;
		}
		int num = genRand.Next(3);
		for (int k = 0; k < 2; k++)
		{
			for (int l = -3; l < 1; l++)
			{
				int num2 = k * 18 + genRand.Next(3) * 36;
				if (l <= -2)
				{
					num2 = k * 18 + num * 36;
				}
				int num3 = (l + 3) * 18;
				Main.tile[x + k, y + l].active(active: true);
				Main.tile[x + k, y + l].frameX = (short)num2;
				Main.tile[x + k, y + l].frameY = (short)num3;
				Main.tile[x + k, y + l].type = type;
			}
		}
	}

	public static void FixSunflowers()
	{
		for (int i = 5; i < Main.maxTilesX - 5; i++)
		{
			for (int j = 5; (double)j < Main.worldSurface; j++)
			{
				if (Main.tile[i, j].active() && Main.tile[i, j].type == 27)
				{
					FixSunflower(i, j);
				}
			}
		}
	}

	public static void FixSunflower(int i, int j)
	{
		if (Main.tile[i, j].type != 27)
		{
			return;
		}
		int num = 0;
		int num2 = j;
		num += Main.tile[i, j].frameX / 18;
		num2 += Main.tile[i, j].frameY / 18 * -1;
		while (num > 1)
		{
			num -= 2;
		}
		num *= -1;
		num += i;
		int num3 = genRand.Next(3) * 36;
		int num4 = 0;
		for (int k = num; k < num + 2; k++)
		{
			for (int l = num2; l < num2 + 4; l++)
			{
				Main.tile[k, l].frameX = (short)(num4 + num3);
			}
			num4 += 18;
		}
	}

	public static void CheckSunflower(int i, int j, int type = 27)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = 0;
		int num2 = j;
		num += Main.tile[i, j].frameX / 18;
		num2 += Main.tile[i, j].frameY / 18 * -1;
		while (num > 1)
		{
			num -= 2;
		}
		num *= -1;
		num += i;
		for (int k = num; k < num + 2; k++)
		{
			for (int l = num2; l < num2 + 4; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = default(Tile);
				}
				int num3;
				for (num3 = Main.tile[k, l].frameX / 18; num3 > 1; num3 -= 2)
				{
				}
				if (!Main.tile[k, l].nactive() || Main.tile[k, l].type != type || num3 != k - num || Main.tile[k, l].frameY != (l - num2) * 18)
				{
					flag = true;
				}
			}
			if (Main.tile[k, num2 + 4] == null)
			{
				Main.tile[k, num2 + 4] = default(Tile);
			}
			if (!Main.tile[k, num2 + 4].nactive() || (Main.tile[k, num2 + 4].type != 2 && Main.tile[k, num2 + 4].type != 477 && Main.tile[k, num2 + 4].type != 492 && Main.tile[k, num2 + 4].type != 109 && Main.tile[k, num2 + 4].type != 60 && Main.tile[k, num2 + 4].type != 633))
			{
				flag = true;
			}
			if (!SolidTile(k, num2 + 4))
			{
				flag = true;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(i, j, type);
		for (int m = num; m < num + 2; m++)
		{
			for (int n = num2; n < num2 + 4; n++)
			{
				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
				{
					KillTile(m, n);
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 63);
			destroyObject = false;
		}
	}

	public static void CheckDye(int x, int y)
	{
		switch (Main.tile[x, y].frameX / 34)
		{
		case 7:
			if (!SolidTile(x, y - 1))
			{
				KillTile(x, y);
			}
			break;
		case 6:
			if (!Main.tile[x, y + 1].nactive() || Main.tile[x, y + 1].type != 80)
			{
				KillTile(x, y);
			}
			break;
		default:
			if (!SolidTile(x, y + 1))
			{
				KillTile(x, y);
			}
			break;
		}
	}

	public static void CheckRockGolemHead(int x, int y)
	{
		if (!SolidTileAllowBottomSlope(x, y + 1))
		{
			KillTile(x, y);
		}
	}

	public static void CheckStinkbugBlocker(int x, int y)
	{
		Tile tileSafely = Framing.GetTileSafely(x, y);
		int num = tileSafely.frameX / 18;
		int style = -1;
		if (AttemptReorientingStinkbugBlocker(x, y, tileSafely.wall, ref style))
		{
			if (style != num)
			{
				tileSafely.frameX = (short)(style * 18);
			}
		}
		else
		{
			KillTile(x, y);
		}
	}

	public static bool AttemptReorientingStinkbugBlocker(int x, int y, int wall, ref int style)
	{
		style = -1;
		if (style == -1 && SolidTileAllowBottomSlope(x, y + 1))
		{
			style = 0;
		}
		if (style == -1 && SolidTileAllowBottomSlope(x, y - 1))
		{
			style = 1;
		}
		if (style == -1 && SolidTileAllowBottomSlope(x + 1, y))
		{
			style = 2;
		}
		if (style == -1 && SolidTileAllowBottomSlope(x - 1, y))
		{
			style = 3;
		}
		if (style == -1 && wall > 0)
		{
			style = 4;
		}
		return style > -1;
	}

	public static void CheckGnome(int x, int j)
	{
		if (destroyObject)
		{
			return;
		}
		int num = 567;
		int num2 = j;
		bool flag = true;
		Tile tileSafely = Framing.GetTileSafely(x, num2);
		Tile tileSafely2 = Framing.GetTileSafely(x, num2 + 1);
		if (tileSafely.frameY > 0)
		{
			num2--;
			tileSafely = Framing.GetTileSafely(x, num2);
			tileSafely2 = Framing.GetTileSafely(x, num2 + 1);
		}
		_ = tileSafely.frameX / 28;
		if (tileSafely.frameY == 0 && tileSafely2.frameY == 20 && tileSafely.type == num && tileSafely2.type == num)
		{
			flag = false;
		}
		if (Main.tile[x, num2 + 2] == null)
		{
			Main.tile[x, num2 + 2] = default(Tile);
		}
		if (!SolidTileAllowBottomSlope(x, num2 + 2) && !TileID.Sets.Platforms[Main.tile[x, num2 + 2].type])
		{
			flag = true;
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		bool drop = TileLoader.Drop(x, j, num);
		if (tileSafely.type == num)
		{
			KillTile(x, num2);
		}
		if (tileSafely2.type == num)
		{
			KillTile(x, num2 + 1);
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			Item.NewItem(GetItemSource_FromTileBreak(x, num2), x * 16, num2 * 16, 16, 32, 4609);
			destroyObject = false;
		}
	}

	public static void PlaceGnome(int x, int y, int style)
	{
		PlaceObject(x, y, 567, mute: false, style);
	}

	public static void PlaceDye(int x, int y, int style)
	{
		bool flag = false;
		if (Main.tile[x, y + 1] == null || Main.tile[x, y - 1] == null)
		{
			return;
		}
		if (style == 7)
		{
			if (Main.tile[x, y + 1].active() && Main.tile[x, y + 1].type != 3 && Main.tile[x, y + 1].type != 51 && Main.tile[x, y + 1].type != 61 && Main.tile[x, y + 1].type != 73 && Main.tile[x, y + 1].type != 74 && Main.tile[x, y + 1].type != 184)
			{
				return;
			}
			if (SolidTile(x, y - 1) && !Main.tile[x, y + 1].active())
			{
				flag = true;
			}
		}
		else
		{
			if (Main.tile[x, y - 1].active() && Main.tile[x, y - 1].type != 3 && Main.tile[x, y - 1].type != 51 && Main.tile[x, y - 1].type != 61 && Main.tile[x, y - 1].type != 73 && Main.tile[x, y - 1].type != 74 && Main.tile[x, y - 1].type != 184)
			{
				return;
			}
			if (style == 6)
			{
				if (Main.tile[x, y + 1].nactive() && Main.tile[x, y + 1].type == 80 && !Main.tile[x - 1, y + 1].active() && !Main.tile[x + 1, y + 1].active())
				{
					flag = true;
				}
			}
			else if (SolidTile(x, y + 1) && !Main.tile[x, y - 1].active())
			{
				switch (style)
				{
				case 5:
					if (Main.tile[x, y].liquid == byte.MaxValue && !Main.tile[x, y].lava() && !Main.tile[x, y].honey() && !Main.tile[x, y].shimmer())
					{
						flag = true;
					}
					break;
				case 8:
				case 9:
				case 10:
				case 11:
					flag = true;
					break;
				default:
					if (Main.tile[x, y].liquid != 0)
					{
						break;
					}
					if (style == 3 || style == 4)
					{
						if (Main.tile[x, y].wall == 0)
						{
							flag = true;
						}
					}
					else
					{
						flag = true;
					}
					break;
				}
			}
		}
		if (flag)
		{
			Main.tile[x, y].type = 227;
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].halfBrick(halfBrick: false);
			Main.tile[x, y].slope(0);
			Main.tile[x, y].frameY = 0;
			Main.tile[x, y].frameX = (short)(34 * style);
		}
	}

	public static bool PlacePot(int x, int y, ushort type = 28, int style = 0)
	{
		bool flag = true;
		if (remixWorldGen && (double)x > (double)Main.maxTilesX * 0.48 && (double)x < (double)Main.maxTilesX * 0.52 && y > Main.maxTilesY - 220)
		{
			flag = false;
		}
		for (int i = x; i < x + 2; i++)
		{
			for (int j = y - 1; j < y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = default(Tile);
				}
				if (Main.tile[i, j].active())
				{
					flag = false;
				}
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = default(Tile);
			}
			if (!Main.tile[i, y + 1].nactive() || Main.tile[i, y + 1].halfBrick() || Main.tile[i, y + 1].slope() != 0 || !Main.tileSolid[Main.tile[i, y + 1].type])
			{
				flag = false;
			}
		}
		if (flag)
		{
			int num = genRand.Next(3) * 36;
			for (int k = 0; k < 2; k++)
			{
				for (int l = -1; l < 1; l++)
				{
					int num2 = k * 18 + num;
					int num3 = (l + 1) * 18;
					Main.tile[x + k, y + l].active(active: true);
					Main.tile[x + k, y + l].frameX = (short)num2;
					Main.tile[x + k, y + l].frameY = (short)(num3 + style * 36);
					Main.tile[x + k, y + l].type = type;
					Main.tile[x + k, y + l].halfBrick(halfBrick: false);
				}
			}
			return true;
		}
		return false;
	}

	public static bool CheckCactus(int i, int j)
	{
		int num = j;
		int num2 = i;
		while (Main.tile[num2, num] != null && Main.tile[num2, num].active() && Main.tile[num2, num].type == 80)
		{
			num++;
			if (Main.tile[num2, num] == null)
			{
				return false;
			}
			if (!Main.tile[num2, num].active() || Main.tile[num2, num].type != 80)
			{
				if (Main.tile[num2 - 1, num] != null && Main.tile[num2 - 1, num].active() && Main.tile[num2 - 1, num].type == 80 && Main.tile[num2 - 1, num - 1] != null && Main.tile[num2 - 1, num - 1].active() && Main.tile[num2 - 1, num - 1].type == 80 && num2 >= i)
				{
					num2--;
				}
				if (Main.tile[num2 + 1, num] != null && Main.tile[num2 + 1, num].active() && Main.tile[num2 + 1, num].type == 80 && Main.tile[num2 + 1, num - 1] != null && Main.tile[num2 + 1, num - 1].active() && Main.tile[num2 + 1, num - 1].type == 80 && num2 <= i)
				{
					num2++;
				}
			}
		}
		if (!Main.tile[num2, num].nactive() || Main.tile[num2, num].halfBrick() || Main.tile[num2, num].slope() != 0 || (Main.tile[num2, num].type != 53 && Main.tile[num2, num].type != 112 && Main.tile[num2, num].type != 116 && Main.tile[num2, num].type != 234 && !TileLoader.CanGrowModCactus(Main.tile[num2, num].type)))
		{
			KillTile(i, j);
			return true;
		}
		if (i != num2)
		{
			if ((!Main.tile[i, j + 1].active() || Main.tile[i, j + 1].type != 80) && (!Main.tile[i - 1, j].active() || Main.tile[i - 1, j].type != 80) && (!Main.tile[i + 1, j].active() || Main.tile[i + 1, j].type != 80))
			{
				KillTile(i, j);
				return true;
			}
		}
		else if (i == num2 && (!Main.tile[i, j + 1].active() || (Main.tile[i, j + 1].type != 80 && Main.tile[i, j + 1].type != 53 && Main.tile[i, j + 1].type != 112 && Main.tile[i, j + 1].type != 116 && Main.tile[i, j + 1].type != 234 && !TileLoader.CanGrowModCactus(Main.tile[i, j + 1].type))))
		{
			KillTile(i, j);
			return true;
		}
		return false;
	}

	public static void PlantCactus(int i, int j)
	{
		GrowCactus(i, j);
		for (int k = 0; k < 150; k++)
		{
			int i2 = genRand.Next(i - 1, i + 2);
			int j2 = genRand.Next(j - 10, j + 2);
			GrowCactus(i2, j2);
		}
	}

	public static void CheckOrb(int i, int j, int type)
	{
		//IL_05b7: Unknown result type (might be due to invalid IL or missing references)
		if (Main.tile[i, j] == null)
		{
			return;
		}
		short frameX = Main.tile[i, j].frameX;
		bool flag = false;
		if (frameX >= 36)
		{
			flag = true;
		}
		if (destroyObject)
		{
			return;
		}
		int num = i;
		int num2 = j;
		num = ((Main.tile[i, j].frameX != 0 && Main.tile[i, j].frameX != 36) ? (i - 1) : i);
		num2 = ((Main.tile[i, j].frameY != 0) ? (j - 1) : j);
		for (int k = 0; k < 2; k++)
		{
			for (int l = 0; l < 2; l++)
			{
				Tile tile = Main.tile[num + k, num2 + l];
				if (tile != null && (!tile.nactive() || tile.type != type))
				{
					destroyObject = true;
					break;
				}
			}
			if (destroyObject)
			{
				break;
			}
			if ((type == 12 || type == 639) && Main.tile[num + k, num2 + 2] != null && !SolidTileAllowBottomSlope(num + k, num2 + 2))
			{
				destroyObject = true;
				break;
			}
		}
		if (!destroyObject)
		{
			return;
		}
		bool drop = TileLoader.Drop(i, j, type);
		for (int m = num; m < num + 2; m++)
		{
			for (int n = num2; n < num2 + 2; n++)
			{
				if (Main.tile[m, n] != null && Main.tile[m, n].type == type)
				{
					KillTile(m, n);
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			if (Main.netMode != 1 && !noTileActions)
			{
				switch (type)
				{
				case 12:
					Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 29);
					break;
				case 639:
					Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 109);
					break;
				case 31:
					if (flag)
					{
						int num3 = Main.rand.Next(5);
						if (!shadowOrbSmashed)
						{
							num3 = 0;
						}
						switch (num3)
						{
						case 0:
						{
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 800, 1, noBroadcast: false, -1);
							int stack = genRand.Next(100, 101);
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 97, stack);
							break;
						}
						case 1:
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 1256, 1, noBroadcast: false, -1);
							break;
						case 2:
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 802, 1, noBroadcast: false, -1);
							break;
						case 3:
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 3062, 1, noBroadcast: false, -1);
							break;
						case 4:
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 1290, 1, noBroadcast: false, -1);
							break;
						}
					}
					else
					{
						int num4 = Main.rand.Next(5);
						if (!shadowOrbSmashed)
						{
							num4 = 0;
						}
						switch (num4)
						{
						case 0:
						{
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 96, 1, noBroadcast: false, -1);
							int stack2 = genRand.Next(100, 101);
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 97, stack2);
							break;
						}
						case 1:
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 64, 1, noBroadcast: false, -1);
							break;
						case 2:
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 162, 1, noBroadcast: false, -1);
							break;
						case 3:
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 115, 1, noBroadcast: false, -1);
							break;
						case 4:
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 111, 1, noBroadcast: false, -1);
							break;
						}
					}
					shadowOrbSmashed = true;
					shadowOrbCount++;
					if (shadowOrbCount >= 3)
					{
						if (!(NPC.AnyNPCs(266) && flag) && (!NPC.AnyNPCs(13) || flag))
						{
							shadowOrbCount = 0;
							float num5 = num * 16;
							float num6 = num2 * 16;
							float num7 = -1f;
							int plr = 0;
							for (int num8 = 0; num8 < 255; num8++)
							{
								float num9 = Math.Abs(Main.player[num8].position.X - num5) + Math.Abs(Main.player[num8].position.Y - num6);
								if (num9 < num7 || num7 == -1f)
								{
									plr = num8;
									num7 = num9;
								}
							}
							if (flag)
							{
								NPC.SpawnOnPlayer(plr, 266);
							}
							else
							{
								NPC.SpawnOnPlayer(plr, 13);
							}
						}
					}
					else
					{
						LocalizedText localizedText = Lang.misc[10];
						if (shadowOrbCount == 2)
						{
							localizedText = Lang.misc[11];
						}
						if (Main.netMode == 0)
						{
							Main.NewText(localizedText.ToString(), 50, byte.MaxValue, 130);
						}
						else if (Main.netMode == 2)
						{
							ChatHelper.BroadcastChatMessage(NetworkText.FromKey(localizedText.Key), new Color(50, 255, 130));
						}
					}
					AchievementsHelper.NotifyProgressionEvent(7);
					break;
				}
			}
			if (flag)
			{
				SoundEngine.PlaySound(4, i * 16, j * 16);
			}
			else
			{
				SoundEngine.PlaySound(13, i * 16, j * 16);
			}
			destroyObject = false;
		}
	}

	public static void CheckPalmTree(int i, int j)
	{
		int num = -1;
		int num2 = -1;
		int type = Main.tile[i, j].type;
		int frameX = Main.tile[i, j].frameX;
		int frameY = Main.tile[i, j].frameY;
		if (Main.tile[i, j - 1] != null && Main.tile[i, j - 1].active())
		{
			num = Main.tile[i, j - 1].type;
		}
		if (Main.tile[i, j + 1] != null && Main.tile[i, j + 1].active())
		{
			num2 = Main.tile[i, j + 1].type;
		}
		if (num2 == 53)
		{
			num2 = 53;
		}
		if (num2 == 234)
		{
			num2 = 53;
		}
		if (num2 == 116)
		{
			num2 = 53;
		}
		if (num2 == 112)
		{
			num2 = 53;
		}
		if (TileLoader.CanGrowModPalmTree(num2))
		{
			num2 = 53;
		}
		if (num2 != 53 && num2 != type)
		{
			KillTile(i, j);
		}
		if ((Main.tile[i, j].frameX == 66 || Main.tile[i, j].frameX == 220) && num2 != 53)
		{
			KillTile(i, j);
		}
		if (num != type && Main.tile[i, j].frameX <= 44)
		{
			Main.tile[i, j].frameX = (short)(genRand.Next(7, 10) * 22);
		}
		else if (num != type && Main.tile[i, j].frameX == 66)
		{
			Main.tile[i, j].frameX = 220;
		}
		if (Main.tile[i, j].frameX != frameX && Main.tile[i, j].frameY != frameY && frameX >= 0 && frameY >= 0)
		{
			TileFrame(i - 1, j);
			TileFrame(i + 1, j);
			TileFrame(i, j - 1);
			TileFrame(i, j + 1);
		}
	}

	public static void CheckTreeWithSettings(int x, int y, CheckTreeSettings settings)
	{
		int num = -1;
		int num2 = -1;
		int num3 = -1;
		int num4 = -1;
		Tile tile = Main.tile[x, y];
		int type = tile.type;
		int frameX = tile.frameX;
		int frameY = tile.frameY;
		if (Main.tile[x - 1, y] != null && Main.tile[x - 1, y].active())
		{
			num2 = Main.tile[x - 1, y].type;
		}
		if (Main.tile[x + 1, y] != null && Main.tile[x + 1, y].active())
		{
			num3 = Main.tile[x + 1, y].type;
		}
		if (Main.tile[x, y - 1] != null && Main.tile[x, y - 1].active())
		{
			num = Main.tile[x, y - 1].type;
		}
		if (Main.tile[x, y + 1] != null && Main.tile[x, y + 1].active())
		{
			num4 = Main.tile[x, y + 1].type;
		}
		bool flag = settings.IsGroundValid(num4);
		bool flag2 = num3 == type;
		bool flag3 = num2 == type;
		if (!flag && num4 != type && ((tile.frameX == 0 && tile.frameY <= 130) || (tile.frameX == 22 && tile.frameY <= 130) || (tile.frameX == 44 && tile.frameY <= 130)))
		{
			KillTile(x, y);
		}
		if (tile.frameX >= 22 && tile.frameX <= 44 && tile.frameY >= 132 && tile.frameY <= 176)
		{
			if (!flag)
			{
				KillTile(x, y);
			}
			else if (!(tile.frameX == 22 && flag3) && !(tile.frameX == 44 && flag2))
			{
				KillTile(x, y);
			}
		}
		else if ((tile.frameX == 88 && tile.frameY >= 0 && tile.frameY <= 44) || (tile.frameX == 66 && tile.frameY >= 66 && tile.frameY <= 130) || (tile.frameX == 110 && tile.frameY >= 66 && tile.frameY <= 110) || (tile.frameX == 132 && tile.frameY >= 0 && tile.frameY <= 176))
		{
			if (flag3 && flag2)
			{
				if (tile.frameNumber() == 0)
				{
					tile.frameX = 110;
					tile.frameY = 66;
				}
				if (tile.frameNumber() == 1)
				{
					tile.frameX = 110;
					tile.frameY = 88;
				}
				if (tile.frameNumber() == 2)
				{
					tile.frameX = 110;
					tile.frameY = 110;
				}
			}
			else if (flag3)
			{
				if (tile.frameNumber() == 0)
				{
					tile.frameX = 88;
					tile.frameY = 0;
				}
				if (tile.frameNumber() == 1)
				{
					tile.frameX = 88;
					tile.frameY = 22;
				}
				if (tile.frameNumber() == 2)
				{
					tile.frameX = 88;
					tile.frameY = 44;
				}
			}
			else if (flag2)
			{
				if (tile.frameNumber() == 0)
				{
					tile.frameX = 66;
					tile.frameY = 66;
				}
				if (tile.frameNumber() == 1)
				{
					tile.frameX = 66;
					tile.frameY = 88;
				}
				if (tile.frameNumber() == 2)
				{
					tile.frameX = 66;
					tile.frameY = 110;
				}
			}
			else
			{
				if (tile.frameNumber() == 0)
				{
					tile.frameX = 0;
					tile.frameY = 0;
				}
				if (tile.frameNumber() == 1)
				{
					tile.frameX = 0;
					tile.frameY = 22;
				}
				if (tile.frameNumber() == 2)
				{
					tile.frameX = 0;
					tile.frameY = 44;
				}
			}
		}
		if (tile.frameY >= 132 && tile.frameY <= 176 && (tile.frameX == 0 || tile.frameX == 66 || tile.frameX == 88))
		{
			if (!flag)
			{
				KillTile(x, y);
			}
			if (!flag3 && !flag2)
			{
				if (tile.frameNumber() == 0)
				{
					tile.frameX = 0;
					tile.frameY = 0;
				}
				if (tile.frameNumber() == 1)
				{
					tile.frameX = 0;
					tile.frameY = 22;
				}
				if (tile.frameNumber() == 2)
				{
					tile.frameX = 0;
					tile.frameY = 44;
				}
			}
			else if (!flag3)
			{
				if (tile.frameNumber() == 0)
				{
					tile.frameX = 0;
					tile.frameY = 132;
				}
				if (tile.frameNumber() == 1)
				{
					tile.frameX = 0;
					tile.frameY = 154;
				}
				if (tile.frameNumber() == 2)
				{
					tile.frameX = 0;
					tile.frameY = 176;
				}
			}
			else if (!flag2)
			{
				if (tile.frameNumber() == 0)
				{
					tile.frameX = 66;
					tile.frameY = 132;
				}
				if (tile.frameNumber() == 1)
				{
					tile.frameX = 66;
					tile.frameY = 154;
				}
				if (tile.frameNumber() == 2)
				{
					tile.frameX = 66;
					tile.frameY = 176;
				}
			}
			else
			{
				if (tile.frameNumber() == 0)
				{
					tile.frameX = 88;
					tile.frameY = 132;
				}
				if (tile.frameNumber() == 1)
				{
					tile.frameX = 88;
					tile.frameY = 154;
				}
				if (tile.frameNumber() == 2)
				{
					tile.frameX = 88;
					tile.frameY = 176;
				}
			}
		}
		if ((tile.frameX == 66 && (tile.frameY == 0 || tile.frameY == 22 || tile.frameY == 44)) || (tile.frameX == 44 && (tile.frameY == 198 || tile.frameY == 220 || tile.frameY == 242)))
		{
			if (!flag2)
			{
				KillTile(x, y);
			}
		}
		else if ((tile.frameX == 88 && (tile.frameY == 66 || tile.frameY == 88 || tile.frameY == 110)) || (tile.frameX == 66 && (tile.frameY == 198 || tile.frameY == 220 || tile.frameY == 242)))
		{
			if (!flag3)
			{
				KillTile(x, y);
			}
		}
		else if (num4 == -1)
		{
			KillTile(x, y);
		}
		else if (num != type && tile.frameY < 198 && ((tile.frameX != 22 && tile.frameX != 44) || tile.frameY < 132))
		{
			if (flag3 || flag2)
			{
				if (num4 == type)
				{
					if (flag3 && flag2)
					{
						if (tile.frameNumber() == 0)
						{
							tile.frameX = 132;
							tile.frameY = 132;
						}
						if (tile.frameNumber() == 1)
						{
							tile.frameX = 132;
							tile.frameY = 154;
						}
						if (tile.frameNumber() == 2)
						{
							tile.frameX = 132;
							tile.frameY = 176;
						}
					}
					else if (flag3)
					{
						if (tile.frameNumber() == 0)
						{
							tile.frameX = 132;
							tile.frameY = 0;
						}
						if (tile.frameNumber() == 1)
						{
							tile.frameX = 132;
							tile.frameY = 22;
						}
						if (tile.frameNumber() == 2)
						{
							tile.frameX = 132;
							tile.frameY = 44;
						}
					}
					else if (flag2)
					{
						if (tile.frameNumber() == 0)
						{
							tile.frameX = 132;
							tile.frameY = 66;
						}
						if (tile.frameNumber() == 1)
						{
							tile.frameX = 132;
							tile.frameY = 88;
						}
						if (tile.frameNumber() == 2)
						{
							tile.frameX = 132;
							tile.frameY = 110;
						}
					}
				}
				else if (flag3 && flag2)
				{
					if (tile.frameNumber() == 0)
					{
						tile.frameX = 154;
						tile.frameY = 132;
					}
					if (tile.frameNumber() == 1)
					{
						tile.frameX = 154;
						tile.frameY = 154;
					}
					if (tile.frameNumber() == 2)
					{
						tile.frameX = 154;
						tile.frameY = 176;
					}
				}
				else if (flag3)
				{
					if (tile.frameNumber() == 0)
					{
						tile.frameX = 154;
						tile.frameY = 0;
					}
					if (tile.frameNumber() == 1)
					{
						tile.frameX = 154;
						tile.frameY = 22;
					}
					if (tile.frameNumber() == 2)
					{
						tile.frameX = 154;
						tile.frameY = 44;
					}
				}
				else if (flag2)
				{
					if (tile.frameNumber() == 0)
					{
						tile.frameX = 154;
						tile.frameY = 66;
					}
					if (tile.frameNumber() == 1)
					{
						tile.frameX = 154;
						tile.frameY = 88;
					}
					if (tile.frameNumber() == 2)
					{
						tile.frameX = 154;
						tile.frameY = 110;
					}
				}
			}
			else
			{
				if (tile.frameNumber() == 0)
				{
					tile.frameX = 110;
					tile.frameY = 0;
				}
				if (tile.frameNumber() == 1)
				{
					tile.frameX = 110;
					tile.frameY = 22;
				}
				if (tile.frameNumber() == 2)
				{
					tile.frameX = 110;
					tile.frameY = 44;
				}
			}
		}
		if (tile.frameX != frameX && tile.frameY != frameY && frameX >= 0 && frameY >= 0)
		{
			TileFrame(x - 1, y);
			TileFrame(x + 1, y);
			TileFrame(x, y - 1);
			TileFrame(x, y + 1);
		}
	}

	public static void CheckTree(int i, int j)
	{
		int num = -1;
		int num2 = -1;
		int num3 = -1;
		int num4 = -1;
		Tile tile = Main.tile[i, j];
		int type = tile.type;
		tile = Main.tile[i, j];
		int frameX = tile.frameX;
		tile = Main.tile[i, j];
		int frameY = tile.frameY;
		if (Main.tile[i - 1, j] != null)
		{
			tile = Main.tile[i - 1, j];
			if (tile.active())
			{
				tile = Main.tile[i - 1, j];
				num2 = tile.type;
			}
		}
		if (Main.tile[i + 1, j] != null)
		{
			tile = Main.tile[i + 1, j];
			if (tile.active())
			{
				tile = Main.tile[i + 1, j];
				num3 = tile.type;
			}
		}
		if (Main.tile[i, j - 1] != null)
		{
			tile = Main.tile[i, j - 1];
			if (tile.active())
			{
				tile = Main.tile[i, j - 1];
				num = tile.type;
			}
		}
		if (Main.tile[i, j + 1] != null)
		{
			tile = Main.tile[i, j + 1];
			if (tile.active())
			{
				tile = Main.tile[i, j + 1];
				num4 = tile.type;
			}
		}
		if (Main.tile[i - 1, j - 1] != null)
		{
			tile = Main.tile[i - 1, j - 1];
			if (tile.active())
			{
				tile = Main.tile[i - 1, j - 1];
				_ = ref tile.type;
			}
		}
		if (Main.tile[i + 1, j - 1] != null)
		{
			tile = Main.tile[i + 1, j - 1];
			if (tile.active())
			{
				tile = Main.tile[i + 1, j - 1];
				_ = ref tile.type;
			}
		}
		if (Main.tile[i - 1, j + 1] != null)
		{
			tile = Main.tile[i - 1, j + 1];
			if (tile.active())
			{
				tile = Main.tile[i - 1, j + 1];
				_ = ref tile.type;
			}
		}
		if (Main.tile[i + 1, j + 1] != null)
		{
			tile = Main.tile[i + 1, j + 1];
			if (tile.active())
			{
				tile = Main.tile[i + 1, j + 1];
				_ = ref tile.type;
			}
		}
		if (num4 == 23 || num4 == 661)
		{
			num4 = 2;
		}
		if (num4 == 477)
		{
			num4 = 2;
		}
		if (num4 == 60)
		{
			num4 = 2;
		}
		if (num4 == 70)
		{
			num4 = 2;
		}
		if (num4 == 109)
		{
			num4 = 2;
		}
		if (num4 == 147)
		{
			num4 = 2;
		}
		if (num4 == 199 || num4 == 662)
		{
			num4 = 2;
		}
		if (num4 == 492)
		{
			num4 = 2;
		}
		if (TileLoader.CanGrowModTree(num4))
		{
			num4 = 2;
		}
		if (num4 != 2 && num4 != type)
		{
			tile = Main.tile[i, j];
			if (tile.frameX == 0)
			{
				tile = Main.tile[i, j];
				if (tile.frameY <= 130)
				{
					goto IL_03b4;
				}
			}
			tile = Main.tile[i, j];
			if (tile.frameX == 22)
			{
				tile = Main.tile[i, j];
				if (tile.frameY <= 130)
				{
					goto IL_03b4;
				}
			}
			tile = Main.tile[i, j];
			if (tile.frameX == 44)
			{
				tile = Main.tile[i, j];
				if (tile.frameY <= 130)
				{
					goto IL_03b4;
				}
			}
		}
		goto IL_03be;
		IL_03b4:
		KillTile(i, j);
		goto IL_03be;
		IL_05e9:
		if (num2 == type && num3 == type)
		{
			tile = Main.tile[i, j];
			if (tile.frameNumber() == 0)
			{
				tile = Main.tile[i, j];
				tile.frameX = 110;
				tile = Main.tile[i, j];
				tile.frameY = 66;
			}
			tile = Main.tile[i, j];
			if (tile.frameNumber() == 1)
			{
				tile = Main.tile[i, j];
				tile.frameX = 110;
				tile = Main.tile[i, j];
				tile.frameY = 88;
			}
			tile = Main.tile[i, j];
			if (tile.frameNumber() == 2)
			{
				tile = Main.tile[i, j];
				tile.frameX = 110;
				tile = Main.tile[i, j];
				tile.frameY = 110;
			}
		}
		else if (num2 == type)
		{
			tile = Main.tile[i, j];
			if (tile.frameNumber() == 0)
			{
				tile = Main.tile[i, j];
				tile.frameX = 88;
				tile = Main.tile[i, j];
				tile.frameY = 0;
			}
			tile = Main.tile[i, j];
			if (tile.frameNumber() == 1)
			{
				tile = Main.tile[i, j];
				tile.frameX = 88;
				tile = Main.tile[i, j];
				tile.frameY = 22;
			}
			tile = Main.tile[i, j];
			if (tile.frameNumber() == 2)
			{
				tile = Main.tile[i, j];
				tile.frameX = 88;
				tile = Main.tile[i, j];
				tile.frameY = 44;
			}
		}
		else if (num3 == type)
		{
			tile = Main.tile[i, j];
			if (tile.frameNumber() == 0)
			{
				tile = Main.tile[i, j];
				tile.frameX = 66;
				tile = Main.tile[i, j];
				tile.frameY = 66;
			}
			tile = Main.tile[i, j];
			if (tile.frameNumber() == 1)
			{
				tile = Main.tile[i, j];
				tile.frameX = 66;
				tile = Main.tile[i, j];
				tile.frameY = 88;
			}
			tile = Main.tile[i, j];
			if (tile.frameNumber() == 2)
			{
				tile = Main.tile[i, j];
				tile.frameX = 66;
				tile = Main.tile[i, j];
				tile.frameY = 110;
			}
		}
		else
		{
			tile = Main.tile[i, j];
			if (tile.frameNumber() == 0)
			{
				tile = Main.tile[i, j];
				tile.frameX = 0;
				tile = Main.tile[i, j];
				tile.frameY = 0;
			}
			tile = Main.tile[i, j];
			if (tile.frameNumber() == 1)
			{
				tile = Main.tile[i, j];
				tile.frameX = 0;
				tile = Main.tile[i, j];
				tile.frameY = 22;
			}
			tile = Main.tile[i, j];
			if (tile.frameNumber() == 2)
			{
				tile = Main.tile[i, j];
				tile.frameX = 0;
				tile = Main.tile[i, j];
				tile.frameY = 44;
			}
		}
		goto IL_0978;
		IL_0e29:
		tile = Main.tile[i, j];
		if (tile.frameX == 44)
		{
			tile = Main.tile[i, j];
			if (tile.frameY != 198)
			{
				tile = Main.tile[i, j];
				if (tile.frameY != 220)
				{
					tile = Main.tile[i, j];
					if (tile.frameY != 242)
					{
						goto IL_0eb1;
					}
				}
			}
			goto IL_0e9a;
		}
		goto IL_0eb1;
		IL_0f1f:
		tile = Main.tile[i, j];
		if (tile.frameX == 66)
		{
			tile = Main.tile[i, j];
			if (tile.frameY != 198)
			{
				tile = Main.tile[i, j];
				if (tile.frameY != 220)
				{
					tile = Main.tile[i, j];
					if (tile.frameY != 242)
					{
						goto IL_0fa7;
					}
				}
			}
			goto IL_0f90;
		}
		goto IL_0fa7;
		IL_103b:
		if (num2 == type || num3 == type)
		{
			if (num4 == type)
			{
				if (num2 == type && num3 == type)
				{
					tile = Main.tile[i, j];
					if (tile.frameNumber() == 0)
					{
						tile = Main.tile[i, j];
						tile.frameX = 132;
						tile = Main.tile[i, j];
						tile.frameY = 132;
					}
					tile = Main.tile[i, j];
					if (tile.frameNumber() == 1)
					{
						tile = Main.tile[i, j];
						tile.frameX = 132;
						tile = Main.tile[i, j];
						tile.frameY = 154;
					}
					tile = Main.tile[i, j];
					if (tile.frameNumber() == 2)
					{
						tile = Main.tile[i, j];
						tile.frameX = 132;
						tile = Main.tile[i, j];
						tile.frameY = 176;
					}
				}
				else if (num2 == type)
				{
					tile = Main.tile[i, j];
					if (tile.frameNumber() == 0)
					{
						tile = Main.tile[i, j];
						tile.frameX = 132;
						tile = Main.tile[i, j];
						tile.frameY = 0;
					}
					tile = Main.tile[i, j];
					if (tile.frameNumber() == 1)
					{
						tile = Main.tile[i, j];
						tile.frameX = 132;
						tile = Main.tile[i, j];
						tile.frameY = 22;
					}
					tile = Main.tile[i, j];
					if (tile.frameNumber() == 2)
					{
						tile = Main.tile[i, j];
						tile.frameX = 132;
						tile = Main.tile[i, j];
						tile.frameY = 44;
					}
				}
				else if (num3 == type)
				{
					tile = Main.tile[i, j];
					if (tile.frameNumber() == 0)
					{
						tile = Main.tile[i, j];
						tile.frameX = 132;
						tile = Main.tile[i, j];
						tile.frameY = 66;
					}
					tile = Main.tile[i, j];
					if (tile.frameNumber() == 1)
					{
						tile = Main.tile[i, j];
						tile.frameX = 132;
						tile = Main.tile[i, j];
						tile.frameY = 88;
					}
					tile = Main.tile[i, j];
					if (tile.frameNumber() == 2)
					{
						tile = Main.tile[i, j];
						tile.frameX = 132;
						tile = Main.tile[i, j];
						tile.frameY = 110;
					}
				}
			}
			else if (num2 == type && num3 == type)
			{
				tile = Main.tile[i, j];
				if (tile.frameNumber() == 0)
				{
					tile = Main.tile[i, j];
					tile.frameX = 154;
					tile = Main.tile[i, j];
					tile.frameY = 132;
				}
				tile = Main.tile[i, j];
				if (tile.frameNumber() == 1)
				{
					tile = Main.tile[i, j];
					tile.frameX = 154;
					tile = Main.tile[i, j];
					tile.frameY = 154;
				}
				tile = Main.tile[i, j];
				if (tile.frameNumber() == 2)
				{
					tile = Main.tile[i, j];
					tile.frameX = 154;
					tile = Main.tile[i, j];
					tile.frameY = 176;
				}
			}
			else if (num2 == type)
			{
				tile = Main.tile[i, j];
				if (tile.frameNumber() == 0)
				{
					tile = Main.tile[i, j];
					tile.frameX = 154;
					tile = Main.tile[i, j];
					tile.frameY = 0;
				}
				tile = Main.tile[i, j];
				if (tile.frameNumber() == 1)
				{
					tile = Main.tile[i, j];
					tile.frameX = 154;
					tile = Main.tile[i, j];
					tile.frameY = 22;
				}
				tile = Main.tile[i, j];
				if (tile.frameNumber() == 2)
				{
					tile = Main.tile[i, j];
					tile.frameX = 154;
					tile = Main.tile[i, j];
					tile.frameY = 44;
				}
			}
			else if (num3 == type)
			{
				tile = Main.tile[i, j];
				if (tile.frameNumber() == 0)
				{
					tile = Main.tile[i, j];
					tile.frameX = 154;
					tile = Main.tile[i, j];
					tile.frameY = 66;
				}
				tile = Main.tile[i, j];
				if (tile.frameNumber() == 1)
				{
					tile = Main.tile[i, j];
					tile.frameX = 154;
					tile = Main.tile[i, j];
					tile.frameY = 88;
				}
				tile = Main.tile[i, j];
				if (tile.frameNumber() == 2)
				{
					tile = Main.tile[i, j];
					tile.frameX = 154;
					tile = Main.tile[i, j];
					tile.frameY = 110;
				}
			}
		}
		else
		{
			tile = Main.tile[i, j];
			if (tile.frameNumber() == 0)
			{
				tile = Main.tile[i, j];
				tile.frameX = 110;
				tile = Main.tile[i, j];
				tile.frameY = 0;
			}
			tile = Main.tile[i, j];
			if (tile.frameNumber() == 1)
			{
				tile = Main.tile[i, j];
				tile.frameX = 110;
				tile = Main.tile[i, j];
				tile.frameY = 22;
			}
			tile = Main.tile[i, j];
			if (tile.frameNumber() == 2)
			{
				tile = Main.tile[i, j];
				tile.frameX = 110;
				tile = Main.tile[i, j];
				tile.frameY = 44;
			}
		}
		goto IL_16e6;
		IL_0f90:
		if (num2 != type)
		{
			KillTile(i, j);
		}
		goto IL_16e6;
		IL_0fa7:
		if (num4 == -1 || num4 == 23)
		{
			KillTile(i, j);
		}
		else if (num != type)
		{
			tile = Main.tile[i, j];
			if (tile.frameY < 198)
			{
				tile = Main.tile[i, j];
				if (tile.frameX != 22)
				{
					tile = Main.tile[i, j];
					if (tile.frameX != 44)
					{
						goto IL_103b;
					}
				}
				tile = Main.tile[i, j];
				if (tile.frameY < 132)
				{
					goto IL_103b;
				}
			}
		}
		goto IL_16e6;
		IL_0978:
		tile = Main.tile[i, j];
		if (tile.frameY >= 132)
		{
			tile = Main.tile[i, j];
			if (tile.frameY <= 176)
			{
				tile = Main.tile[i, j];
				if (tile.frameX != 0)
				{
					tile = Main.tile[i, j];
					if (tile.frameX != 66)
					{
						tile = Main.tile[i, j];
						if (tile.frameX != 88)
						{
							goto IL_0dbd;
						}
					}
				}
				if (num4 != 2)
				{
					KillTile(i, j);
				}
				if (num2 != type && num3 != type)
				{
					tile = Main.tile[i, j];
					if (tile.frameNumber() == 0)
					{
						tile = Main.tile[i, j];
						tile.frameX = 0;
						tile = Main.tile[i, j];
						tile.frameY = 0;
					}
					tile = Main.tile[i, j];
					if (tile.frameNumber() == 1)
					{
						tile = Main.tile[i, j];
						tile.frameX = 0;
						tile = Main.tile[i, j];
						tile.frameY = 22;
					}
					tile = Main.tile[i, j];
					if (tile.frameNumber() == 2)
					{
						tile = Main.tile[i, j];
						tile.frameX = 0;
						tile = Main.tile[i, j];
						tile.frameY = 44;
					}
				}
				else if (num2 != type)
				{
					tile = Main.tile[i, j];
					if (tile.frameNumber() == 0)
					{
						tile = Main.tile[i, j];
						tile.frameX = 0;
						tile = Main.tile[i, j];
						tile.frameY = 132;
					}
					tile = Main.tile[i, j];
					if (tile.frameNumber() == 1)
					{
						tile = Main.tile[i, j];
						tile.frameX = 0;
						tile = Main.tile[i, j];
						tile.frameY = 154;
					}
					tile = Main.tile[i, j];
					if (tile.frameNumber() == 2)
					{
						tile = Main.tile[i, j];
						tile.frameX = 0;
						tile = Main.tile[i, j];
						tile.frameY = 176;
					}
				}
				else if (num3 != type)
				{
					tile = Main.tile[i, j];
					if (tile.frameNumber() == 0)
					{
						tile = Main.tile[i, j];
						tile.frameX = 66;
						tile = Main.tile[i, j];
						tile.frameY = 132;
					}
					tile = Main.tile[i, j];
					if (tile.frameNumber() == 1)
					{
						tile = Main.tile[i, j];
						tile.frameX = 66;
						tile = Main.tile[i, j];
						tile.frameY = 154;
					}
					tile = Main.tile[i, j];
					if (tile.frameNumber() == 2)
					{
						tile = Main.tile[i, j];
						tile.frameX = 66;
						tile = Main.tile[i, j];
						tile.frameY = 176;
					}
				}
				else
				{
					tile = Main.tile[i, j];
					if (tile.frameNumber() == 0)
					{
						tile = Main.tile[i, j];
						tile.frameX = 88;
						tile = Main.tile[i, j];
						tile.frameY = 132;
					}
					tile = Main.tile[i, j];
					if (tile.frameNumber() == 1)
					{
						tile = Main.tile[i, j];
						tile.frameX = 88;
						tile = Main.tile[i, j];
						tile.frameY = 154;
					}
					tile = Main.tile[i, j];
					if (tile.frameNumber() == 2)
					{
						tile = Main.tile[i, j];
						tile.frameX = 88;
						tile = Main.tile[i, j];
						tile.frameY = 176;
					}
				}
			}
		}
		goto IL_0dbd;
		IL_0dbd:
		tile = Main.tile[i, j];
		if (tile.frameX != 66)
		{
			goto IL_0e29;
		}
		tile = Main.tile[i, j];
		if (tile.frameY != 0)
		{
			tile = Main.tile[i, j];
			if (tile.frameY != 22)
			{
				tile = Main.tile[i, j];
				if (tile.frameY != 44)
				{
					goto IL_0e29;
				}
			}
		}
		goto IL_0e9a;
		IL_0e9a:
		if (num3 != type)
		{
			KillTile(i, j);
		}
		goto IL_16e6;
		IL_16e6:
		tile = Main.tile[i, j];
		if (tile.frameX != frameX)
		{
			tile = Main.tile[i, j];
			if (tile.frameY != frameY && frameX >= 0 && frameY >= 0)
			{
				TileFrame(i - 1, j);
				TileFrame(i + 1, j);
				TileFrame(i, j - 1);
				TileFrame(i, j + 1);
			}
		}
		return;
		IL_0eb1:
		tile = Main.tile[i, j];
		if (tile.frameX != 88)
		{
			goto IL_0f1f;
		}
		tile = Main.tile[i, j];
		if (tile.frameY != 66)
		{
			tile = Main.tile[i, j];
			if (tile.frameY != 88)
			{
				tile = Main.tile[i, j];
				if (tile.frameY != 110)
				{
					goto IL_0f1f;
				}
			}
		}
		goto IL_0f90;
		IL_03be:
		tile = Main.tile[i, j];
		if (tile.frameX >= 22)
		{
			tile = Main.tile[i, j];
			if (tile.frameX <= 44)
			{
				tile = Main.tile[i, j];
				if (tile.frameY >= 132)
				{
					tile = Main.tile[i, j];
					if (tile.frameY <= 176)
					{
						if (num4 != 2)
						{
							KillTile(i, j);
						}
						else
						{
							tile = Main.tile[i, j];
							if (tile.frameX != 22 || num2 != type)
							{
								tile = Main.tile[i, j];
								if (tile.frameX != 44 || num3 != type)
								{
									KillTile(i, j);
								}
							}
						}
						goto IL_0978;
					}
				}
			}
		}
		tile = Main.tile[i, j];
		if (tile.frameX == 88)
		{
			tile = Main.tile[i, j];
			if (tile.frameY >= 0)
			{
				tile = Main.tile[i, j];
				if (tile.frameY <= 44)
				{
					goto IL_05e9;
				}
			}
		}
		tile = Main.tile[i, j];
		if (tile.frameX == 66)
		{
			tile = Main.tile[i, j];
			if (tile.frameY >= 66)
			{
				tile = Main.tile[i, j];
				if (tile.frameY <= 130)
				{
					goto IL_05e9;
				}
			}
		}
		tile = Main.tile[i, j];
		if (tile.frameX == 110)
		{
			tile = Main.tile[i, j];
			if (tile.frameY >= 66)
			{
				tile = Main.tile[i, j];
				if (tile.frameY <= 110)
				{
					goto IL_05e9;
				}
			}
		}
		tile = Main.tile[i, j];
		if (tile.frameX == 132)
		{
			tile = Main.tile[i, j];
			if (tile.frameY >= 0)
			{
				tile = Main.tile[i, j];
				if (tile.frameY <= 176)
				{
					goto IL_05e9;
				}
			}
		}
		goto IL_0978;
	}

	public static bool TileIsExposedToAir(int x, int y)
	{
		if (!InWorld(x, y, 2))
		{
			return false;
		}
		for (int i = x - 1; i <= x + 1; i++)
		{
			for (int j = y - 1; j <= y + 1; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile != null && (!tile.active() || !Main.tileSolid[tile.type] || TileID.Sets.Platforms[tile.type]))
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool TryKillingTreesAboveIfTheyWouldBecomeInvalid(int i, int j, int newFloorType)
	{
		if (newFloorType < 0)
		{
			return false;
		}
		if (!InWorld(i, j, 2))
		{
			return false;
		}
		Tile tile = Main.tile[i, j - 1];
		if (tile == null || !tile.active())
		{
			return false;
		}
		int type = tile.type;
		if (!IsTreeType(tile.type) && tile.type != 323)
		{
			return false;
		}
		bool flag = true;
		flag = type switch
		{
			72 => newFloorType == 70, 
			323 => TileID.Sets.Conversion.Sand[newFloorType], 
			_ => TileID.Sets.Conversion.Grass[newFloorType] || TileID.Sets.Conversion.JungleGrass[newFloorType] || TileID.Sets.Conversion.Snow[newFloorType], 
		};
		if (flag && GrowTreeSettings.Profiles.TryGetFromTreeId(type, out var profile))
		{
			flag = profile.GroundTest(newFloorType);
		}
		if (!flag)
		{
			KillTile(i, j - 1);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 0, i, j - 1);
			}
		}
		return true;
	}

	/// <summary>
	/// Converts biome variant tiles and walls to a target biome.<br />
	/// Converts a 9x9 square by default, but can be adjusted with the <paramref name="size" /> parameter.
	/// </summary>
	/// <remarks>
	/// For an easily-viewable usage example, refer to the code for projectile AI style 31 (used for the Clentaminator's solutions).
	/// </remarks>
	/// <param name="i">The X coordinate of the target tile.</param>
	/// <param name="j">The Y coordinate of the target tile.</param>
	/// <param name="conversionType">The biome that you wish to convert to. See <see cref="T:Terraria.ID.BiomeConversionID" />
	/// Setting this to 0 (Purity) returns affected tiles to their default states (e.g. Ebonstone, Crimstone, and Pearlstone will be converted back into normal Stone Blocks).<br />
	/// </param>
	/// <param name="size">
	/// When using this method to convert tiles, a square centered on the target tile is converted into those of the target biome.<br />
	/// This optional parameter, which defaults to 4, determines the "radius" of that square in tiles, counting outward from the central tile.<br />
	/// Set to 0 if you only want to convert a single tile. In other cases, use this parameter wisely.
	/// </param>
	public static void Convert(int i, int j, int conversionType, int size = 4)
	{
		for (int k = i - size; k <= i + size; k++)
		{
			for (int l = j - size; l <= j + size; l++)
			{
				if (!InWorld(k, l, 1) || Math.Abs(k - i) + Math.Abs(l - j) >= 6)
				{
					continue;
				}
				Tile tile = Main.tile[k, l];
				int type = tile.type;
				int wall = tile.wall;
				switch (conversionType)
				{
				case 4:
					if (type <= TileLoader.TileCount && wall <= WallLoader.WallCount)
					{
						if (WallID.Sets.Conversion.Grass[wall] && wall != 81)
						{
							tile.wall = 81;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.Stone[wall] && wall != 83)
						{
							tile.wall = 83;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 218)
						{
							tile.wall = 218;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 221)
						{
							tile.wall = 221;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 192)
						{
							tile.wall = 192;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 193)
						{
							tile.wall = 193;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 194)
						{
							tile.wall = 194;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 195)
						{
							tile.wall = 195;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 203)
						{
							TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 203);
							tile.type = 203;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.JungleGrass[type] && type != 662)
						{
							TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 662);
							tile.type = 662;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.Grass[type] && type != 199)
						{
							TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 199);
							tile.type = 199;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.Ice[type] && type != 200)
						{
							TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 200);
							tile.type = 200;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.Sand[type] && type != 234)
						{
							TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 234);
							tile.type = 234;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.HardenedSand[type] && type != 399)
						{
							tile.type = 399;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.Sandstone[type] && type != 401)
						{
							tile.type = 401;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.Thorn[type] && type != 352)
						{
							tile.type = 352;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
					}
					continue;
				case 2:
					if (type >= TileLoader.TileCount || wall >= WallLoader.WallCount)
					{
						continue;
					}
					if (WallID.Sets.Conversion.Grass[wall] && wall != 70)
					{
						tile.wall = 70;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (WallID.Sets.Conversion.Stone[wall] && wall != 28)
					{
						tile.wall = 28;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 219)
					{
						tile.wall = 219;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 222)
					{
						tile.wall = 222;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 200)
					{
						tile.wall = 200;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 201)
					{
						tile.wall = 201;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 202)
					{
						tile.wall = 202;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 203)
					{
						tile.wall = 203;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 117)
					{
						TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 117);
						tile.type = 117;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (TileID.Sets.Conversion.GolfGrass[type] && type != 492)
					{
						TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 492);
						tile.type = 492;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (TileID.Sets.Conversion.Grass[type] && type != 109 && type != 492)
					{
						TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 109);
						tile.type = 109;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (TileID.Sets.Conversion.Ice[type] && type != 164)
					{
						TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 164);
						tile.type = 164;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (TileID.Sets.Conversion.Sand[type] && type != 116)
					{
						TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 116);
						tile.type = 116;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (TileID.Sets.Conversion.HardenedSand[type] && type != 402)
					{
						tile.type = 402;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (TileID.Sets.Conversion.Sandstone[type] && type != 403)
					{
						tile.type = 403;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (TileID.Sets.Conversion.Thorn[type])
					{
						KillTile(k, l);
						if (Main.netMode == 1)
						{
							NetMessage.SendData(17, -1, -1, null, 0, k, l);
						}
					}
					if (type == 59 && (Main.tile[k - 1, l].type == 109 || Main.tile[k + 1, l].type == 109 || Main.tile[k, l - 1].type == 109 || Main.tile[k, l + 1].type == 109))
					{
						tile.type = 0;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					continue;
				case 1:
					if (type <= TileLoader.TileCount && wall <= WallLoader.WallCount)
					{
						if (WallID.Sets.Conversion.Grass[wall] && wall != 69)
						{
							tile.wall = 69;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.JungleGrass[type] && type != 661)
						{
							tile.type = 661;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.Stone[wall] && wall != 3)
						{
							tile.wall = 3;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 217)
						{
							tile.wall = 217;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 220)
						{
							tile.wall = 220;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 188)
						{
							tile.wall = 188;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 189)
						{
							tile.wall = 189;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 190)
						{
							tile.wall = 190;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 191)
						{
							tile.wall = 191;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 25)
						{
							TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 25);
							tile.type = 25;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.Grass[type] && type != 23)
						{
							TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 23);
							tile.type = 23;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.Ice[type] && type != 163)
						{
							TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 163);
							tile.type = 163;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.Sand[type] && type != 112)
						{
							TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 112);
							tile.type = 112;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.HardenedSand[type] && type != 398)
						{
							tile.type = 398;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.Sandstone[type] && type != 400)
						{
							tile.type = 400;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.Thorn[type] && type != 32)
						{
							tile.type = 32;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
					}
					continue;
				case 3:
					if (WallID.Sets.CanBeConvertedToGlowingMushroom[wall])
					{
						tile.wall = 80;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					if (tile.type == 60)
					{
						TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 70);
						tile.type = 70;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (TileID.Sets.Conversion.Thorn[type])
					{
						KillTile(k, l);
						if (Main.netMode == 1)
						{
							NetMessage.SendData(17, -1, -1, null, 0, k, l);
						}
					}
					continue;
				case 5:
					if (type < 0 || type >= TileLoader.TileCount || wall < 0 || wall >= WallLoader.WallCount)
					{
						continue;
					}
					if ((WallID.Sets.Conversion.Stone[wall] || WallID.Sets.Conversion.NewWall1[wall] || WallID.Sets.Conversion.NewWall2[wall] || WallID.Sets.Conversion.NewWall3[wall] || WallID.Sets.Conversion.NewWall4[wall] || WallID.Sets.Conversion.Ice[wall] || WallID.Sets.Conversion.Sandstone[wall]) && wall != 187)
					{
						tile.wall = 187;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if ((WallID.Sets.Conversion.HardenedSand[wall] || WallID.Sets.Conversion.Dirt[wall] || WallID.Sets.Conversion.Snow[wall]) && wall != 216)
					{
						tile.wall = 216;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					if ((TileID.Sets.Conversion.Grass[type] || TileID.Sets.Conversion.Sand[type] || TileID.Sets.Conversion.Snow[type] || TileID.Sets.Conversion.Dirt[type]) && type != 53)
					{
						int num = 53;
						if (BlockBelowMakesSandConvertIntoHardenedSand(k, l))
						{
							num = 397;
						}
						TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, num);
						tile.type = (ushort)num;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (TileID.Sets.Conversion.HardenedSand[type] && type != 397)
					{
						tile.type = 397;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type] || TileID.Sets.Conversion.Ice[type] || TileID.Sets.Conversion.Sandstone[type]) && type != 396)
					{
						TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 396);
						tile.type = 396;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (TileID.Sets.Conversion.Thorn[type] && type != 69)
					{
						KillTile(k, l);
						if (Main.netMode == 1)
						{
							NetMessage.SendData(17, -1, -1, null, 0, k, l);
						}
					}
					continue;
				case 6:
					if (type < 0 || type >= TileLoader.TileCount || wall < 0 || wall >= WallLoader.WallCount)
					{
						continue;
					}
					if ((WallID.Sets.Conversion.Stone[wall] || WallID.Sets.Conversion.NewWall1[wall] || WallID.Sets.Conversion.NewWall2[wall] || WallID.Sets.Conversion.NewWall3[wall] || WallID.Sets.Conversion.NewWall4[wall] || WallID.Sets.Conversion.Ice[wall] || WallID.Sets.Conversion.Sandstone[wall]) && wall != 71)
					{
						tile.wall = 71;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if ((WallID.Sets.Conversion.HardenedSand[wall] || WallID.Sets.Conversion.Dirt[wall] || WallID.Sets.Conversion.Snow[wall]) && wall != 40)
					{
						tile.wall = 40;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					if ((TileID.Sets.Conversion.Grass[type] || TileID.Sets.Conversion.Sand[type] || TileID.Sets.Conversion.HardenedSand[type] || TileID.Sets.Conversion.Snow[type] || TileID.Sets.Conversion.Dirt[type]) && type != 147)
					{
						TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 147);
						tile.type = 147;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type] || TileID.Sets.Conversion.Ice[type] || TileID.Sets.Conversion.Sandstone[type]) && type != 161)
					{
						TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 161);
						tile.type = 161;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (TileID.Sets.Conversion.Thorn[type] && type != 69)
					{
						KillTile(k, l);
						if (Main.netMode == 1)
						{
							NetMessage.SendData(17, -1, -1, null, 0, k, l);
						}
					}
					continue;
				case 7:
					if (type < 0 || type >= TileLoader.TileCount || wall < 0 || wall >= WallLoader.WallCount)
					{
						continue;
					}
					if ((WallID.Sets.Conversion.Stone[wall] || WallID.Sets.Conversion.Ice[wall] || WallID.Sets.Conversion.Sandstone[wall]) && wall != 1)
					{
						tile.wall = 1;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if ((WallID.Sets.Conversion.HardenedSand[wall] || WallID.Sets.Conversion.Snow[wall] || WallID.Sets.Conversion.Dirt[wall]) && wall != 2)
					{
						tile.wall = 2;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 196)
					{
						tile.wall = 196;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 197)
					{
						tile.wall = 197;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 198)
					{
						tile.wall = 198;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 199)
					{
						tile.wall = 199;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					if ((TileID.Sets.Conversion.Stone[type] || TileID.Sets.Conversion.Ice[type] || TileID.Sets.Conversion.Sandstone[type]) && type != 1)
					{
						TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 1);
						tile.type = 1;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (TileID.Sets.Conversion.GolfGrass[type] && type != 477)
					{
						TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 477);
						tile.type = 477;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (TileID.Sets.Conversion.Grass[type] && type != 2 && type != 477)
					{
						TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 2);
						tile.type = 2;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if ((TileID.Sets.Conversion.Sand[type] || TileID.Sets.Conversion.HardenedSand[type] || TileID.Sets.Conversion.Snow[type] || TileID.Sets.Conversion.Dirt[type]) && type != 0)
					{
						int num2 = 0;
						if (TileIsExposedToAir(k, l))
						{
							num2 = 2;
						}
						TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, num2);
						tile.type = (ushort)num2;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (TileID.Sets.Conversion.Thorn[type] && type != 69)
					{
						KillTile(k, l);
						if (Main.netMode == 1)
						{
							NetMessage.SendData(17, -1, -1, null, 0, k, l);
						}
					}
					continue;
				}
				if (tile.wall == 69 || tile.wall == 70 || tile.wall == 81)
				{
					if ((double)l < Main.worldSurface)
					{
						if (genRand.Next(10) == 0)
						{
							tile.wall = 65;
						}
						else
						{
							tile.wall = 63;
						}
					}
					else
					{
						tile.wall = 64;
					}
					SquareWallFrame(k, l);
					NetMessage.SendTileSquare(-1, k, l);
				}
				else if (WallID.Sets.Conversion.Stone[wall] && wall != 1 && wall != 262 && wall != 274 && wall != 61 && wall != 185)
				{
					tile.wall = 1;
					SquareWallFrame(k, l);
					NetMessage.SendTileSquare(-1, k, l);
				}
				else if (WallID.Sets.Conversion.Stone[wall] && wall == 262)
				{
					tile.wall = 61;
					SquareWallFrame(k, l);
					NetMessage.SendTileSquare(-1, k, l);
				}
				else if (WallID.Sets.Conversion.Stone[wall] && wall == 274)
				{
					tile.wall = 185;
					SquareWallFrame(k, l);
					NetMessage.SendTileSquare(-1, k, l);
				}
				if (WallID.Sets.Conversion.NewWall1[wall] && wall != 212)
				{
					tile.wall = 212;
					SquareWallFrame(k, l);
					NetMessage.SendTileSquare(-1, k, l);
				}
				else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 213)
				{
					tile.wall = 213;
					SquareWallFrame(k, l);
					NetMessage.SendTileSquare(-1, k, l);
				}
				else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 214)
				{
					tile.wall = 214;
					SquareWallFrame(k, l);
					NetMessage.SendTileSquare(-1, k, l);
				}
				else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 215)
				{
					tile.wall = 215;
					SquareWallFrame(k, l);
					NetMessage.SendTileSquare(-1, k, l);
				}
				else if (tile.wall == 80)
				{
					if ((double)l < Main.worldSurface + 4.0 + (double)genRand.Next(3) || (double)l > ((double)Main.maxTilesY + Main.rockLayer) / 2.0 - 3.0 + (double)genRand.Next(3))
					{
						tile.wall = 15;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else
					{
						tile.wall = 64;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
				}
				else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 216)
				{
					tile.wall = 216;
					SquareWallFrame(k, l);
					NetMessage.SendTileSquare(-1, k, l);
				}
				else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 187)
				{
					tile.wall = 187;
					SquareWallFrame(k, l);
					NetMessage.SendTileSquare(-1, k, l);
				}
				if (tile.type == 492)
				{
					TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 477);
					tile.type = 477;
					SquareTileFrame(k, l);
					NetMessage.SendTileSquare(-1, k, l);
				}
				else if (TileID.Sets.Conversion.JungleGrass[type] && type != 60)
				{
					TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 60);
					tile.type = 60;
					SquareTileFrame(k, l);
					NetMessage.SendTileSquare(-1, k, l);
				}
				else if (TileID.Sets.Conversion.Grass[type] && type != 2 && type != 477)
				{
					TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 2);
					tile.type = 2;
					SquareTileFrame(k, l);
					NetMessage.SendTileSquare(-1, k, l);
				}
				else if (TileID.Sets.Conversion.Stone[type] && type != 1)
				{
					TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 1);
					tile.type = 1;
					SquareTileFrame(k, l);
					NetMessage.SendTileSquare(-1, k, l);
				}
				else if (TileID.Sets.Conversion.Sand[type] && type != 53)
				{
					TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 53);
					tile.type = 53;
					SquareTileFrame(k, l);
					NetMessage.SendTileSquare(-1, k, l);
				}
				else if (TileID.Sets.Conversion.HardenedSand[type] && type != 397)
				{
					tile.type = 397;
					SquareTileFrame(k, l);
					NetMessage.SendTileSquare(-1, k, l);
				}
				else if (TileID.Sets.Conversion.Sandstone[type] && type != 396)
				{
					tile.type = 396;
					SquareTileFrame(k, l);
					NetMessage.SendTileSquare(-1, k, l);
				}
				else if (TileID.Sets.Conversion.Ice[type] && type != 161)
				{
					TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 161);
					tile.type = 161;
					SquareTileFrame(k, l);
					NetMessage.SendTileSquare(-1, k, l);
				}
				else if (TileID.Sets.Conversion.MushroomGrass[type])
				{
					TryKillingTreesAboveIfTheyWouldBecomeInvalid(k, l, 60);
					tile.type = 60;
					SquareTileFrame(k, l);
					NetMessage.SendTileSquare(-1, k, l);
				}
				else if (tile.type == 32 || Main.tile[k, l].type == 352)
				{
					KillTile(k, l);
					if (Main.netMode == 1)
					{
						NetMessage.SendData(17, -1, -1, null, 0, k, l);
					}
				}
			}
		}
	}

	public static void CactusFrame(int i, int j)
	{
		try
		{
			int num = j;
			int num4 = i;
			if (CheckCactus(i, j))
			{
				return;
			}
			while (Main.tile[num4, num].active() && Main.tile[num4, num].type == 80)
			{
				num++;
				if (Main.tile[num4, num] == null)
				{
					return;
				}
				if (!Main.tile[num4, num].active() || Main.tile[num4, num].type != 80)
				{
					if (Main.tile[num4 - 1, num] != null && Main.tile[num4 - 1, num].active() && Main.tile[num4 - 1, num].type == 80 && Main.tile[num4 - 1, num - 1].active() && Main.tile[num4 - 1, num - 1].type == 80 && num4 >= i)
					{
						num4--;
					}
					if (Main.tile[num4 + 1, num] != null && Main.tile[num4 + 1, num].active() && Main.tile[num4 + 1, num].type == 80 && Main.tile[num4 + 1, num - 1].active() && Main.tile[num4 + 1, num - 1].type == 80 && num4 <= i)
					{
						num4++;
					}
				}
			}
			num--;
			int num5 = i - num4;
			num4 = i;
			num = j;
			if (Main.tile[i - 2, j] == null)
			{
				return;
			}
			int type = Main.tile[i - 2, j].type;
			if (Main.tile[i - 1, j] == null)
			{
				return;
			}
			int num6 = Main.tile[i - 1, j].type;
			if (Main.tile[i + 1, j] == null)
			{
				return;
			}
			int num7 = Main.tile[i + 1, j].type;
			if (Main.tile[i, j - 1] == null)
			{
				return;
			}
			int num8 = Main.tile[i, j - 1].type;
			if (num8 == 227)
			{
				num8 = 80;
			}
			int num9 = Main.tile[i, j + 1].type;
			int num10 = Main.tile[i - 1, j + 1].type;
			int num11 = Main.tile[i + 1, j + 1].type;
			if (!Main.tile[i - 1, j].active())
			{
				num6 = -1;
			}
			if (!Main.tile[i + 1, j].active())
			{
				num7 = -1;
			}
			if (!Main.tile[i, j - 1].active())
			{
				num8 = -1;
			}
			if (!Main.tile[i, j + 1].active())
			{
				num9 = -1;
			}
			if (!Main.tile[i - 1, j + 1].active())
			{
				num10 = -1;
			}
			if (!Main.tile[i + 1, j + 1].active())
			{
				num11 = -1;
			}
			short num2 = Main.tile[i, j].frameX;
			short num3 = Main.tile[i, j].frameY;
			switch (num5)
			{
			case 0:
				if (num8 != 80)
				{
					if (num6 == 80 && num7 == 80 && num10 != 80 && num11 != 80 && type != 80)
					{
						num2 = 90;
						num3 = 0;
					}
					else if (num6 == 80 && num10 != 80 && type != 80)
					{
						num2 = 72;
						num3 = 0;
					}
					else if (num7 == 80 && num11 != 80)
					{
						num2 = 18;
						num3 = 0;
					}
					else
					{
						num2 = 0;
						num3 = 0;
					}
				}
				else if (num6 == 80 && num7 == 80 && num10 != 80 && num11 != 80 && type != 80)
				{
					num2 = 90;
					num3 = 36;
				}
				else if (num6 == 80 && num10 != 80 && type != 80)
				{
					num2 = 72;
					num3 = 36;
				}
				else if (num7 == 80 && num11 != 80)
				{
					num2 = 18;
					num3 = 36;
				}
				else if (num9 >= 0 && Main.tileSolid[num9])
				{
					num2 = 0;
					num3 = 36;
				}
				else
				{
					num2 = 0;
					num3 = 18;
				}
				break;
			case -1:
				if (num7 == 80)
				{
					if (num8 != 80 && num9 != 80)
					{
						num2 = 108;
						num3 = 36;
					}
					else if (num9 != 80)
					{
						num2 = 54;
						num3 = 36;
					}
					else if (num8 != 80)
					{
						num2 = 54;
						num3 = 0;
					}
					else
					{
						num2 = 54;
						num3 = 18;
					}
				}
				else if (num8 != 80)
				{
					num2 = 54;
					num3 = 0;
				}
				else
				{
					num2 = 54;
					num3 = 18;
				}
				break;
			case 1:
				if (num6 == 80)
				{
					if (num8 != 80 && num9 != 80)
					{
						num2 = 108;
						num3 = 18;
					}
					else if (num9 != 80)
					{
						num2 = 36;
						num3 = 36;
					}
					else if (num8 != 80)
					{
						num2 = 36;
						num3 = 0;
					}
					else
					{
						num2 = 36;
						num3 = 18;
					}
				}
				else if (num8 != 80)
				{
					num2 = 36;
					num3 = 0;
				}
				else
				{
					num2 = 36;
					num3 = 18;
				}
				break;
			}
			if (num2 != Main.tile[i, j].frameX || num3 != Main.tile[i, j].frameY)
			{
				Main.tile[i, j].frameX = num2;
				Main.tile[i, j].frameY = num3;
				DiamondTileFrame(i, j);
			}
		}
		catch
		{
			Main.tile[i, j].frameX = 0;
			Main.tile[i, j].frameY = 0;
		}
	}

	public static void GrowCactus(int i, int j)
	{
		int num = j;
		int num5 = i;
		Tile tile = Main.tile[i, j];
		if (!tile.nactive())
		{
			return;
		}
		tile = Main.tile[i, j];
		if (tile.halfBrick())
		{
			return;
		}
		if (!gen)
		{
			tile = Main.tile[i, j];
			if (tile.slope() != 0)
			{
				return;
			}
		}
		tile = Main.tile[i, j - 1];
		if (tile.liquid > 0)
		{
			return;
		}
		tile = Main.tile[i, j];
		if (tile.type != 53)
		{
			tile = Main.tile[i, j];
			if (tile.type != 80)
			{
				tile = Main.tile[i, j];
				if (tile.type != 234)
				{
					tile = Main.tile[i, j];
					if (tile.type != 112)
					{
						tile = Main.tile[i, j];
						if (tile.type != 116)
						{
							return;
						}
					}
				}
			}
		}
		int num6 = 0;
		for (int k = i - cactusWaterWidth; k < i + cactusWaterWidth; k++)
		{
			for (int l = j - cactusWaterHeight; l < j + cactusWaterHeight; l++)
			{
				int num13 = num6;
				tile = Main.tile[k, l];
				num6 = num13 + tile.liquid;
			}
		}
		if ((!Main.remixWorld || !((double)j > Main.worldSurface)) && num6 / 255 > cactusWaterLimit)
		{
			return;
		}
		tile = Main.tile[i, j];
		if (tile.type != 53)
		{
			tile = Main.tile[i, j];
			if (tile.type != 112)
			{
				tile = Main.tile[i, j];
				if (tile.type != 116)
				{
					tile = Main.tile[i, j];
					if (tile.type != 234)
					{
						tile = Main.tile[i, j];
						if (!TileLoader.CanGrowModCactus(tile.type))
						{
							tile = Main.tile[i, j];
							if (tile.type != 80)
							{
								return;
							}
							while (true)
							{
								tile = Main.tile[num5, num];
								if (!tile.active())
								{
									break;
								}
								tile = Main.tile[num5, num];
								if (tile.type != 80)
								{
									break;
								}
								num++;
								tile = Main.tile[num5, num];
								if (tile.active())
								{
									tile = Main.tile[num5, num];
									if (tile.type == 80)
									{
										continue;
									}
								}
								tile = Main.tile[num5 - 1, num];
								if (tile.active())
								{
									tile = Main.tile[num5 - 1, num];
									if (tile.type == 80)
									{
										tile = Main.tile[num5 - 1, num - 1];
										if (tile.active())
										{
											tile = Main.tile[num5 - 1, num - 1];
											if (tile.type == 80 && num5 >= i)
											{
												num5--;
											}
										}
									}
								}
								tile = Main.tile[num5 + 1, num];
								if (!tile.active())
								{
									continue;
								}
								tile = Main.tile[num5 + 1, num];
								if (tile.type != 80)
								{
									continue;
								}
								tile = Main.tile[num5 + 1, num - 1];
								if (tile.active())
								{
									tile = Main.tile[num5 + 1, num - 1];
									if (tile.type == 80 && num5 <= i)
									{
										num5++;
									}
								}
							}
							num--;
							int num9 = num - j;
							int num10 = i - num5;
							num5 = i - num10;
							num = j;
							int num11 = 11 - num9;
							int num12 = 0;
							for (int num2 = num5 - 2; num2 <= num5 + 2; num2++)
							{
								for (int num3 = num - num11; num3 <= num + num9; num3++)
								{
									tile = Main.tile[num2, num3];
									if (tile.active())
									{
										tile = Main.tile[num2, num3];
										if (tile.type == 80)
										{
											num12++;
										}
									}
								}
							}
							if (Main.drunkWorld)
							{
								if (num12 >= genRand.Next(11, 20))
								{
									return;
								}
							}
							else if (num12 >= genRand.Next(11, 13))
							{
								return;
							}
							num5 = i;
							num = j;
							if (num10 == 0)
							{
								if (num9 == 0)
								{
									tile = Main.tile[num5, num - 1];
									if (!tile.active())
									{
										tile = Main.tile[num5, num - 1];
										tile.active(active: true);
										tile = Main.tile[num5, num - 1];
										tile.type = 80;
										SquareTileFrame(num5, num - 1);
										if (Main.netMode == 2)
										{
											NetMessage.SendTileSquare(-1, num5, num - 1);
										}
									}
									return;
								}
								bool flag = false;
								bool flag2 = false;
								tile = Main.tile[num5, num - 1];
								if (tile.active())
								{
									tile = Main.tile[num5, num - 1];
									if (tile.type == 80)
									{
										tile = Main.tile[num5 - 1, num];
										if (!tile.active())
										{
											tile = Main.tile[num5 - 2, num + 1];
											if (!tile.active())
											{
												tile = Main.tile[num5 - 1, num - 1];
												if (!tile.active())
												{
													tile = Main.tile[num5 - 1, num + 1];
													if (!tile.active())
													{
														tile = Main.tile[num5 - 2, num];
														if (!tile.active())
														{
															flag = true;
														}
													}
												}
											}
										}
										tile = Main.tile[num5 + 1, num];
										if (!tile.active())
										{
											tile = Main.tile[num5 + 2, num + 1];
											if (!tile.active())
											{
												tile = Main.tile[num5 + 1, num - 1];
												if (!tile.active())
												{
													tile = Main.tile[num5 + 1, num + 1];
													if (!tile.active())
													{
														tile = Main.tile[num5 + 2, num];
														if (!tile.active())
														{
															flag2 = true;
														}
													}
												}
											}
										}
									}
								}
								int num4 = genRand.Next(3);
								if (num4 == 0 && flag)
								{
									tile = Main.tile[num5 - 1, num];
									tile.active(active: true);
									tile = Main.tile[num5 - 1, num];
									tile.type = 80;
									SquareTileFrame(num5 - 1, num);
									if (Main.netMode == 2)
									{
										NetMessage.SendTileSquare(-1, num5 - 1, num);
									}
								}
								else if (num4 == 1 && flag2)
								{
									tile = Main.tile[num5 + 1, num];
									tile.active(active: true);
									tile = Main.tile[num5 + 1, num];
									tile.type = 80;
									SquareTileFrame(num5 + 1, num);
									if (Main.netMode == 2)
									{
										NetMessage.SendTileSquare(-1, num5 + 1, num);
									}
								}
								else
								{
									if (num9 >= genRand.Next(2, 8))
									{
										return;
									}
									tile = Main.tile[num5 - 1, num - 1];
									if (tile.active())
									{
										tile = Main.tile[num5 - 1, num - 1];
										_ = ref tile.type;
									}
									tile = Main.tile[num5 + 1, num - 1];
									if (tile.active())
									{
										tile = Main.tile[num5 + 1, num - 1];
										if (tile.type == 80)
										{
											return;
										}
									}
									tile = Main.tile[num5, num - 1];
									if (!tile.active())
									{
										tile = Main.tile[num5, num - 1];
										tile.active(active: true);
										tile = Main.tile[num5, num - 1];
										tile.type = 80;
										SquareTileFrame(num5, num - 1);
										if (Main.netMode == 2)
										{
											NetMessage.SendTileSquare(-1, num5, num - 1);
										}
									}
								}
								return;
							}
							tile = Main.tile[num5, num - 1];
							if (tile.active())
							{
								return;
							}
							tile = Main.tile[num5, num - 2];
							if (tile.active())
							{
								return;
							}
							tile = Main.tile[num5 + num10, num - 1];
							if (tile.active())
							{
								return;
							}
							tile = Main.tile[num5 - num10, num - 1];
							if (!tile.active())
							{
								return;
							}
							tile = Main.tile[num5 - num10, num - 1];
							if (tile.type == 80)
							{
								tile = Main.tile[num5, num - 1];
								tile.active(active: true);
								tile = Main.tile[num5, num - 1];
								tile.type = 80;
								SquareTileFrame(num5, num - 1);
								if (Main.netMode == 2)
								{
									NetMessage.SendTileSquare(-1, num5, num - 1);
								}
							}
							return;
						}
					}
				}
			}
		}
		tile = Main.tile[i, j - 1];
		if (tile.active())
		{
			return;
		}
		tile = Main.tile[i - 1, j - 1];
		if (tile.active())
		{
			return;
		}
		tile = Main.tile[i + 1, j - 1];
		if (tile.active())
		{
			return;
		}
		int num7 = 0;
		int num8 = 0;
		for (int m = i - 6; m <= i + 6; m++)
		{
			for (int n = j - 3; n <= j + 1; n++)
			{
				try
				{
					tile = Main.tile[m, n];
					if (!tile.active())
					{
						continue;
					}
					tile = Main.tile[m, n];
					if (tile.type == 80)
					{
						num7++;
						if (num7 >= 4)
						{
							return;
						}
					}
					tile = Main.tile[m, n];
					if (tile.type == 53)
					{
						goto IL_032c;
					}
					tile = Main.tile[m, n];
					if (tile.type == 112)
					{
						goto IL_032c;
					}
					tile = Main.tile[m, n];
					if (tile.type == 116)
					{
						goto IL_032c;
					}
					tile = Main.tile[m, n];
					if (tile.type == 234)
					{
						goto IL_032c;
					}
					tile = Main.tile[m, n];
					if (TileLoader.CanGrowModCactus(tile.type))
					{
						goto IL_032c;
					}
					goto end_IL_0257;
					IL_032c:
					num8++;
					end_IL_0257:;
				}
				catch
				{
				}
			}
		}
		if (num8 > 10)
		{
			if (gen && genRand.Next(2) == 0)
			{
				tile = Main.tile[i, j];
				tile.slope(0);
			}
			tile = Main.tile[i, j - 1];
			tile.active(active: true);
			tile = Main.tile[i, j - 1];
			tile.type = 80;
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, i, j - 1);
			}
			SquareTileFrame(num5, num - 1);
		}
	}

	public static void CheckPot(int i, int j, int type = 28)
	{
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_030c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0312: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_033d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0359: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_0382: Unknown result type (might be due to invalid IL or missing references)
		//IL_0389: Unknown result type (might be due to invalid IL or missing references)
		//IL_038f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0402: Unknown result type (might be due to invalid IL or missing references)
		//IL_0409: Unknown result type (might be due to invalid IL or missing references)
		//IL_040f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0430: Unknown result type (might be due to invalid IL or missing references)
		//IL_0437: Unknown result type (might be due to invalid IL or missing references)
		//IL_043d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0459: Unknown result type (might be due to invalid IL or missing references)
		//IL_0460: Unknown result type (might be due to invalid IL or missing references)
		//IL_0466: Unknown result type (might be due to invalid IL or missing references)
		//IL_0482: Unknown result type (might be due to invalid IL or missing references)
		//IL_0489: Unknown result type (might be due to invalid IL or missing references)
		//IL_048f: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0512: Unknown result type (might be due to invalid IL or missing references)
		//IL_0519: Unknown result type (might be due to invalid IL or missing references)
		//IL_051f: Unknown result type (might be due to invalid IL or missing references)
		//IL_053b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0542: Unknown result type (might be due to invalid IL or missing references)
		//IL_0548: Unknown result type (might be due to invalid IL or missing references)
		//IL_0575: Unknown result type (might be due to invalid IL or missing references)
		//IL_057c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0582: Unknown result type (might be due to invalid IL or missing references)
		//IL_059e: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_05df: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0601: Unknown result type (might be due to invalid IL or missing references)
		//IL_0608: Unknown result type (might be due to invalid IL or missing references)
		//IL_060e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0668: Unknown result type (might be due to invalid IL or missing references)
		//IL_066f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0675: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0721: Unknown result type (might be due to invalid IL or missing references)
		//IL_0728: Unknown result type (might be due to invalid IL or missing references)
		//IL_072e: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_07df: Unknown result type (might be due to invalid IL or missing references)
		//IL_07fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0802: Unknown result type (might be due to invalid IL or missing references)
		//IL_0808: Unknown result type (might be due to invalid IL or missing references)
		//IL_0824: Unknown result type (might be due to invalid IL or missing references)
		//IL_082b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0831: Unknown result type (might be due to invalid IL or missing references)
		//IL_077d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0784: Unknown result type (might be due to invalid IL or missing references)
		//IL_078a: Unknown result type (might be due to invalid IL or missing references)
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = 0;
		int num2 = j;
		for (num += Main.tile[i, j].frameX / 18; num > 1; num -= 2)
		{
		}
		num *= -1;
		num += i;
		int num3 = Main.tile[i, j].frameY / 18;
		int num4 = 0;
		while (num3 > 1)
		{
			num3 -= 2;
			num4++;
		}
		num2 -= num3;
		for (int k = num; k < num + 2; k++)
		{
			for (int l = num2; l < num2 + 2; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = default(Tile);
				}
				int num5;
				for (num5 = Main.tile[k, l].frameX / 18; num5 > 1; num5 -= 2)
				{
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || num5 != k - num || Main.tile[k, l].frameY != (l - num2) * 18 + num4 * 36)
				{
					flag = true;
				}
			}
			if (Main.tile[k, num2 + 2] == null)
			{
				Main.tile[k, num2 + 2] = default(Tile);
			}
			if (!SolidTile2(k, num2 + 2))
			{
				flag = true;
			}
		}
		if (!flag)
		{
			return;
		}
		destroyObject = true;
		if (num4 >= 7 && num4 <= 9)
		{
			SoundEngine.PlaySound(6, i * 16, j * 16);
		}
		else if (num4 >= 16 && num4 <= 24)
		{
			SoundEngine.PlaySound(4, i * 16, j * 16);
		}
		else
		{
			SoundEngine.PlaySound(13, i * 16, j * 16);
		}
		bool drop = TileLoader.Drop(i, j, type);
		for (int m = num; m < num + 2; m++)
		{
			for (int n = num2; n < num2 + 2; n++)
			{
				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
				{
					KillTile(m, n);
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			switch (num4)
			{
			case 0:
				Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 51);
				Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 52);
				Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 53);
				break;
			case 1:
				Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 166);
				Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 167);
				Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 168);
				break;
			case 2:
				Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 169);
				Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 170);
				Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 171);
				break;
			case 3:
				Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 172);
				Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 173);
				Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 174);
				break;
			case 4:
			case 5:
			case 6:
				Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 197);
				Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 198);
				break;
			case 7:
			case 8:
			case 9:
				Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 199);
				Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 200);
				break;
			default:
				if (num4 >= 10 && num4 <= 12)
				{
					Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 201);
					Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 202);
				}
				else if (num4 >= 13 && num4 <= 15)
				{
					Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 203);
					Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 204);
				}
				else
				{
					if ((num4 >= 16 && num4 <= 18) || (num4 >= 19 && num4 <= 21) || (num4 >= 22 && num4 <= 24))
					{
						break;
					}
					if (num4 >= 25 && num4 <= 27)
					{
						Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), genRand.Next(217, 220));
						Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), genRand.Next(217, 220));
					}
					else if (num4 >= 28 && num4 <= 30)
					{
						Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), genRand.Next(315, 317));
						Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), genRand.Next(315, 317));
					}
					else if (num4 >= 31 && num4 <= 33)
					{
						int num6 = genRand.Next(2, 5);
						for (int num7 = 0; num7 < num6; num7++)
						{
							Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 698 + genRand.Next(6));
						}
					}
					else if (num4 >= 34 && num4 <= 36)
					{
						Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 1122);
						Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 1123);
						Gore.NewGore(new Vector2((float)(i * 16), (float)(j * 16)), default(Vector2), 1124);
					}
				}
				break;
			}
			if (Main.netMode != 1 && type != 653)
			{
				SpawnThingsFromPot(i, j, num, num2, num4);
			}
			destroyObject = false;
		}
	}

	private static void SpawnThingsFromPot(int i, int j, int x2, int y2, int style)
	{
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0e7c: Unknown result type (might be due to invalid IL or missing references)
		bool flag = (double)j < Main.rockLayer;
		bool flag2 = j < Main.UnderworldLayer;
		if (Main.remixWorld)
		{
			flag = (double)j > Main.rockLayer && j < Main.UnderworldLayer;
			flag2 = (double)j > Main.worldSurface && (double)j < Main.rockLayer;
		}
		float num = 1f;
		bool flag3 = style >= 34 && style <= 36;
		switch (style)
		{
		case 4:
		case 5:
		case 6:
			num = 1.25f;
			break;
		case 7:
		case 8:
		case 9:
			num = 1.75f;
			break;
		default:
			if (style >= 10 && style <= 12)
			{
				num = 1.9f;
			}
			else if (style >= 13 && style <= 15)
			{
				num = 2.1f;
			}
			else if (style >= 16 && style <= 18)
			{
				num = 1.6f;
			}
			else if (style >= 19 && style <= 21)
			{
				num = 3.5f;
			}
			else if (style >= 22 && style <= 24)
			{
				num = 1.6f;
			}
			else if (style >= 25 && style <= 27)
			{
				num = 10f;
			}
			else if (style >= 28 && style <= 30)
			{
				if (Main.hardMode)
				{
					num = 4f;
				}
			}
			else if (style >= 31 && style <= 33)
			{
				num = 2f;
			}
			else if (style >= 34 && style <= 36)
			{
				num = 1.25f;
			}
			break;
		case 0:
		case 1:
		case 2:
		case 3:
			break;
		}
		num = (num * 2f + 1f) / 3f;
		int range = (int)(500f / ((num + 1f) / 2f));
		if (gen)
		{
			return;
		}
		if (Player.GetClosestRollLuck(i, j, range) == 0f)
		{
			if (Main.netMode != 1)
			{
				Projectile.NewProjectile(GetProjectileSource_TileBreak(i, j), i * 16 + 16, j * 16 + 16, 0f, -12f, 518, 0, 0f, Main.myPlayer);
			}
			return;
		}
		if (genRand.Next(35) == 0 && Main.wallDungeon[Main.tile[i, j].wall] && (double)j > Main.worldSurface)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 327);
			return;
		}
		if (Main.getGoodWorld && genRand.Next(6) == 0)
		{
			Projectile.NewProjectile(GetProjectileSource_TileBreak(i, j), i * 16 + 16, j * 16 + 8, (float)Main.rand.Next(-100, 101) * 0.002f, 0f, 28, 0, 0f, Main.myPlayer, 16f, 16f);
			return;
		}
		if (Main.remixWorld && Main.netMode != 1 && genRand.Next(5) == 0)
		{
			Player player = Main.player[Player.FindClosest(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16)];
			if (Main.rand.Next(2) == 0)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 75);
			}
			else if (player.ZoneJungle)
			{
				int num12 = -1;
				num12 = NPC.NewNPC(NPC.GetSpawnSourceForNaturalSpawn(), x2 * 16 + 16, y2 * 16 + 32, -10);
				if (num12 > -1)
				{
					Main.npc[num12].ai[1] = 75f;
					Main.npc[num12].netUpdate = true;
				}
			}
			else if ((double)j > Main.rockLayer && j < Main.maxTilesY - 350)
			{
				int num13 = -1;
				num13 = ((Main.rand.Next(9) == 0) ? NPC.NewNPC(NPC.GetSpawnSourceForNaturalSpawn(), x2 * 16 + 16, y2 * 16 + 32, -7) : ((Main.rand.Next(7) == 0) ? NPC.NewNPC(NPC.GetSpawnSourceForNaturalSpawn(), x2 * 16 + 16, y2 * 16 + 32, -8) : ((Main.rand.Next(6) == 0) ? NPC.NewNPC(NPC.GetSpawnSourceForNaturalSpawn(), x2 * 16 + 16, y2 * 16 + 32, -9) : ((Main.rand.Next(3) != 0) ? NPC.NewNPC(NPC.GetSpawnSourceForNaturalSpawn(), x2 * 16 + 16, y2 * 16 + 32, 1) : NPC.NewNPC(NPC.GetSpawnSourceForNaturalSpawn(), x2 * 16 + 16, y2 * 16 + 32, -3)))));
				if (num13 > -1)
				{
					Main.npc[num13].ai[1] = 75f;
					Main.npc[num13].netUpdate = true;
				}
			}
			else if ((double)j > Main.worldSurface && (double)j <= Main.rockLayer)
			{
				int num14 = -1;
				num14 = NPC.NewNPC(NPC.GetSpawnSourceForNaturalSpawn(), x2 * 16 + 16, y2 * 16 + 32, -6);
				if (num14 > -1)
				{
					Main.npc[num14].ai[1] = 75f;
					Main.npc[num14].netUpdate = true;
				}
			}
			else
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 75);
			}
			return;
		}
		if (Main.remixWorld && (double)i > (double)Main.maxTilesX * 0.37 && (double)i < (double)Main.maxTilesX * 0.63 && j > Main.maxTilesY - 220)
		{
			int stack = Main.rand.Next(20, 41);
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 965, stack);
			return;
		}
		if (genRand.Next(45) == 0 || (Main.rand.Next(45) == 0 && Main.expertMode))
		{
			if ((double)j < Main.worldSurface)
			{
				int num16 = genRand.Next(10);
				if (num16 == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 292);
				}
				if (num16 == 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 298);
				}
				if (num16 == 2)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 299);
				}
				if (num16 == 3)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 290);
				}
				if (num16 == 4)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2322);
				}
				if (num16 == 5)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2324);
				}
				if (num16 == 6)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2325);
				}
				if (num16 >= 7)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2350, genRand.Next(1, 3));
				}
			}
			else if (flag)
			{
				int num17 = genRand.Next(11);
				if (num17 == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 289);
				}
				if (num17 == 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 298);
				}
				if (num17 == 2)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 299);
				}
				if (num17 == 3)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 290);
				}
				if (num17 == 4)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 303);
				}
				if (num17 == 5)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 291);
				}
				if (num17 == 6)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 304);
				}
				if (num17 == 7)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2322);
				}
				if (num17 == 8)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2329);
				}
				if (num17 >= 7)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2350, genRand.Next(1, 3));
				}
			}
			else if (flag2)
			{
				int num18 = genRand.Next(15);
				if (num18 == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 296);
				}
				if (num18 == 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 295);
				}
				if (num18 == 2)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 299);
				}
				if (num18 == 3)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 302);
				}
				if (num18 == 4)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 303);
				}
				if (num18 == 5)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 305);
				}
				if (num18 == 6)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 301);
				}
				if (num18 == 7)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 302);
				}
				if (num18 == 8)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 297);
				}
				if (num18 == 9)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 304);
				}
				if (num18 == 10)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2322);
				}
				if (num18 == 11)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2323);
				}
				if (num18 == 12)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2327);
				}
				if (num18 == 13)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2329);
				}
				if (num18 >= 7)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2350, genRand.Next(1, 3));
				}
			}
			else
			{
				int num19 = genRand.Next(14);
				if (num19 == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 296);
				}
				if (num19 == 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 295);
				}
				if (num19 == 2)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 293);
				}
				if (num19 == 3)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 288);
				}
				if (num19 == 4)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 294);
				}
				if (num19 == 5)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 297);
				}
				if (num19 == 6)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 304);
				}
				if (num19 == 7)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 305);
				}
				if (num19 == 8)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 301);
				}
				if (num19 == 9)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 302);
				}
				if (num19 == 10)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 288);
				}
				if (num19 == 11)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 300);
				}
				if (num19 == 12)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2323);
				}
				if (num19 == 13)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2326);
				}
				if (genRand.Next(5) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 4870);
				}
			}
			return;
		}
		if (Main.netMode == 2 && Main.rand.Next(30) == 0)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2997);
			return;
		}
		int num15 = Main.rand.Next(7);
		if (Main.expertMode)
		{
			num15--;
		}
		Player player2 = Main.player[Player.FindClosest(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16)];
		int num2 = 0;
		int num3 = 20;
		for (int k = 0; k < 50; k++)
		{
			Item item = player2.inventory[k];
			if (!item.IsAir && item.createTile == 4)
			{
				num2 += item.stack;
				if (num2 >= num3)
				{
					break;
				}
			}
		}
		bool flag4 = num2 < num3;
		if (num15 == 0 && player2.statLife < player2.statLifeMax2)
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 58);
			if (Main.rand.Next(2) == 0)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 58);
			}
			if (Main.expertMode)
			{
				if (Main.rand.Next(2) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 58);
				}
				if (Main.rand.Next(2) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 58);
				}
			}
			return;
		}
		if (num15 == 1 || (num15 == 0 && flag4))
		{
			int num4 = Main.rand.Next(2, 7);
			if (Main.expertMode)
			{
				num4 += Main.rand.Next(1, 7);
			}
			int type = 8;
			int type2 = 282;
			if (player2.ZoneHallow)
			{
				num4 += Main.rand.Next(2, 7);
				type = 4387;
			}
			else if ((style >= 22 && style <= 24) || player2.ZoneCrimson)
			{
				num4 += Main.rand.Next(2, 7);
				type = 4386;
			}
			else if ((style >= 16 && style <= 18) || player2.ZoneCorrupt)
			{
				num4 += Main.rand.Next(2, 7);
				type = 4385;
			}
			else if (style >= 7 && style <= 9)
			{
				num4 += Main.rand.Next(2, 7);
				num4 = (int)((float)num4 * 1.5f);
				type = 4388;
			}
			else if (style >= 4 && style <= 6)
			{
				type = 974;
				type2 = 286;
			}
			else if (style >= 34 && style <= 36)
			{
				num4 += Main.rand.Next(2, 7);
				type = 4383;
			}
			else if (player2.ZoneGlowshroom)
			{
				num4 += Main.rand.Next(2, 7);
				type = 5293;
			}
			if (Main.tile[i, j].liquid > 0)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, type2, num4);
			}
			else
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, type, num4);
			}
			return;
		}
		switch (num15)
		{
		case 2:
		{
			int stack2 = Main.rand.Next(10, 21);
			int type4 = 40;
			if (flag && genRand.Next(2) == 0)
			{
				type4 = ((!Main.hardMode) ? 42 : 168);
			}
			if (j > Main.UnderworldLayer)
			{
				type4 = 265;
			}
			else if (Main.hardMode)
			{
				type4 = ((Main.rand.Next(2) != 0) ? 47 : ((SavedOreTiers.Silver != 168) ? 278 : 4915));
			}
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, type4, stack2);
			return;
		}
		case 3:
		{
			int type5 = 28;
			if (j > Main.UnderworldLayer || Main.hardMode)
			{
				type5 = 188;
			}
			int num6 = 1;
			if (Main.expertMode && Main.rand.Next(3) != 0)
			{
				num6++;
			}
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, type5, num6);
			return;
		}
		case 4:
			if (flag3 || flag2)
			{
				int type3 = 166;
				if (flag3)
				{
					type3 = 4423;
				}
				int num5 = Main.rand.Next(4) + 1;
				if (Main.expertMode)
				{
					num5 += Main.rand.Next(4);
				}
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, type3, num5);
				return;
			}
			break;
		}
		if ((num15 == 4 || num15 == 5) && j < Main.UnderworldLayer && !Main.hardMode)
		{
			int stack3 = Main.rand.Next(20, 41);
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 965, stack3);
			return;
		}
		float num7 = 200 + genRand.Next(-100, 101);
		if ((double)j < Main.worldSurface)
		{
			num7 *= 0.5f;
		}
		else if (flag)
		{
			num7 *= 0.75f;
		}
		else if (j > Main.maxTilesY - 250)
		{
			num7 *= 1.25f;
		}
		num7 *= 1f + (float)Main.rand.Next(-20, 21) * 0.01f;
		if (Main.rand.Next(4) == 0)
		{
			num7 *= 1f + (float)Main.rand.Next(5, 11) * 0.01f;
		}
		if (Main.rand.Next(8) == 0)
		{
			num7 *= 1f + (float)Main.rand.Next(10, 21) * 0.01f;
		}
		if (Main.rand.Next(12) == 0)
		{
			num7 *= 1f + (float)Main.rand.Next(20, 41) * 0.01f;
		}
		if (Main.rand.Next(16) == 0)
		{
			num7 *= 1f + (float)Main.rand.Next(40, 81) * 0.01f;
		}
		if (Main.rand.Next(20) == 0)
		{
			num7 *= 1f + (float)Main.rand.Next(50, 101) * 0.01f;
		}
		if (Main.expertMode)
		{
			num7 *= 2.5f;
		}
		if (Main.expertMode && Main.rand.Next(2) == 0)
		{
			num7 *= 1.25f;
		}
		if (Main.expertMode && Main.rand.Next(3) == 0)
		{
			num7 *= 1.5f;
		}
		if (Main.expertMode && Main.rand.Next(4) == 0)
		{
			num7 *= 1.75f;
		}
		num7 *= num;
		if (NPC.downedBoss1)
		{
			num7 *= 1.1f;
		}
		if (NPC.downedBoss2)
		{
			num7 *= 1.1f;
		}
		if (NPC.downedBoss3)
		{
			num7 *= 1.1f;
		}
		if (NPC.downedMechBoss1)
		{
			num7 *= 1.1f;
		}
		if (NPC.downedMechBoss2)
		{
			num7 *= 1.1f;
		}
		if (NPC.downedMechBoss3)
		{
			num7 *= 1.1f;
		}
		if (NPC.downedPlantBoss)
		{
			num7 *= 1.1f;
		}
		if (NPC.downedQueenBee)
		{
			num7 *= 1.1f;
		}
		if (NPC.downedGolemBoss)
		{
			num7 *= 1.1f;
		}
		if (NPC.downedPirates)
		{
			num7 *= 1.1f;
		}
		if (NPC.downedGoblins)
		{
			num7 *= 1.1f;
		}
		if (NPC.downedFrost)
		{
			num7 *= 1.1f;
		}
		while ((int)num7 > 0)
		{
			if (num7 > 1000000f)
			{
				int num8 = (int)(num7 / 1000000f);
				if (num8 > 50 && Main.rand.Next(2) == 0)
				{
					num8 /= Main.rand.Next(3) + 1;
				}
				if (Main.rand.Next(2) == 0)
				{
					num8 /= Main.rand.Next(3) + 1;
				}
				num7 -= (float)(1000000 * num8);
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 74, num8);
				continue;
			}
			if (num7 > 10000f)
			{
				int num9 = (int)(num7 / 10000f);
				if (num9 > 50 && Main.rand.Next(2) == 0)
				{
					num9 /= Main.rand.Next(3) + 1;
				}
				if (Main.rand.Next(2) == 0)
				{
					num9 /= Main.rand.Next(3) + 1;
				}
				num7 -= (float)(10000 * num9);
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 73, num9);
				continue;
			}
			if (num7 > 100f)
			{
				int num10 = (int)(num7 / 100f);
				if (num10 > 50 && Main.rand.Next(2) == 0)
				{
					num10 /= Main.rand.Next(3) + 1;
				}
				if (Main.rand.Next(2) == 0)
				{
					num10 /= Main.rand.Next(3) + 1;
				}
				num7 -= (float)(100 * num10);
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 72, num10);
				continue;
			}
			int num11 = (int)num7;
			if (num11 > 50 && Main.rand.Next(2) == 0)
			{
				num11 /= Main.rand.Next(3) + 1;
			}
			if (Main.rand.Next(2) == 0)
			{
				num11 /= Main.rand.Next(4) + 1;
			}
			if (num11 < 1)
			{
				num11 = 1;
			}
			num7 -= (float)num11;
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 71, num11);
		}
	}

	public static int PlaceChest(int x, int y, ushort type = 21, bool notNearOtherChests = false, int style = 0)
	{
		int num = -1;
		if (TileID.Sets.Boulders[Main.tile[x, y + 1].type] || TileID.Sets.Boulders[Main.tile[x + 1, y + 1].type])
		{
			return -1;
		}
		if (TileObject.CanPlace(x, y, type, style, 1, out var objectData))
		{
			bool flag = true;
			if (notNearOtherChests && Chest.NearOtherChests(x - 1, y - 1))
			{
				flag = false;
			}
			if (flag)
			{
				TileObject.Place(objectData);
				num = Chest.CreateChest(objectData.xCoord, objectData.yCoord);
			}
		}
		else
		{
			num = -1;
		}
		if (num != -1 && Main.netMode == 1 && type == 21)
		{
			NetMessage.SendData(34, -1, -1, null, 0, x, y, style);
		}
		if (num != -1 && Main.netMode == 1 && type == 467)
		{
			NetMessage.SendData(34, -1, -1, null, 4, x, y, style);
		}
		if (num != 1 && Main.netMode == 1 && type >= TileID.Count && TileID.Sets.BasicChest[type])
		{
			NetMessage.SendData(34, -1, -1, null, 100, x, y, style, 0, type);
		}
		return num;
	}

	public static void PlaceChestDirect(int x, int y, ushort type, int style, int id)
	{
		Chest.CreateChest(x, y - 1, id);
		for (int i = 0; i <= 1; i++)
		{
			for (int j = -1; j <= 0; j++)
			{
				if (Main.tile[x + i, y + j] == null)
				{
					Main.tile[x + i, y + j] = default(Tile);
				}
			}
		}
		Main.tile[x, y - 1].active(active: true);
		Main.tile[x, y - 1].frameY = 0;
		Main.tile[x, y - 1].frameX = (short)(36 * style);
		Main.tile[x, y - 1].type = type;
		Main.tile[x, y - 1].halfBrick(halfBrick: false);
		Main.tile[x + 1, y - 1].active(active: true);
		Main.tile[x + 1, y - 1].frameY = 0;
		Main.tile[x + 1, y - 1].frameX = (short)(18 + 36 * style);
		Main.tile[x + 1, y - 1].type = type;
		Main.tile[x + 1, y - 1].halfBrick(halfBrick: false);
		Main.tile[x, y].active(active: true);
		Main.tile[x, y].frameY = 18;
		Main.tile[x, y].frameX = (short)(36 * style);
		Main.tile[x, y].type = type;
		Main.tile[x, y].halfBrick(halfBrick: false);
		Main.tile[x + 1, y].active(active: true);
		Main.tile[x + 1, y].frameY = 18;
		Main.tile[x + 1, y].frameX = (short)(18 + 36 * style);
		Main.tile[x + 1, y].type = type;
		Main.tile[x + 1, y].halfBrick(halfBrick: false);
	}

	public static void PlaceDresserDirect(int x, int y, ushort type, int style, int id)
	{
		Chest.CreateChest(x - 1, y - 1, id);
		for (int i = -1; i <= 1; i++)
		{
			for (int j = -1; j <= 0; j++)
			{
				if (Main.tile[x + i, y + j] == null)
				{
					Main.tile[x + i, y + j] = default(Tile);
				}
			}
		}
		short num = (short)(style * 54);
		Main.tile[x - 1, y - 1].active(active: true);
		Main.tile[x - 1, y - 1].frameY = 0;
		Main.tile[x - 1, y - 1].frameX = num;
		Main.tile[x - 1, y - 1].type = type;
		Main.tile[x, y - 1].active(active: true);
		Main.tile[x, y - 1].frameY = 0;
		Main.tile[x, y - 1].frameX = (short)(num + 18);
		Main.tile[x, y - 1].type = type;
		Main.tile[x + 1, y - 1].active(active: true);
		Main.tile[x + 1, y - 1].frameY = 0;
		Main.tile[x + 1, y - 1].frameX = (short)(num + 36);
		Main.tile[x + 1, y - 1].type = type;
		Main.tile[x - 1, y].active(active: true);
		Main.tile[x - 1, y].frameY = 18;
		Main.tile[x - 1, y].frameX = num;
		Main.tile[x - 1, y].type = type;
		Main.tile[x, y].active(active: true);
		Main.tile[x, y].frameY = 18;
		Main.tile[x, y].frameX = (short)(num + 18);
		Main.tile[x, y].type = type;
		Main.tile[x + 1, y].active(active: true);
		Main.tile[x + 1, y].frameY = 18;
		Main.tile[x + 1, y].frameX = (short)(num + 36);
		Main.tile[x + 1, y].type = type;
	}

	public static void CheckChest(int i, int j, int type)
	{
		if (destroyObject)
		{
			return;
		}
		bool flag = false;
		int num = 0;
		int num2 = j;
		num += Main.tile[i, j].frameX / 18;
		num2 += Main.tile[i, j].frameY / 18 * -1;
		while (num > 1)
		{
			num -= 2;
		}
		num *= -1;
		num += i;
		for (int k = num; k < num + 2; k++)
		{
			for (int l = num2; l < num2 + 2; l++)
			{
				if (Main.tile[k, l] == null)
				{
					Main.tile[k, l] = default(Tile);
				}
				int num3;
				for (num3 = Main.tile[k, l].frameX / 18; num3 > 1; num3 -= 2)
				{
				}
				if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || num3 != k - num || Main.tile[k, l].frameY != (l - num2) * 18)
				{
					flag = true;
				}
			}
			if (Main.tile[k, num2 + 2] == null)
			{
				Main.tile[k, num2 + 2] = default(Tile);
			}
			if ((!Main.tile[k, num2 + 2].active() || !Main.tileSolid[Main.tile[k, num2 + 2].type]) && Chest.CanDestroyChest(num, num2))
			{
				flag = true;
			}
		}
		if (!flag)
		{
			return;
		}
		int chestItemDrop = GetChestItemDrop(i, j, type);
		destroyObject = true;
		bool drop = TileLoader.Drop(i, j, type);
		for (int m = num; m < num + 2; m++)
		{
			for (int n = num2; n < num2 + 3; n++)
			{
				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
				{
					Chest.DestroyChest(m, n);
					KillTile(m, n);
				}
			}
		}
		using (new Item.DisableNewItemMethod(!drop))
		{
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, chestItemDrop);
			destroyObject = false;
		}
	}

	private static int GetChestItemDrop(int x, int y, int type)
	{
		int num = Main.tile[x, y].frameX / 36;
		if (type == 467)
		{
			return Chest.chestItemSpawn2[num];
		}
		return Chest.chestItemSpawn[num];
	}

	public static bool PlaceActuator(int i, int j)
	{
		if (!Main.tile[i, j].actuator())
		{
			SoundEngine.PlaySound(0, i * 16, j * 16);
			Main.tile[i, j].actuator(actuator: true);
			return true;
		}
		return false;
	}

	public static bool KillActuator(int i, int j)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		if (Main.tile[i, j].actuator())
		{
			SoundEngine.PlaySound(0, i * 16, j * 16);
			Main.tile[i, j].actuator(actuator: false);
			if (Main.netMode != 1)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 849);
			}
			for (int k = 0; k < 5; k++)
			{
				Dust.NewDust(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16, 50);
			}
			return true;
		}
		return false;
	}

	public static bool PlaceWire(int i, int j)
	{
		if (!Main.tile[i, j].wire())
		{
			SoundEngine.PlaySound(0, i * 16, j * 16);
			Main.tile[i, j].wire(wire: true);
			return true;
		}
		return false;
	}

	public static bool KillWire(int i, int j)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		if (Main.tile[i, j].wire())
		{
			SoundEngine.PlaySound(0, i * 16, j * 16);
			Main.tile[i, j].wire(wire: false);
			if (Main.netMode != 1)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 530);
			}
			for (int k = 0; k < 5; k++)
			{
				Dust.NewDust(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16, 50);
			}
			return true;
		}
		return false;
	}

	public static bool PlaceWire2(int i, int j)
	{
		if (!Main.tile[i, j].wire2())
		{
			SoundEngine.PlaySound(0, i * 16, j * 16);
			Main.tile[i, j].wire2(wire2: true);
			return true;
		}
		return false;
	}

	public static bool KillWire2(int i, int j)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		if (Main.tile[i, j].wire2())
		{
			SoundEngine.PlaySound(0, i * 16, j * 16);
			Main.tile[i, j].wire2(wire2: false);
			if (Main.netMode != 1)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 530);
			}
			for (int k = 0; k < 5; k++)
			{
				Dust.NewDust(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16, 50);
			}
			return true;
		}
		return false;
	}

	public static bool PlaceWire3(int i, int j)
	{
		if (!Main.tile[i, j].wire3())
		{
			SoundEngine.PlaySound(0, i * 16, j * 16);
			Main.tile[i, j].wire3(wire3: true);
			return true;
		}
		return false;
	}

	public static bool KillWire3(int i, int j)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		if (Main.tile[i, j].wire3())
		{
			SoundEngine.PlaySound(0, i * 16, j * 16);
			Main.tile[i, j].wire3(wire3: false);
			if (Main.netMode != 1)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 530);
			}
			for (int k = 0; k < 5; k++)
			{
				Dust.NewDust(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16, 50);
			}
			return true;
		}
		return false;
	}

	public static bool PlaceWire4(int i, int j)
	{
		if (!Main.tile[i, j].wire4())
		{
			SoundEngine.PlaySound(0, i * 16, j * 16);
			Main.tile[i, j].wire4(wire4: true);
			return true;
		}
		return false;
	}

	public static bool KillWire4(int i, int j)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		if (Main.tile[i, j].wire4())
		{
			SoundEngine.PlaySound(0, i * 16, j * 16);
			Main.tile[i, j].wire4(wire4: false);
			if (Main.netMode != 1)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 530);
			}
			for (int k = 0; k < 5; k++)
			{
				Dust.NewDust(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16, 50);
			}
			return true;
		}
		return false;
	}

	public static bool IsFitToPlaceFlowerIn(int x, int y, int typeAttemptedToPlace)
	{
		if (y < 1 || y > Main.maxTilesY - 1)
		{
			return false;
		}
		Tile tile = Main.tile[x, y + 1];
		if (tile.active() && tile.slope() == 0 && !tile.halfBrick())
		{
			if (((tile.type != 2 && tile.type != 78 && tile.type != 380 && tile.type != 477 && tile.type != 579) || typeAttemptedToPlace != 3) && ((tile.type != 23 && tile.type != 661) || typeAttemptedToPlace != 24) && ((tile.type != 109 && tile.type != 492) || typeAttemptedToPlace != 110) && ((tile.type != 199 && tile.type != 662) || typeAttemptedToPlace != 201))
			{
				if (tile.type == 633)
				{
					return typeAttemptedToPlace == 637;
				}
				return false;
			}
			return true;
		}
		return false;
	}

	private static bool SeaOatWaterCheck(int x, int y)
	{
		int num = 45;
		int num2 = 20;
		int num3 = 20;
		int num4 = num + 1;
		int num5 = 0;
		bool flag = false;
		if (x <= beachDistance || x >= Main.maxTilesX - beachDistance)
		{
			flag = true;
			num = 65;
			num2 += 5;
		}
		for (int i = x - num; i <= x + num; i++)
		{
			for (int j = y - num2; j <= y + num2; j++)
			{
				if (InWorld(i, j) && !SolidTile(i, j) && Main.tile[i, j].liquid > 0)
				{
					num5 += Main.tile[i, j].liquid;
					int num6 = Math.Abs(i - x);
					if (num6 < num4)
					{
						num4 = num6;
					}
				}
			}
		}
		if (num5 / 255 >= num3)
		{
			if (flag)
			{
				return false;
			}
			return true;
		}
		if (flag)
		{
			return true;
		}
		return false;
	}

	private static bool PlantSeaOat(int x, int y)
	{
		if (Main.tile[x, y].wall > 0 || Main.tile[x, y].active() || Main.tile[x, y].liquid > 0 || !SolidTileAllowBottomSlope(x, y + 1) || !TileID.Sets.Conversion.Sand[Main.tile[x, y + 1].type])
		{
			return false;
		}
		if (!SeaOatWaterCheck(x, y))
		{
			return false;
		}
		Main.tile[x, y].active(active: true);
		Main.tile[x, y].slope(0);
		Main.tile[x, y].halfBrick(halfBrick: false);
		Main.tile[x, y].type = 529;
		Main.tile[x, y].frameX = (short)(genRand.Next(5) * 18);
		int num = 0;
		Main.tile[x, y].frameY = (short)(num * 34);
		if (Main.netMode == 2)
		{
			NetMessage.SendTileSquare(-1, x, y);
		}
		return true;
	}

	private static bool CheckSeaOat(int x, int y)
	{
		if (!SeaOatWaterCheck(x, y))
		{
			KillTile(x, y);
			if (Main.netMode == 2)
			{
				NetMessage.SendData(17, -1, -1, null, 0, x, y);
			}
			return false;
		}
		return true;
	}

	private static bool GrowSeaOat(int x, int y)
	{
		Tile tile = Main.tile[x, y];
		if (tile.frameX < 180)
		{
			tile = Main.tile[x, y];
			tile.frameX += 90;
		}
		if (Main.netMode == 2)
		{
			NetMessage.SendTileSquare(-1, x, y);
		}
		return false;
	}

	private static int GetWaterDepth(int x, int y)
	{
		int num = y;
		while (!SolidTile(x, num))
		{
			num++;
			if (num > Main.maxTilesY - 1)
			{
				return 0;
			}
		}
		num--;
		int num2 = num;
		while (Main.tile[x, num2].liquid > 0 && !SolidTile(x, num2))
		{
			num2--;
		}
		return num - num2;
	}

	private static int CountGrowingPlantTiles(int x, int y, int range, int type)
	{
		int num = 0;
		for (int i = x - range; i <= x + range; i++)
		{
			for (int j = y - range * 3; j <= y + range * 3; j++)
			{
				if (Main.tile[i, j].active() && Main.tile[i, j].type == type)
				{
					num++;
				}
			}
		}
		return num;
	}

	private static bool PlaceBamboo(int x, int y)
	{
		int num = 2;
		int num2 = 5;
		int num3 = genRand.Next(1, 21);
		Tile tile = Main.tile[x, y];
		if (tile.wall > 0 && (double)y <= Main.worldSurface)
		{
			return false;
		}
		if (tile.active() && tile.type == 314)
		{
			return false;
		}
		Tile tile2 = Main.tile[x, y + 1];
		if (tile2.type == 571 || tile2.type == 60)
		{
			int waterDepth = GetWaterDepth(x, y);
			if (waterDepth < num || waterDepth > num2)
			{
				return false;
			}
			int num4 = CountGrowingPlantTiles(x, y, 5, 571);
			int i = 1;
			if (tile2.type == 571)
			{
				for (; !SolidTile(x, y + i); i++)
				{
				}
				if (i + num4 / genRand.Next(1, 21) > num3)
				{
					return false;
				}
			}
			else
			{
				num4 += 25;
			}
			num4 += i * 2;
			if (num4 > genRand.Next(40, 61))
			{
				return false;
			}
			tile = Main.tile[x, y];
			tile.active(active: true);
			tile.type = 571;
			tile.frameX = 0;
			tile.frameY = 0;
			tile.slope(0);
			tile.halfBrick(halfBrick: false);
			SquareTileFrame(x, y);
			return true;
		}
		return false;
	}

	public static void CheckBamboo(int x, int y)
	{
		Tile tile = Main.tile[x, y + 1];
		if (tile == null)
		{
			return;
		}
		if (!tile.active() || (tile.type != 60 && tile.type != 571))
		{
			KillTile(x, y);
			if (Main.netMode == 2)
			{
				NetMessage.SendData(17, -1, -1, null, 0, x, y);
			}
			SquareTileFrame(x, y);
			return;
		}
		Tile tile2 = Main.tile[x, y - 1];
		if (tile2 == null)
		{
			return;
		}
		Tile tile3 = Main.tile[x, y];
		if (tile3 == null)
		{
			return;
		}
		bool num3 = tile2.active() && tile2.type == 571;
		bool flag = tile.active() && tile.type == 571;
		int num2 = tile3.frameX / 18;
		tile3.frameY = 0;
		if (num3)
		{
			if (flag)
			{
				if (num2 < 5 || num2 > 14)
				{
					tile3.frameX = (short)(genRand.Next(5, 15) * 18);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y);
					}
				}
			}
			else if (num2 < 1 || num2 > 4)
			{
				tile3.frameX = (short)(genRand.Next(1, 5) * 18);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
			}
		}
		else if (flag)
		{
			if (num2 < 15 || num2 > 19)
			{
				tile3.frameX = (short)(genRand.Next(15, 20) * 18);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
			}
		}
		else if (num2 != 0)
		{
			tile3.frameX = 0;
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, x, y);
			}
		}
	}

	public static void PlaceUnderwaterPlant(ushort type, int x, int y)
	{
		if (CanUnderwaterPlantGrowHere(type, x, y, ignoreSelf: false))
		{
			Tile tileSafely = Framing.GetTileSafely(x, y + 1);
			tileSafely.slope(0);
			tileSafely.halfBrick(halfBrick: false);
			Tile tileSafely2 = Framing.GetTileSafely(x, y);
			tileSafely2.active(active: true);
			tileSafely2.type = type;
			tileSafely2.frameX = 0;
			tileSafely2.frameY = 0;
			tileSafely2.slope(0);
			tileSafely2.halfBrick(halfBrick: false);
			SquareTileFrame(x, y);
		}
	}

	public static bool CanUnderwaterPlantGrowHere(ushort type, int x, int y, bool ignoreSelf)
	{
		if (!InWorld(x, y, 50))
		{
			return false;
		}
		Tile tileSafely = Framing.GetTileSafely(x, y);
		if (!ignoreSelf && tileSafely.active())
		{
			return false;
		}
		for (int i = 0; i < 3; i++)
		{
			tileSafely = Framing.GetTileSafely(x, y - i);
			if (tileSafely.liquid == 0 || tileSafely.liquidType() != 0)
			{
				return false;
			}
		}
		Tile tileSafely2 = Framing.GetTileSafely(x, y + 1);
		if (!tileSafely2.nactive())
		{
			return false;
		}
		if (!TileID.Sets.Conversion.Sand[tileSafely2.type] && type != tileSafely2.type)
		{
			return false;
		}
		ushort wall = Framing.GetTileSafely(x, y).wall;
		if (wall != 0 && (uint)(wall - 63) > 6u && (uint)(wall - 80) > 1u)
		{
			return false;
		}
		return true;
	}

	public static void CheckUnderwaterPlant(ushort type, int x, int y)
	{
		if (!CanUnderwaterPlantGrowHere(type, x, y, ignoreSelf: true))
		{
			KillTile(x, y);
			if (Main.netMode == 2)
			{
				NetMessage.SendData(17, -1, -1, null, 0, x, y);
			}
			SquareTileFrame(x, y);
			return;
		}
		Tile tileSafely = Framing.GetTileSafely(x, y - 1);
		Tile tileSafely2 = Framing.GetTileSafely(x, y);
		Tile tileSafely3 = Framing.GetTileSafely(x, y + 1);
		bool num3 = tileSafely.active() && tileSafely.type == type;
		bool flag = tileSafely3.active() && tileSafely3.type == type;
		int num2 = tileSafely2.frameX / 18;
		tileSafely2.frameY = 0;
		if (num3)
		{
			if (1 > num2 || num2 > 7)
			{
				tileSafely2.frameX = (short)(genRand.Next(1, 8) * 18);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
			}
		}
		else if (flag)
		{
			if (7 > num2 || num2 > 12)
			{
				tileSafely2.frameX = (short)(genRand.Next(7, 13) * 18);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
			}
		}
		else if (num2 != 0)
		{
			tileSafely2.frameX = 0;
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, x, y);
			}
		}
	}

	public static Point PlaceCatTail(int x, int j)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0317: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03be: Unknown result type (might be due to invalid IL or missing references)
		//IL_0437: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f8: Unknown result type (might be due to invalid IL or missing references)
		int num = j;
		Point result = default(Point);
		((Point)(ref result))._002Ector(-1, -1);
		if (x < 50 || x > Main.maxTilesX - 50 || num < 50 || num > Main.maxTilesY - 50)
		{
			return result;
		}
		if ((Main.tile[x, num].active() && Main.tile[x, num].type != 71) || Main.tile[x, num].liquid == 0 || Main.tile[x, num].liquidType() != 0)
		{
			return result;
		}
		while (Main.tile[x, num].liquid > 0 && num > 50)
		{
			num--;
		}
		num++;
		if (Main.tile[x, num].active() || Main.tile[x, num - 1].active() || Main.tile[x, num].liquid == 0 || Main.tile[x, num].liquidType() != 0)
		{
			return result;
		}
		if (Main.tile[x, num].wall != 0 && Main.tile[x, num].wall != 80 && Main.tile[x, num].wall != 81 && Main.tile[x, num].wall != 69 && (Main.tile[x, num].wall < 63 || Main.tile[x, num].wall > 68))
		{
			return result;
		}
		int num2 = 7;
		int num3 = 0;
		for (int i = x - num2; i <= x + num2; i++)
		{
			for (int k = num - num2; k <= num + num2; k++)
			{
				if (Main.tile[i, k].active() && Main.tile[i, k].type == 519)
				{
					num3++;
					break;
				}
			}
		}
		if (num3 > 3)
		{
			return result;
		}
		int l;
		for (l = num; (!Main.tile[x, l].active() || !Main.tileSolid[Main.tile[x, l].type] || Main.tileSolidTop[Main.tile[x, l].type]) && l < Main.maxTilesY - 50; l++)
		{
			if (Main.tile[x, l].active() && Main.tile[x, l].type != 71)
			{
				return result;
			}
		}
		int num4 = catTailDistance - 1;
		if (l - num > num4)
		{
			return result;
		}
		if (l - num < 2)
		{
			return result;
		}
		int type = Main.tile[x, l].type;
		if (!Main.tile[x, l].nactive())
		{
			return result;
		}
		int num5 = -1;
		switch (type)
		{
		case 2:
		case 477:
			num5 = 0;
			break;
		case 53:
			if (x < beachDistance || x > Main.maxTilesX - beachDistance)
			{
				return result;
			}
			num5 = 18;
			break;
		case 199:
		case 234:
		case 662:
			num5 = 54;
			break;
		case 23:
		case 112:
		case 661:
			num5 = 72;
			break;
		case 70:
			num5 = 90;
			break;
		}
		if (num5 < 0)
		{
			return result;
		}
		if (Main.tile[x, l].topSlope() && gen && genRand.Next(3) != 0)
		{
			Main.tile[x, l].slope(0);
		}
		else if (Main.tile[x, l].topSlope() || Main.tile[x, l].halfBrick())
		{
			return result;
		}
		num = l - 1;
		Main.tile[x, num].active(active: true);
		Main.tile[x, num].type = 519;
		Main.tile[x, num].frameX = 0;
		Main.tile[x, num].frameY = (short)num5;
		Main.tile[x, num].halfBrick(halfBrick: false);
		Main.tile[x, num].slope(0);
		Main.tile[x, num].CopyPaintAndCoating(Main.tile[x, num + 1]);
		SquareTileFrame(x, num);
		return new Point(x, num);
	}

	public static void CheckCatTail(int x, int j)
	{
		if (Main.tile[x, j] == null)
		{
			return;
		}
		int num = j;
		bool flag = false;
		int num2 = num;
		while ((!Main.tile[x, num2].active() || !Main.tileSolid[Main.tile[x, num2].type] || Main.tileSolidTop[Main.tile[x, num2].type]) && num2 < Main.maxTilesY - 50)
		{
			if (Main.tile[x, num2].active() && Main.tile[x, num2].type != 519)
			{
				flag = true;
			}
			if (!Main.tile[x, num2].active())
			{
				break;
			}
			num2++;
			if (Main.tile[x, num2] == null)
			{
				return;
			}
		}
		num = num2 - 1;
		if (Main.tile[x, num] == null)
		{
			return;
		}
		while (Main.tile[x, num] != null && Main.tile[x, num].liquid > 0 && num > 50)
		{
			if ((Main.tile[x, num].active() && Main.tile[x, num].type != 519) || Main.tile[x, num].liquidType() != 0)
			{
				flag = true;
			}
			num--;
			if (Main.tile[x, num] == null)
			{
				return;
			}
		}
		num++;
		if (Main.tile[x, num] == null)
		{
			return;
		}
		int num3 = num;
		int num4 = catTailDistance;
		if (num2 - num3 > num4)
		{
			flag = true;
		}
		int type = Main.tile[x, num2].type;
		int num5 = -1;
		switch (type)
		{
		case 2:
		case 477:
			num5 = 0;
			break;
		case 53:
			num5 = 18;
			break;
		case 199:
		case 234:
		case 662:
			num5 = 54;
			break;
		case 23:
		case 112:
		case 661:
			num5 = 72;
			break;
		case 70:
			num5 = 90;
			break;
		}
		if (!Main.tile[x, num2].nactive())
		{
			flag = true;
		}
		if (num5 < 0)
		{
			flag = true;
		}
		num = num2 - 1;
		if (Main.tile[x, num] != null && !Main.tile[x, num].active())
		{
			for (int num6 = num; num6 >= num3; num6--)
			{
				if (Main.tile[x, num6] == null)
				{
					return;
				}
				if (Main.tile[x, num6].active() && Main.tile[x, num6].type == 519)
				{
					num = num6;
					break;
				}
			}
		}
		while (Main.tile[x, num] != null && Main.tile[x, num].active() && Main.tile[x, num].type == 519)
		{
			num--;
		}
		num++;
		if (Main.tile[x, num2 - 1] != null && Main.tile[x, num2 - 1].liquid < 127 && genRand.Next(4) == 0)
		{
			flag = true;
		}
		if (Main.tile[x, num] != null && Main.tile[x, num].frameX >= 180 && Main.tile[x, num].liquid > 127 && genRand.Next(4) == 0)
		{
			flag = true;
		}
		if (Main.tile[x, num] != null && Main.tile[x, num2 - 1] != null && Main.tile[x, num].frameX > 18)
		{
			if (Main.tile[x, num2 - 1].frameX < 36 || Main.tile[x, num2 - 1].frameX > 72)
			{
				flag = true;
			}
			else if (Main.tile[x, num].frameX < 90)
			{
				flag = true;
			}
			else if (Main.tile[x, num].frameX >= 108 && Main.tile[x, num].frameX <= 162)
			{
				Main.tile[x, num].frameX = 90;
			}
		}
		if (num2 > num + 4 && Main.tile[x, num + 4] != null && Main.tile[x, num + 3] != null && Main.tile[x, num + 4].liquid == 0 && Main.tile[x, num + 3].type == 519)
		{
			flag = true;
		}
		if (flag)
		{
			int num7 = num3;
			if (num < num3)
			{
				num7 = num;
			}
			num7 -= 4;
			for (int i = num7; i <= num2; i++)
			{
				if (Main.tile[x, i] != null && Main.tile[x, i].active() && Main.tile[x, i].type == 519)
				{
					KillTile(x, i);
					if (Main.netMode == 2)
					{
						NetMessage.SendData(17, -1, -1, null, 0, x, i);
					}
					SquareTileFrame(x, i);
				}
			}
		}
		else
		{
			if (num5 == Main.tile[x, num].frameY)
			{
				return;
			}
			for (int k = num; k < num2; k++)
			{
				if (Main.tile[x, k] != null && Main.tile[x, k].active() && Main.tile[x, k].type == 519)
				{
					Main.tile[x, k].frameY = (short)num5;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, num);
					}
				}
			}
		}
	}

	public static void GrowCheckSeaweed(int x, int y)
	{
		int maxValue = 1;
		if (Main.netMode == 1)
		{
			return;
		}
		if ((Main.tile[x, y].type == 549 && Main.tile[x, y].liquid < 200) || Main.tile[x, y - 1].liquid < 200)
		{
			if (Main.tile[x, y].active() && Main.tile[x, y].type == 549 && genRand.Next(2) == 0)
			{
				KillTile(x, y);
				if (Main.netMode == 2)
				{
					NetMessage.SendData(17, -1, -1, null, 0, x, y);
				}
			}
		}
		else
		{
			if (Main.tile[x, y - 1].active() || Main.tile[x, y - 2].active() || genRand.Next(maxValue) != 0 || Main.tile[x, y - 2].liquid != byte.MaxValue || Main.tile[x, y - 3].liquid != byte.MaxValue)
			{
				return;
			}
			int num = 17;
			int num2 = 4;
			int num3 = 30;
			int num4 = 0;
			for (int i = x - num2; i <= x + num2; i++)
			{
				for (int j = y; j <= y + num2 * 3; j++)
				{
					if (Main.tile[i, j].active() && Main.tile[i, j].type == 549)
					{
						num4++;
						if (num4 > num3)
						{
							return;
						}
					}
				}
			}
			int k;
			for (k = y; !SolidTile(x, k) && k < Main.maxTilesY - 50; k++)
			{
			}
			if (k - y < num - genRand.Next(20))
			{
				PlaceTile(x, y - 1, 549, mute: true);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y - 1);
				}
			}
		}
	}

	public static void GrowCatTail(int x, int j)
	{
		if (Main.netMode == 1)
		{
			return;
		}
		int num = j;
		Tile tile;
		while (true)
		{
			tile = Main.tile[x, num];
			if (tile.liquid <= 0 || num <= 50)
			{
				break;
			}
			num--;
		}
		num++;
		int i = num;
		while (true)
		{
			tile = Main.tile[x, i];
			if (tile.active())
			{
				bool[] tileSolid = Main.tileSolid;
				tile = Main.tile[x, i];
				if (tileSolid[tile.type])
				{
					bool[] tileSolidTop = Main.tileSolidTop;
					tile = Main.tile[x, i];
					if (!tileSolidTop[tile.type])
					{
						break;
					}
				}
			}
			if (i >= Main.maxTilesY - 50)
			{
				break;
			}
			i++;
		}
		num = i - 1;
		while (true)
		{
			tile = Main.tile[x, num];
			if (!tile.active())
			{
				break;
			}
			tile = Main.tile[x, num];
			if (tile.type != 519)
			{
				break;
			}
			num--;
		}
		num++;
		tile = Main.tile[x, num];
		if (tile.frameX == 90)
		{
			tile = Main.tile[x, num - 1];
			if (tile.active())
			{
				bool[] tileCut = Main.tileCut;
				tile = Main.tile[x, num - 1];
				if (tileCut[tile.type])
				{
					KillTile(x, num - 1);
					if (Main.netMode == 2)
					{
						NetMessage.SendData(17, -1, -1, null, 0, x, num - 1);
					}
				}
			}
		}
		tile = Main.tile[x, num - 1];
		if (tile.active())
		{
			return;
		}
		tile = Main.tile[x, num];
		if (tile.frameX == 0)
		{
			tile = Main.tile[x, num];
			tile.frameX = 18;
			SquareTileFrame(x, num);
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, x, num);
			}
		}
		else
		{
			tile = Main.tile[x, num];
			if (tile.frameX == 18)
			{
				tile = Main.tile[x, num];
				tile.frameX = (short)(18 * genRand.Next(2, 5));
				tile = Main.tile[x, num - 1];
				tile.active(active: true);
				tile = Main.tile[x, num - 1];
				tile.type = 519;
				tile = Main.tile[x, num - 1];
				tile.frameX = 90;
				tile = Main.tile[x, num - 1];
				ref short frameY = ref tile.frameY;
				tile = Main.tile[x, num];
				frameY = tile.frameY;
				tile = Main.tile[x, num - 1];
				tile.halfBrick(halfBrick: false);
				tile = Main.tile[x, num - 1];
				tile.slope(0);
				tile = Main.tile[x, num - 1];
				tile.CopyPaintAndCoating(Main.tile[x, num]);
				SquareTileFrame(x, num);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, num);
				}
			}
			else
			{
				tile = Main.tile[x, num];
				if (tile.frameX == 90)
				{
					tile = Main.tile[x, num - 1];
					if (tile.liquid == 0)
					{
						tile = Main.tile[x, num - 2];
						if (!tile.active())
						{
							tile = Main.tile[x, num];
							if (tile.liquid <= 0)
							{
								tile = Main.tile[x, num + 1];
								if (tile.liquid <= 0)
								{
									tile = Main.tile[x, num + 2];
									if (tile.liquid <= 0)
									{
										goto IL_0482;
									}
								}
							}
							if (genRand.Next(3) == 0)
							{
								tile = Main.tile[x, num];
								tile.frameX = 108;
								tile = Main.tile[x, num - 1];
								tile.active(active: true);
								tile = Main.tile[x, num - 1];
								tile.type = 519;
								tile = Main.tile[x, num - 1];
								tile.frameX = 90;
								tile = Main.tile[x, num - 1];
								ref short frameY2 = ref tile.frameY;
								tile = Main.tile[x, num];
								frameY2 = tile.frameY;
								tile = Main.tile[x, num - 1];
								tile.halfBrick(halfBrick: false);
								tile = Main.tile[x, num - 1];
								tile.slope(0);
								tile = Main.tile[x, num - 1];
								tile.CopyPaintAndCoating(Main.tile[x, num]);
								SquareTileFrame(x, num);
								goto IL_0670;
							}
						}
						goto IL_0482;
					}
					tile = Main.tile[x, num];
					tile.frameX = 108;
					tile = Main.tile[x, num - 1];
					tile.active(active: true);
					tile = Main.tile[x, num - 1];
					tile.type = 519;
					tile = Main.tile[x, num - 1];
					tile.frameX = 90;
					tile = Main.tile[x, num - 1];
					ref short frameY3 = ref tile.frameY;
					tile = Main.tile[x, num];
					frameY3 = tile.frameY;
					tile = Main.tile[x, num - 1];
					tile.halfBrick(halfBrick: false);
					tile = Main.tile[x, num - 1];
					tile.slope(0);
					tile = Main.tile[x, num - 1];
					tile.CopyPaintAndCoating(Main.tile[x, num]);
					SquareTileFrame(x, num);
				}
			}
		}
		goto IL_0670;
		IL_0670:
		SquareTileFrame(x, num - 1, resetFrame: false);
		if (Main.netMode == 2)
		{
			NetMessage.SendTileSquare(-1, x, num - 1, 1, 2);
		}
		return;
		IL_0482:
		int num2 = genRand.Next(3);
		tile = Main.tile[x, num];
		tile.frameX = (short)(126 + num2 * 18);
		tile = Main.tile[x, num - 1];
		tile.active(active: true);
		tile = Main.tile[x, num - 1];
		tile.type = 519;
		tile = Main.tile[x, num - 1];
		tile.frameX = (short)(180 + num2 * 18);
		tile = Main.tile[x, num - 1];
		ref short frameY4 = ref tile.frameY;
		tile = Main.tile[x, num];
		frameY4 = tile.frameY;
		tile = Main.tile[x, num - 1];
		tile.halfBrick(halfBrick: false);
		tile = Main.tile[x, num - 1];
		tile.slope(0);
		tile = Main.tile[x, num - 1];
		tile.CopyPaintAndCoating(Main.tile[x, num]);
		SquareTileFrame(x, num);
		goto IL_0670;
	}

	public static bool PlaceLilyPad(int x, int j)
	{
		int num = j;
		if (x < 50 || x > Main.maxTilesX - 50 || num < 50 || num > Main.maxTilesY - 50)
		{
			return false;
		}
		if (Main.tile[x, num].active() || Main.tile[x, num].liquid == 0 || Main.tile[x, num].liquidType() != 0)
		{
			return false;
		}
		while (Main.tile[x, num].liquid > 0 && num > 50)
		{
			num--;
		}
		num++;
		if (Main.tile[x, num].active() || Main.tile[x, num - 1].active() || Main.tile[x, num].liquid == 0 || Main.tile[x, num].liquidType() != 0)
		{
			return false;
		}
		if (Main.tile[x, num].wall != 0 && Main.tile[x, num].wall != 15 && Main.tile[x, num].wall != 70 && (Main.tile[x, num].wall < 63 || Main.tile[x, num].wall > 68))
		{
			return false;
		}
		int num2 = 5;
		int num3 = 0;
		for (int i = x - num2; i <= x + num2; i++)
		{
			for (int k = num - num2; k <= num + num2; k++)
			{
				if (Main.tile[i, k].active() && Main.tile[i, k].type == 518)
				{
					num3++;
				}
			}
		}
		if (num3 > 3)
		{
			return false;
		}
		int l;
		for (l = num; (!Main.tile[x, l].active() || !Main.tileSolid[Main.tile[x, l].type] || Main.tileSolidTop[Main.tile[x, l].type]) && l < Main.maxTilesY - 50; l++)
		{
			if (Main.tile[x, l].active() && Main.tile[x, l].type == 519)
			{
				return false;
			}
		}
		int num4 = 12;
		if (l - num > num4)
		{
			return false;
		}
		if (l - num < 3)
		{
			return false;
		}
		int type = Main.tile[x, l].type;
		int num5 = -1;
		if (type == 2 || type == 477)
		{
			num5 = 0;
		}
		if (type == 109 || type == 109 || type == 116)
		{
			num5 = 18;
		}
		if (type == 60)
		{
			num5 = 36;
		}
		if (num5 < 0)
		{
			return false;
		}
		Main.tile[x, num].active(active: true);
		Main.tile[x, num].type = 518;
		if (genRand.Next(2) == 0)
		{
			Main.tile[x, num].frameX = (short)(18 * genRand.Next(3));
		}
		else if (genRand.Next(15) == 0)
		{
			Main.tile[x, num].frameX = (short)(18 * genRand.Next(18));
		}
		else
		{
			int num6 = Main.maxTilesX / 5;
			if (x < num6)
			{
				Main.tile[x, num].frameX = (short)(18 * genRand.Next(6, 9));
			}
			else if (x < num6 * 2)
			{
				Main.tile[x, num].frameX = (short)(18 * genRand.Next(9, 12));
			}
			else if (x < num6 * 3)
			{
				Main.tile[x, num].frameX = (short)(18 * genRand.Next(3, 6));
			}
			else if (x < num6 * 4)
			{
				Main.tile[x, num].frameX = (short)(18 * genRand.Next(15, 18));
			}
			else
			{
				Main.tile[x, num].frameX = (short)(18 * genRand.Next(12, 15));
			}
		}
		Main.tile[x, num].frameY = (short)num5;
		Main.tile[x, num].halfBrick(halfBrick: false);
		Main.tile[x, num].slope(0);
		SquareTileFrame(x, num);
		return true;
	}

	public static void CheckLilyPad(int x, int y)
	{
		if (Main.netMode == 1)
		{
			return;
		}
		Tile tile = Main.tile[x, y];
		if (tile.liquidType() != 0)
		{
			KillTile(x, y);
			if (Main.netMode == 2)
			{
				NetMessage.SendData(17, -1, -1, null, 0, x, y);
			}
			return;
		}
		int num = y;
		while (true)
		{
			tile = Main.tile[x, num];
			if (tile.active())
			{
				bool[] tileSolid = Main.tileSolid;
				tile = Main.tile[x, num];
				if (tileSolid[tile.type])
				{
					bool[] tileSolidTop = Main.tileSolidTop;
					tile = Main.tile[x, num];
					if (!tileSolidTop[tile.type])
					{
						break;
					}
				}
			}
			if (num >= Main.maxTilesY - 50)
			{
				break;
			}
			num++;
			if (Main.tile[x, num] == null)
			{
				return;
			}
		}
		tile = Main.tile[x, num];
		int type = tile.type;
		int num2 = -1;
		if (type == 2 || type == 477)
		{
			num2 = 0;
		}
		if (type == 109 || type == 109 || type == 116)
		{
			num2 = 18;
		}
		if (type == 60)
		{
			num2 = 36;
		}
		if (num2 >= 0)
		{
			int num3 = num2;
			tile = Main.tile[x, y];
			if (num3 != tile.frameY)
			{
				tile = Main.tile[x, y];
				tile.frameY = (short)num2;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
			}
			tile = Main.tile[x, y - 1];
			if (tile.liquid > 0)
			{
				tile = Main.tile[x, y - 1];
				if (!tile.active())
				{
					tile = Main.tile[x, y - 1];
					tile.active(active: true);
					tile = Main.tile[x, y - 1];
					tile.type = 518;
					tile = Main.tile[x, y - 1];
					ref short frameX = ref tile.frameX;
					tile = Main.tile[x, y];
					frameX = tile.frameX;
					tile = Main.tile[x, y - 1];
					ref short frameY = ref tile.frameY;
					tile = Main.tile[x, y];
					frameY = tile.frameY;
					tile = Main.tile[x, y - 1];
					tile.halfBrick(halfBrick: false);
					tile = Main.tile[x, y - 1];
					tile.slope(0);
					tile = Main.tile[x, y];
					tile.active(active: false);
					tile = Main.tile[x, y];
					tile.type = 0;
					SquareTileFrame(x, y - 1, resetFrame: false);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y - 1, 1, 2);
					}
					return;
				}
			}
			tile = Main.tile[x, y];
			if (tile.liquid != 0)
			{
				return;
			}
			Tile tileSafely = Framing.GetTileSafely(x, y + 1);
			if (!tileSafely.active())
			{
				tile = Main.tile[x, y + 1];
				tile.active(active: true);
				tile = Main.tile[x, y + 1];
				tile.type = 518;
				tile = Main.tile[x, y + 1];
				ref short frameX2 = ref tile.frameX;
				tile = Main.tile[x, y];
				frameX2 = tile.frameX;
				tile = Main.tile[x, y + 1];
				ref short frameY2 = ref tile.frameY;
				tile = Main.tile[x, y];
				frameY2 = tile.frameY;
				tile = Main.tile[x, y + 1];
				tile.halfBrick(halfBrick: false);
				tile = Main.tile[x, y + 1];
				tile.slope(0);
				tile = Main.tile[x, y];
				tile.active(active: false);
				tile = Main.tile[x, y];
				tile.type = 0;
				SquareTileFrame(x, y + 1, resetFrame: false);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y, 1, 2);
				}
			}
			else if (tileSafely.active() && !TileID.Sets.Platforms[tileSafely.type] && (!Main.tileSolid[tileSafely.type] || Main.tileSolidTop[tileSafely.type]))
			{
				KillTile(x, y);
				if (Main.netMode == 2)
				{
					NetMessage.SendData(17, -1, -1, null, 0, x, y);
				}
			}
		}
		else
		{
			KillTile(x, y);
			if (Main.netMode == 2)
			{
				NetMessage.SendData(17, -1, -1, null, 0, x, y);
			}
		}
	}

	public static bool TryKillingReplaceableTile(int x, int y, int tileType)
	{
		if (!InWorld(x, y, 2))
		{
			return false;
		}
		if (Main.tile[x, y].active() && (Main.tileCut[Main.tile[x, y].type] || TileID.Sets.BreakableWhenPlacing[Main.tile[x, y].type] || (Main.tile[x, y].type >= 373 && Main.tile[x, y].type <= 375) || Main.tile[x, y].type == 461))
		{
			if (Main.tile[x, y].type != tileType)
			{
				bool num = Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 579;
				bool flag = Main.tile[x, y].type == 3 || Main.tile[x, y].type == 73;
				bool flag2 = Main.tileAlch[Main.tile[x, y].type] && IsHarvestableHerbWithSeed(Main.tile[x, y].type, Main.tile[x, y].frameX / 18);
				bool flag3 = Main.tileAlch[tileType];
				if (num || ((flag || flag2) && flag3))
				{
					KillTile(x, y);
					if (!Main.tile[x, y].active() && Main.netMode != 0)
					{
						NetMessage.SendData(17, -1, -1, null, 0, x, y);
					}
					return true;
				}
				return false;
			}
			return false;
		}
		return false;
	}

	public static bool PlaceTile(int i, int j, int Type, bool mute = false, bool forced = false, int plr = -1, int style = 0)
	{
		//IL_0cb3: Unknown result type (might be due to invalid IL or missing references)
		//IL_2c92: Unknown result type (might be due to invalid IL or missing references)
		//IL_2caa: Unknown result type (might be due to invalid IL or missing references)
		//IL_2cb0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0da0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0da7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d99: Unknown result type (might be due to invalid IL or missing references)
		//IL_0d9e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0dd5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ddc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0df4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0dfb: Unknown result type (might be due to invalid IL or missing references)
		int num = Type;
		if (gen && Main.tile[i, j].active() && Main.tile[i, j].type == 488)
		{
			return false;
		}
		bool result = false;
		if (i >= 0 && j >= 0 && i < Main.maxTilesX && j < Main.maxTilesY)
		{
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				tile = (Main.tile[i, j] = default(Tile));
			}
			if (tile.active())
			{
				if (num == 23 && tile.type == 59)
				{
					num = 661;
				}
				if (num == 199 && tile.type == 59)
				{
					num = 662;
				}
			}
			if (forced || Collision.EmptyTile(i, j) || !Main.tileSolid[num] || (num == 23 && tile.type == 0 && tile.active()) || (num == 199 && tile.type == 0 && tile.active()) || (num == 2 && tile.type == 0 && tile.active()) || (num == 109 && tile.type == 0 && tile.active()) || (num == 60 && tile.type == 59 && tile.active()) || (num == 661 && tile.type == 59 && tile.active()) || (num == 662 && tile.type == 59 && tile.active()) || (num == 70 && tile.type == 59 && tile.active()) || (num == 633 && tile.type == 57 && tile.active()) || (Main.tileMoss[num] && (tile.type == 1 || tile.type == 38) && tile.active()))
			{
				if (num == 23 && (tile.type != 0 || !tile.active()))
				{
					return false;
				}
				if (num == 199 && (tile.type != 0 || !tile.active()))
				{
					return false;
				}
				if (num == 2 && (tile.type != 0 || !tile.active()))
				{
					return false;
				}
				if (num == 109 && (tile.type != 0 || !tile.active()))
				{
					return false;
				}
				if (num == 60 && (tile.type != 59 || !tile.active()))
				{
					return false;
				}
				if (num == 661 && (tile.type != 59 || !tile.active()))
				{
					return false;
				}
				if (num == 662 && (tile.type != 59 || !tile.active()))
				{
					return false;
				}
				if (num == 70 && (tile.type != 59 || !tile.active()))
				{
					return false;
				}
				if (num == 633 && (tile.type != 57 || !tile.active()))
				{
					return false;
				}
				if (Main.tileMoss[num])
				{
					if ((tile.type != 1 && tile.type != 38) || !tile.active())
					{
						return false;
					}
					if (tile.type == 38)
					{
						num = num switch
						{
							381 => 517, 
							534 => 535, 
							536 => 537, 
							539 => 540, 
							625 => 626, 
							627 => 628, 
							_ => 512 + num - 179, 
						};
					}
				}
				if (num == 81)
				{
					if (Main.tile[i, j - 1] == null)
					{
						Main.tile[i, j - 1] = default(Tile);
					}
					if (Main.tile[i, j + 1] == null)
					{
						Main.tile[i, j + 1] = default(Tile);
					}
					if (Main.tile[i, j - 1].active())
					{
						return false;
					}
					if (!Main.tile[i, j + 1].active() || !Main.tileSolid[Main.tile[i, j + 1].type] || Main.tile[i, j + 1].halfBrick() || Main.tile[i, j + 1].slope() != 0)
					{
						return false;
					}
				}
				if ((num == 373 || num == 375 || num == 374 || num == 461) && (Main.tile[i, j - 1] == null || Main.tile[i, j - 1].bottomSlope()))
				{
					return false;
				}
				if (tile.liquid > 0 || tile.checkingLiquid())
				{
					int num5 = num;
					if (num5 == 4)
					{
						if (style != 8 && style != 11 && style != 17)
						{
							return false;
						}
					}
					else if (!TileID.Sets.Torch[num])
					{
						if (num5 == 3 || TileID.Sets.TreeSapling[num])
						{
							goto IL_0603;
						}
						if (num5 <= 72)
						{
							if (num5 <= 32)
							{
								if (num5 == 24 || num5 == 27 || num5 == 32)
								{
									goto IL_0603;
								}
							}
							else if (num5 == 51 || num5 == 69 || num5 == 72)
							{
								goto IL_0603;
							}
						}
						else if (num5 <= 529)
						{
							if (num5 == 201 || num5 == 352 || num5 == 529)
							{
								goto IL_0603;
							}
						}
						else if (num5 == 624 || num5 == 637 || num5 == 656)
						{
							goto IL_0603;
						}
					}
					else if (TileObjectData.GetTileData(num, style).WaterPlacement != 0)
					{
						return false;
					}
				}
				if (TileID.Sets.ResetsHalfBrickPlacementAttempt[num] && (!tile.active() || !Main.tileFrameImportant[tile.type]))
				{
					tile.halfBrick(halfBrick: false);
					tile.frameY = 0;
					tile.frameX = 0;
				}
				if (num == 624)
				{
					if ((!tile.active() || Main.tileCut[tile.type] || TileID.Sets.BreakableWhenPlacing[tile.type]) && HasValidGroundForAbigailsFlowerBelowSpot(i, j))
					{
						tile.active(active: true);
						tile.type = 624;
						tile.halfBrick(halfBrick: false);
						tile.slope(0);
						tile.frameX = 0;
						tile.frameY = 0;
					}
				}
				else if (num == 656)
				{
					if ((!tile.active() || Main.tileCut[tile.type] || TileID.Sets.BreakableWhenPlacing[tile.type]) && HasValidGroundForGlowTulipBelowSpot(i, j))
					{
						tile.active(active: true);
						tile.type = 656;
						tile.halfBrick(halfBrick: false);
						tile.slope(0);
						tile.frameX = 0;
						tile.frameY = 0;
					}
				}
				else if (num == 3 || num == 24 || num == 110 || num == 201 || num == 637)
				{
					if (IsFitToPlaceFlowerIn(i, j, num))
					{
						if (num == 24 && genRand.Next(13) == 0)
						{
							tile.active(active: true);
							tile.type = 32;
							SquareTileFrame(i, j);
						}
						else if (num == 201 && genRand.Next(13) == 0)
						{
							tile.active(active: true);
							tile.type = 352;
							SquareTileFrame(i, j);
						}
						else if (Main.tile[i, j + 1].type == 78 || Main.tile[i, j + 1].type == 380 || Main.tile[i, j + 1].type == 579)
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							int num2 = genRand.NextFromList<int>(6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 24, 27, 30, 33, 36, 39, 42);
							switch (num2)
							{
							case 21:
							case 24:
							case 27:
							case 30:
							case 33:
							case 36:
							case 39:
							case 42:
								num2 += genRand.Next(3);
								break;
							}
							tile.frameX = (short)(num2 * 18);
						}
						else if (tile.wall >= 0 && WallID.Sets.AllowsPlantsToGrow[tile.wall] && Main.tile[i, j + 1].wall >= 0 && Main.tile[i, j + 1].wall < WallLoader.WallCount && WallID.Sets.AllowsPlantsToGrow[Main.tile[i, j + 1].wall])
						{
							if (genRand.Next(50) == 0 || ((num == 24 || num == 201) && genRand.Next(40) == 0))
							{
								tile.active(active: true);
								tile.type = (ushort)num;
								if (num == 201)
								{
									tile.frameX = 270;
								}
								else
								{
									tile.frameX = 144;
								}
							}
							else if (genRand.Next(35) == 0 || (Main.tile[i, j].wall >= 63 && Main.tile[i, j].wall <= 70))
							{
								tile.active(active: true);
								tile.type = (ushort)num;
								int num3 = genRand.NextFromList<int>(6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20);
								if (num == 201)
								{
									num3 = genRand.NextFromList<int>(6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 18, 19, 20, 21, 22);
								}
								if (num == 637)
								{
									num3 = genRand.NextFromList<int>(6, 7, 8, 9, 10);
								}
								tile.frameX = (short)(num3 * 18);
							}
							else
							{
								tile.active(active: true);
								tile.type = (ushort)num;
								tile.frameX = (short)(genRand.Next(6) * 18);
							}
						}
					}
				}
				else if (num == 61)
				{
					if (j + 1 < Main.maxTilesY && Main.tile[i, j + 1].active() && Main.tile[i, j + 1].slope() == 0 && !Main.tile[i, j + 1].halfBrick() && Main.tile[i, j + 1].type == 60)
					{
						bool flag = (double)j > Main.rockLayer || Main.remixWorld || remixWorldGen;
						if (genRand.Next(16) == 0 && (double)j > Main.worldSurface)
						{
							tile.active(active: true);
							tile.type = 69;
							SquareTileFrame(i, j);
						}
						else if (genRand.Next(60) == 0 && flag)
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							tile.frameX = 144;
						}
						else if (genRand.Next(230) == 0 && flag)
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							tile.frameX = 162;
						}
						else if (genRand.Next(15) == 0)
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							if (genRand.Next(3) != 0)
							{
								tile.frameX = (short)(genRand.Next(2) * 18 + 108);
							}
							else
							{
								tile.frameX = (short)(genRand.Next(13) * 18 + 180);
							}
						}
						else
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							tile.frameX = (short)(genRand.Next(6) * 18);
						}
					}
				}
				else if (num == 518)
				{
					PlaceLilyPad(i, j);
				}
				else if (num == 519)
				{
					PlaceCatTail(i, j);
				}
				else if (num == 529)
				{
					PlantSeaOat(i, j);
				}
				else if (num == 571)
				{
					PlaceBamboo(i, j);
				}
				else if (num == 549)
				{
					PlaceUnderwaterPlant(549, i, j);
				}
				else if (num == 71)
				{
					if (j + 1 < Main.maxTilesY && Main.tile[i, j + 1].active() && Main.tile[i, j + 1].slope() == 0 && !Main.tile[i, j + 1].halfBrick() && Main.tile[i, j + 1].type == 70)
					{
						Point point = default(Point);
						((Point)(ref point))._002Ector(-1, -1);
						if ((double)j > Main.worldSurface)
						{
							point = PlaceCatTail(i, j);
						}
						if (InWorld(point.X, point.Y))
						{
							if (gen)
							{
								int num4 = genRand.Next(14);
								for (int k = 0; k < num4; k++)
								{
									GrowCatTail(point.X, point.Y);
								}
								SquareTileFrame(point.X, point.Y);
							}
						}
						else
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							tile.frameX = (short)(genRand.Next(5) * 18);
						}
					}
				}
				else if (num == 129)
				{
					if (SolidTile(i - 1, j) || SolidTile(i + 1, j) || SolidTile(i, j - 1) || SolidTile(i, j + 1))
					{
						tile.active(active: true);
						tile.type = (ushort)num;
						tile.frameX = (short)(style * 18);
						SquareTileFrame(i, j);
					}
				}
				else if (num == 178)
				{
					if (SolidTile(i - 1, j, noDoors: true) || SolidTile(i + 1, j, noDoors: true) || SolidTile(i, j - 1) || SolidTile(i, j + 1))
					{
						tile.active(active: true);
						tile.type = (ushort)num;
						tile.frameX = (short)(style * 18);
						tile.frameY = (short)(genRand.Next(3) * 18);
						SquareTileFrame(i, j);
					}
				}
				else if (num == 184)
				{
					if ((Main.tileMoss[Main.tile[i - 1, j].type] && SolidTile(i - 1, j)) || (Main.tileMoss[Main.tile[i + 1, j].type] && SolidTile(i + 1, j)) || (Main.tileMoss[Main.tile[i, j - 1].type] && SolidTile(i, j - 1)) || (Main.tileMoss[Main.tile[i, j + 1].type] && SolidTile(i, j + 1)))
					{
						tile.active(active: true);
						tile.type = (ushort)num;
						tile.frameX = (short)(style * 18);
						tile.frameY = (short)(genRand.Next(3) * 18);
						SquareTileFrame(i, j);
					}
					if ((TileID.Sets.tileMossBrick[Main.tile[i - 1, j].type] && SolidTile(i - 1, j)) || (TileID.Sets.tileMossBrick[Main.tile[i + 1, j].type] && SolidTile(i + 1, j)) || (TileID.Sets.tileMossBrick[Main.tile[i, j - 1].type] && SolidTile(i, j - 1)) || (TileID.Sets.tileMossBrick[Main.tile[i, j + 1].type] && SolidTile(i, j + 1)))
					{
						tile.active(active: true);
						tile.type = (ushort)num;
						tile.frameX = (short)(style * 18);
						tile.frameY = (short)(genRand.Next(3) * 18);
						SquareTileFrame(i, j);
					}
				}
				else if (num == 485)
				{
					PlaceObject(i, j, num, mute, style);
				}
				else if (num == 171)
				{
					PlaceXmasTree(i, j, 171);
				}
				else if (num == 254)
				{
					Place2x2Style(i, j, (ushort)num, style);
				}
				else if (num == 335 || num == 564 || num == 594)
				{
					Place2x2(i, j, (ushort)num, 0);
				}
				else if (num == 654 || num == 319 || num == 132 || num == 484 || num == 138 || num == 664 || num == 142 || num == 143 || num == 282 || (num >= 288 && num <= 295) || (num >= 316 && num <= 318))
				{
					Place2x2(i, j, (ushort)num, 0);
				}
				else
				{
					int num5;
					switch (num)
					{
					case 411:
						Place2x2(i, j, (ushort)num, 0);
						break;
					case 457:
						Place2x2Horizontal(i, j, 457, style);
						break;
					case 137:
						tile.active(active: true);
						tile.type = (ushort)num;
						tile.frameY = (short)(18 * style);
						break;
					case 136:
						if (Main.tile[i - 1, j] == null)
						{
							Main.tile[i - 1, j] = default(Tile);
						}
						if (Main.tile[i + 1, j] == null)
						{
							Main.tile[i + 1, j] = default(Tile);
						}
						if (Main.tile[i, j + 1] == null)
						{
							Main.tile[i, j + 1] = default(Tile);
						}
						if ((Main.tile[i - 1, j].nactive() && !Main.tile[i - 1, j].halfBrick() && !TileID.Sets.NotReallySolid[Main.tile[i - 1, j].type] && Main.tile[i - 1, j].slope() == 0 && (SolidTile(i - 1, j) || TileID.Sets.IsBeam[Main.tile[i - 1, j].type] || (Main.tile[i - 1, j].type == 5 && Main.tile[i - 1, j - 1].type == 5 && Main.tile[i - 1, j + 1].type == 5))) || (Main.tile[i + 1, j].nactive() && !Main.tile[i + 1, j].halfBrick() && !TileID.Sets.NotReallySolid[Main.tile[i + 1, j].type] && Main.tile[i + 1, j].slope() == 0 && (SolidTile(i + 1, j) || TileID.Sets.IsBeam[Main.tile[i + 1, j].type] || (Main.tile[i + 1, j].type == 5 && Main.tile[i + 1, j - 1].type == 5 && Main.tile[i + 1, j + 1].type == 5))) || (Main.tile[i, j + 1].nactive() && !Main.tile[i, j + 1].halfBrick() && SolidTile(i, j + 1) && Main.tile[i, j + 1].slope() == 0) || tile.wall > 0)
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							SquareTileFrame(i, j);
						}
						break;
					case 442:
						if (Main.tile[i - 1, j] == null)
						{
							Main.tile[i - 1, j] = default(Tile);
						}
						if (Main.tile[i + 1, j] == null)
						{
							Main.tile[i + 1, j] = default(Tile);
						}
						if (Main.tile[i, j + 1] == null)
						{
							Main.tile[i, j + 1] = default(Tile);
						}
						if ((Main.tile[i - 1, j].nactive() && !Main.tile[i - 1, j].halfBrick() && !TileID.Sets.NotReallySolid[Main.tile[i - 1, j].type] && Main.tile[i - 1, j].slope() == 0 && (SolidTile(i - 1, j) || TileID.Sets.IsBeam[Main.tile[i - 1, j].type] || (Main.tile[i - 1, j].type == 5 && Main.tile[i - 1, j - 1].type == 5 && Main.tile[i - 1, j + 1].type == 5))) || (Main.tile[i + 1, j].nactive() && !Main.tile[i + 1, j].halfBrick() && !TileID.Sets.NotReallySolid[Main.tile[i + 1, j].type] && Main.tile[i + 1, j].slope() == 0 && (SolidTile(i + 1, j) || TileID.Sets.IsBeam[Main.tile[i + 1, j].type] || (Main.tile[i + 1, j].type == 5 && Main.tile[i + 1, j - 1].type == 5 && Main.tile[i + 1, j + 1].type == 5))) || (Main.tile[i, j + 1].nactive() && !Main.tile[i, j + 1].halfBrick() && SolidTile(i, j + 1) && Main.tile[i, j + 1].slope() == 0))
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							SquareTileFrame(i, j);
						}
						break;
					default:
						{
							if (TileID.Sets.Torch[num])
							{
								if (Main.tile[i - 1, j] == null)
								{
									Main.tile[i - 1, j] = default(Tile);
								}
								if (Main.tile[i + 1, j] == null)
								{
									Main.tile[i + 1, j] = default(Tile);
								}
								if (Main.tile[i, j + 1] == null)
								{
									Main.tile[i, j + 1] = default(Tile);
								}
								Tile tile2 = Main.tile[i - 1, j];
								Tile tile3 = Main.tile[i + 1, j];
								Tile tile4 = Main.tile[i, j + 1];
								if (tile.wall > 0 || (tile2.active() && (tile2.slope() == 0 || tile2.slope() % 2 != 1) && ((Main.tileSolid[tile2.type] && !Main.tileSolidTop[tile2.type] && !TileID.Sets.NotReallySolid[tile2.type]) || TileID.Sets.IsBeam[tile2.type] || (IsTreeType(tile2.type) && IsTreeType(Main.tile[i - 1, j - 1].type) && IsTreeType(Main.tile[i - 1, j + 1].type)))) || (tile3.active() && (tile3.slope() == 0 || tile3.slope() % 2 != 0) && ((Main.tileSolid[tile3.type] && !Main.tileSolidTop[tile3.type] && !TileID.Sets.NotReallySolid[tile3.type]) || TileID.Sets.IsBeam[tile3.type] || (IsTreeType(tile3.type) && IsTreeType(Main.tile[i + 1, j - 1].type) && IsTreeType(Main.tile[i + 1, j + 1].type)))) || (tile4.active() && Main.tileSolid[tile4.type] && ((TileID.Sets.Platforms[tile4.type] && TopEdgeCanBeAttachedTo(i, j + 1)) || ((!Main.tileSolidTop[tile4.type] || (tile4.type == 380 && tile4.slope() == 0)) && !TileID.Sets.NotReallySolid[tile4.type] && !tile4.halfBrick() && tile4.slope() == 0))))
								{
									tile.active(active: true);
									tile.type = (ushort)num;
									tile.frameY = (short)(22 * style);
									SquareTileFrame(i, j);
								}
								break;
							}
							if (num == 10)
							{
								if (Main.tile[i, j - 1] == null)
								{
									Main.tile[i, j - 1] = default(Tile);
								}
								if (Main.tile[i, j - 2] == null)
								{
									Main.tile[i, j - 2] = default(Tile);
								}
								if (Main.tile[i, j - 3] == null)
								{
									Main.tile[i, j - 3] = default(Tile);
								}
								if (Main.tile[i, j + 1] == null)
								{
									Main.tile[i, j + 1] = default(Tile);
								}
								if (Main.tile[i, j + 2] == null)
								{
									Main.tile[i, j + 2] = default(Tile);
								}
								if (Main.tile[i, j + 3] == null)
								{
									Main.tile[i, j + 3] = default(Tile);
								}
								if (!Main.tile[i, j - 1].active() && !Main.tile[i, j - 2].active() && Main.tile[i, j - 3].active() && Main.tileSolid[Main.tile[i, j - 3].type])
								{
									PlaceDoor(i, j - 1, num, style);
									SquareTileFrame(i, j);
									break;
								}
								if (Main.tile[i, j + 1].active() || Main.tile[i, j + 2].active() || !Main.tile[i, j + 3].active() || !Main.tileSolid[Main.tile[i, j + 3].type])
								{
									return false;
								}
								PlaceDoor(i, j + 1, num, style);
								SquareTileFrame(i, j);
								break;
							}
							if ((num >= 275 && num <= 281) || num == 296 || num == 297 || num == 309 || num == 358 || num == 359 || num == 413 || num == 414 || num == 542)
							{
								Place6x3(i, j, (ushort)num);
								break;
							}
							if (num == 237 || num == 244 || num == 285 || num == 286 || num == 298 || num == 299 || num == 310 || num == 339 || num == 538 || (num >= 361 && num <= 364) || num == 532 || num == 533 || num == 486 || num == 488 || num == 544 || num == 582 || num == 619 || num == 629)
							{
								Place3x2(i, j, (ushort)num);
								break;
							}
							if (num == 128)
							{
								PlaceMan(i, j, style);
								SquareTileFrame(i, j);
								break;
							}
							if (num == 269)
							{
								PlaceWoman(i, j, style);
								SquareTileFrame(i, j);
								break;
							}
							if (num == 334)
							{
								int style2 = 0;
								if (style == -1)
								{
									style2 = 1;
								}
								Place3x3Wall(i, j, 334, style2);
								SquareTileFrame(i, j);
								break;
							}
							if (num == 149)
							{
								if (SolidTile(i - 1, j) || SolidTile(i + 1, j) || SolidTile(i, j - 1) || SolidTile(i, j + 1))
								{
									tile.frameX = (short)(18 * style);
									tile.active(active: true);
									tile.type = (ushort)num;
									SquareTileFrame(i, j);
								}
								break;
							}
							if (num == 139 || num == 35)
							{
								PlaceMB(i, j, (ushort)num, style);
								SquareTileFrame(i, j);
								break;
							}
							if (num == 165)
							{
								PlaceTight(i, j);
								SquareTileFrame(i, j);
								break;
							}
							if (num == 235)
							{
								Place3x1(i, j, (ushort)num);
								SquareTileFrame(i, j);
								break;
							}
							if (num == 240)
							{
								Place3x3Wall(i, j, (ushort)num, style);
								break;
							}
							if (num == 440)
							{
								Place3x3Wall(i, j, (ushort)num, style);
								break;
							}
							if (num == 245)
							{
								Place2x3Wall(i, j, (ushort)num, style);
								break;
							}
							if (num == 246)
							{
								Place3x2Wall(i, j, (ushort)num, style);
								break;
							}
							if (num == 241)
							{
								Place4x3Wall(i, j, (ushort)num, style);
								break;
							}
							if (num == 242)
							{
								Place6x4Wall(i, j, (ushort)num, style);
								break;
							}
							if (num == 34)
							{
								PlaceChand(i, j, (ushort)num, style);
								SquareTileFrame(i, j);
								break;
							}
							if (num == 106 || num == 212 || num == 219 || num == 220 || num == 228 || num == 231 || num == 243 || num == 247 || num == 283 || (num >= 300 && num <= 308) || num == 354 || num == 355 || num == 491 || num == 642)
							{
								Place3x3(i, j, (ushort)num, style);
								SquareTileFrame(i, j);
								break;
							}
							num5 = num;
							if (num5 <= 50)
							{
								if (num5 <= 14)
								{
									if (num5 == 13)
									{
										goto IL_2484;
									}
									if (num5 != 14)
									{
										goto IL_249b;
									}
								}
								else if (num5 != 26)
								{
									if (num5 == 33 || (uint)(num5 - 49) <= 1u)
									{
										goto IL_2484;
									}
									goto IL_249b;
								}
								goto IL_24a7;
							}
							if (num5 <= 87)
							{
								if (num5 == 78)
								{
									goto IL_2484;
								}
								if ((uint)(num5 - 86) <= 1u)
								{
									goto IL_24a7;
								}
							}
							else if (num5 == 174 || num5 == 372 || num5 == 646)
							{
								goto IL_2484;
							}
							goto IL_249b;
						}
						IL_249b:
						if (!TileID.Sets.BasicDresser[num])
						{
							if (num5 <= 215)
							{
								if (num5 <= 114)
								{
									if (num5 == 89 || num5 == 114)
									{
										goto IL_24a7;
									}
								}
								else if ((uint)(num5 - 186) <= 1u || num5 == 215)
								{
									goto IL_24a7;
								}
							}
							else if (num5 <= 236)
							{
								if ((uint)(num5 - 217) <= 1u)
								{
									goto IL_24a7;
								}
								if (num5 == 236)
								{
									PlaceJunglePlant(i, j, (ushort)num, genRand.Next(3), 0);
									SquareTileFrame(i, j);
									break;
								}
							}
							else
							{
								if (num5 == 238)
								{
									PlaceJunglePlant(i, j, (ushort)num, 0, 0);
									SquareTileFrame(i, j);
									break;
								}
								if (num5 == 377 || num5 == 469)
								{
									goto IL_24a7;
								}
							}
							if (!TileID.Sets.TreeSapling[num])
							{
								switch (num5)
								{
								case 15:
								case 216:
								case 338:
								case 390:
									if (Main.tile[i, j - 1] == null)
									{
										Main.tile[i, j - 1] = default(Tile);
									}
									if (Main.tile[i, j] == null)
									{
										Main.tile[i, j] = default(Tile);
									}
									Place1x2(i, j, (ushort)num, style);
									SquareTileFrame(i, j);
									break;
								case 227:
									PlaceDye(i, j, style);
									SquareTileFrame(i, j);
									break;
								case 567:
									PlaceGnome(i, j, style);
									SquareTileFrame(i, j);
									break;
								case 16:
								case 18:
								case 29:
								case 103:
								case 134:
								case 462:
									Place2x1(i, j, (ushort)num, style);
									SquareTileFrame(i, j);
									break;
								case 92:
								case 93:
								case 453:
									Place1xX(i, j, (ushort)num, style);
									SquareTileFrame(i, j);
									break;
								case 104:
								case 105:
								case 320:
								case 337:
								case 349:
								case 356:
								case 378:
								case 456:
								case 506:
								case 545:
								case 663:
									Place2xX(i, j, (ushort)num, style);
									SquareTileFrame(i, j);
									break;
								case 17:
								case 77:
								case 133:
									Place3x2(i, j, (ushort)num, style);
									SquareTileFrame(i, j);
									break;
								case 207:
									Place2xX(i, j, (ushort)num, style);
									SquareTileFrame(i, j);
									break;
								case 410:
								case 480:
								case 509:
								case 657:
								case 658:
									Place2xX(i, j, (ushort)num, style);
									SquareTileFrame(i, j);
									break;
								case 465:
								case 531:
								case 591:
								case 592:
									Place2xX(i, j, (ushort)num, style);
									SquareTileFrame(i, j);
									break;
								default:
									if (TileID.Sets.BasicChest[num])
									{
										PlaceChest(i, j, (ushort)num, notNearOtherChests: false, style);
										SquareTileFrame(i, j);
										break;
									}
									switch (num)
									{
									case 91:
										PlaceBanner(i, j, (ushort)num, style);
										SquareTileFrame(i, j);
										break;
									case 419:
									case 420:
									case 423:
									case 424:
									case 429:
									case 445:
										PlaceLogicTiles(i, j, num, style);
										SquareTileFrame(i, j);
										break;
									case 36:
									case 135:
									case 141:
									case 144:
									case 210:
									case 239:
									case 324:
									case 476:
									case 494:
										Place1x1(i, j, num, style);
										SquareTileFrame(i, j);
										break;
									case 101:
									case 102:
									case 463:
										Place3x4(i, j, (ushort)num, style);
										SquareTileFrame(i, j);
										break;
									case 464:
									case 466:
										Place5x4(i, j, (ushort)num, style);
										SquareTileFrame(i, j);
										break;
									case 27:
										PlaceSunflower(i, j, 27);
										SquareTileFrame(i, j);
										break;
									case 28:
										PlacePot(i, j, 28, genRand.Next(4));
										SquareTileFrame(i, j);
										break;
									case 42:
									case 270:
									case 271:
										Place1x2Top(i, j, (ushort)num, style);
										SquareTileFrame(i, j);
										break;
									case 55:
									case 425:
									case 510:
									case 511:
										PlaceSign(i, j, (ushort)num, style);
										break;
									case 85:
									case 376:
										Place2x2Horizontal(i, j, (ushort)num, style);
										break;
									default:
										if (Main.tileAlch[num])
										{
											PlaceAlch(i, j, style);
											break;
										}
										switch (num)
										{
										case 94:
										case 95:
										case 97:
										case 98:
										case 99:
										case 100:
										case 125:
										case 126:
										case 172:
										case 173:
										case 287:
											Place2x2(i, j, (ushort)num, style);
											break;
										case 96:
											Place2x2Style(i, j, (ushort)num, style);
											break;
										case 79:
										case 90:
										{
											int direction = 1;
											if (plr > -1)
											{
												direction = Main.player[plr].direction;
											}
											Place4x2(i, j, (ushort)num, direction, style);
											break;
										}
										case 209:
											PlaceCannon(i, j, (ushort)num, style);
											break;
										case 81:
											tile.frameX = (short)(26 * genRand.Next(6));
											tile.active(active: true);
											tile.type = (ushort)num;
											break;
										case 19:
											tile.frameY = (short)(18 * style);
											tile.active(active: true);
											tile.type = (ushort)num;
											break;
										case 380:
											tile.frameY = (short)(18 * style);
											tile.active(active: true);
											tile.type = (ushort)num;
											break;
										case 314:
											Minecart.PlaceTrack(tile, style);
											break;
										default:
											if (num >= TileID.Count && TileObjectData.GetTileData(num, style) != null)
											{
												PlaceObject(i, j, (ushort)num, mute, style);
												break;
											}
											tile.active(active: true);
											tile.type = (ushort)num;
											if (Main.tenthAnniversaryWorld && !Main.remixWorld && (num == 53 || num == 396 || num == 397))
											{
												tile.color(7);
											}
											break;
										}
										break;
									}
									break;
								}
							}
							else
							{
								if (Main.tile[i, j + 1] == null)
								{
									Main.tile[i, j + 1] = default(Tile);
								}
								int type = Main.tile[i, j + 1].type;
								int dummyType = 20;
								int dummyStyle = 0;
								if (Main.tile[i, j + 1].active() && (type == 2 || type == 109 || type == 147 || type == 60 || type == 23 || type == 199 || type == 661 || type == 662 || type == 53 || type == 234 || type == 116 || type == 112 || TileLoader.SaplingGrowthType(type, ref dummyType, ref dummyStyle)))
								{
									Place1x2(i, j, (ushort)dummyType, dummyStyle);
									SquareTileFrame(i, j);
								}
							}
							break;
						}
						goto IL_24a7;
						IL_2484:
						PlaceOnTable1x1(i, j, num, style);
						SquareTileFrame(i, j);
						break;
						IL_24a7:
						Place3x2(i, j, (ushort)num, style);
						SquareTileFrame(i, j);
						break;
					}
				}
				if (tile.active())
				{
					if (TileID.Sets.BlocksWaterDrawingBehindSelf[tile.type])
					{
						SquareWallFrame(i, j);
					}
					SquareTileFrame(i, j);
					result = true;
					if (!mute && !generatingWorld)
					{
						switch (num)
						{
						case 127:
							SoundEngine.PlaySound(SoundID.Item30, i * 16, j * 16);
							break;
						case 314:
							SoundEngine.PlaySound(SoundID.Item52, i * 16, j * 16);
							break;
						case 330:
						case 331:
						case 332:
						case 333:
							SoundEngine.PlaySound(18, i * 16, j * 16);
							break;
						default:
							SoundEngine.PlaySound(0, i * 16, j * 16);
							break;
						}
						if (num == 22 || num == 140)
						{
							for (int l = 0; l < 3; l++)
							{
								Dust.NewDust(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16, 14);
							}
						}
					}
				}
			}
		}
		return result;
		IL_0603:
		return false;
	}

	public static void KillWall(int i, int j, bool fail = false)
	{
		if (i < 0 || j < 0 || i >= Main.maxTilesX || j >= Main.maxTilesY)
		{
			return;
		}
		Tile tile = Main.tile[i, j];
		if (tile == null)
		{
			tile = (Main.tile[i, j] = default(Tile));
		}
		if (tile.wall <= 0)
		{
			return;
		}
		fail = KillWall_CheckFailure(fail, tile);
		WallLoader.KillWall(i, j, tile.wall, ref fail);
		KillWall_PlaySounds(i, j, tile, fail);
		int num = 10;
		if (fail)
		{
			num = 3;
		}
		WallLoader.NumDust(i, j, tile.wall, fail, ref num);
		for (int k = 0; k < num; k++)
		{
			KillWall_MakeWallDust(i, j, tile);
		}
		if (fail)
		{
			SquareWallFrame(i, j);
			return;
		}
		KillWall_DropItems(i, j, tile);
		tile.wall = 0;
		tile.ClearWallPaintAndCoating();
		SquareWallFrame(i, j);
		if (tile.type >= 0 && TileID.Sets.FramesOnKillWall[tile.type])
		{
			TileFrame(i, j);
		}
	}

	private static bool KillWall_CheckFailure(bool fail, Tile tileCache)
	{
		if (Main.wallDungeon[tileCache.wall] && !NPC.downedBoss3)
		{
			fail = true;
		}
		if (tileCache.wall == 87 && !NPC.downedGolemBoss)
		{
			fail = true;
		}
		return fail;
	}

	private static void KillWall_PlaySounds(int i, int j, Tile tileCache, bool fail = false)
	{
		if (WallLoader.KillSound(i, j, tileCache.wall, fail))
		{
			if (tileCache.wall == 241 || (tileCache.wall >= 88 && tileCache.wall <= 93) || tileCache.wall == 21 || tileCache.wall == 186 || tileCache.wall == 136 || tileCache.wall == 137 || tileCache.wall == 168 || tileCache.wall == 169 || tileCache.wall == 172 || tileCache.wall == 226 || tileCache.wall == 227 || tileCache.wall == 242 || tileCache.wall == 243)
			{
				SoundEngine.PlaySound(13, i * 16, j * 16);
			}
			else if ((tileCache.wall >= 63 && tileCache.wall <= 70) || tileCache.wall == 264 || tileCache.wall == 268 || tileCache.wall == 265)
			{
				SoundEngine.PlaySound(6, i * 16, j * 16);
			}
			else
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
			}
		}
	}

	private static void KillWall_DropItems(int i, int j, Tile tileCache)
	{
		int num = KillWall_GetItemDrops(tileCache);
		if (WallLoader.Drop(i, j, Main.tile[i, j].wall, ref num) && num > 0)
		{
			Item.NewItem(GetItemSource_FromWallBreak(i, j), i * 16, j * 16, 16, 16, num);
		}
	}

	private static int KillWall_GetItemDrops(Tile tileCache)
	{
		switch (tileCache.wall)
		{
		case 237:
			return 4233;
		case 238:
			return 4234;
		case 239:
			return 4235;
		case 240:
			return 4236;
		case 246:
			return 4486;
		case 247:
			return 4487;
		case 248:
			return 4488;
		case 249:
			return 4489;
		case 250:
			return 4490;
		case 251:
			return 4491;
		case 252:
			return 4492;
		case 253:
			return 4493;
		case 254:
			return 4494;
		case 255:
			return 4495;
		case 314:
			return 4647;
		case 256:
			return 4496;
		case 257:
			return 4497;
		case 258:
			return 4498;
		case 259:
			return 4499;
		case 260:
			return 4500;
		case 261:
			return 4501;
		case 262:
			return 4502;
		case 263:
			return 4503;
		case 264:
			return 4504;
		case 265:
			return 4505;
		case 266:
			return 4506;
		case 267:
			return 4507;
		case 268:
			return 4508;
		case 269:
			return 4509;
		case 270:
			return 4510;
		case 271:
			return 4511;
		case 274:
			return 4512;
		case 275:
			return 3273;
		case 276:
			return 4513;
		case 277:
			return 4514;
		case 278:
			return 4515;
		case 279:
			return 4516;
		case 280:
			return 4517;
		case 281:
			return 4518;
		case 282:
			return 4519;
		case 283:
			return 4520;
		case 284:
			return 4521;
		case 285:
			return 4522;
		case 286:
			return 4523;
		case 287:
			return 4524;
		case 288:
			return 4525;
		case 289:
			return 4526;
		case 290:
			return 4527;
		case 291:
			return 4528;
		case 292:
			return 4529;
		case 293:
			return 4530;
		case 294:
			return 4531;
		case 295:
			return 4532;
		case 296:
			return 4533;
		case 297:
			return 4534;
		case 298:
			return 4535;
		case 299:
			return 4536;
		case 300:
			return 4537;
		case 301:
			return 4538;
		case 302:
			return 4539;
		case 303:
			return 4540;
		case 304:
			return 3340;
		case 305:
			return 3341;
		case 306:
			return 3342;
		case 307:
			return 3343;
		case 308:
			return 3344;
		case 309:
			return 3345;
		case 310:
			return 3346;
		case 311:
			return 3348;
		default:
		{
			int result = 0;
			if (tileCache.wall == 168)
			{
				result = 2696;
			}
			if (tileCache.wall == 169)
			{
				result = 2698;
			}
			if (tileCache.wall == 226)
			{
				result = 3752;
			}
			if (tileCache.wall == 227)
			{
				result = 3753;
			}
			if (tileCache.wall == 228)
			{
				result = 3760;
			}
			if (tileCache.wall == 229)
			{
				result = 3761;
			}
			if (tileCache.wall == 230)
			{
				result = 3762;
			}
			if (tileCache.wall == 142)
			{
				result = 2263;
			}
			if (tileCache.wall == 143)
			{
				result = 2264;
			}
			if (tileCache.wall == 144)
			{
				result = 2271;
			}
			if (tileCache.wall == 149)
			{
				result = 2505;
			}
			if (tileCache.wall == 150)
			{
				result = 2507;
			}
			if (tileCache.wall == 151)
			{
				result = 2506;
			}
			if (tileCache.wall == 152)
			{
				result = 2508;
			}
			if (tileCache.wall == 316)
			{
				result = 5216;
			}
			if (tileCache.wall == 317)
			{
				result = 5217;
			}
			if (tileCache.wall == 245)
			{
				result = 4424;
			}
			if (tileCache.wall == 315)
			{
				result = 4667;
			}
			if (tileCache.wall == 1)
			{
				result = 26;
			}
			if (tileCache.wall == 4)
			{
				result = 93;
			}
			if (tileCache.wall == 5)
			{
				result = 130;
			}
			if (tileCache.wall == 6)
			{
				result = 132;
			}
			if (tileCache.wall == 7)
			{
				result = 135;
			}
			if (tileCache.wall == 8)
			{
				result = 138;
			}
			if (tileCache.wall == 9)
			{
				result = 140;
			}
			if (tileCache.wall == 10)
			{
				result = 142;
			}
			if (tileCache.wall == 11)
			{
				result = 144;
			}
			if (tileCache.wall == 12)
			{
				result = 146;
			}
			if (tileCache.wall == 14)
			{
				result = 330;
			}
			if (tileCache.wall == 224)
			{
				result = 3472;
			}
			if (tileCache.wall == 323)
			{
				result = 5409;
			}
			if (tileCache.wall == 324)
			{
				result = 5410;
			}
			if (tileCache.wall == 325)
			{
				result = 5411;
			}
			if (tileCache.wall == 326)
			{
				result = 5412;
			}
			if (tileCache.wall == 327)
			{
				result = 5413;
			}
			if (tileCache.wall == 328)
			{
				result = 5414;
			}
			if (tileCache.wall == 329)
			{
				result = 5415;
			}
			if (tileCache.wall == 330)
			{
				result = 5416;
			}
			if (tileCache.wall == 331)
			{
				result = 5418;
			}
			if (tileCache.wall == 332)
			{
				result = 5420;
			}
			if (tileCache.wall == 333)
			{
				result = 5422;
			}
			if (tileCache.wall == 334)
			{
				result = 5424;
			}
			if (tileCache.wall == 335)
			{
				result = 5426;
			}
			if (tileCache.wall == 336)
			{
				result = 5428;
			}
			if (tileCache.wall == 337)
			{
				result = 5434;
			}
			if (tileCache.wall == 338)
			{
				result = 5436;
			}
			if (tileCache.wall == 339)
			{
				result = 5430;
			}
			if (tileCache.wall == 340)
			{
				result = 5432;
			}
			if (tileCache.wall == 341)
			{
				result = 5445;
			}
			if (tileCache.wall == 342)
			{
				result = 5446;
			}
			if (tileCache.wall == 343)
			{
				result = 5447;
			}
			if (tileCache.wall == 344)
			{
				result = 5448;
			}
			if (tileCache.wall == 345)
			{
				result = 5449;
			}
			if (tileCache.wall == 346)
			{
				result = 5450;
			}
			if (tileCache.wall == 177)
			{
				result = 3067;
			}
			if (tileCache.wall == 167)
			{
				result = 2691;
			}
			if (tileCache.wall == 60)
			{
				result = 3584;
			}
			if (tileCache.wall == 231)
			{
				result = 3952;
			}
			if (tileCache.wall == 232)
			{
				result = 3954;
			}
			if (tileCache.wall == 225)
			{
				result = 3751;
			}
			if (tileCache.wall == 233)
			{
				result = 3956;
			}
			if (tileCache.wall == 234)
			{
				result = 4052;
			}
			if (tileCache.wall == 235)
			{
				result = 4053;
			}
			if (tileCache.wall == 236)
			{
				result = 4140;
			}
			if (tileCache.wall == 312)
			{
				result = 4565;
			}
			if (tileCache.wall == 313)
			{
				result = 4548;
			}
			if (tileCache.wall == 319)
			{
				result = 5307;
			}
			if (tileCache.wall == 318)
			{
				result = 5291;
			}
			if (tileCache.wall == 179)
			{
				result = 3083;
			}
			if (tileCache.wall == 183)
			{
				result = 3082;
			}
			if (tileCache.wall == 321)
			{
				result = 5397;
			}
			if (tileCache.wall == 322)
			{
				result = 5399;
			}
			if (tileCache.wall == 181)
			{
				result = 3089;
			}
			if (tileCache.wall == 184)
			{
				result = 3088;
			}
			if (tileCache.wall == 186)
			{
				result = 3238;
			}
			if (tileCache.wall == 320)
			{
				result = 5396;
			}
			if (tileCache.wall >= 153 && tileCache.wall <= 166)
			{
				switch (tileCache.wall)
				{
				case 154:
					result = 2679;
					break;
				case 158:
					result = 2680;
					break;
				case 166:
					result = 2689;
					break;
				case 163:
					result = 2690;
					break;
				case 165:
					result = 2687;
					break;
				case 162:
					result = 2688;
					break;
				case 156:
					result = 2683;
					break;
				case 160:
					result = 2684;
					break;
				case 164:
					result = 2685;
					break;
				case 161:
					result = 2686;
					break;
				case 155:
					result = 2681;
					break;
				case 159:
					result = 2682;
					break;
				case 153:
					result = 2677;
					break;
				case 157:
					result = 2678;
					break;
				}
			}
			if (tileCache.wall == 136)
			{
				result = 2169;
			}
			if (tileCache.wall == 137)
			{
				result = 2170;
			}
			if (tileCache.wall == 172)
			{
				result = 2788;
			}
			if (tileCache.wall == 242)
			{
				result = 4279;
			}
			if (tileCache.wall == 243)
			{
				result = 4280;
			}
			if (tileCache.wall == 145)
			{
				result = 2333;
			}
			if (tileCache.wall == 16)
			{
				result = 30;
			}
			if (tileCache.wall == 17)
			{
				result = 135;
			}
			if (tileCache.wall == 18)
			{
				result = 138;
			}
			if (tileCache.wall == 19)
			{
				result = 140;
			}
			if (tileCache.wall == 20)
			{
				result = 330;
			}
			if (tileCache.wall == 21)
			{
				result = 392;
			}
			if (tileCache.wall == 86 || tileCache.wall == 108)
			{
				result = 1126;
			}
			if (tileCache.wall == 173)
			{
				result = 2789;
			}
			if (tileCache.wall == 174)
			{
				result = 2790;
			}
			if (tileCache.wall == 175)
			{
				result = 2791;
			}
			if (tileCache.wall == 176)
			{
				result = 2861;
			}
			if (tileCache.wall == 182)
			{
				result = 3101;
			}
			if (tileCache.wall == 133)
			{
				result = 2158;
			}
			if (tileCache.wall == 134)
			{
				result = 2159;
			}
			if (tileCache.wall == 135)
			{
				result = 2160;
			}
			else if (tileCache.wall == 113)
			{
				result = 1726;
			}
			else if (tileCache.wall == 114)
			{
				result = 1728;
			}
			else if (tileCache.wall == 115)
			{
				result = 1730;
			}
			else if (tileCache.wall == 146)
			{
				result = 2432;
			}
			else if (tileCache.wall == 147)
			{
				result = 2433;
			}
			else if (tileCache.wall == 148)
			{
				result = 2434;
			}
			if (tileCache.wall >= 116 && tileCache.wall <= 125)
			{
				result = 1948 + tileCache.wall - 116;
			}
			if (tileCache.wall >= 126 && tileCache.wall <= 132)
			{
				result = 2008 + tileCache.wall - 126;
			}
			if (tileCache.wall == 22)
			{
				result = 417;
			}
			if (tileCache.wall == 23)
			{
				result = 418;
			}
			if (tileCache.wall == 24)
			{
				result = 419;
			}
			if (tileCache.wall == 25)
			{
				result = 420;
			}
			if (tileCache.wall == 26)
			{
				result = 421;
			}
			if (tileCache.wall == 29)
			{
				result = 587;
			}
			if (tileCache.wall == 30)
			{
				result = 592;
			}
			if (tileCache.wall == 31)
			{
				result = 595;
			}
			if (tileCache.wall == 32)
			{
				result = 605;
			}
			if (tileCache.wall == 33)
			{
				result = 606;
			}
			if (tileCache.wall == 34)
			{
				result = 608;
			}
			if (tileCache.wall == 35)
			{
				result = 610;
			}
			if (tileCache.wall == 36)
			{
				result = 615;
			}
			if (tileCache.wall == 37)
			{
				result = 616;
			}
			if (tileCache.wall == 38)
			{
				result = 617;
			}
			if (tileCache.wall == 39)
			{
				result = 618;
			}
			if (tileCache.wall == 41)
			{
				result = 622;
			}
			if (tileCache.wall == 42)
			{
				result = 623;
			}
			if (tileCache.wall == 43)
			{
				result = 624;
			}
			if (tileCache.wall == 44)
			{
				result = 663;
			}
			if (tileCache.wall == 45)
			{
				result = 720;
			}
			if (tileCache.wall == 46)
			{
				result = 721;
			}
			if (tileCache.wall == 47)
			{
				result = 722;
			}
			if (tileCache.wall == 66)
			{
				result = 745;
			}
			if (tileCache.wall == 67)
			{
				result = 746;
			}
			if (tileCache.wall == 68)
			{
				result = 747;
			}
			if (tileCache.wall == 84)
			{
				result = 884;
			}
			if (tileCache.wall == 72)
			{
				result = 750;
			}
			if (tileCache.wall == 73)
			{
				result = 752;
			}
			if (tileCache.wall == 74)
			{
				result = 764;
			}
			if (tileCache.wall == 85)
			{
				result = 927;
			}
			if (tileCache.wall == 75)
			{
				result = 768;
			}
			if (tileCache.wall == 76)
			{
				result = 769;
			}
			if (tileCache.wall == 77)
			{
				result = 770;
			}
			if (tileCache.wall == 82)
			{
				result = 825;
			}
			if (tileCache.wall == 27)
			{
				result = 479;
			}
			if (tileCache.wall == 106)
			{
				result = 1447;
			}
			if (tileCache.wall == 107)
			{
				result = 1448;
			}
			if (tileCache.wall == 109)
			{
				result = 1590;
			}
			if (tileCache.wall == 110)
			{
				result = 1592;
			}
			if (tileCache.wall == 111)
			{
				result = 1594;
			}
			if (tileCache.wall == 78)
			{
				result = 1723;
			}
			if (tileCache.wall == 87 || tileCache.wall == 112)
			{
				result = 1102;
			}
			if (tileCache.wall == 94 || tileCache.wall == 100)
			{
				result = 1378;
			}
			if (tileCache.wall == 95 || tileCache.wall == 101)
			{
				result = 1379;
			}
			if (tileCache.wall == 96 || tileCache.wall == 102)
			{
				result = 1380;
			}
			if (tileCache.wall == 97 || tileCache.wall == 103)
			{
				result = 1381;
			}
			if (tileCache.wall == 98 || tileCache.wall == 104)
			{
				result = 1382;
			}
			if (tileCache.wall == 99 || tileCache.wall == 105)
			{
				result = 1383;
			}
			if (tileCache.wall == 241)
			{
				result = 4260;
			}
			if (tileCache.wall >= 88 && tileCache.wall <= 93)
			{
				result = 1267 + tileCache.wall - 88;
			}
			if (tileCache.wall >= 138 && tileCache.wall <= 141)
			{
				result = 2210 + tileCache.wall - 138;
			}
			return result;
		}
		}
	}

	private static void KillWall_MakeWallDust(int i, int j, Tile tileCache)
	{
		//IL_10b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_10d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1163: Unknown result type (might be due to invalid IL or missing references)
		//IL_1183: Unknown result type (might be due to invalid IL or missing references)
		//IL_11a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_11b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_11bf: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		switch (tileCache.wall)
		{
		case 316:
		case 317:
			num = 36;
			break;
		case 7:
		case 17:
		case 94:
		case 95:
		case 100:
		case 101:
		case 331:
			num = 275;
			break;
		case 8:
		case 18:
		case 98:
		case 99:
		case 104:
		case 105:
		case 332:
			num = 276;
			break;
		case 9:
		case 19:
		case 96:
		case 97:
		case 102:
		case 103:
		case 333:
			num = 277;
			break;
		case 232:
			num = 82;
			break;
		case 231:
			num = 8;
			break;
		case 233:
			num = 18;
			break;
		case 237:
			num = 6;
			break;
		case 238:
			num = 61;
			break;
		case 239:
			num = 242;
			break;
		case 240:
			num = 135;
			break;
		case 3:
		case 246:
			num = ((genRand.Next(2) != 0) ? 1 : 14);
			break;
		case 15:
		case 247:
			num = 38;
			break;
		case 22:
		case 28:
		case 248:
			num = 51;
			break;
		case 40:
		case 249:
			num = 51;
			break;
		case 48:
		case 49:
		case 50:
		case 51:
		case 52:
		case 53:
		case 54:
		case 55:
		case 56:
		case 57:
		case 58:
		case 185:
		case 250:
		case 251:
		case 252:
		case 253:
		case 254:
		case 255:
		case 256:
		case 257:
		case 258:
		case 259:
		case 260:
		case 274:
		case 314:
			num = 1;
			break;
		case 59:
		case 61:
		case 261:
		case 262:
			num = 0;
			break;
		case 62:
		case 263:
			num = 0;
			break;
		case 69:
		case 264:
			num = ((genRand.Next(2) != 0) ? 17 : 14);
			break;
		case 70:
		case 265:
			num = 47;
			break;
		case 71:
		case 266:
			num = 80;
			break;
		case 79:
		case 267:
			num = 37;
			break;
		case 81:
		case 268:
			num = 123;
			break;
		case 83:
		case 234:
		case 269:
			num = ((genRand.Next(2) == 0) ? 1 : 117);
			break;
		case 170:
		case 171:
		case 270:
		case 271:
			num = 0;
			break;
		case 187:
		case 275:
			num = 0;
			break;
		case 188:
		case 189:
		case 190:
		case 191:
		case 276:
		case 277:
		case 278:
		case 279:
			num = 37;
			break;
		case 192:
		case 193:
		case 194:
		case 195:
		case 280:
		case 281:
		case 282:
		case 283:
			num = 117;
			break;
		case 196:
		case 197:
		case 198:
		case 199:
		case 284:
		case 285:
		case 286:
		case 287:
			num = 0;
			break;
		case 200:
		case 202:
		case 288:
		case 290:
			num = ((genRand.Next(2) != 0) ? 70 : 69);
			break;
		case 201:
		case 289:
			num = 17;
			break;
		case 203:
		case 291:
			num = ((genRand.Next(2) != 0) ? 68 : 69);
			break;
		case 204:
		case 205:
		case 207:
		case 292:
		case 293:
		case 295:
			num = 0;
			break;
		case 206:
		case 294:
			num = 1;
			break;
		case 208:
		case 209:
		case 210:
		case 211:
		case 296:
		case 297:
		case 298:
		case 299:
			num = ((genRand.Next(2) != 0) ? 125 : 155);
			break;
		case 212:
		case 213:
		case 214:
		case 215:
		case 300:
		case 301:
		case 302:
		case 303:
			num = 1;
			break;
		case 216:
		case 304:
			num = 0;
			break;
		case 217:
		case 305:
			num = 37;
			break;
		case 218:
		case 306:
			num = 155;
			break;
		case 219:
		case 307:
			num = 17;
			break;
		case 220:
		case 308:
			num = 37;
			break;
		case 221:
		case 309:
			num = 155;
			break;
		case 222:
		case 310:
			num = 37;
			break;
		case 223:
		case 311:
			num = 0;
			break;
		case 312:
		case 313:
		case 315:
			num = -1;
			break;
		}
		if (tileCache.wall == 148)
		{
			num = -1;
		}
		if (tileCache.wall == 1 || tileCache.wall == 5 || tileCache.wall == 6 || tileCache.wall == 107)
		{
			num = 1;
		}
		if (tileCache.wall == 35)
		{
			num = 37;
		}
		if (tileCache.wall == 4 || tileCache.wall == 106)
		{
			num = 7;
		}
		if (tileCache.wall == 12)
		{
			num = 9;
		}
		if (tileCache.wall == 336)
		{
			num = 9;
		}
		if (tileCache.wall == 10)
		{
			num = 10;
		}
		if (tileCache.wall == 334)
		{
			num = 10;
		}
		if (tileCache.wall == 11)
		{
			num = 11;
		}
		if (tileCache.wall == 335)
		{
			num = 11;
		}
		if (tileCache.wall == 21)
		{
			num = 13;
		}
		if (tileCache.wall == 34)
		{
			num = 32;
		}
		if (tileCache.wall == 225)
		{
			num = 1;
		}
		if (tileCache.wall == 145)
		{
			num = 8;
		}
		if (tileCache.wall == 23)
		{
			num = 38;
		}
		if (tileCache.wall == 24)
		{
			num = 36;
		}
		if (tileCache.wall == 25 || tileCache.wall == 339)
		{
			num = 48;
		}
		if (tileCache.wall == 179 || tileCache.wall == 178 || tileCache.wall == 183)
		{
			num = 236;
		}
		if (tileCache.wall == 181 || tileCache.wall == 180 || tileCache.wall == 184)
		{
			num = 240;
		}
		if (tileCache.wall == 113)
		{
			num = 189;
		}
		if (tileCache.wall == 114)
		{
			num = 190;
		}
		if (tileCache.wall == 115)
		{
			num = 191;
		}
		if (tileCache.wall == 177 || tileCache.wall == 13 || tileCache.wall == 338)
		{
			num = 25;
		}
		if (tileCache.wall == 186)
		{
			num = genRand.Next(68, 71);
		}
		if (tileCache.wall == 319)
		{
			num = 171;
		}
		if (tileCache.wall == 321)
		{
			num = 308;
		}
		if (tileCache.wall == 322)
		{
			num = 308;
		}
		if (tileCache.wall == 318)
		{
			num = 226;
		}
		if (tileCache.wall == 142)
		{
			num = 210;
		}
		if (tileCache.wall == 143)
		{
			num = 210;
		}
		if (tileCache.wall == 224)
		{
			num = 265;
		}
		if (tileCache.wall == 323)
		{
			num = 314;
		}
		if (tileCache.wall == 324)
		{
			num = 315;
		}
		if (tileCache.wall == 325)
		{
			num = 316;
		}
		if (tileCache.wall == 326)
		{
			num = 317;
		}
		if (tileCache.wall == 327)
		{
			num = 318;
		}
		if (tileCache.wall == 328)
		{
			num = 319;
		}
		if (tileCache.wall == 329)
		{
			num = 320;
		}
		if (tileCache.wall == 330)
		{
			num = 321;
		}
		if (tileCache.wall == 320)
		{
			num = 0;
		}
		if (tileCache.wall == 341)
		{
			num = 258;
		}
		if (tileCache.wall == 342)
		{
			num = 301;
		}
		if (tileCache.wall == 343)
		{
			num = 299;
		}
		if (tileCache.wall == 344)
		{
			num = 300;
		}
		if (tileCache.wall == 345)
		{
			num = 305;
		}
		if (tileCache.wall == 173)
		{
			num = 128;
		}
		if (tileCache.wall == 174)
		{
			num = 117;
		}
		if (tileCache.wall == 175)
		{
			num = 42;
		}
		if (tileCache.wall == 176)
		{
			num = 226;
		}
		if (tileCache.wall == 182)
		{
			num = ((genRand.Next(2) != 0) ? 23 : 6);
		}
		if (tileCache.wall >= 153 && tileCache.wall <= 166)
		{
			switch (tileCache.wall)
			{
			case 154:
			case 158:
				num = 86;
				break;
			case 163:
			case 166:
				num = 87;
				break;
			case 162:
			case 165:
				num = 88;
				break;
			case 156:
			case 160:
				num = 89;
				break;
			case 161:
			case 164:
				num = 90;
				break;
			case 155:
			case 159:
				num = 91;
				break;
			case 153:
			case 157:
				num = 138;
				break;
			}
		}
		if (tileCache.wall == 26 || tileCache.wall == 30 || tileCache.wall == 340)
		{
			num = 49;
		}
		if (tileCache.wall == 29 || tileCache.wall == 32)
		{
			num = 50;
		}
		if (tileCache.wall == 31)
		{
			num = 51;
		}
		if (tileCache.wall == 14 || tileCache.wall == 20 || tileCache.wall == 337)
		{
			num = 109;
		}
		if (tileCache.wall == 241)
		{
			num = 286;
		}
		if (tileCache.wall >= 88 && tileCache.wall <= 93)
		{
			num = 86 + tileCache.wall - 88;
			if (tileCache.wall == 93)
			{
				num = genRand.Next(88, 94);
			}
		}
		if (tileCache.wall == 33)
		{
			num = 14;
		}
		if (tileCache.wall == 41)
		{
			num = 77;
		}
		if (tileCache.wall == 42)
		{
			num = 78;
		}
		if (tileCache.wall == 43)
		{
			num = 78;
		}
		if (tileCache.wall == 36)
		{
			num = 26;
		}
		if (tileCache.wall == 37)
		{
			num = 32;
		}
		if (tileCache.wall == 38)
		{
			num = 2;
		}
		if (tileCache.wall == 39)
		{
			num = 1;
		}
		if (tileCache.wall == 45)
		{
			num = 81;
		}
		if (tileCache.wall == 46)
		{
			num = 83;
		}
		if (tileCache.wall == 47)
		{
			num = 84;
		}
		if (tileCache.wall == 85)
		{
			num = 126;
		}
		if (tileCache.wall == 63)
		{
			num = 3;
		}
		if (tileCache.wall == 65)
		{
			num = 3;
		}
		if (tileCache.wall == 66)
		{
			num = 3;
		}
		if (tileCache.wall == 68)
		{
			num = 3;
		}
		if (tileCache.wall == 64)
		{
			num = 40;
		}
		if (tileCache.wall == 67)
		{
			num = 40;
		}
		if (tileCache.wall == 84)
		{
			num = 80;
		}
		if (tileCache.wall == 60)
		{
			num = 3;
		}
		if (tileCache.wall == 167)
		{
			num = 81;
		}
		if (tileCache.wall == 147)
		{
			num = 51;
		}
		if (tileCache.wall == 146)
		{
			num = 9;
		}
		if (tileCache.wall == 109)
		{
			num = 144;
		}
		if (tileCache.wall == 110)
		{
			num = 145;
		}
		if (tileCache.wall == 111)
		{
			num = 146;
		}
		if (tileCache.wall == 86 || tileCache.wall == 108)
		{
			num = 147;
		}
		if (tileCache.wall == 87)
		{
			num = 148;
		}
		if (tileCache.wall == 136)
		{
			num = 13;
		}
		if (tileCache.wall == 137)
		{
			num = 13;
		}
		if (tileCache.wall == 168)
		{
			num = 13;
		}
		if (tileCache.wall == 169)
		{
			num = 13;
		}
		if (tileCache.wall == 172)
		{
			num = 13;
		}
		if (tileCache.wall == 226)
		{
			num = 13;
		}
		if (tileCache.wall == 227)
		{
			num = 13;
		}
		if (tileCache.wall == 242)
		{
			num = 13;
		}
		if (tileCache.wall == 243)
		{
			num = 13;
		}
		if (tileCache.wall == 72)
		{
			num = 40;
		}
		if (tileCache.wall == 73)
		{
			num = 16;
		}
		if (tileCache.wall == 74 || tileCache.wall == 80)
		{
			num = 26;
		}
		if (tileCache.wall == 144)
		{
			num = ((genRand.Next(2) != 0) ? 118 : 10);
		}
		if (tileCache.wall == 75)
		{
			num = 26;
		}
		if (tileCache.wall == 76)
		{
			num = 4;
		}
		if (tileCache.wall == 77 || tileCache.wall == 81)
		{
			num = 5;
		}
		if (tileCache.wall == 78 || tileCache.wall == 244)
		{
			num = 7;
		}
		if (tileCache.wall == 82)
		{
			num = 36;
		}
		if (tileCache.wall == 27)
		{
			num = ((genRand.Next(2) != 0) ? 1 : 7);
		}
		if (tileCache.wall == 138)
		{
			num = 77;
		}
		if (tileCache.wall == 139)
		{
			num = 78;
		}
		if (tileCache.wall == 140)
		{
			num = 79;
		}
		if (tileCache.wall == 141)
		{
			num = 126;
		}
		if (tileCache.wall == 149 || tileCache.wall == 150)
		{
			num = 214;
		}
		if (tileCache.wall == 151 || tileCache.wall == 152)
		{
			num = 215;
		}
		if (tileCache.wall == 245)
		{
			num = 195;
		}
		ModWall modWall = WallLoader.GetWall(tileCache.wall);
		if (modWall != null)
		{
			num = modWall.DustType;
		}
		if (!WallLoader.CreateDust(i, j, tileCache.wall, ref num))
		{
			return;
		}
		if (tileCache.wall == 44 || tileCache.wall == 346)
		{
			int num2 = Dust.NewDust(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16, 66, 0f, 0f, 100, new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB), 0.75f);
			Main.dust[num2].noGravity = true;
		}
		else if ((tileCache.wall < 133 || tileCache.wall > 135) && (tileCache.wall < 116 || tileCache.wall > 125) && (tileCache.wall < 126 || tileCache.wall > 132))
		{
			if (tileCache.wall == 76)
			{
				Dust.NewDust(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16, num, 0f, 0f, 75, new Color(0, 80, 255, 100), 0.75f);
			}
			else if (num >= 0)
			{
				Dust.NewDust(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16, num);
			}
		}
	}

	public static void LaunchRocket(int x, int y, bool fromWiring)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		int num = Main.tile[x, y].frameY;
		int num2 = 0;
		while (num >= 40)
		{
			num -= 40;
			num2++;
		}
		if (num == 18)
		{
			y--;
		}
		Vector2 vector = default(Vector2);
		((Vector2)(ref vector))._002Ector((float)(x * 16 + 8), (float)(y * 16 + 4));
		int type = 167 + num2;
		int damage = 150;
		int num3 = 7;
		int num4 = Projectile.NewProjectile(GetProjectileSource_PlayerOrWires(x, y, fromWiring, Main.LocalPlayer), vector.X, vector.Y + 2f, 0f, -8f, type, damage, num3, Main.myPlayer);
		Main.projectile[num4].originatedFromActivableTile = true;
		Main.tile[x, y].active(active: false);
		Main.tile[x, y + 1].active(active: false);
		NetMessage.SendTileSquare(-1, x, y, 1, 2);
	}

	public static void LaunchRocketSmall(int x, int y, bool fromWiring)
	{
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		if (Main.tile[x, y].frameX == 18)
		{
			x--;
		}
		if (Main.tile[x, y].frameY == 18)
		{
			y--;
		}
		Vector2 vector = default(Vector2);
		((Vector2)(ref vector))._002Ector((float)(x * 16 + 16), (float)(y * 16));
		int type = 415 + Main.rand.Next(4);
		int damage = 0;
		int num = 0;
		int num2 = Projectile.NewProjectile(GetProjectileSource_PlayerOrWires(x, y, fromWiring, Main.LocalPlayer), vector.X, vector.Y + 2f, 0f, -8f, type, damage, num, Main.myPlayer);
		Main.projectile[num2].originatedFromActivableTile = true;
	}

	public static bool CanKillTile(int i, int j, SpecialKillTileContext context)
	{
		if (context == SpecialKillTileContext.MowingTheGrass)
		{
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				return false;
			}
			if (tile.type == 2 || tile.type == 109)
			{
				return true;
			}
		}
		return CanKillTile(i, j);
	}

	public static bool CanKillTile(int i, int j)
	{
		bool blockDamaged;
		return CanKillTile(i, j, out blockDamaged);
	}

	public static bool CanKillTile(int i, int j, out bool blockDamaged)
	{
		blockDamaged = false;
		if (i < 0 || j < 0 || i >= Main.maxTilesX || j >= Main.maxTilesY)
		{
			return false;
		}
		Tile tile = Main.tile[i, j];
		Tile tile2 = default(Tile);
		if (tile == null)
		{
			return false;
		}
		if (!tile.active())
		{
			return false;
		}
		if (!TileLoader.CanKillTile(i, j, tile.type, ref blockDamaged))
		{
			return false;
		}
		if (j >= 1)
		{
			tile2 = Main.tile[i, j - 1];
		}
		int type;
		int num3;
		if (tile2 != null && tile2.active())
		{
			type = tile2.type;
			if (TileID.Sets.IsATreeTrunk[type] && tile.type != type && (tile2.frameX != 66 || tile2.frameY < 0 || tile2.frameY > 44) && (tile2.frameX != 88 || tile2.frameY < 66 || tile2.frameY > 110) && tile2.frameY < 198)
			{
				return false;
			}
			num3 = type;
			if (num3 <= 77)
			{
				if (num3 <= 26)
				{
					if (num3 != 21 && num3 != 26)
					{
						goto IL_0178;
					}
				}
				else if (num3 != 72 && num3 != 77)
				{
					goto IL_0178;
				}
			}
			else if (num3 <= 323)
			{
				if (num3 != 88)
				{
					if (num3 != 323)
					{
						goto IL_0178;
					}
					if (tile.type != type && (tile2.frameX == 66 || tile2.frameX == 220))
					{
						return false;
					}
					goto IL_01bd;
				}
			}
			else if (num3 != 467 && num3 != 488)
			{
				goto IL_0178;
			}
			goto IL_018a;
		}
		goto IL_01bd;
		IL_01bd:
		if (TileID.Sets.Boulders[tile.type] && CheckBoulderChest(i, j))
		{
			blockDamaged = true;
			return false;
		}
		ushort t2 = tile.type;
		switch (t2)
		{
		case 10:
			if (IsLockedDoor(tile))
			{
				blockDamaged = true;
				return false;
			}
			break;
		case 235:
		{
			int num2 = i - tile.frameX % 54 / 18;
			for (int k = 0; k < 3; k++)
			{
				Tile tile3 = Main.tile[num2 + k, j - 1];
				if (tile3.active() && IsAContainer(tile3))
				{
					blockDamaged = true;
					return false;
				}
			}
			break;
		}
		default:
		{
			if (TileID.Sets.BasicChest[t2])
			{
				if (!Chest.CanDestroyChest(i - tile.frameX / 18 % 2, j - tile.frameY / 18))
				{
					return false;
				}
				break;
			}
			ushort t = t2;
			if (TileID.Sets.BasicDresser[t] && !Chest.CanDestroyChest(i - tile.frameX / 18 % 3, j - tile.frameY / 18))
			{
				return false;
			}
			break;
		}
		}
		return true;
		IL_0178:
		if (TileID.Sets.BasicDresser[type] || TileID.Sets.BasicChest[type])
		{
			goto IL_018a;
		}
		if (num3 == 80 && tile.type != type)
		{
			int num = tile2.frameX / 18;
			if ((uint)num <= 1u || (uint)(num - 4) <= 1u)
			{
				return false;
			}
		}
		goto IL_01bd;
		IL_018a:
		if (tile.type != type)
		{
			return false;
		}
		goto IL_01bd;
	}

	public static bool IsTileReplacable(int x, int y)
	{
		Tile tile = Main.tile[x, y];
		if (y >= 1)
		{
			Tile tile2 = Main.tile[x, y - 1];
			if (tile == null || tile2 == null)
			{
				return false;
			}
			if (tile2.active())
			{
				if (tile2.type == 80)
				{
					return false;
				}
				if (tile2.type == 488)
				{
					return false;
				}
				if (TileID.Sets.PreventsTileReplaceIfOnTopOfIt[tile2.type] && tile.type != tile2.type)
				{
					if (TileID.Sets.IsATreeTrunk[tile2.type])
					{
						if ((tile2.frameX == 66 && tile2.frameY >= 0 && tile2.frameY <= 44) || (tile2.frameX == 88 && tile2.frameY >= 66 && tile2.frameY <= 110) || tile2.frameY >= 198)
						{
							return true;
						}
						return false;
					}
					if (tile2.type == 323)
					{
						if (tile2.frameX == 66 || tile2.frameX == 220)
						{
							return false;
						}
						return true;
					}
					return false;
				}
			}
		}
		return true;
	}

	public static int CheckTileBreakability(int x, int y)
	{
		if (Main.tile[x, y] == null)
		{
			Main.tile[x, y] = default(Tile);
		}
		Tile tile = Main.tile[x, y];
		if (y >= 1 && y <= Main.maxTilesY - 1)
		{
			if (Main.tile[x, y - 1] == null)
			{
				Main.tile[x, y - 1] = default(Tile);
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = default(Tile);
			}
			Tile tile2 = Main.tile[x, y - 1];
			Tile tile3 = Main.tile[x, y + 1];
			if (tile3 != null && tile3.active() && IsLockedDoor(x, y + 1))
			{
				return 2;
			}
			if (!Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type])
			{
				return 0;
			}
			if (tile2.active())
			{
				if ((TileID.Sets.PreventsTileRemovalIfOnTopOfIt[tile2.type] && tile.type != tile2.type) | IsLockedDoor(x, y - 1) | (tile2.type == 77 && tile.type != 77 && !Main.hardMode) | (IsAContainer(tile2) && !IsAContainer(tile)))
				{
					if (TileID.Sets.IsATreeTrunk[tile2.type])
					{
						if ((tile2.frameX == 66 && tile2.frameY >= 0 && tile2.frameY <= 44) || (tile2.frameX == 88 && tile2.frameY >= 66 && tile2.frameY <= 110) || tile2.frameY >= 198)
						{
							return 0;
						}
						return 2;
					}
					if (tile2.type == 323)
					{
						if (tile2.frameX == 66 || tile2.frameX == 220)
						{
							return 2;
						}
						return 0;
					}
					return 2;
				}
				if (tile2.type == 80 && tile2.type != tile.type)
				{
					int num = tile2.frameX / 18;
					if ((uint)num <= 1u || (uint)(num - 4) <= 1u)
					{
						return 2;
					}
				}
				if (tile.type == 10 && IsLockedDoor(tile))
				{
					return 1;
				}
				if (TileID.Sets.Boulders[tile.type])
				{
					if (CheckBoulderChest(x, y))
					{
						return 1;
					}
					return 0;
				}
			}
			if (tile.type == 235)
			{
				int frameX = tile.frameX;
				int num2 = x - frameX % 54 / 18;
				for (int i = 0; i < 3; i++)
				{
					if (Main.tile[num2 + i, y - 1].active() && IsAContainer(Main.tile[num2 + i, y - 1]))
					{
						return 2;
					}
				}
			}
		}
		return 0;
	}

	public static bool CheckTileBreakability2_ShouldTileSurvive(int x, int y)
	{
		if (Main.netMode == 1)
		{
			return false;
		}
		if (Main.tile[x, y] == null)
		{
			Main.tile[x, y] = default(Tile);
		}
		Tile tile = Main.tile[x, y];
		if (TileID.Sets.BasicChest[tile.type])
		{
			int num = tile.frameX / 18;
			int y2 = y - tile.frameY / 18;
			while (num > 1)
			{
				num -= 2;
			}
			num = x - num;
			if (!Chest.DestroyChest(num, y2))
			{
				return true;
			}
		}
		if (TileID.Sets.BasicDresser[tile.type])
		{
			int num2 = tile.frameX / 18;
			int y3 = y - tile.frameY / 18;
			num2 %= 3;
			num2 = x - num2;
			if (!Chest.DestroyChest(num2, y3))
			{
				return true;
			}
		}
		if (tile.type == 470)
		{
			return !TEDisplayDoll.IsBreakable(x, y);
		}
		if (tile.type == 475)
		{
			return !TEHatRack.IsBreakable(x, y);
		}
		return false;
	}

	public static bool ReplaceWall(int x, int y, ushort targetWall)
	{
		if (targetWall >= WallLoader.WallCount)
		{
			return false;
		}
		Tile tile = Main.tile[x, y];
		if (tile.wall == 0 || targetWall == 0)
		{
			return false;
		}
		if (KillWall_CheckFailure(fail: false, tile))
		{
			return false;
		}
		int num = 10;
		for (int i = 0; i < num; i++)
		{
			KillWall_MakeWallDust(x, y, tile);
		}
		KillWall_PlaySounds(x, y, tile);
		KillWall_DropItems(x, y, tile);
		tile.wall = targetWall;
		tile.ClearWallPaintAndCoating();
		SquareWallFrame(x, y);
		return true;
	}

	public static bool ReplaceTile(int x, int y, ushort targetType, int targetStyle)
	{
		Tile tileSafely = Framing.GetTileSafely(x, y);
		if (!WouldTileReplacementWork(targetType, x, y))
		{
			return false;
		}
		if (!IsTileReplacable(x, y))
		{
			return false;
		}
		MoveReplaceTileAnchor(ref x, ref y, targetType, tileSafely);
		int num = KillTile_GetTileDustAmount(fail: false, tileSafely, x, y);
		for (int i = 0; i < num; i++)
		{
			KillTile_MakeTileDust(x, y, tileSafely);
		}
		KillTile_PlaySounds(x, y, fail: false, tileSafely);
		KillTile_DropItems(x, y, tileSafely, includeLargeObjectDrops: true);
		AttemptFossilShattering(x, y, tileSafely, fail: false);
		ReplaceTIle_DoActualReplacement(targetType, targetStyle, x, y, tileSafely);
		return true;
	}

	private static void ReplaceTIle_DoActualReplacement(ushort targetType, int targetStyle, int topLeftX, int topLeftY, Tile t)
	{
		if (TileID.Sets.BasicChest[targetType])
		{
			if (IsChestRigged(topLeftX, topLeftY) && Main.netMode != 1)
			{
				Wiring.HitSwitch(topLeftX, topLeftY);
				NetMessage.SendData(59, -1, -1, null, topLeftX, topLeftY);
			}
			ReplaceTile_DoActualReplacement_Area(targetType, targetStyle, topLeftX, topLeftY, 2, 2);
		}
		else if (TileID.Sets.BasicDresser[targetType])
		{
			ReplaceTile_DoActualReplacement_Area(targetType, targetStyle, topLeftX, topLeftY, 3, 2);
		}
		else if (TileID.Sets.Campfire[targetType])
		{
			ReplaceTile_DoActualReplacement_Area(targetType, targetStyle, topLeftX, topLeftY, 3, 2);
		}
		else
		{
			ReplaceTile_DoActualReplacement_Single(targetType, targetStyle, topLeftX, topLeftY, t);
		}
	}

	private static void ReplaceTile_DoActualReplacement_Single(ushort targetType, int targetStyle, int topLeftX, int topLeftY, Tile t)
	{
		ReplaceTile_EliminateNaturalExtras(topLeftX, topLeftY);
		int type = t.type;
		t.type = targetType;
		if (TileID.Sets.Platforms[t.type])
		{
			t.frameY = (short)(targetStyle * 18);
		}
		if (TileID.Sets.Torch[t.type])
		{
			t.frameY = (short)(targetStyle * 22);
		}
		t.ClearBlockPaintAndCoating();
		bool flag = !CanPoundTile(topLeftX, topLeftY);
		if (TileID.Sets.Platforms[type] && TileID.Sets.Platforms[t.type])
		{
			flag = false;
		}
		if (flag)
		{
			t.slope(0);
			t.halfBrick(halfBrick: false);
		}
		if (Main.tenthAnniversaryWorld && !Main.remixWorld && (targetType == 53 || targetType == 396 || targetType == 397))
		{
			t.color(7);
		}
		TileFrame(topLeftX, topLeftY);
		SquareTileFrame(topLeftX, topLeftY);
	}

	private static void ReplaceTile_EliminateNaturalExtras(int x, int y)
	{
		if (InWorld(x, y, 2))
		{
			if (Main.tile[x, y - 1] != null && Main.tile[x, y - 1].active() && (TileID.Sets.ReplaceTileBreakUp[Main.tile[x, y - 1].type] || (Main.tile[x, y - 1].type == 165 && (Main.tile[x, y - 1].frameY == 36 || Main.tile[x, y - 1].frameY == 54 || Main.tile[x, y - 1].frameY == 90))))
			{
				KillTile(x, y - 1);
			}
			if (Main.tile[x, y + 1] != null && Main.tile[x, y + 1].active() && (TileID.Sets.ReplaceTileBreakDown[Main.tile[x, y + 1].type] || (Main.tile[x, y + 1].type == 165 && (Main.tile[x, y + 1].frameY == 0 || Main.tile[x, y + 1].frameY == 18 || Main.tile[x, y + 1].frameY == 72))))
			{
				KillTile(x, y + 1);
			}
		}
	}

	private static void ReplaceTile_DoActualReplacement_Area(ushort targetType, int targetStyle, int topLeftX, int topLeftY, int areaSizeX, int areaSizeY)
	{
		for (int i = 0; i < areaSizeX; i++)
		{
			for (int j = 0; j < areaSizeY; j++)
			{
				Tile tile = Main.tile[topLeftX + i, topLeftY + j];
				tile.type = targetType;
				tile.frameX = (short)(targetStyle * (areaSizeX * 18) + i * 18);
				tile.frameY = (short)(j * 18);
				tile.ClearBlockPaintAndCoating();
			}
		}
		for (int k = 0; k < areaSizeX; k++)
		{
			for (int l = 0; l < areaSizeY; l++)
			{
				SquareTileFrame(topLeftX + k, topLeftY + l);
			}
		}
	}

	private static void MoveReplaceTileAnchor(ref int x, ref int y, ushort targetType, Tile t)
	{
		if (TileID.Sets.BasicChest[t.type])
		{
			x -= t.frameX % 36 / 18;
			y -= t.frameY % 36 / 18;
		}
		if (TileID.Sets.BasicDresser[t.type])
		{
			x -= t.frameX % 54 / 18;
			y -= t.frameY % 36 / 18;
		}
		if (TileID.Sets.Campfire[t.type])
		{
			x -= t.frameX % 54 / 18;
			y -= t.frameY % 36 / 18;
		}
	}

	public static bool WouldTileReplacementBeBlockedByLiquid(int x, int y, int liquidType)
	{
		if ((Main.tile[x - 1, y].liquid <= 0 || Main.tile[x - 1, y].liquidType() != liquidType) && (Main.tile[x + 1, y].liquid <= 0 || Main.tile[x + 1, y].liquidType() != liquidType))
		{
			if (Main.tile[x, y - 1].liquid > 0)
			{
				return Main.tile[x, y - 1].liquidType() == liquidType;
			}
			return false;
		}
		return true;
	}

	public static bool WouldTileReplacementWork(ushort attemptingToReplaceWith, int x, int y)
	{
		Tile tile = Main.tile[x, y];
		if (attemptingToReplaceWith >= TileLoader.TileCount)
		{
			return false;
		}
		if (TileID.Sets.Conversion.Grass[attemptingToReplaceWith] || attemptingToReplaceWith == 633)
		{
			return false;
		}
		if (Main.tileRope[tile.type] && InWorld(x, y, 2))
		{
			Tile tile2 = Main.tile[x - 1, y];
			Tile tile3 = Main.tile[x + 1, y];
			if (attemptingToReplaceWith == 314 && tile2 != null && tile3 != null && ((tile2.active() && tile2.type == 314) || (tile3.active() && tile3.type == 314)))
			{
				return true;
			}
			if (TileID.Sets.Platforms[attemptingToReplaceWith] && tile2 != null && tile3 != null && ((tile2.active() && TileID.Sets.Platforms[tile2.type]) || (tile3.active() && TileID.Sets.Platforms[tile3.type])))
			{
				return true;
			}
		}
		bool flag = !ReplaceTile_IsValidSolid(attemptingToReplaceWith) || !ReplaceTile_IsValidSolid(tile.type);
		bool flag2 = !ReplaceTile_IsValidTorch(attemptingToReplaceWith) || !ReplaceTile_IsValidTorch(tile.type);
		bool flag3 = !ReplaceTile_IsValidCampfire(attemptingToReplaceWith) || !ReplaceTile_IsValidCampfire(tile.type);
		bool num = !ReplaceTile_IsValidPlatform(attemptingToReplaceWith) || !ReplaceTile_IsValidPlatform(tile.type);
		bool flag4 = (!ReplaceTile_IsValidSolid(attemptingToReplaceWith) && !ReplaceTile_IsValidPlatform(attemptingToReplaceWith)) || (!ReplaceTile_IsValidSolid(tile.type) && !ReplaceTile_IsValidPlatform(tile.type));
		bool flag5 = !ReplaceTile_IsValidChest(attemptingToReplaceWith) || !ReplaceTile_IsValidChest(tile.type) || Chest.IsLocked(x, y, tile);
		bool flag6 = !ReplaceTile_IsValidDresser(attemptingToReplaceWith) || !ReplaceTile_IsValidDresser(tile.type);
		return !(num && flag2 && flag3 && flag && flag4 && flag5 && flag6);
	}

	private static bool ReplaceTile_IsValidSolid(int type)
	{
		if (Main.tileSolid[type] && !Main.tileSolidTop[type])
		{
			if (!Main.tileRope[type])
			{
				return !Main.tileFrameImportant[type];
			}
			return true;
		}
		return false;
	}

	private static bool ReplaceTile_IsValidTorch(int type)
	{
		return TileID.Sets.Torch[type];
	}

	private static bool ReplaceTile_IsValidCampfire(int type)
	{
		return TileID.Sets.Campfire[type];
	}

	private static bool ReplaceTile_IsValidChest(int type)
	{
		return TileID.Sets.BasicChest[type];
	}

	private static bool ReplaceTile_IsValidDresser(int type)
	{
		return TileID.Sets.BasicDresser[type];
	}

	private static bool ReplaceTile_IsValidPlatform(int type)
	{
		return TileID.Sets.Platforms[type];
	}

	public static bool GetAshTreeFoliageData(int i, int j, int xoffset, ref int treeFrame, ref int treeStyle, out int floorY, out int topTextureFrameWidth, out int topTextureFrameHeight)
	{
		_ = Main.tile[i, j];
		int num = i + xoffset;
		topTextureFrameWidth = 116;
		topTextureFrameHeight = 96;
		floorY = j;
		for (int k = 0; k < 100; k++)
		{
			floorY = j + k;
			Tile tile = Main.tile[num, floorY];
			if (tile == null)
			{
				return false;
			}
			if (tile.type == 633)
			{
				treeStyle = 31;
				return true;
			}
		}
		return false;
	}

	public static bool GetVanityTreeFoliageData(int i, int j, int xoffset, ref int treeFrame, ref int treeStyle, out int floorY, out int topTextureFrameWidth, out int topTextureFrameHeight)
	{
		Tile tile = Main.tile[i, j];
		int num = i + xoffset;
		topTextureFrameWidth = 118;
		topTextureFrameHeight = 96;
		floorY = j;
		for (int k = 0; k < 100; k++)
		{
			floorY = j + k;
			Tile tile2 = Main.tile[num, floorY];
			if (tile2 == null)
			{
				return false;
			}
			if (TileID.Sets.Conversion.Grass[tile2.type])
			{
				switch (tile.type)
				{
				case 596:
					treeStyle = 29;
					return true;
				case 616:
					treeStyle = 30;
					return true;
				}
			}
		}
		return false;
	}

	public static bool GetGemTreeFoliageData(int i, int j, int xoffset, ref int treeFrame, ref int treeStyle, out int floorY, out int topTextureFrameWidth, out int topTextureFrameHeight)
	{
		Tile tile = Main.tile[i, j];
		int num = i + xoffset;
		topTextureFrameWidth = 116;
		topTextureFrameHeight = 96;
		floorY = j;
		if (!GrowTreeSettings.Profiles.TryGetFromTreeId(tile.type, out var profile))
		{
			return false;
		}
		for (int k = 0; k < 100; k++)
		{
			floorY = j + k;
			Tile tile2 = Main.tile[num, floorY];
			if (tile2 == null)
			{
				return false;
			}
			if (profile.GroundTest(tile2.type))
			{
				switch (tile.type)
				{
				case 583:
					treeStyle = 22;
					return true;
				case 584:
					treeStyle = 23;
					return true;
				case 585:
					treeStyle = 24;
					return true;
				case 586:
					treeStyle = 25;
					return true;
				case 587:
					treeStyle = 26;
					return true;
				case 588:
					treeStyle = 27;
					return true;
				case 589:
					treeStyle = 28;
					return true;
				}
			}
		}
		return false;
	}

	public static bool GetCommonTreeFoliageData(int i, int j, int xoffset, ref int treeFrame, ref int treeStyle, out int floorY, out int topTextureFrameWidth, out int topTextureFrameHeight)
	{
		_ = Main.tile[i, j];
		int num = i + xoffset;
		topTextureFrameWidth = 80;
		topTextureFrameHeight = 80;
		floorY = j;
		int num2 = 0;
		int k = 0;
		while (k < 100)
		{
			floorY = j + k;
			Tile tile = Main.tile[num, floorY];
			if (tile == null)
			{
				return false;
			}
			switch (tile.type)
			{
			case 2:
			case 477:
			{
				int num3 = 0;
				num3 = ((num <= Main.treeX[0]) ? TreeTops.GetTreeStyle(0) : ((num <= Main.treeX[1]) ? TreeTops.GetTreeStyle(1) : ((num > Main.treeX[2]) ? TreeTops.GetTreeStyle(3) : TreeTops.GetTreeStyle(2))));
				switch (num3)
				{
				case 0:
					treeStyle = 0;
					break;
				case 5:
					treeStyle = 10;
					break;
				default:
					treeStyle = 5 + num3;
					break;
				}
				return true;
			}
			case 23:
			case 661:
				treeStyle = 1;
				return true;
			case 70:
				treeStyle = 14;
				return true;
			case 199:
			case 662:
				treeStyle = 5;
				return true;
			case 60:
				topTextureFrameHeight = 96;
				topTextureFrameWidth = 114;
				treeStyle = 2;
				num2 = TreeTops.GetTreeStyle(5);
				if (num2 == 1)
				{
					treeStyle = 11;
					topTextureFrameWidth = 116;
				}
				if ((double)floorY > Main.worldSurface)
				{
					treeStyle = 13;
					topTextureFrameWidth = 116;
				}
				return true;
			case 147:
				treeStyle = 4;
				num2 = TreeTops.GetTreeStyle(6);
				if (num2 == 0)
				{
					treeStyle = 12;
					if (i % 10 == 0)
					{
						treeStyle = 18;
					}
				}
				if (num2 == 2 || num2 == 3 || num2 == 32 || num2 == 4 || num2 == 42 || num2 == 5 || num2 == 7)
				{
					if (num2 % 2 == 0)
					{
						if (i < Main.maxTilesX / 2)
						{
							treeStyle = 16;
						}
						else
						{
							treeStyle = 17;
						}
					}
					else if (i > Main.maxTilesX / 2)
					{
						treeStyle = 16;
					}
					else
					{
						treeStyle = 17;
					}
				}
				return true;
			case 109:
			case 492:
			{
				topTextureFrameHeight = 140;
				int num4 = (treeStyle = GetHollowTreeFoliageStyle());
				if (num4 == 19)
				{
					topTextureFrameWidth = 120;
				}
				if (num4 == 20)
				{
					treeStyle = 20;
					if (i % 6 == 1)
					{
						treeFrame += 3;
					}
					else if (i % 6 == 2)
					{
						treeFrame += 6;
					}
					else if (i % 6 == 3)
					{
						treeFrame += 9;
					}
					else if (i % 6 == 4)
					{
						treeFrame += 12;
					}
					else if (i % 6 == 5)
					{
						treeFrame += 15;
					}
				}
				else if (i % 3 == 1)
				{
					treeFrame += 3;
				}
				else if (i % 3 == 2)
				{
					treeFrame += 6;
				}
				return true;
			}
			default:
			{
				ModTree tree = PlantLoader.Get<ModTree>(5, tile.type);
				if (tree != null)
				{
					tree.SetTreeFoliageSettings(tile, ref xoffset, ref treeFrame, ref floorY, ref topTextureFrameWidth, ref topTextureFrameHeight);
					treeStyle = tile.type + 100;
					return true;
				}
				k++;
				break;
			}
			}
		}
		return false;
	}

	public static int GetHollowTreeFoliageStyle()
	{
		TreeTops.GetTreeStyle(7);
		switch (hallowBG)
		{
		default:
			return 3;
		case 4:
			return 19;
		case 2:
		case 3:
			return 20;
		}
	}

	public static int GetTreeFrame(Tile t)
	{
		if (t.frameY == 220)
		{
			return 1;
		}
		if (t.frameY == 242)
		{
			return 2;
		}
		return 0;
	}

	public static TreeTypes GetTreeType(int tileType)
	{
		TreeTypes modType = PlantLoader.GetModTreeType(tileType);
		if (modType != 0)
		{
			return modType;
		}
		switch (tileType)
		{
		case 2:
		case 477:
			return TreeTypes.Forest;
		case 23:
			return TreeTypes.Corrupt;
		case 70:
			return TreeTypes.Mushroom;
		case 199:
			return TreeTypes.Crimson;
		case 60:
			return TreeTypes.Jungle;
		case 147:
			return TreeTypes.Snow;
		case 109:
		case 492:
			return TreeTypes.Hallowed;
		case 53:
			return TreeTypes.Palm;
		case 112:
			return TreeTypes.PalmCorrupt;
		case 234:
			return TreeTypes.PalmCrimson;
		case 116:
			return TreeTypes.PalmHallowed;
		case 633:
			return TreeTypes.Ash;
		default:
			return TreeTypes.None;
		}
	}

	public static bool IsThisAMushroomTree(int i, int j)
	{
		GetTreeBottom(i, j, out var x, out var y);
		if (GetTreeType(Main.tile[x, y].type) == TreeTypes.Mushroom)
		{
			return true;
		}
		return false;
	}

	public static void ResetTreeShakes()
	{
		numTreeShakes = 0;
	}

	private static void ShakeTree(int i, int j)
	{
		//IL_08bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0808: Unknown result type (might be due to invalid IL or missing references)
		//IL_0844: Unknown result type (might be due to invalid IL or missing references)
		//IL_0849: Unknown result type (might be due to invalid IL or missing references)
		if (numTreeShakes == maxTreeShakes)
		{
			return;
		}
		GetTreeBottom(i, j, out var x, out var y);
		int num = y;
		TreeTypes treeType = GetTreeType(Main.tile[x, y].type);
		if (treeType == TreeTypes.None)
		{
			return;
		}
		for (int k = 0; k < numTreeShakes; k++)
		{
			if (treeShakeX[k] == x && treeShakeY[k] == y)
			{
				return;
			}
		}
		treeShakeX[numTreeShakes] = x;
		treeShakeY[numTreeShakes] = y;
		numTreeShakes++;
		y--;
		while (y > 10 && Main.tile[x, y].active() && TileID.Sets.IsShakeable[Main.tile[x, y].type])
		{
			y--;
		}
		y++;
		if (!IsTileALeafyTreeTop(x, y) || Collision.SolidTiles(x - 2, x + 2, y - 2, y + 2))
		{
			return;
		}
		bool createLeaves = true;
		if (PlantLoader.ShakeTree(x, y, Main.tile[x, num].type, ref createLeaves))
		{
			if (Main.getGoodWorld && genRand.Next(17) == 0)
			{
				Projectile.NewProjectile(GetProjectileSource_ShakeTree(x, y), x * 16, y * 16, (float)Main.rand.Next(-100, 101) * 0.002f, 0f, 28, 0, 0f, Main.myPlayer, 16f, 16f);
			}
			else if (genRand.Next(300) == 0 && treeType == TreeTypes.Forest)
			{
				Item.NewItem(GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 832);
			}
			else if (genRand.Next(300) == 0 && treeType == TreeTypes.Forest)
			{
				Item.NewItem(GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 933);
			}
			else if (genRand.Next(200) == 0 && treeType == TreeTypes.Jungle)
			{
				Item.NewItem(GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 3360);
			}
			else if (genRand.Next(200) == 0 && treeType == TreeTypes.Jungle)
			{
				Item.NewItem(GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 3361);
			}
			else if (genRand.Next(1000) == 0 && treeType == TreeTypes.Forest)
			{
				Item.NewItem(GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 4366);
			}
			else if (genRand.Next(7) == 0 && (treeType == TreeTypes.Forest || treeType == TreeTypes.Snow || treeType == TreeTypes.Hallowed || treeType == TreeTypes.Ash))
			{
				Item.NewItem(GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 27, genRand.Next(1, 3));
			}
			else if (genRand.Next(8) == 0 && treeType == TreeTypes.Mushroom)
			{
				Item.NewItem(GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 194, genRand.Next(1, 2));
			}
			else if (genRand.Next(35) == 0 && Main.halloween)
			{
				Item.NewItem(GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 1809, genRand.Next(1, 3));
			}
			else if (genRand.Next(12) == 0)
			{
				int dropItem = 0;
				KillTile_GetItemDrops(i, j, Main.tile[i, j], out dropItem, out var _, out var _, out var _);
				Item.NewItem(GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, dropItem, genRand.Next(1, 4));
			}
			else if (genRand.Next(20) == 0)
			{
				int type = 71;
				int num2 = genRand.Next(50, 100);
				if (genRand.Next(30) == 0)
				{
					type = 73;
					num2 = 1;
					if (genRand.Next(5) == 0)
					{
						num2++;
					}
					if (genRand.Next(10) == 0)
					{
						num2++;
					}
				}
				else if (genRand.Next(10) == 0)
				{
					type = 72;
					num2 = genRand.Next(1, 21);
					if (genRand.Next(3) == 0)
					{
						num2 += genRand.Next(1, 21);
					}
					if (genRand.Next(4) == 0)
					{
						num2 += genRand.Next(1, 21);
					}
				}
				Item.NewItem(GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, type, num2);
			}
			else if (genRand.Next(15) == 0 && (treeType == TreeTypes.Forest || treeType == TreeTypes.Hallowed))
			{
				int type2 = genRand.Next(5) switch
				{
					0 => 74, 
					1 => 297, 
					2 => 298, 
					3 => 299, 
					_ => 538, 
				};
				if (Player.GetClosestRollLuck(x, y, NPC.goldCritterChance) == 0f)
				{
					type2 = ((genRand.Next(2) != 0) ? 539 : 442);
				}
				NPC.NewNPC(new EntitySource_ShakeTree(x, y), x * 16, y * 16, type2);
			}
			else if (genRand.Next(50) == 0 && treeType == TreeTypes.Hallowed && !Main.dayTime)
			{
				int type3 = Main.rand.NextFromList(new short[3] { 583, 584, 585 });
				if (Main.tenthAnniversaryWorld && Main.rand.Next(4) != 0)
				{
					type3 = 583;
				}
				NPC.NewNPC(new EntitySource_ShakeTree(x, y), x * 16, y * 16, type3);
			}
			else if (genRand.Next(50) == 0 && treeType == TreeTypes.Forest && !Main.dayTime)
			{
				NPC obj = Main.npc[NPC.NewNPC(new EntitySource_ShakeTree(x, y), x * 16, y * 16, 611)];
				obj.velocity.Y = 1f;
				obj.netUpdate = true;
			}
			else if (genRand.Next(50) == 0 && treeType == TreeTypes.Jungle && Main.dayTime)
			{
				NPC obj2 = Main.npc[NPC.NewNPC(new EntitySource_ShakeTree(x, y), x * 16, y * 16, Main.rand.NextFromList(new short[5] { 671, 672, 673, 674, 675 }))];
				obj2.velocity.Y = 1f;
				obj2.netUpdate = true;
			}
			else if (genRand.Next(40) == 0 && treeType == TreeTypes.Forest && !Main.dayTime && Main.halloween)
			{
				NPC.NewNPC(new EntitySource_ShakeTree(x, y), x * 16, y * 16, 301);
			}
			else if (genRand.Next(50) == 0 && (treeType == TreeTypes.Forest || treeType == TreeTypes.Hallowed))
			{
				Point point = default(Point);
				for (int l = 0; l < 5; l++)
				{
					((Point)(ref point))._002Ector(x + Main.rand.Next(-2, 2), y - 1 + Main.rand.Next(-2, 2));
					int type4 = ((Player.GetClosestRollLuck(x, y, NPC.goldCritterChance) != 0f) ? Main.rand.NextFromList(new short[3] { 74, 297, 298 }) : 442);
					NPC obj3 = Main.npc[NPC.NewNPC(new EntitySource_ShakeTree(x, y), point.X * 16, point.Y * 16, type4)];
					obj3.velocity = Main.rand.NextVector2CircularEdge(3f, 3f);
					obj3.netUpdate = true;
				}
			}
			else if (genRand.Next(40) == 0 && treeType == TreeTypes.Jungle)
			{
				Point point2 = default(Point);
				for (int m = 0; m < 5; m++)
				{
					((Point)(ref point2))._002Ector(x + Main.rand.Next(-2, 2), y - 1 + Main.rand.Next(-2, 2));
					NPC obj4 = Main.npc[NPC.NewNPC(new EntitySource_ShakeTree(x, y), point2.X * 16, point2.Y * 16, Main.rand.NextFromList(new short[2] { 210, 211 }))];
					obj4.ai[1] = 65f;
					obj4.netUpdate = true;
				}
			}
			else if (genRand.Next(20) == 0 && (treeType == TreeTypes.Palm || treeType == TreeTypes.PalmCorrupt || treeType == TreeTypes.PalmCrimson || treeType == TreeTypes.PalmHallowed) && !IsPalmOasisTree(x))
			{
				NPC.NewNPC(new EntitySource_ShakeTree(x, y), x * 16, y * 16, 603);
			}
			else if (genRand.Next(30) == 0 && (treeType == TreeTypes.Crimson || treeType == TreeTypes.PalmCrimson))
			{
				NPC.NewNPC(new EntitySource_ShakeTree(x, y), x * 16 + 8, (y - 1) * 16, -22);
			}
			else if (genRand.Next(30) == 0 && (treeType == TreeTypes.Corrupt || treeType == TreeTypes.PalmCorrupt))
			{
				NPC.NewNPC(new EntitySource_ShakeTree(x, y), x * 16 + 8, (y - 1) * 16, -11);
			}
			else if (genRand.Next(30) == 0 && treeType == TreeTypes.Jungle && !Main.dayTime)
			{
				NPC.NewNPC(new EntitySource_ShakeTree(x, y), x * 16, y * 16, 51);
			}
			else if (genRand.Next(40) == 0 && treeType == TreeTypes.Jungle)
			{
				Projectile.NewProjectile(GetProjectileSource_ShakeTree(x, y), x * 16 + 8, (y - 1) * 16, 0f, 0f, 655, 0, 0f, Main.myPlayer);
			}
			else if (genRand.Next(20) == 0 && (treeType == TreeTypes.Forest || treeType == TreeTypes.Hallowed) && !Main.raining && !NPC.TooWindyForButterflies && Main.dayTime)
			{
				int type5 = 356;
				if (Player.GetClosestRollLuck(x, y, NPC.goldCritterChance) == 0f)
				{
					type5 = 444;
				}
				NPC.NewNPC(new EntitySource_ShakeTree(x, y), x * 16, y * 16, type5);
			}
			else if (genRand.Next(20) == 0 && treeType == TreeTypes.Ash && y > Main.maxTilesY - 250)
			{
				int secondaryItemStack = genRand.Next(3);
				NPC.NewNPC(new EntitySource_ShakeTree(x, y), x * 16, y * 16, secondaryItemStack switch
				{
					0 => 654, 
					1 => 653, 
					_ => 655, 
				});
			}
			else if (Main.remixWorld && genRand.Next(20) == 0 && treeType == TreeTypes.Ash && y > Main.maxTilesY - 250)
			{
				Item.NewItem(GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, 965, genRand.Next(20, 41));
			}
			else if (genRand.Next(12) == 0 && treeType == TreeTypes.Forest)
			{
				Item.NewItem(Type: genRand.Next(5) switch
				{
					0 => 4009, 
					1 => 4293, 
					2 => 4282, 
					3 => 4290, 
					_ => 4291, 
				}, source: GetItemSource_FromTreeShake(x, y), X: x * 16, Y: y * 16, Width: 16, Height: 16);
			}
			else if (genRand.Next(12) == 0 && treeType == TreeTypes.Snow)
			{
				int secondaryItemStack = ((genRand.Next(2) != 0) ? 4295 : 4286);
				Item.NewItem(GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, secondaryItemStack);
			}
			else if (genRand.Next(12) == 0 && treeType == TreeTypes.Jungle)
			{
				int secondaryItemStack = ((genRand.Next(2) != 0) ? 4292 : 4294);
				Item.NewItem(GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, secondaryItemStack);
			}
			else if (genRand.Next(12) == 0 && (treeType == TreeTypes.Palm || treeType == TreeTypes.PalmCorrupt || treeType == TreeTypes.PalmCrimson || treeType == TreeTypes.PalmHallowed) && !IsPalmOasisTree(x))
			{
				int secondaryItemStack = ((genRand.Next(2) != 0) ? 4287 : 4283);
				Item.NewItem(GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, secondaryItemStack);
			}
			else if (genRand.Next(12) == 0 && (treeType == TreeTypes.Corrupt || treeType == TreeTypes.PalmCorrupt))
			{
				int secondaryItemStack = ((genRand.Next(2) != 0) ? 4289 : 4284);
				Item.NewItem(GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, secondaryItemStack);
			}
			else if (genRand.Next(12) == 0 && (treeType == TreeTypes.Hallowed || treeType == TreeTypes.PalmHallowed))
			{
				int secondaryItemStack = ((genRand.Next(2) != 0) ? 4288 : 4297);
				Item.NewItem(GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, secondaryItemStack);
			}
			else if (genRand.Next(12) == 0 && (treeType == TreeTypes.Crimson || treeType == TreeTypes.PalmCrimson))
			{
				int secondaryItemStack = ((genRand.Next(2) != 0) ? 4285 : 4296);
				Item.NewItem(GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, secondaryItemStack);
			}
			else if (genRand.Next(12) == 0 && treeType == TreeTypes.Ash)
			{
				int secondaryItemStack = ((genRand.Next(2) != 0) ? 5278 : 5277);
				Item.NewItem(GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, secondaryItemStack);
			}
		}
		if (!createLeaves)
		{
			return;
		}
		int treeHeight = 0;
		int treeFrame = 0;
		int passStyle = 0;
		GetTreeLeaf(x, Main.tile[x, y], Main.tile[x, num], ref treeHeight, out treeFrame, out passStyle);
		if (passStyle > 0)
		{
			if (Main.netMode == 2)
			{
				NetMessage.SendData(112, -1, -1, null, 1, x, y, 1f, passStyle);
			}
			if (Main.netMode == 0)
			{
				TreeGrowFX(x, y, 1, passStyle, hitTree: true);
			}
		}
	}

	private static void GetVineTop(int i, int j, out int x, out int y)
	{
		x = i;
		y = j;
		Tile tileSafely = Framing.GetTileSafely(x, y);
		if (TileID.Sets.IsVine[tileSafely.type])
		{
			while (y > 20 && tileSafely.active() && TileID.Sets.IsVine[tileSafely.type])
			{
				y--;
				tileSafely = Framing.GetTileSafely(x, y);
			}
		}
	}

	public static void GetTreeBottom(int i, int j, out int x, out int y)
	{
		x = i;
		y = j;
		Tile tileSafely = Framing.GetTileSafely(x, y);
		if (tileSafely.type == 323)
		{
			while (y < Main.maxTilesY - 50 && (!tileSafely.active() || tileSafely.type == 323))
			{
				y++;
				tileSafely = Framing.GetTileSafely(x, y);
			}
			return;
		}
		int num = tileSafely.frameX / 22;
		int num2 = tileSafely.frameY / 22;
		if (num == 3 && num2 <= 2)
		{
			x++;
		}
		else if (num == 4 && num2 >= 3 && num2 <= 5)
		{
			x--;
		}
		else if (num == 1 && num2 >= 6 && num2 <= 8)
		{
			x--;
		}
		else if (num == 2 && num2 >= 6 && num2 <= 8)
		{
			x++;
		}
		else if (num == 2 && num2 >= 9)
		{
			x++;
		}
		else if (num == 3 && num2 >= 9)
		{
			x--;
		}
		tileSafely = Framing.GetTileSafely(x, y);
		while (y < Main.maxTilesY - 50 && (!tileSafely.active() || TileID.Sets.IsATreeTrunk[tileSafely.type] || tileSafely.type == 72))
		{
			y++;
			tileSafely = Framing.GetTileSafely(x, y);
		}
	}

	private static void AttemptFossilShattering(int i, int j, Tile tileCache, bool fail)
	{
		if (tileCache.type != 404 || Main.netMode == 1 || fossilBreak)
		{
			return;
		}
		fossilBreak = true;
		for (int k = i - 1; k <= i + 1; k++)
		{
			for (int l = j - 1; l <= j + 1; l++)
			{
				int maxValue = 15;
				if (!SolidTile(k, l + 1))
				{
					maxValue = 4;
				}
				else if (k == i && l == j - 1 && !fail)
				{
					maxValue = 4;
				}
				if ((k != i || l != j) && Main.tile[k, l].active() && Main.tile[k, l].type == 404 && genRand.Next(maxValue) == 0)
				{
					KillTile(k, l, fail: false, effectOnly: false, noItem: true);
					if (Main.netMode == 2)
					{
						NetMessage.SendData(17, -1, -1, null, 0, k, l);
					}
				}
			}
		}
		fossilBreak = false;
	}

	public static void KillTile(int i, int j, bool fail = false, bool effectOnly = false, bool noItem = false)
	{
		//IL_039b: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c66: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c6b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c6d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c74: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c8a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c91: Unknown result type (might be due to invalid IL or missing references)
		//IL_0c9f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0ca6: Unknown result type (might be due to invalid IL or missing references)
		if (i < 0 || j < 0 || i >= Main.maxTilesX || j >= Main.maxTilesY)
		{
			return;
		}
		Tile tile = Main.tile[i, j];
		if (tile == null)
		{
			tile = (Main.tile[i, j] = default(Tile));
		}
		if (!tile.active())
		{
			return;
		}
		if (j >= 1 && Main.tile[i, j - 1] == null)
		{
			Main.tile[i, j - 1] = default(Tile);
		}
		int num31 = CheckTileBreakability(i, j);
		if (num31 == 1)
		{
			fail = true;
		}
		if (num31 == 2)
		{
			return;
		}
		TileLoader.KillTile(i, j, tile.type, ref fail, ref effectOnly, ref noItem);
		if (gen)
		{
			noItem = true;
		}
		if (!effectOnly && !stopDrops)
		{
			if (!noItem && FixExploitManEaters.SpotProtected(i, j))
			{
				return;
			}
			if (!Main.dedServ && !gen && !Main.gameMenu)
			{
				KillTile_PlaySounds(i, j, fail, tile);
			}
		}
		if (tile.type == 128 || tile.type == 269)
		{
			int num20 = i;
			int num25 = tile.frameX;
			int num26;
			for (num26 = tile.frameX; num26 >= 100; num26 -= 100)
			{
			}
			while (num26 >= 36)
			{
				num26 -= 36;
			}
			if (num26 == 18)
			{
				num25 = Main.tile[i - 1, j].frameX;
				num20--;
			}
			if (num25 >= 100)
			{
				int num27 = 0;
				while (num25 >= 100)
				{
					num25 -= 100;
					num27++;
				}
				int num32 = Main.tile[num20, j].frameY / 18;
				if (num32 == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, Item.headType[num27]);
				}
				if (num32 == 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, Item.bodyType[num27]);
				}
				if (num32 == 2)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, Item.legType[num27]);
				}
				for (num25 = Main.tile[num20, j].frameX; num25 >= 100; num25 -= 100)
				{
				}
				Main.tile[num20, j].frameX = (short)num25;
			}
		}
		if (tile.type == 334)
		{
			int num28 = i;
			int frameX = tile.frameX;
			int num29 = tile.frameX;
			int num30 = 0;
			while (num29 >= 5000)
			{
				num29 -= 5000;
				num30++;
			}
			if (num30 != 0)
			{
				num29 = (num30 - 1) * 18;
			}
			num29 %= 54;
			if (num29 == 18)
			{
				frameX = Main.tile[i - 1, j].frameX;
				num28--;
			}
			if (num29 == 36)
			{
				frameX = Main.tile[i - 2, j].frameX;
				num28 -= 2;
			}
			if (frameX >= 5000)
			{
				int num10 = frameX % 5000;
				num10 -= 100;
				int frameX2 = Main.tile[num28 + 1, j].frameX;
				frameX2 = ((frameX2 < 25000) ? (frameX2 - 10000) : (frameX2 - 25000));
				if (Main.netMode != 1)
				{
					Item item = new Item();
					item.netDefaults(num10);
					item.Prefix(frameX2);
					int num11 = Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, num10, 1, noBroadcast: true);
					item.position = Main.item[num11].position;
					Main.item[num11] = item;
					NetMessage.SendData(21, -1, -1, null, num11);
				}
				frameX = Main.tile[num28, j].frameX;
				int num12 = 0;
				while (frameX >= 5000)
				{
					frameX -= 5000;
					num12++;
				}
				if (num12 != 0)
				{
					frameX = (num12 - 1) * 18;
				}
				Main.tile[num28, j].frameX = (short)frameX;
				Main.tile[num28 + 1, j].frameX = (short)(frameX + 18);
			}
		}
		if (tile.type == 395)
		{
			int num13 = TEItemFrame.Find(i - tile.frameX % 36 / 18, j - tile.frameY % 36 / 18);
			if (num13 != -1 && ((TEItemFrame)TileEntity.ByID[num13]).item.stack > 0)
			{
				((TEItemFrame)TileEntity.ByID[num13]).DropItem();
				if (Main.netMode != 2)
				{
					Main.LocalPlayer.InterruptItemUsageIfOverTile(395);
				}
				return;
			}
		}
		if (tile.type == 471)
		{
			int num14 = TEWeaponsRack.Find(i - tile.frameX % 54 / 18, j - tile.frameY % 54 / 18);
			if (num14 != -1 && ((TEWeaponsRack)TileEntity.ByID[num14]).item.stack > 0)
			{
				((TEWeaponsRack)TileEntity.ByID[num14]).DropItem();
				if (Main.netMode != 2)
				{
					Main.LocalPlayer.InterruptItemUsageIfOverTile(471);
				}
				return;
			}
		}
		if (tile.type == 520)
		{
			int num15 = TEFoodPlatter.Find(i, j);
			if (num15 != -1 && ((TEFoodPlatter)TileEntity.ByID[num15]).item.stack > 0)
			{
				((TEFoodPlatter)TileEntity.ByID[num15]).DropItem();
				if (Main.netMode != 2)
				{
					Main.LocalPlayer.InterruptItemUsageIfOverTile(520);
				}
				return;
			}
		}
		if ((tile.type == 470 && (CheckTileBreakability2_ShouldTileSurvive(i, j) || fail)) || (tile.type == 475 && (CheckTileBreakability2_ShouldTileSurvive(i, j) || fail)))
		{
			return;
		}
		int num16 = KillTile_GetTileDustAmount(fail, tile, i, j);
		for (int k = 0; k < num16; k++)
		{
			KillTile_MakeTileDust(i, j, tile);
		}
		if (effectOnly)
		{
			return;
		}
		AttemptFossilShattering(i, j, tile, fail);
		if (fail)
		{
			if (Main.netMode != 1 && TileID.Sets.IsShakeable[tile.type])
			{
				ShakeTree(i, j);
			}
			if (tile.type == 2 || tile.type == 23 || tile.type == 109 || tile.type == 199 || tile.type == 477 || tile.type == 492)
			{
				tile.type = 0;
			}
			if (tile.type == 633)
			{
				tile.type = 57;
			}
			if (tile.type == 60 || tile.type == 661 || tile.type == 662 || tile.type == 70)
			{
				tile.type = 59;
			}
			if (Main.tileMoss[tile.type])
			{
				tile.type = 1;
			}
			if (TileID.Sets.tileMossBrick[tile.type])
			{
				tile.type = 38;
			}
			SquareTileFrame(i, j);
			return;
		}
		if (Main.getGoodWorld && Main.netMode != 1 && tile.type == 57)
		{
			for (int l = 0; l < 8; l++)
			{
				int maxValue = 2;
				int num17 = i;
				int num18 = j;
				switch (l)
				{
				case 0:
					num17--;
					break;
				case 1:
					num17++;
					break;
				case 2:
					num18--;
					break;
				case 3:
					num18++;
					break;
				case 4:
					num17--;
					num18--;
					break;
				case 5:
					num17++;
					num18--;
					break;
				case 6:
					num17--;
					num18++;
					break;
				case 7:
					num17++;
					num18++;
					break;
				}
				Tile tile2 = Main.tile[num17, num18];
				if (tile2.active() && genRand.Next(maxValue) == 0 && tile2.type == 57 && !SolidTile(num17, num18 + 1))
				{
					KillTile(num17, num18, fail: false, effectOnly: false, noItem: true);
					if (Main.netMode == 2)
					{
						NetMessage.TrySendData(17, -1, -1, null, 20, num17, num18);
					}
					int num19 = Projectile.NewProjectile(GetProjectileSource_TileBreak(num17, num18), num17 * 16 + 8, num18 * 16 + 8, 0f, 0.41f, 40, 15, 0f, Main.myPlayer);
					Main.projectile[num19].netUpdate = true;
				}
			}
		}
		if (Main.netMode != 1 && tile.type >= 481 && tile.type <= 483)
		{
			for (int m = 0; m < 8; m++)
			{
				int num21 = 6;
				int num22 = i;
				int num23 = j;
				switch (m)
				{
				case 0:
					num22--;
					break;
				case 1:
					num22++;
					break;
				case 2:
					num23--;
					num21 /= 2;
					break;
				case 3:
					num23++;
					break;
				case 4:
					num22--;
					num23--;
					break;
				case 5:
					num22++;
					num23--;
					break;
				case 6:
					num22--;
					num23++;
					break;
				case 7:
					num22++;
					num23++;
					break;
				}
				Tile tile3 = Main.tile[num22, num23];
				if (tile3.active() && genRand.Next(num21) == 0 && tile3.type >= 481 && tile3.type <= 483)
				{
					tile.active(active: false);
					KillTile(num22, num23, fail: false, effectOnly: false, noItem: true);
					if (Main.netMode == 2)
					{
						NetMessage.TrySendData(17, -1, -1, null, 20, num22, num23);
					}
				}
			}
			int type = tile.type - 481 + 736;
			int damage = 20;
			EntitySource_TileBreak projectileSource_TileBreak = GetProjectileSource_TileBreak(i, j);
			if (Main.netMode == 0)
			{
				Projectile.NewProjectile(projectileSource_TileBreak, i * 16 + 8, j * 16 + 8, 0f, 0.41f, type, damage, 0f, Main.myPlayer);
			}
			else if (Main.netMode == 2)
			{
				int num24 = Projectile.NewProjectile(projectileSource_TileBreak, i * 16 + 8, j * 16 + 8, 0f, 0.41f, type, damage, 0f, Main.myPlayer);
				Main.projectile[num24].netUpdate = true;
			}
		}
		if (CheckTileBreakability2_ShouldTileSurvive(i, j))
		{
			return;
		}
		if (tile.type == 51 && tile.wall == 62 && genRand.Next(4) != 0)
		{
			noItem = true;
		}
		if (!noItem && !stopDrops && Main.netMode != 1)
		{
			KillTile_DropBait(i, j, tile);
			KillTile_DropItems(i, j, tile);
		}
		if (tile.type == 520)
		{
			TEFoodPlatter.Kill(i, j);
		}
		if (tile.type == 423)
		{
			TELogicSensor.Kill(i, j);
		}
		if (Main.netMode != 2)
		{
			AchievementsHelper.NotifyTileDestroyed(Main.player[Main.myPlayer], tile.type);
		}
		tile.active(active: false);
		tile.halfBrick(halfBrick: false);
		tile.frameX = -1;
		tile.frameY = -1;
		tile.ClearBlockPaintAndCoating();
		tile.frameNumber(0);
		if (Main.netMode != 1)
		{
			if (tile.type == 58 && j > Main.UnderworldLayer)
			{
				tile.lava(lava: true);
				tile.liquid = 128;
			}
			else if (tile.type == 230 && Main.getGoodWorld && genRand.Next(2) == 0)
			{
				tile.lava(lava: true);
				tile.liquid = 128;
			}
		}
		if (tile.type == 419)
		{
			Wiring.PokeLogicGate(i, j + 1);
		}
		else if (TileID.Sets.BlocksWaterDrawingBehindSelf[tile.type])
		{
			SquareWallFrame(i, j);
		}
		tile.type = 0;
		tile.inActive(inActive: false);
		SquareTileFrame(i, j);
		while (!destroyObject && ExploitDestroyQueue.Count > 0)
		{
			Point point = ExploitDestroyQueue.Dequeue();
			if (Framing.GetTileSafely(point.X, point.Y).active())
			{
				SquareTileFrame(point.X, point.Y);
				NetMessage.SendTileSquare(-1, point.X, point.Y);
			}
		}
	}

	private static Player GetPlayerForTile(int x, int y)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		return Main.player[Player.FindClosest(new Vector2((float)x, (float)y) * 16f, 16, 16)];
	}

	internal static void KillTile_DropItems(int x, int y, Tile tileCache, bool includeLargeObjectDrops = false, bool includeAllModdedLargeObjectDrops = false)
	{
		if (!TileLoader.Drop(x, y, Main.tile[x, y].type, includeLargeObjectDrops))
		{
			return;
		}
		KillTile_GetItemDrops(x, y, tileCache, out var dropItem, out var dropItemStack, out var secondaryItem, out var secondaryItemStack, includeLargeObjectDrops);
		TileLoader.GetItemDrops(x, y, tileCache, includeLargeObjectDrops, includeAllModdedLargeObjectDrops);
		if (!Main.getGoodWorld || tileCache.active())
		{
			if (dropItem > 0)
			{
				int num = Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, dropItem, dropItemStack, noBroadcast: false, -1);
				Main.item[num].TryCombiningIntoNearbyItems(num);
			}
			if (secondaryItem > 0)
			{
				int num2 = Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, secondaryItem, secondaryItemStack, noBroadcast: false, -1);
				Main.item[num2].TryCombiningIntoNearbyItems(num2);
			}
		}
	}

	internal static void KillTile_GetItemDrops(int x, int y, Tile tileCache, out int dropItem, out int dropItemStack, out int secondaryItem, out int secondaryItemStack, bool includeLargeObjectDrops = false)
	{
		//IL_1982: Unknown result type (might be due to invalid IL or missing references)
		dropItem = 0;
		dropItemStack = 1;
		secondaryItem = 0;
		secondaryItemStack = 1;
		int num = 0;
		if (includeLargeObjectDrops)
		{
			switch (tileCache.type)
			{
			case 21:
			case 467:
				dropItem = GetChestItemDrop(x, y, tileCache.type);
				break;
			case 88:
				num = tileCache.frameX / 54;
				dropItem = GetDresserItemDrop(num);
				break;
			case 215:
				num = tileCache.frameX / 54;
				dropItem = GetCampfireItemDrop(num);
				break;
			}
		}
		switch (tileCache.type)
		{
		case 668:
			dropItem = 5400;
			break;
		case 659:
			dropItem = 5349;
			break;
		case 667:
			dropItem = 5398;
			break;
		case 179:
		case 180:
		case 181:
		case 182:
		case 183:
		case 381:
		case 534:
		case 536:
		case 539:
		case 625:
		case 627:
			dropItem = 3;
			break;
		case 512:
		case 513:
		case 514:
		case 515:
		case 516:
		case 517:
		case 535:
		case 537:
		case 540:
		case 626:
		case 628:
			dropItem = 129;
			break;
		case 0:
		case 2:
		case 109:
		case 199:
		case 477:
		case 492:
			dropItem = 2;
			break;
		case 633:
			dropItem = 172;
			break;
		case 426:
			dropItem = 3621;
			break;
		case 430:
			dropItem = 3633;
			break;
		case 431:
			dropItem = 3634;
			break;
		case 432:
			dropItem = 3635;
			break;
		case 433:
			dropItem = 3636;
			break;
		case 434:
			dropItem = 3637;
			break;
		case 427:
			dropItem = 3622;
			break;
		case 435:
			dropItem = 3638;
			break;
		case 436:
			dropItem = 3639;
			break;
		case 437:
			dropItem = 3640;
			break;
		case 438:
			dropItem = 3641;
			break;
		case 439:
			dropItem = 3642;
			break;
		case 446:
			dropItem = 3736;
			break;
		case 447:
			dropItem = 3737;
			break;
		case 448:
			dropItem = 3738;
			break;
		case 449:
			dropItem = 3739;
			break;
		case 450:
			dropItem = 3740;
			break;
		case 451:
			dropItem = 3741;
			break;
		case 368:
			dropItem = 3086;
			break;
		case 369:
			dropItem = 3087;
			break;
		case 367:
			dropItem = 3081;
			break;
		case 379:
			dropItem = 3214;
			break;
		case 353:
			dropItem = 2996;
			break;
		case 365:
			dropItem = 3077;
			break;
		case 366:
			dropItem = 3078;
			break;
		case 357:
			dropItem = 3066;
			break;
		case 1:
			dropItem = 3;
			break;
		case 442:
			dropItem = 3707;
			break;
		case 383:
			dropItem = 620;
			break;
		case 315:
			dropItem = 2435;
			break;
		case 641:
			dropItem = 5306;
			break;
		case 330:
			dropItem = 71;
			break;
		case 331:
			dropItem = 72;
			break;
		case 332:
			dropItem = 73;
			break;
		case 333:
			dropItem = 74;
			break;
		case 408:
			dropItem = 3460;
			break;
		case 409:
			dropItem = 3461;
			break;
		case 669:
			dropItem = 5401;
			break;
		case 670:
			dropItem = 5402;
			break;
		case 671:
			dropItem = 5403;
			break;
		case 672:
			dropItem = 5404;
			break;
		case 673:
			dropItem = 5405;
			break;
		case 674:
			dropItem = 5406;
			break;
		case 675:
			dropItem = 5407;
			break;
		case 676:
			dropItem = 5408;
			break;
		case 677:
			dropItem = 5417;
			break;
		case 678:
			dropItem = 5419;
			break;
		case 679:
			dropItem = 5421;
			break;
		case 680:
			dropItem = 5423;
			break;
		case 681:
			dropItem = 5425;
			break;
		case 682:
			dropItem = 5427;
			break;
		case 683:
			dropItem = 5433;
			break;
		case 684:
			dropItem = 5435;
			break;
		case 685:
			dropItem = 5429;
			break;
		case 686:
			dropItem = 5431;
			break;
		case 687:
			dropItem = 5439;
			break;
		case 688:
			dropItem = 5440;
			break;
		case 689:
			dropItem = 5441;
			break;
		case 690:
			dropItem = 5442;
			break;
		case 691:
			dropItem = 5443;
			break;
		case 692:
			dropItem = 5444;
			break;
		case 666:
			dropItem = 5395;
			break;
		case 415:
			dropItem = 3573;
			break;
		case 416:
			dropItem = 3574;
			break;
		case 417:
			dropItem = 3575;
			break;
		case 418:
			dropItem = 3576;
			break;
		case 421:
			dropItem = 3609;
			break;
		case 422:
			dropItem = 3610;
			break;
		case 498:
			dropItem = 4139;
			break;
		case 424:
			dropItem = 3616;
			break;
		case 445:
			dropItem = 3725;
			break;
		case 429:
			dropItem = 3629;
			break;
		case 272:
			dropItem = 1344;
			break;
		case 273:
			dropItem = 2119;
			break;
		case 274:
			dropItem = 2120;
			break;
		case 618:
			dropItem = 4962;
			break;
		case 460:
			dropItem = 3756;
			break;
		case 541:
			dropItem = 4392;
			break;
		case 630:
			dropItem = 5137;
			break;
		case 631:
			dropItem = 5138;
			break;
		case 472:
			dropItem = 3951;
			break;
		case 473:
			dropItem = 3953;
			break;
		case 474:
			dropItem = 3955;
			break;
		case 478:
			dropItem = 4050;
			break;
		case 479:
			dropItem = 4051;
			break;
		case 496:
			dropItem = 4091;
			break;
		case 495:
			dropItem = 4090;
			break;
		case 346:
			dropItem = 2792;
			break;
		case 347:
			dropItem = 2793;
			break;
		case 348:
			dropItem = 2794;
			break;
		case 350:
			dropItem = 2860;
			break;
		case 336:
			dropItem = 2701;
			break;
		case 340:
			dropItem = 2751;
			break;
		case 341:
			dropItem = 2752;
			break;
		case 342:
			dropItem = 2753;
			break;
		case 343:
			dropItem = 2754;
			break;
		case 344:
			dropItem = 2755;
			break;
		case 351:
			dropItem = 2868;
			break;
		case 500:
			dropItem = 4229;
			break;
		case 501:
			dropItem = 4230;
			break;
		case 502:
			dropItem = 4231;
			break;
		case 503:
			dropItem = 4232;
			break;
		case 546:
		case 557:
			dropItem = 4422;
			break;
		case 561:
			dropItem = 4554;
			break;
		case 574:
			dropItem = 4717;
			break;
		case 575:
			dropItem = 4718;
			break;
		case 576:
			dropItem = 4719;
			break;
		case 577:
			dropItem = 4720;
			break;
		case 578:
			dropItem = 4721;
			break;
		case 562:
			dropItem = 4564;
			break;
		case 571:
			dropItem = 4564;
			dropItemStack = genRand.Next(1, 3);
			break;
		case 563:
			dropItem = 4547;
			break;
		case 251:
			dropItem = 1725;
			break;
		case 252:
			dropItem = 1727;
			break;
		case 253:
			dropItem = 1729;
			break;
		case 325:
			dropItem = 2692;
			break;
		case 370:
			dropItem = 3100;
			break;
		case 396:
			dropItem = 3271;
			break;
		case 400:
			dropItem = 3276;
			break;
		case 401:
			dropItem = 3277;
			break;
		case 403:
			dropItem = 3339;
			break;
		case 397:
			dropItem = 3272;
			break;
		case 398:
			dropItem = 3274;
			break;
		case 399:
			dropItem = 3275;
			break;
		case 402:
			dropItem = 3338;
			break;
		case 404:
			dropItem = 3347;
			break;
		case 407:
			dropItem = 3380;
			break;
		case 579:
			dropItem = 4761;
			break;
		case 593:
			dropItem = 4868;
			break;
		case 624:
			dropItem = 5114;
			break;
		case 656:
			dropItem = 5333;
			break;
		case 170:
			dropItem = 1872;
			break;
		case 284:
			dropItem = 2173;
			break;
		case 214:
			dropItem = 85;
			break;
		case 213:
			dropItem = 965;
			break;
		case 211:
			dropItem = 947;
			break;
		case 6:
			dropItem = 11;
			break;
		case 7:
			dropItem = 12;
			break;
		case 8:
			dropItem = 13;
			break;
		case 9:
			dropItem = 14;
			break;
		case 202:
			dropItem = 824;
			break;
		case 234:
			dropItem = 1246;
			break;
		case 226:
			dropItem = 1101;
			break;
		case 224:
			dropItem = 1103;
			break;
		case 36:
			dropItem = 1869;
			break;
		case 311:
			dropItem = 2260;
			break;
		case 312:
			dropItem = 2261;
			break;
		case 313:
			dropItem = 2262;
			break;
		case 229:
			dropItem = 1125;
			break;
		case 230:
			dropItem = 1127;
			break;
		case 221:
			dropItem = 1104;
			break;
		case 222:
			dropItem = 1105;
			break;
		case 223:
			dropItem = 1106;
			break;
		case 248:
			dropItem = 1589;
			break;
		case 249:
			dropItem = 1591;
			break;
		case 250:
			dropItem = 1593;
			break;
		case 191:
			dropItem = 9;
			break;
		case 203:
			dropItem = 836;
			break;
		case 204:
			dropItem = 880;
			break;
		case 166:
			dropItem = 699;
			break;
		case 167:
			dropItem = 700;
			break;
		case 168:
			dropItem = 701;
			break;
		case 169:
			dropItem = 702;
			break;
		case 123:
			dropItem = 424;
			break;
		case 124:
			dropItem = 480;
			break;
		case 157:
			dropItem = 619;
			break;
		case 158:
			dropItem = 620;
			break;
		case 159:
			dropItem = 621;
			break;
		case 161:
			dropItem = 664;
			break;
		case 206:
			dropItem = 883;
			break;
		case 232:
			dropItem = 1150;
			break;
		case 198:
			dropItem = 775;
			break;
		case 314:
			dropItem = Minecart.GetTrackItem(tileCache);
			break;
		case 189:
			dropItem = 751;
			break;
		case 195:
			dropItem = 763;
			break;
		case 194:
			dropItem = 154;
			break;
		case 193:
			dropItem = 762;
			break;
		case 196:
			dropItem = 765;
			break;
		case 197:
			dropItem = 767;
			break;
		case 22:
			dropItem = 56;
			break;
		case 140:
			dropItem = 577;
			break;
		case 23:
			dropItem = 2;
			break;
		case 25:
			dropItem = 61;
			break;
		case 30:
			dropItem = 9;
			break;
		case 208:
			dropItem = 911;
			break;
		case 372:
			dropItem = 3117;
			break;
		case 646:
			dropItem = 5322;
			break;
		case 371:
			dropItem = 3113;
			break;
		case 174:
			dropItem = 713;
			break;
		case 37:
			dropItem = 116;
			break;
		case 38:
			dropItem = 129;
			break;
		case 39:
			dropItem = 131;
			break;
		case 40:
			dropItem = 133;
			break;
		case 41:
			dropItem = 134;
			break;
		case 43:
			dropItem = 137;
			break;
		case 44:
			dropItem = 139;
			break;
		case 45:
			dropItem = 141;
			break;
		case 46:
			dropItem = 143;
			break;
		case 47:
			dropItem = 145;
			break;
		case 48:
			dropItem = 147;
			break;
		case 49:
			dropItem = 148;
			break;
		case 51:
			dropItem = 150;
			break;
		case 53:
			dropItem = 169;
			break;
		case 151:
			dropItem = 607;
			break;
		case 152:
			dropItem = 609;
			break;
		case 56:
			dropItem = 173;
			break;
		case 57:
			dropItem = 172;
			break;
		case 58:
			dropItem = 174;
			break;
		case 70:
			dropItem = 176;
			break;
		case 75:
			dropItem = 192;
			break;
		case 76:
			dropItem = 214;
			break;
		case 78:
			dropItem = 222;
			break;
		case 81:
			dropItem = 275;
			break;
		case 80:
			dropItem = 276;
			break;
		case 188:
			dropItem = 276;
			break;
		case 107:
			dropItem = 364;
			break;
		case 108:
			dropItem = 365;
			break;
		case 111:
			dropItem = 366;
			break;
		case 150:
			dropItem = 604;
			break;
		case 112:
			dropItem = 370;
			break;
		case 116:
			dropItem = 408;
			break;
		case 117:
			dropItem = 409;
			break;
		case 118:
			dropItem = 412;
			break;
		case 119:
			dropItem = 413;
			break;
		case 120:
			dropItem = 414;
			break;
		case 121:
			dropItem = 415;
			break;
		case 122:
			dropItem = 416;
			break;
		case 136:
			dropItem = 538;
			break;
		case 385:
			dropItem = 3234;
			break;
		case 141:
			dropItem = 580;
			break;
		case 145:
			dropItem = 586;
			break;
		case 146:
			dropItem = 591;
			break;
		case 147:
			dropItem = 593;
			break;
		case 148:
			dropItem = 594;
			break;
		case 153:
			dropItem = 611;
			break;
		case 154:
			dropItem = 612;
			break;
		case 155:
			dropItem = 613;
			break;
		case 156:
			dropItem = 614;
			break;
		case 160:
			dropItem = 662;
			break;
		case 175:
			dropItem = 717;
			break;
		case 176:
			dropItem = 718;
			break;
		case 177:
			dropItem = 719;
			break;
		case 163:
			dropItem = 833;
			break;
		case 164:
			dropItem = 834;
			break;
		case 200:
			dropItem = 835;
			break;
		case 210:
			dropItem = 937;
			break;
		case 130:
			dropItem = 511;
			break;
		case 131:
			dropItem = 512;
			break;
		case 321:
			dropItem = 2503;
			break;
		case 322:
			dropItem = 2504;
			break;
		case 635:
			dropItem = 5215;
			break;
		case 54:
			dropItem = 170;
			break;
		case 326:
			dropItem = 2693;
			break;
		case 327:
			dropItem = 2694;
			break;
		case 458:
			dropItem = 3754;
			break;
		case 459:
			dropItem = 3755;
			break;
		case 345:
			dropItem = 2787;
			break;
		case 328:
			dropItem = 2695;
			break;
		case 329:
			dropItem = 2697;
			break;
		case 507:
			dropItem = 4277;
			break;
		case 508:
			dropItem = 4278;
			break;
		case 255:
		case 256:
		case 257:
		case 258:
		case 259:
		case 260:
		case 261:
			dropItem = 1970 + tileCache.type - 255;
			break;
		case 262:
		case 263:
		case 264:
		case 265:
		case 266:
		case 267:
		case 268:
			dropItem = 1970 + tileCache.type - 262;
			break;
		case 59:
		case 60:
		case 661:
		case 662:
			dropItem = 176;
			break;
		case 190:
			dropItem = 183;
			break;
		case 63:
		case 64:
		case 65:
		case 66:
		case 67:
		case 68:
			dropItem = tileCache.type - 63 + 177;
			break;
		case 566:
			dropItem = 999;
			break;
		case 637:
			if (Main.rand.Next(100) == 0)
			{
				dropItem = 5214;
			}
			break;
		case 129:
			if (tileCache.frameX >= 324)
			{
				dropItem = 4988;
			}
			else
			{
				dropItem = 502;
			}
			break;
		case 3:
			if (tileCache.frameX == 144)
			{
				dropItem = 5;
			}
			else if (KillTile_ShouldDropSeeds(x, y))
			{
				dropItem = 283;
			}
			break;
		case 519:
			if (tileCache.frameY == 90 && genRand.Next(2) == 0)
			{
				dropItem = 183;
			}
			break;
		case 528:
			if (genRand.Next(2) == 0)
			{
				dropItem = 183;
			}
			break;
		case 110:
			if (tileCache.frameX == 144)
			{
				dropItem = 5;
			}
			break;
		case 24:
			if (tileCache.frameX == 144)
			{
				dropItem = 60;
			}
			break;
		case 201:
			if (tileCache.frameX == 270)
			{
				dropItem = 2887;
			}
			break;
		case 73:
			if (KillTile_ShouldDropSeeds(x, y))
			{
				dropItem = 283;
			}
			break;
		case 52:
		case 62:
		case 382:
			if (Main.rand.Next(2) == 0 && GetPlayerForTile(x, y).cordage)
			{
				dropItem = 2996;
			}
			break;
		case 227:
			num = tileCache.frameX / 34;
			dropItem = 1107 + num;
			if (num >= 8 && num <= 11)
			{
				dropItem = 3385 + num - 8;
			}
			break;
		case 4:
			num = tileCache.frameY / 22;
			switch (num)
			{
			case 0:
				dropItem = 8;
				break;
			case 8:
				dropItem = 523;
				break;
			case 9:
				dropItem = 974;
				break;
			case 10:
				dropItem = 1245;
				break;
			case 11:
				dropItem = 1333;
				break;
			case 12:
				dropItem = 2274;
				break;
			case 13:
				dropItem = 3004;
				break;
			case 14:
				dropItem = 3045;
				break;
			case 15:
				dropItem = 3114;
				break;
			case 16:
				dropItem = 4383;
				break;
			case 17:
				dropItem = 4384;
				break;
			case 18:
				dropItem = 4385;
				break;
			case 19:
				dropItem = 4386;
				break;
			case 20:
				dropItem = 4387;
				break;
			case 21:
				dropItem = 4388;
				break;
			case 22:
				dropItem = 5293;
				break;
			case 23:
				dropItem = 5353;
				break;
			default:
				dropItem = 426 + num;
				break;
			}
			break;
		case 239:
			num = tileCache.frameX / 18;
			if (num == 0)
			{
				dropItem = 20;
			}
			if (num == 1)
			{
				dropItem = 703;
			}
			if (num == 2)
			{
				dropItem = 22;
			}
			if (num == 3)
			{
				dropItem = 704;
			}
			if (num == 4)
			{
				dropItem = 21;
			}
			if (num == 5)
			{
				dropItem = 705;
			}
			if (num == 6)
			{
				dropItem = 19;
			}
			if (num == 7)
			{
				dropItem = 706;
			}
			if (num == 8)
			{
				dropItem = 57;
			}
			if (num == 9)
			{
				dropItem = 117;
			}
			if (num == 10)
			{
				dropItem = 175;
			}
			if (num == 11)
			{
				dropItem = 381;
			}
			if (num == 12)
			{
				dropItem = 1184;
			}
			if (num == 13)
			{
				dropItem = 382;
			}
			if (num == 14)
			{
				dropItem = 1191;
			}
			if (num == 15)
			{
				dropItem = 391;
			}
			if (num == 16)
			{
				dropItem = 1198;
			}
			if (num == 17)
			{
				dropItem = 1006;
			}
			if (num == 18)
			{
				dropItem = 1225;
			}
			if (num == 19)
			{
				dropItem = 1257;
			}
			if (num == 20)
			{
				dropItem = 1552;
			}
			if (num == 21)
			{
				dropItem = 3261;
			}
			if (num == 22)
			{
				dropItem = 3467;
			}
			break;
		case 380:
			num = tileCache.frameY / 18;
			dropItem = 3215 + num;
			break;
		case 5:
		case 596:
		case 616:
		case 634:
		{
			bool bonusWood = false;
			KillTile_GetTreeDrops(x, y, tileCache, ref bonusWood, ref dropItem, ref secondaryItem);
			if (bonusWood)
			{
				dropItemStack++;
			}
			break;
		}
		case 323:
		{
			dropItem = 2504;
			if (Main.tenthAnniversaryWorld)
			{
				dropItemStack += genRand.Next(2, 5);
			}
			if (tileCache.frameX <= 132 && tileCache.frameX >= 88)
			{
				secondaryItem = 27;
			}
			int j;
			for (j = y; !Main.tile[x, j].active() || !Main.tileSolid[Main.tile[x, j].type]; j++)
			{
			}
			if (Main.tile[x, j].active())
			{
				switch (Main.tile[x, j].type)
				{
				case 234:
					dropItem = 911;
					break;
				case 116:
					dropItem = 621;
					break;
				case 112:
					dropItem = 619;
					break;
				}
				TileLoader.DropPalmTreeWood(Main.tile[x, j].type, ref dropItem);
			}
			break;
		}
		case 171:
			if (tileCache.frameX >= 10)
			{
				dropXmasTree(x, y, 0);
				dropXmasTree(x, y, 1);
				dropXmasTree(x, y, 2);
				dropXmasTree(x, y, 3);
			}
			break;
		case 324:
			switch (tileCache.frameY / 22)
			{
			case 0:
				dropItem = 2625;
				break;
			case 1:
				dropItem = 2626;
				break;
			case 2:
				dropItem = 4072;
				break;
			case 3:
				dropItem = 4073;
				break;
			case 4:
				dropItem = 4071;
				break;
			}
			break;
		case 419:
			switch (tileCache.frameX / 18)
			{
			case 0:
				dropItem = 3602;
				break;
			case 1:
				dropItem = 3618;
				break;
			case 2:
				dropItem = 3663;
				break;
			}
			break;
		case 428:
			switch (tileCache.frameY / 18)
			{
			case 0:
				dropItem = 3630;
				break;
			case 1:
				dropItem = 3632;
				break;
			case 2:
				dropItem = 3631;
				break;
			case 3:
				dropItem = 3626;
				break;
			}
			PressurePlateHelper.DestroyPlate(new Point(x, y));
			break;
		case 420:
			switch (tileCache.frameY / 18)
			{
			case 0:
				dropItem = 3603;
				break;
			case 1:
				dropItem = 3604;
				break;
			case 2:
				dropItem = 3605;
				break;
			case 3:
				dropItem = 3606;
				break;
			case 4:
				dropItem = 3607;
				break;
			case 5:
				dropItem = 3608;
				break;
			}
			break;
		case 650:
			num = tileCache.frameX / 18;
			if (num < 6)
			{
				dropItem = 3;
			}
			else if (num < 12)
			{
				dropItem = 2;
			}
			else if (num < 20)
			{
				dropItem = 154;
			}
			else if (num < 28)
			{
				dropItem = 154;
			}
			else if (num < 36)
			{
				dropItem = 9;
			}
			else if (num < 42)
			{
				dropItem = 593;
			}
			else if (num < 48)
			{
				dropItem = 664;
			}
			else if (num < 54)
			{
				dropItem = 150;
			}
			else if (num < 60)
			{
				dropItem = 3271;
			}
			else if (num < 66)
			{
				dropItem = 3086;
			}
			else if (num < 72)
			{
				dropItem = 3081;
			}
			else if (num < 73)
			{
				dropItem = 62;
			}
			else if (num < 77)
			{
				dropItem = 169;
			}
			break;
		case 476:
			dropItem = 4040;
			break;
		case 494:
			dropItem = 4089;
			break;
		case 423:
			TELogicSensor.Kill(x, y);
			switch (tileCache.frameY / 18)
			{
			case 0:
				dropItem = 3613;
				break;
			case 1:
				dropItem = 3614;
				break;
			case 2:
				dropItem = 3615;
				break;
			case 3:
				dropItem = 3726;
				break;
			case 4:
				dropItem = 3727;
				break;
			case 5:
				dropItem = 3728;
				break;
			case 6:
				dropItem = 3729;
				break;
			}
			break;
		case 520:
			dropItem = 4326;
			break;
		case 225:
			if (Main.rand.Next(3) == 0)
			{
				tileCache.honey(honey: true);
				tileCache.liquid = byte.MaxValue;
				break;
			}
			dropItem = 1124;
			if (Main.netMode != 1 && Main.rand.Next(2) == 0)
			{
				int num3 = 1;
				if (Main.rand.Next(3) == 0)
				{
					num3 = 2;
				}
				for (int i = 0; i < num3; i++)
				{
					int type = Main.rand.Next(210, 212);
					int num4 = NPC.NewNPC(GetNPCSource_TileBreak(x, y), x * 16 + 8, y * 16 + 15, type, 1);
					Main.npc[num4].velocity.X = (float)Main.rand.Next(-200, 201) * 0.002f;
					Main.npc[num4].velocity.Y = (float)Main.rand.Next(-200, 201) * 0.002f;
					Main.npc[num4].netUpdate = true;
				}
			}
			break;
		case 178:
			switch (tileCache.frameX / 18)
			{
			case 0:
				dropItem = 181;
				break;
			case 1:
				dropItem = 180;
				break;
			case 2:
				dropItem = 177;
				break;
			case 3:
				dropItem = 179;
				break;
			case 4:
				dropItem = 178;
				break;
			case 5:
				dropItem = 182;
				break;
			case 6:
				dropItem = 999;
				break;
			}
			break;
		case 149:
			if (tileCache.frameX == 0 || tileCache.frameX == 54)
			{
				dropItem = 596;
			}
			else if (tileCache.frameX == 18 || tileCache.frameX == 72)
			{
				dropItem = 597;
			}
			else if (tileCache.frameX == 36 || tileCache.frameX == 90)
			{
				dropItem = 598;
			}
			break;
		case 13:
			switch (tileCache.frameX / 18)
			{
			case 1:
				dropItem = 28;
				break;
			case 2:
				dropItem = 110;
				break;
			case 3:
				dropItem = 350;
				break;
			case 4:
				dropItem = 351;
				break;
			case 5:
				dropItem = 2234;
				break;
			case 6:
				dropItem = 2244;
				break;
			case 7:
				dropItem = 2257;
				break;
			case 8:
				dropItem = 2258;
				break;
			default:
				dropItem = 31;
				break;
			}
			break;
		case 19:
			num = tileCache.frameY / 18;
			switch (num)
			{
			case 0:
				dropItem = 94;
				break;
			case 1:
				dropItem = 631;
				break;
			case 2:
				dropItem = 632;
				break;
			case 3:
				dropItem = 633;
				break;
			case 4:
				dropItem = 634;
				break;
			case 5:
				dropItem = 913;
				break;
			case 6:
				dropItem = 1384;
				break;
			case 7:
				dropItem = 1385;
				break;
			case 8:
				dropItem = 1386;
				break;
			case 9:
				dropItem = 1387;
				break;
			case 10:
				dropItem = 1388;
				break;
			case 11:
				dropItem = 1389;
				break;
			case 12:
				dropItem = 1418;
				break;
			case 13:
				dropItem = 1457;
				break;
			case 14:
				dropItem = 1702;
				break;
			case 15:
				dropItem = 1796;
				break;
			case 16:
				dropItem = 1818;
				break;
			case 17:
				dropItem = 2518;
				break;
			case 18:
				dropItem = 2549;
				break;
			case 19:
				dropItem = 2566;
				break;
			case 20:
				dropItem = 2581;
				break;
			case 21:
				dropItem = 2627;
				break;
			case 22:
				dropItem = 2628;
				break;
			case 23:
				dropItem = 2629;
				break;
			case 24:
				dropItem = 2630;
				break;
			case 25:
				dropItem = 2744;
				break;
			case 26:
				dropItem = 2822;
				break;
			case 27:
				dropItem = 3144;
				break;
			case 28:
				dropItem = 3146;
				break;
			case 29:
				dropItem = 3145;
				break;
			case 30:
			case 31:
			case 32:
			case 33:
			case 34:
			case 35:
				dropItem = 3903 + num - 30;
				break;
			case 36:
				dropItem = 3945;
				break;
			case 37:
				dropItem = 3957;
				break;
			case 38:
				dropItem = 4159;
				break;
			case 39:
				dropItem = 4180;
				break;
			case 40:
				dropItem = 4201;
				break;
			case 41:
				dropItem = 4222;
				break;
			case 42:
				dropItem = 4311;
				break;
			case 43:
				dropItem = 4416;
				break;
			case 44:
				dropItem = 4580;
				break;
			case 45:
				dropItem = 5162;
				break;
			case 46:
				dropItem = 5183;
				break;
			case 47:
				dropItem = 5204;
				break;
			case 48:
				dropItem = 5292;
				break;
			}
			break;
		case 33:
			num = tileCache.frameY / 22;
			dropItem = 105;
			switch (num)
			{
			case 1:
				dropItem = 1405;
				break;
			case 2:
				dropItem = 1406;
				break;
			case 3:
				dropItem = 1407;
				break;
			case 4:
			case 5:
			case 6:
			case 7:
			case 8:
			case 9:
			case 10:
			case 11:
			case 12:
			case 13:
				dropItem = 2045 + num - 4;
				break;
			case 14:
			case 15:
			case 16:
				dropItem = 2153 + num - 14;
				break;
			default:
				switch (num)
				{
				case 17:
					dropItem = 2236;
					break;
				case 18:
					dropItem = 2523;
					break;
				case 19:
					dropItem = 2542;
					break;
				case 20:
					dropItem = 2556;
					break;
				case 21:
					dropItem = 2571;
					break;
				case 22:
					dropItem = 2648;
					break;
				case 23:
					dropItem = 2649;
					break;
				case 24:
					dropItem = 2650;
					break;
				case 25:
					dropItem = 2651;
					break;
				case 26:
					dropItem = 2818;
					break;
				case 27:
					dropItem = 3171;
					break;
				case 28:
					dropItem = 3173;
					break;
				case 29:
					dropItem = 3172;
					break;
				case 30:
					dropItem = 3890;
					break;
				case 31:
					dropItem = 3936;
					break;
				case 32:
					dropItem = 3962;
					break;
				case 33:
					dropItem = 4150;
					break;
				case 34:
					dropItem = 4171;
					break;
				case 35:
					dropItem = 4192;
					break;
				case 36:
					dropItem = 4213;
					break;
				case 37:
					dropItem = 4303;
					break;
				case 38:
					dropItem = 4571;
					break;
				case 39:
					dropItem = 5153;
					break;
				case 40:
					dropItem = 5174;
					break;
				case 41:
					dropItem = 5195;
					break;
				}
				break;
			}
			break;
		case 137:
			num = tileCache.frameY / 18;
			if (num == 0)
			{
				dropItem = 539;
			}
			if (num == 1)
			{
				dropItem = 1146;
			}
			if (num == 2)
			{
				dropItem = 1147;
			}
			if (num == 3)
			{
				dropItem = 1148;
			}
			if (num == 4)
			{
				dropItem = 1149;
			}
			if (num == 5)
			{
				dropItem = 5135;
			}
			break;
		case 135:
			num = tileCache.frameY / 18;
			if (num == 0)
			{
				dropItem = 529;
			}
			if (num == 1)
			{
				dropItem = 541;
			}
			if (num == 2)
			{
				dropItem = 542;
			}
			if (num == 3)
			{
				dropItem = 543;
			}
			if (num == 4)
			{
				dropItem = 852;
			}
			if (num == 5)
			{
				dropItem = 853;
			}
			if (num == 6)
			{
				dropItem = 1151;
			}
			break;
		case 144:
			if (tileCache.frameX == 0)
			{
				dropItem = 583;
			}
			if (tileCache.frameX == 18)
			{
				dropItem = 584;
			}
			if (tileCache.frameX == 36)
			{
				dropItem = 585;
			}
			if (tileCache.frameX == 54)
			{
				dropItem = 4484;
			}
			if (tileCache.frameX == 72)
			{
				dropItem = 4485;
			}
			break;
		case 61:
		case 74:
			if (tileCache.frameX == 144 && tileCache.type == 61)
			{
				dropItem = 331;
				dropItemStack = Main.rand.Next(2, 4);
			}
			else if (tileCache.frameX == 162 && tileCache.type == 61)
			{
				dropItem = 223;
			}
			else if (tileCache.frameX >= 108 && tileCache.frameX <= 126 && tileCache.type == 61 && Main.rand.Next(20) == 0)
			{
				dropItem = 208;
			}
			else if (Main.rand.Next(100) == 0)
			{
				dropItem = 195;
			}
			break;
		case 71:
		case 72:
			if (Main.rand.Next(40) == 0)
			{
				dropItem = 194;
			}
			else if (Main.rand.Next(2) == 0)
			{
				dropItem = 183;
			}
			break;
		case 50:
			if (tileCache.frameX == 90)
			{
				dropItem = 165;
			}
			else
			{
				dropItem = 149;
			}
			break;
		case 83:
		case 84:
		{
			num = tileCache.frameX / 18;
			dropItem = 313 + num;
			int num2 = 307 + num;
			if (num == 6)
			{
				dropItem = 2358;
				num2 = 2357;
			}
			bool flag = IsHarvestableHerbWithSeed(tileCache.type, num);
			Player playerForTile = GetPlayerForTile(x, y);
			if (playerForTile.HeldItem.type == 213 || playerForTile.HeldItem.type == 5295)
			{
				dropItemStack = Main.rand.Next(1, 3);
				secondaryItem = num2;
				secondaryItemStack = Main.rand.Next(1, 6);
			}
			else if (flag)
			{
				secondaryItem = num2;
				secondaryItemStack = Main.rand.Next(1, 4);
			}
			break;
		}
		case 589:
			SetGemTreeDrops(999, 4857, tileCache, ref dropItem, ref secondaryItem);
			if (dropItem == 3)
			{
				dropItemStack = Main.rand.Next(1, 3);
			}
			break;
		case 584:
			SetGemTreeDrops(181, 4852, tileCache, ref dropItem, ref secondaryItem);
			if (dropItem == 3)
			{
				dropItemStack = Main.rand.Next(1, 3);
			}
			break;
		case 583:
			SetGemTreeDrops(180, 4851, tileCache, ref dropItem, ref secondaryItem);
			if (dropItem == 3)
			{
				dropItemStack = Main.rand.Next(1, 3);
			}
			break;
		case 586:
			SetGemTreeDrops(179, 4854, tileCache, ref dropItem, ref secondaryItem);
			if (dropItem == 3)
			{
				dropItemStack = Main.rand.Next(1, 3);
			}
			break;
		case 585:
			SetGemTreeDrops(177, 4853, tileCache, ref dropItem, ref secondaryItem);
			if (dropItem == 3)
			{
				dropItemStack = Main.rand.Next(1, 3);
			}
			break;
		case 587:
			SetGemTreeDrops(178, 4855, tileCache, ref dropItem, ref secondaryItem);
			if (dropItem == 3)
			{
				dropItemStack = Main.rand.Next(1, 3);
			}
			break;
		case 588:
			SetGemTreeDrops(182, 4856, tileCache, ref dropItem, ref secondaryItem);
			if (dropItem == 3)
			{
				dropItemStack = Main.rand.Next(1, 3);
			}
			break;
		case 10:
		case 11:
		case 12:
		case 14:
		case 15:
		case 16:
		case 17:
		case 18:
		case 20:
		case 21:
		case 26:
		case 27:
		case 28:
		case 29:
		case 31:
		case 32:
		case 34:
		case 35:
		case 42:
		case 55:
		case 69:
		case 77:
		case 79:
		case 82:
		case 85:
		case 86:
		case 87:
		case 88:
		case 89:
		case 90:
		case 91:
		case 92:
		case 93:
		case 94:
		case 95:
		case 96:
		case 97:
		case 98:
		case 99:
		case 100:
		case 101:
		case 102:
		case 103:
		case 104:
		case 105:
		case 106:
		case 113:
		case 114:
		case 115:
		case 125:
		case 126:
		case 127:
		case 128:
		case 132:
		case 133:
		case 134:
		case 138:
		case 139:
		case 142:
		case 143:
		case 162:
		case 165:
		case 172:
		case 173:
		case 184:
		case 185:
		case 186:
		case 187:
		case 192:
		case 205:
		case 207:
		case 209:
		case 212:
		case 215:
		case 216:
		case 217:
		case 218:
		case 219:
		case 220:
		case 228:
		case 231:
		case 233:
		case 235:
		case 236:
		case 237:
		case 238:
		case 240:
		case 241:
		case 242:
		case 243:
		case 244:
		case 245:
		case 246:
		case 247:
		case 254:
		case 269:
		case 270:
		case 271:
		case 275:
		case 276:
		case 277:
		case 278:
		case 279:
		case 280:
		case 281:
		case 282:
		case 283:
		case 285:
		case 286:
		case 287:
		case 288:
		case 289:
		case 290:
		case 291:
		case 292:
		case 293:
		case 294:
		case 295:
		case 296:
		case 297:
		case 298:
		case 299:
		case 300:
		case 301:
		case 302:
		case 303:
		case 304:
		case 305:
		case 306:
		case 307:
		case 308:
		case 309:
		case 310:
		case 316:
		case 317:
		case 318:
		case 319:
		case 320:
		case 334:
		case 335:
		case 337:
		case 338:
		case 339:
		case 349:
		case 352:
		case 354:
		case 355:
		case 356:
		case 358:
		case 359:
		case 360:
		case 361:
		case 362:
		case 363:
		case 364:
		case 373:
		case 374:
		case 375:
		case 376:
		case 377:
		case 378:
		case 384:
		case 386:
		case 387:
		case 388:
		case 389:
		case 390:
		case 391:
		case 392:
		case 393:
		case 394:
		case 395:
		case 405:
		case 406:
		case 410:
		case 411:
		case 412:
		case 413:
		case 414:
		case 425:
		case 440:
		case 441:
		case 443:
		case 444:
		case 452:
		case 453:
		case 454:
		case 455:
		case 456:
		case 457:
		case 461:
		case 462:
		case 463:
		case 464:
		case 465:
		case 466:
		case 467:
		case 468:
		case 469:
		case 470:
		case 471:
		case 475:
		case 480:
		case 481:
		case 482:
		case 483:
		case 484:
		case 485:
		case 486:
		case 487:
		case 488:
		case 489:
		case 490:
		case 491:
		case 493:
		case 497:
		case 499:
		case 504:
		case 505:
		case 506:
		case 509:
		case 510:
		case 511:
		case 518:
		case 521:
		case 522:
		case 523:
		case 524:
		case 525:
		case 526:
		case 527:
		case 529:
		case 530:
		case 531:
		case 532:
		case 533:
		case 538:
		case 542:
		case 543:
		case 544:
		case 545:
		case 547:
		case 548:
		case 549:
		case 550:
		case 551:
		case 552:
		case 553:
		case 554:
		case 555:
		case 556:
		case 558:
		case 559:
		case 560:
		case 564:
		case 565:
		case 567:
		case 568:
		case 569:
		case 570:
		case 572:
		case 573:
		case 580:
		case 581:
		case 582:
		case 590:
		case 591:
		case 592:
		case 594:
		case 595:
		case 597:
		case 598:
		case 599:
		case 600:
		case 601:
		case 602:
		case 603:
		case 604:
		case 605:
		case 606:
		case 607:
		case 608:
		case 609:
		case 610:
		case 611:
		case 612:
		case 613:
		case 614:
		case 615:
		case 617:
		case 619:
		case 620:
		case 621:
		case 622:
		case 623:
		case 629:
		case 632:
		case 636:
		case 638:
		case 639:
		case 640:
		case 642:
		case 643:
		case 644:
		case 645:
		case 647:
		case 648:
		case 649:
		case 651:
		case 652:
		case 653:
		case 654:
		case 655:
		case 657:
		case 658:
		case 660:
		case 663:
		case 664:
		case 665:
			break;
		}
	}

	private static void SetGemTreeDrops(int gemType, int seedType, Tile tileCache, ref int dropItem, ref int secondaryItem)
	{
		if (Main.rand.Next(10) == 0)
		{
			dropItem = gemType;
		}
		else
		{
			dropItem = 3;
		}
		if (tileCache.frameX >= 22 && tileCache.frameY >= 198 && Main.rand.Next(2) == 0)
		{
			secondaryItem = seedType;
		}
	}

	private static void SetVanityTreeDrops(int dropType, Tile tileCache, ref int dropItem)
	{
		if (Main.rand.Next(2) == 0)
		{
			dropItem = dropType;
		}
	}

	public static bool IsHarvestableHerbWithSeed(int type, int style)
	{
		switch (type)
		{
		case 82:
			return false;
		default:
			return false;
		case 83:
		case 84:
		{
			bool result = false;
			if (type == 84)
			{
				result = true;
			}
			if (style == 0 && Main.dayTime)
			{
				result = true;
			}
			if (style == 1 && !Main.dayTime)
			{
				result = true;
			}
			if (style == 3 && !Main.dayTime && (Main.bloodMoon || Main.moonPhase == 0))
			{
				result = true;
			}
			if (style == 4 && (Main.raining || Main.cloudAlpha > 0f))
			{
				result = true;
			}
			if (style == 5 && !Main.raining && Main.dayTime && Main.time > 40500.0)
			{
				result = true;
			}
			return result;
		}
		}
	}

	private static bool KillTile_ShouldDropSeeds(int x, int y)
	{
		if (Main.rand.Next(2) == 0)
		{
			if (!GetPlayerForTile(x, y).HasItem(281))
			{
				return GetPlayerForTile(x, y).HasItem(986);
			}
			return true;
		}
		return false;
	}

	private static void KillTile_GetTreeDrops(int i, int j, Tile tileCache, ref bool bonusWood, ref int dropItem, ref int secondaryItem)
	{
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		if (tileCache.frameX >= 22 && tileCache.frameY >= 198)
		{
			if (Main.netMode != 1)
			{
				if (genRand.Next(2) == 0)
				{
					int k;
					for (k = j; Main.tile[i, k] != null && (!Main.tile[i, k].active() || !Main.tileSolid[Main.tile[i, k].type] || Main.tileSolidTop[Main.tile[i, k].type]); k++)
					{
					}
					if (Main.tile[i, k] != null)
					{
						Tile tile = Main.tile[i, k];
						bool vanillaResult = false;
						if (tile.type == 2 || tile.type == 109 || tile.type == 477 || tile.type == 492 || tile.type == 147 || tile.type == 199 || tile.type == 23 || tile.type == 633)
						{
							vanillaResult = true;
						}
						if (vanillaResult || TileLoader.CanDropAcorn(tile.type))
						{
							dropItem = 9;
							secondaryItem = 27;
						}
						else
						{
							dropItem = 9;
						}
					}
				}
				else
				{
					dropItem = 9;
				}
			}
		}
		else
		{
			dropItem = 9;
		}
		if (dropItem != 9)
		{
			return;
		}
		GetTreeBottom(i, j, out var x, out var y);
		if (Main.tile[x, y].active())
		{
			switch (Main.tile[x, y].type)
			{
			case 633:
				dropItem = 5215;
				break;
			case 23:
			case 661:
				dropItem = 619;
				break;
			case 199:
			case 662:
				dropItem = 911;
				break;
			case 60:
				dropItem = 620;
				break;
			case 109:
			case 492:
				dropItem = 621;
				break;
			case 70:
				if (genRand.Next(2) == 0)
				{
					dropItem = 183;
				}
				else
				{
					dropItem = 0;
				}
				break;
			case 147:
				dropItem = 2503;
				break;
			}
			TileLoader.DropTreeWood(Main.tile[x, y].type, ref dropItem);
		}
		int num = Player.FindClosest(new Vector2((float)(x * 16), (float)(y * 16)), 16, 16);
		int axe = Main.player[num].inventory[Main.player[num].selectedItem].axe;
		if (genRand.Next(100) < axe || Main.rand.Next(3) == 0)
		{
			bonusWood = true;
		}
	}

	private static void KillTile_DropBait(int i, int j, Tile tileCache)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		int num = -1;
		int num3 = -1;
		int num4 = -1;
		int num5 = -1;
		int num6 = Player.FindClosest(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16);
		if (tileCache.type == 3)
		{
			num = 400;
			num3 = 100;
			if (Main.player[num6].flowerBoots && tileCache.frameX >= 108)
			{
				num *= 10000;
				num3 *= 10000;
			}
		}
		if (tileCache.type == 73)
		{
			num = 200;
			num3 = 50;
			if (Main.player[num6].flowerBoots && tileCache.frameX >= 108)
			{
				num *= 10000;
				num3 *= 10000;
			}
		}
		if (tileCache.type == 637)
		{
			num5 = 100;
			if (Main.player[num6].flowerBoots && tileCache.frameX >= 108)
			{
				num5 *= 10000;
			}
		}
		if (tileCache.type == 61)
		{
			num4 = 80;
			if (Main.player[num6].flowerBoots && tileCache.frameX >= 108)
			{
				num4 *= 10000;
			}
		}
		if (tileCache.type == 74)
		{
			num4 = 40;
			if (Main.player[num6].flowerBoots && tileCache.frameX >= 108)
			{
				num4 *= 10000;
			}
		}
		if (tileCache.type == 62)
		{
			num4 = 250;
		}
		if (tileCache.type == 185)
		{
			if (tileCache.frameY == 0 && tileCache.frameX < 214)
			{
				num = 6;
			}
			if (tileCache.frameY == 18 && (tileCache.frameX < 214 || tileCache.frameX >= 1368))
			{
				num = 6;
			}
		}
		else if (tileCache.type == 186)
		{
			if (tileCache.frameX >= 378 && tileCache.frameX <= 700)
			{
				num = 6;
			}
		}
		else if (tileCache.type == 187)
		{
			if (tileCache.frameX >= 756 && tileCache.frameX <= 916)
			{
				num = 6;
			}
			if (tileCache.frameX <= 322)
			{
				num = 6;
			}
		}
		else if (tileCache.type == 233)
		{
			num4 = 10;
		}
		int num7 = 357;
		if (Main.player[num6].ZoneGraveyard)
		{
			num7 = 606;
		}
		TileLoader.DropCritterChance(i, j, tileCache.type, ref num, ref num3, ref num4);
		if (num > 0 && NPC.CountNPCS(num7) < 5 && genRand.Next(num) == 0)
		{
			int type = num7;
			if (num7 == 357 && Player.GetClosestRollLuck(i, j, NPC.goldCritterChance) == 0f)
			{
				type = 448;
			}
			int num8 = NPC.NewNPC(GetNPCSource_TileBreak(i, j), i * 16 + 10, j * 16, type);
			Main.npc[num8].TargetClosest();
			Main.npc[num8].velocity.Y = (float)genRand.Next(-50, -21) * 0.1f;
			Main.npc[num8].velocity.X = (float)genRand.Next(0, 26) * 0.1f * (float)(-Main.npc[num8].direction);
			Main.npc[num8].direction *= -1;
			Main.npc[num8].netUpdate = true;
		}
		if (num3 > 0 && NPC.CountNPCS(377) < 5 && genRand.Next(num3) == 0)
		{
			int type2 = 377;
			if (Player.GetClosestRollLuck(i, j, NPC.goldCritterChance) == 0f)
			{
				type2 = 446;
			}
			int num9 = NPC.NewNPC(GetNPCSource_TileBreak(i, j), i * 16 + 10, j * 16, type2);
			Main.npc[num9].TargetClosest();
			Main.npc[num9].velocity.Y = (float)genRand.Next(-50, -21) * 0.1f;
			Main.npc[num9].velocity.X = (float)genRand.Next(0, 26) * 0.1f * (float)(-Main.npc[num9].direction);
			Main.npc[num9].direction *= -1;
			Main.npc[num9].netUpdate = true;
		}
		if (num4 > 0 && NPC.CountNPCS(485) + NPC.CountNPCS(486) + NPC.CountNPCS(487) < 8 && genRand.Next(num4) == 0)
		{
			int type3 = 485;
			if (genRand.Next(4) == 0)
			{
				type3 = 486;
			}
			if (genRand.Next(12) == 0)
			{
				type3 = 487;
			}
			int num10 = NPC.NewNPC(GetNPCSource_TileBreak(i, j), i * 16 + 10, j * 16, type3);
			Main.npc[num10].TargetClosest();
			Main.npc[num10].velocity.Y = (float)genRand.Next(-50, -21) * 0.1f;
			Main.npc[num10].velocity.X = (float)genRand.Next(0, 26) * 0.1f * (float)(-Main.npc[num10].direction);
			Main.npc[num10].direction *= -1;
			Main.npc[num10].netUpdate = true;
		}
		if (num5 > 0 && NPC.CountNPCS(654) + NPC.CountNPCS(653) < 8 && genRand.Next(num5) == 0)
		{
			int type4 = 653;
			if (genRand.Next(2) == 0)
			{
				type4 = 654;
			}
			int num2 = NPC.NewNPC(GetNPCSource_TileBreak(i, j), i * 16 + 10, j * 16, type4);
			Main.npc[num2].TargetClosest();
			Main.npc[num2].velocity.Y = (float)genRand.Next(-50, -21) * 0.1f;
			Main.npc[num2].velocity.X = (float)genRand.Next(0, 26) * 0.1f * (float)(-Main.npc[num2].direction);
			Main.npc[num2].direction *= -1;
			Main.npc[num2].netUpdate = true;
		}
	}

	public static void KillTile_PlaySounds(int i, int j, bool fail, Tile tileCache)
	{
		if (gen)
		{
			return;
		}
		int type = tileCache.type;
		if (!TileLoader.KillSound(i, j, type, fail))
		{
			return;
		}
		if (type == 127 || type == 623)
		{
			SoundEngine.PlaySound(SoundID.Item27, i * 16, j * 16);
		}
		else if (type == 147 || type == 224)
		{
			if (genRand.Next(2) == 0)
			{
				SoundEngine.PlaySound(SoundID.Item48, i * 16, j * 16);
			}
			else
			{
				SoundEngine.PlaySound(SoundID.Item49, i * 16, j * 16);
			}
		}
		else if (type == 161 || type == 163 || type == 164 || type == 200 || type == 541)
		{
			SoundEngine.PlaySound(SoundID.Item50, i * 16, j * 16);
		}
		else if (type == 518 || type == 519 || type == 528 || type == 529 || type == 549 || type == 637 || type == 638 || type == 636)
		{
			SoundEngine.PlaySound(6, i * 16, j * 16);
		}
		else if (type == 530 && tileCache.frameX < 270)
		{
			SoundEngine.PlaySound(6, i * 16, j * 16);
		}
		else
		{
			switch (type)
			{
			case 3:
			case 110:
				SoundEngine.PlaySound(6, i * 16, j * 16);
				break;
			case 254:
				SoundEngine.PlaySound(6, i * 16, j * 16);
				break;
			case 24:
				SoundEngine.PlaySound(6, i * 16, j * 16);
				break;
			default:
				if (Main.tileAlch[type] || type == 384 || type == 227 || type == 32 || type == 51 || type == 52 || type == 61 || type == 62 || type == 69 || type == 655 || type == 71 || type == 73 || type == 74 || type == 113 || type == 115 || type == 184 || type == 192 || type == 205 || type == 233 || type == 352 || type == 382 || type == 624 || type == 656)
				{
					SoundEngine.PlaySound(6, i * 16, j * 16);
				}
				else if (type == 485)
				{
					SoundEngine.PlaySound(4, i * 16, j * 16, 11);
				}
				else if (type == 201)
				{
					SoundEngine.PlaySound(6, i * 16, j * 16);
				}
				else if (type == 481 || type == 482 || type == 483)
				{
					SoundEngine.PlaySound(SoundID.Item127, i * 16, j * 16);
				}
				else if (type == 1 || type == 6 || type == 7 || type == 8 || type == 9 || type == 22 || type == 140 || type == 25 || type == 37 || type == 38 || type == 39 || type == 41 || type == 43 || type == 44 || type == 45 || type == 46 || type == 47 || type == 48 || type == 56 || type == 58 || type == 63 || type == 64 || type == 65 || type == 66 || type == 67 || type == 68 || type == 75 || type == 76 || type == 107 || type == 108 || type == 111 || type == 117 || type == 118 || type == 119 || type == 120 || type == 121 || type == 122 || type == 150 || type == 151 || type == 152 || type == 153 || type == 154 || type == 155 || type == 156 || type == 160 || type == 161 || type == 166 || type == 167 || type == 168 || type == 169 || type == 175 || type == 176 || type == 177 || type == 203 || type == 202 || type == 204 || type == 206 || type == 211 || type == 221 || type == 222 || type == 223 || type == 226 || type == 248 || type == 249 || type == 250 || type == 272 || type == 273 || type == 274 || type == 478 || type == 284 || type == 325 || type == 346 || type == 347 || type == 348 || type == 350 || type == 367 || type == 357 || type == 368 || type == 369 || type == 370 || type == 407 || type == 472 || type == 473 || type == 500 || type == 501 || type == 502 || type == 503 || type == 546 || type == 557 || type == 566 || type == 618 || type == 408 || type == 409 || type == 669 || type == 670 || type == 671 || type == 672 || type == 673 || type == 674 || type == 675 || type == 676 || type == 677 || type == 678 || type == 679 || type == 680 || type == 681 || type == 682 || type == 683 || type == 684 || type == 685 || type == 686 || type == 687 || type == 689 || type == 688 || type == 690 || type == 691 || type == 692)
				{
					SoundEngine.PlaySound(21, i * 16, j * 16);
				}
				else if (type == 666)
				{
					SoundEngine.PlaySound(SoundID.Item177, i * 16, j * 16);
				}
				else if (type == 231 || type == 195 || type == 474)
				{
					SoundEngine.PlaySound(4, i * 16, j * 16);
					if (type == 231)
					{
						SoundEngine.PlaySound(SoundID.Item173, i * 16, j * 16);
					}
				}
				else if (type == 26 && tileCache.frameX >= 54)
				{
					SoundEngine.PlaySound(4, i * 16, j * 16);
				}
				else if (type != 314)
				{
					if ((uint)(type - 330) <= 3u)
					{
						SoundEngine.PlaySound(18, i * 16, j * 16);
					}
					else if ((type == 162 || type == 385 || type == 129 || (type == 165 && tileCache.frameX < 54)) && !fail)
					{
						SoundEngine.PlaySound(SoundID.Item27, i * 16, j * 16);
					}
					else if (type != 138)
					{
						SoundEngine.PlaySound(0, i * 16, j * 16);
					}
				}
				else
				{
					SoundEngine.PlaySound(SoundID.Item52, i * 16, j * 16);
				}
				break;
			}
		}
		if (!fail)
		{
			if (tileCache.type == 13)
			{
				SoundEngine.PlaySound(13, i * 16, j * 16);
			}
			else if (tileCache.type == 54)
			{
				SoundEngine.PlaySound(13, i * 16, j * 16);
			}
			else if (tileCache.type == 326)
			{
				SoundEngine.PlaySound(13, i * 16, j * 16);
			}
			else if (tileCache.type == 327)
			{
				SoundEngine.PlaySound(13, i * 16, j * 16);
			}
			else if (tileCache.type == 458)
			{
				SoundEngine.PlaySound(13, i * 16, j * 16);
			}
			else if (tileCache.type == 459)
			{
				SoundEngine.PlaySound(13, i * 16, j * 16);
			}
			else if (tileCache.type == 345)
			{
				SoundEngine.PlaySound(13, i * 16, j * 16);
			}
			else if (tileCache.type == 328)
			{
				SoundEngine.PlaySound(13, i * 16, j * 16);
			}
			else if (tileCache.type == 329)
			{
				SoundEngine.PlaySound(13, i * 16, j * 16);
			}
			else if (tileCache.type == 507)
			{
				SoundEngine.PlaySound(13, i * 16, j * 16);
			}
			else if (tileCache.type == 508)
			{
				SoundEngine.PlaySound(13, i * 16, j * 16);
			}
		}
	}

	public static Rectangle? GetTileVisualHitbox(int x, int y)
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		Tile tile = Main.tile[x, y];
		if (tile == null || !tile.nactive())
		{
			return null;
		}
		Rectangle value = default(Rectangle);
		((Rectangle)(ref value))._002Ector(x * 16, y * 16, 16, 16);
		if (tile.type == 323)
		{
			value.X += tile.frameY;
		}
		if (tile.halfBrick())
		{
			value.Y += 8;
			value.Height = 8;
		}
		return value;
	}

	public static int KillTile_GetTileDustAmount(bool fail, Tile tileCache, int x, int y)
	{
		int result = KillTile_GetTileDustAmount_Vanilla(fail, tileCache);
		TileLoader.NumDust(x, y, tileCache.type, fail, ref result);
		return result;
	}

	private static int KillTile_GetTileDustAmount_Vanilla(bool fail, Tile tileCache)
	{
		switch (tileCache.type)
		{
		default:
			if (!fail)
			{
				return 10;
			}
			return 3;
		case 654:
			return 0;
		case 630:
		case 631:
			return 0;
		case 231:
			if (!fail)
			{
				return 6;
			}
			return 3;
		case 481:
		case 482:
		case 483:
			return 3;
		case 541:
			return 1;
		case 549:
			return 2;
		case 125:
		case 138:
		case 172:
		case 287:
		case 300:
		case 301:
		case 302:
		case 303:
		case 304:
		case 305:
		case 306:
		case 307:
		case 308:
		case 354:
		case 355:
		case 373:
		case 374:
		case 375:
		case 376:
		case 461:
		case 484:
		case 499:
		case 564:
		case 565:
		case 593:
		case 594:
		case 617:
		case 664:
		case 665:
			return 0;
		case 534:
		case 536:
		case 539:
		case 625:
		case 627:
			if (!fail)
			{
				return 5;
			}
			return 3;
		case 184:
			if (tileCache.frameX / 22 >= 5)
			{
				return 5;
			}
			if (!fail)
			{
				return 10;
			}
			return 3;
		}
	}

	public static int KillTile_MakeTileDust(int i, int j, Tile tileCache)
	{
		//IL_400c: Unknown result type (might be due to invalid IL or missing references)
		//IL_4030: Unknown result type (might be due to invalid IL or missing references)
		//IL_40a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_40ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_40c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_4196: Unknown result type (might be due to invalid IL or missing references)
		//IL_41bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_40f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_4108: Unknown result type (might be due to invalid IL or missing references)
		//IL_410e: Unknown result type (might be due to invalid IL or missing references)
		//IL_4145: Unknown result type (might be due to invalid IL or missing references)
		//IL_414f: Unknown result type (might be due to invalid IL or missing references)
		//IL_4154: Unknown result type (might be due to invalid IL or missing references)
		//IL_4204: Unknown result type (might be due to invalid IL or missing references)
		//IL_421b: Unknown result type (might be due to invalid IL or missing references)
		//IL_4221: Unknown result type (might be due to invalid IL or missing references)
		//IL_424a: Unknown result type (might be due to invalid IL or missing references)
		//IL_4277: Unknown result type (might be due to invalid IL or missing references)
		//IL_427d: Unknown result type (might be due to invalid IL or missing references)
		//IL_42ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_4304: Unknown result type (might be due to invalid IL or missing references)
		//IL_430a: Unknown result type (might be due to invalid IL or missing references)
		//IL_4362: Unknown result type (might be due to invalid IL or missing references)
		//IL_4382: Unknown result type (might be due to invalid IL or missing references)
		//IL_43ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_43cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_450a: Unknown result type (might be due to invalid IL or missing references)
		//IL_4521: Unknown result type (might be due to invalid IL or missing references)
		//IL_4527: Unknown result type (might be due to invalid IL or missing references)
		//IL_44d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_44ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_44f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_4459: Unknown result type (might be due to invalid IL or missing references)
		//IL_4492: Unknown result type (might be due to invalid IL or missing references)
		//IL_4402: Unknown result type (might be due to invalid IL or missing references)
		//IL_441a: Unknown result type (might be due to invalid IL or missing references)
		//IL_4420: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		if (tileCache.type == 216)
		{
			num = -1;
		}
		if (tileCache.type == 324)
		{
			num = ((tileCache.frameY != 0) ? (281 + tileCache.frameX / 18) : 280);
		}
		if (tileCache.type == 216)
		{
			num = -1;
		}
		if (tileCache.type == 335)
		{
			num = -1;
		}
		if (tileCache.type == 338)
		{
			num = -1;
		}
		if (tileCache.type == 0)
		{
			num = 0;
		}
		if (tileCache.type == 192)
		{
			num = 3;
		}
		if (tileCache.type == 208)
		{
			num = 126;
		}
		else if (tileCache.type == 408 || tileCache.type == 409)
		{
			num = 265;
		}
		else if (tileCache.type == 669)
		{
			num = 314;
		}
		else if (tileCache.type == 670)
		{
			num = 315;
		}
		else if (tileCache.type == 671)
		{
			num = 316;
		}
		else if (tileCache.type == 672)
		{
			num = 317;
		}
		else if (tileCache.type == 673)
		{
			num = 318;
		}
		else if (tileCache.type == 674)
		{
			num = 319;
		}
		else if (tileCache.type == 675)
		{
			num = 320;
		}
		else if (tileCache.type == 676)
		{
			num = 321;
		}
		if (tileCache.type == 16)
		{
			num = 1;
			if (tileCache.frameX >= 36)
			{
				num = 82;
			}
		}
		else if (tileCache.type == 415 || tileCache.type == 500)
		{
			num = 6;
		}
		else if (tileCache.type == 416 || tileCache.type == 501)
		{
			num = 61;
		}
		else if (tileCache.type == 417 || tileCache.type == 502)
		{
			num = 242;
		}
		else if (tileCache.type == 418 || tileCache.type == 503)
		{
			num = 135;
		}
		else if (tileCache.type == 474)
		{
			num = 18;
		}
		if (tileCache.type == 1 || tileCache.type == 17 || tileCache.type == 38 || tileCache.type == 39 || tileCache.type == 41 || tileCache.type == 43 || tileCache.type == 44 || tileCache.type == 481 || tileCache.type == 482 || tileCache.type == 483 || tileCache.type == 48 || Main.tileStone[tileCache.type] || tileCache.type == 85 || tileCache.type == 90 || tileCache.type == 92 || tileCache.type == 96 || tileCache.type == 97 || tileCache.type == 99 || tileCache.type == 117 || tileCache.type == 130 || tileCache.type == 131 || tileCache.type == 132 || tileCache.type == 135 || tileCache.type == 135 || tileCache.type == 142 || tileCache.type == 143 || tileCache.type == 144 || tileCache.type == 210 || tileCache.type == 207 || tileCache.type == 235 || tileCache.type == 247 || tileCache.type == 272 || tileCache.type == 273 || tileCache.type == 283 || tileCache.type == 410 || tileCache.type == 480 || tileCache.type == 509 || tileCache.type == 618 || tileCache.type == 657 || tileCache.type == 658 || tileCache.type == 677 || tileCache.type == 678 || tileCache.type == 679)
		{
			num = 1;
		}
		if (tileCache.type == 379)
		{
			num = 257;
		}
		if (tileCache.type == 311)
		{
			num = 207;
		}
		if (tileCache.type == 312)
		{
			num = 208;
		}
		if (tileCache.type == 313)
		{
			num = 209;
		}
		if (tileCache.type == 104)
		{
			num = -1;
		}
		if (tileCache.type == 95 || tileCache.type == 98 || tileCache.type == 100 || tileCache.type == 174 || tileCache.type == 173)
		{
			num = 6;
		}
		if (tileCache.type == 30 || tileCache.type == 86 || tileCache.type == 94 || tileCache.type == 106 || tileCache.type == 114 || tileCache.type == 124 || tileCache.type == 128 || tileCache.type == 269)
		{
			num = 7;
		}
		if (tileCache.type == 372)
		{
			num = 242;
		}
		if (tileCache.type == 646)
		{
			num = 29;
		}
		if (tileCache.type == 49)
		{
			num = 29;
		}
		if (tileCache.type == 371)
		{
			num = 243;
		}
		if (tileCache.type == 334)
		{
			num = 7;
		}
		switch (tileCache.type)
		{
		case 10:
		case 11:
		case 87:
		case 89:
		case 93:
		case 139:
		case 209:
		case 319:
		case 320:
		case 386:
		case 387:
		case 390:
		case 405:
		case 406:
		case 411:
		case 412:
		case 419:
		case 420:
		case 421:
		case 422:
		case 423:
		case 424:
		case 425:
		case 428:
		case 429:
		case 441:
		case 442:
		case 445:
		case 446:
		case 447:
		case 448:
		case 449:
		case 450:
		case 451:
		case 452:
		case 453:
		case 455:
		case 456:
		case 457:
		case 462:
		case 463:
		case 464:
		case 465:
		case 466:
		case 468:
		case 476:
		case 486:
		case 487:
		case 489:
		case 490:
		case 491:
		case 493:
		case 494:
		case 497:
		case 510:
		case 511:
		case 520:
		case 521:
		case 522:
		case 523:
		case 524:
		case 525:
		case 526:
		case 527:
		case 531:
		case 545:
		case 547:
		case 548:
		case 560:
		case 564:
		case 565:
		case 567:
		case 572:
		case 579:
		case 591:
		case 592:
		case 593:
		case 594:
		case 613:
		case 614:
		case 621:
		case 622:
		case 623:
		case 624:
		case 630:
		case 631:
		case 656:
			num = -1;
			break;
		case 668:
			num = 0;
			break;
		case 407:
			num = 10;
			break;
		case 454:
			num = 139;
			break;
		case 41:
		case 481:
		case 677:
			num = 275;
			break;
		case 43:
		case 482:
		case 678:
			num = 276;
			break;
		case 44:
		case 483:
		case 679:
			num = 277;
			break;
		case 473:
			num = 82;
			break;
		case 472:
		case 546:
		case 557:
			num = 8;
			break;
		case 498:
			num = 30;
			break;
		case 517:
		case 687:
			num = 258;
			break;
		case 535:
		case 689:
			num = 299;
			break;
		case 537:
		case 690:
			num = 300;
			break;
		case 540:
		case 688:
			num = 301;
			break;
		case 626:
		case 691:
			num = 305;
			break;
		case 184:
		{
			int num10 = tileCache.frameX / 22;
			num = num10 switch
			{
				5 => 258, 
				6 => 299, 
				7 => 300, 
				8 => 301, 
				9 => 305, 
				10 => 267, 
				_ => 93 + num10, 
			};
			break;
		}
		case 515:
			num = 96;
			break;
		case 516:
			num = 97;
			break;
		case 514:
			num = 95;
			break;
		case 513:
			num = 94;
			break;
		case 512:
			num = 93;
			break;
		case 541:
			num = 226;
			break;
		case 590:
			num = 1;
			break;
		case 583:
			num = ((genRand.Next(10) != 0) ? 1 : 87);
			break;
		case 584:
			num = ((genRand.Next(10) != 0) ? 1 : 86);
			break;
		case 585:
			num = ((genRand.Next(10) != 0) ? 1 : 88);
			break;
		case 586:
			num = ((genRand.Next(10) != 0) ? 1 : 89);
			break;
		case 587:
			num = ((genRand.Next(10) != 0) ? 1 : 90);
			break;
		case 588:
			num = ((genRand.Next(10) != 0) ? 1 : 91);
			break;
		case 589:
			num = ((genRand.Next(10) != 0) ? 1 : 138);
			break;
		case 595:
			num = 78;
			break;
		case 596:
			num = 78;
			break;
		case 615:
			num = 78;
			break;
		case 616:
			num = 78;
			break;
		case 633:
			num = ((genRand.Next(6) != 0) ? 237 : 36);
			break;
		case 637:
		case 638:
			num = 237;
			break;
		case 634:
			num = ((genRand.Next(10) != 0) ? 36 : 31);
			if (genRand.Next(12) == 0)
			{
				num = 6;
			}
			break;
		}
		if (Main.tileMoss[tileCache.type])
		{
			num = ((tileCache.type == 381) ? 258 : ((tileCache.type == 534) ? 299 : ((tileCache.type == 536) ? 300 : ((tileCache.type == 539) ? 301 : ((tileCache.type == 625) ? 305 : ((tileCache.type != 627) ? (tileCache.type - 179 + 93) : 267))))));
		}
		if (tileCache.type == 240)
		{
			int num17 = tileCache.frameX / 54;
			if (tileCache.frameY >= 54)
			{
				num17 += 36 * (tileCache.frameY / 54);
			}
			num = 7;
			if (num17 == 16 || num17 == 17)
			{
				num = 26;
			}
			if (num17 >= 46 && num17 <= 49)
			{
				num = -1;
			}
		}
		if (tileCache.type == 241)
		{
			num = 1;
		}
		if (tileCache.type == 242)
		{
			num = -1;
		}
		if (tileCache.type == 529)
		{
			num = Main.tile[i, j + 1].type switch
			{
				116 => num = 47, 
				234 => num = 125, 
				112 => num = 17, 
				_ => (i >= beachDistance && i <= Main.maxTilesX - beachDistance) ? 289 : 290, 
			};
		}
		if (tileCache.type == 356)
		{
			num = -1;
		}
		if (tileCache.type == 663)
		{
			num = -1;
		}
		if (tileCache.type == 351)
		{
			num = -1;
		}
		if (tileCache.type == 246)
		{
			num = -1;
		}
		if (tileCache.type == 36)
		{
			num = -1;
		}
		if (tileCache.type == 365)
		{
			num = 239;
		}
		if (tileCache.type == 366)
		{
			num = 30;
		}
		if (tileCache.type == 504)
		{
			num = -1;
		}
		if (tileCache.type == 357 || tileCache.type == 367 || tileCache.type == 561)
		{
			num = 236;
		}
		if (tileCache.type == 368 || tileCache.type == 369 || tileCache.type == 576)
		{
			num = 240;
		}
		if (tileCache.type == 170)
		{
			num = 196;
		}
		if (tileCache.type == 315)
		{
			num = 225;
		}
		if (tileCache.type == 641)
		{
			num = ((genRand.Next(2) != 0) ? 161 : 243);
		}
		if (tileCache.type == 659)
		{
			num = 308;
		}
		if (tileCache.type == 667)
		{
			num = 308;
		}
		if (tileCache.type == 346)
		{
			num = 128;
		}
		if (tileCache.type == 347)
		{
			num = 117;
		}
		if (tileCache.type == 348)
		{
			num = 42;
		}
		if (tileCache.type == 350)
		{
			num = 226;
		}
		if (tileCache.type == 370)
		{
			num = ((genRand.Next(2) != 0) ? 23 : 6);
		}
		if (tileCache.type == 171)
		{
			num = ((genRand.Next(2) != 0) ? (-1) : 196);
		}
		if (tileCache.type == 326)
		{
			num = 13;
		}
		if (tileCache.type == 327)
		{
			num = 13;
		}
		if (tileCache.type == 345)
		{
			num = 13;
		}
		if (tileCache.type == 458)
		{
			num = 13;
		}
		if (tileCache.type == 459)
		{
			num = 13;
		}
		if (tileCache.type == 336)
		{
			num = 6;
		}
		if (tileCache.type == 340)
		{
			num = 75;
		}
		if (tileCache.type == 341)
		{
			num = 65;
		}
		if (tileCache.type == 342)
		{
			num = 135;
		}
		if (tileCache.type == 343)
		{
			num = 169;
		}
		if (tileCache.type == 344)
		{
			num = 156;
		}
		if (tileCache.type == 328)
		{
			num = 13;
		}
		if (tileCache.type == 329)
		{
			num = 13;
		}
		if (tileCache.type == 507)
		{
			num = 13;
		}
		if (tileCache.type == 508)
		{
			num = 13;
		}
		if (tileCache.type == 562)
		{
			num = -1;
		}
		if (tileCache.type == 571)
		{
			num = 40;
		}
		if (tileCache.type == 563)
		{
			num = -1;
		}
		if (tileCache.type == 330)
		{
			num = 9;
		}
		if (tileCache.type == 331)
		{
			num = 11;
		}
		if (tileCache.type == 332)
		{
			num = 19;
		}
		if (tileCache.type == 333)
		{
			num = 11;
		}
		if (tileCache.type == 101)
		{
			num = -1;
		}
		if (tileCache.type == 19)
		{
			num = (tileCache.frameY / 18) switch
			{
				0 => 7, 
				1 => 77, 
				2 => 78, 
				3 => 79, 
				4 => 26, 
				5 => 126, 
				6 => 275, 
				7 => 277, 
				8 => 276, 
				9 => 1, 
				10 => 214, 
				11 => 214, 
				12 => 214, 
				13 => 109, 
				14 => 13, 
				15 => 189, 
				16 => 191, 
				17 => 215, 
				18 => 26, 
				19 => 214, 
				20 => 4, 
				21 => 10, 
				22 => 32, 
				23 => 78, 
				24 => 147, 
				25 => 40, 
				26 => 226, 
				27 => 23, 
				28 => 240, 
				29 => 236, 
				30 => 68 + Main.rand.Next(3), 
				31 => 10, 
				32 => 78, 
				33 => 148, 
				34 => 5, 
				35 => 80, 
				37 => 18, 
				38 => 6, 
				39 => 61, 
				40 => 242, 
				41 => 135, 
				42 => 287, 
				44 => 273, 
				45 => 243, 
				46 => 243, 
				47 => 36, 
				48 => 226, 
				_ => 1, 
			};
		}
		if (tileCache.type == 79)
		{
			int num18 = tileCache.frameY / 36;
			num = ((num18 == 0) ? 7 : ((num18 == 1) ? 77 : ((num18 == 2) ? 78 : ((num18 == 3) ? 79 : ((num18 == 4) ? 126 : ((num18 == 8) ? 109 : ((num18 < 9) ? 1 : (-1))))))));
		}
		if (tileCache.type == 18)
		{
			switch (tileCache.frameX / 36)
			{
			case 0:
				num = 7;
				break;
			case 1:
				num = 77;
				break;
			case 2:
				num = 78;
				break;
			case 3:
				num = 79;
				break;
			case 4:
				num = 26;
				break;
			case 5:
				num = 40;
				break;
			case 6:
				num = 5;
				break;
			case 7:
				num = 26;
				break;
			case 8:
				num = 4;
				break;
			case 9:
				num = 126;
				break;
			case 10:
				num = 148;
				break;
			case 11:
			case 12:
			case 13:
				num = 1;
				break;
			case 14:
				num = 109;
				break;
			case 15:
				num = 126;
				break;
			default:
				num = -1;
				break;
			}
		}
		if (tileCache.type == 14 || tileCache.type == 87 || tileCache.type == 88 || tileCache.type == 469)
		{
			num = -1;
		}
		if (tileCache.type >= 255 && tileCache.type <= 261)
		{
			int num19 = tileCache.type - 255;
			num = 86 + num19;
			if (num19 == 6)
			{
				num = 138;
			}
		}
		if (tileCache.type >= 262 && tileCache.type <= 268)
		{
			int num20 = tileCache.type - 262;
			num = 86 + num20;
			if (num20 == 6)
			{
				num = 138;
			}
		}
		if (tileCache.type == 178)
		{
			int num21 = tileCache.frameX / 18;
			num = 86 + num21;
			if (num21 == 6)
			{
				num = 138;
			}
		}
		if (tileCache.type == 440)
		{
			num = (tileCache.frameX / 54) switch
			{
				0 => 90, 
				1 => 88, 
				2 => 89, 
				3 => 87, 
				4 => 86, 
				5 => 91, 
				6 => 138, 
				_ => -1, 
			};
			if (tileCache.frameY < 54)
			{
				num = -1;
			}
		}
		switch (tileCache.type)
		{
		case 426:
		case 427:
			num = 90;
			break;
		case 430:
		case 435:
			num = 89;
			break;
		case 431:
		case 436:
			num = 88;
			break;
		case 432:
		case 437:
			num = 87;
			break;
		case 433:
		case 438:
			num = 86;
			break;
		case 434:
		case 439:
			num = 91;
			break;
		case 496:
			num = 109;
			break;
		case 549:
			num = 3;
			break;
		case 552:
			num = 32;
			break;
		}
		if (tileCache.type == 186)
		{
			num = ((tileCache.frameX <= 360) ? 26 : ((tileCache.frameX <= 846) ? 1 : ((tileCache.frameX <= 954) ? 9 : ((tileCache.frameX <= 1062) ? 11 : ((tileCache.frameX <= 1170) ? 10 : ((tileCache.frameX > 1332) ? ((tileCache.frameX > 1386) ? 80 : 10) : 0))))));
		}
		if (tileCache.type == 187)
		{
			if (tileCache.frameX <= 144)
			{
				num = 1;
			}
			else if (tileCache.frameX <= 306)
			{
				num = 38;
			}
			else if (tileCache.frameX <= 468)
			{
				num = 36;
			}
			else if (tileCache.frameX <= 738)
			{
				num = 30;
			}
			else if (tileCache.frameX <= 970)
			{
				num = 1;
			}
			else if (tileCache.frameX <= 1132)
			{
				num = 148;
			}
			else if (tileCache.frameX <= 1132)
			{
				num = 155;
			}
			else if (tileCache.frameX <= 1348)
			{
				num = 1;
			}
			else if (tileCache.frameX <= 1564)
			{
				num = 0;
			}
			else if (tileCache.frameX <= 1890)
			{
				num = 250;
			}
			else if (tileCache.frameX <= 2196)
			{
				num = 240;
			}
			else if (tileCache.frameX <= 2520)
			{
				num = 236;
			}
		}
		if (tileCache.type == 647)
		{
			int num22 = tileCache.frameX / 54;
			if (num22 < 7)
			{
				num = 26;
			}
			else if (num22 < 16)
			{
				num = 1;
			}
			else if (num22 < 18)
			{
				num = 9;
			}
			else if (num22 < 20)
			{
				num = 11;
			}
			else if (num22 < 22)
			{
				num = 10;
			}
			else if (num22 < 26)
			{
				num = 7;
			}
			else if (num22 < 32)
			{
				num = 80;
			}
			else if (num22 < 35)
			{
				num = 80;
			}
		}
		if (tileCache.type == 648)
		{
			int num23 = tileCache.frameX / 54;
			num23 += tileCache.frameY / 36 * 35;
			if (num23 < 3)
			{
				num = 1;
			}
			else if (num23 < 6)
			{
				num = 38;
			}
			else if (num23 < 9)
			{
				num = 36;
			}
			else if (num23 < 14)
			{
				num = 30;
			}
			else if (num23 < 17)
			{
				num = 1;
			}
			else if (num23 < 18)
			{
				num = 1;
			}
			else if (num23 < 21)
			{
				num = 148;
			}
			else if (num23 < 29)
			{
				num = 155;
			}
			else if (num23 < 35)
			{
				num = 287;
			}
			else if (num23 < 41)
			{
				num = 240;
			}
			else if (num23 < 47)
			{
				num = 236;
			}
			else if (num23 < 50)
			{
				num = 0;
			}
			else if (num23 < 52)
			{
				num = 2;
			}
			else if (num23 < 55)
			{
				num = 26;
			}
		}
		if (tileCache.type == 105)
		{
			num = 1;
			if (tileCache.frameX >= 1548 && tileCache.frameX <= 1654 && tileCache.frameY < 54)
			{
				num = 148;
			}
		}
		if (tileCache.type == 349)
		{
			num = 1;
		}
		if (tileCache.type == 337 || tileCache.type == 506)
		{
			num = 1;
		}
		if (tileCache.type == 239)
		{
			int num24 = tileCache.frameX / 18;
			if (num24 == 0)
			{
				num = 9;
			}
			if (num24 == 1)
			{
				num = 81;
			}
			if (num24 == 2)
			{
				num = 8;
			}
			if (num24 == 3)
			{
				num = 82;
			}
			if (num24 == 4)
			{
				num = 11;
			}
			if (num24 == 5)
			{
				num = 83;
			}
			if (num24 == 6)
			{
				num = 10;
			}
			if (num24 == 7)
			{
				num = 84;
			}
			if (num24 == 8)
			{
				num = 14;
			}
			if (num24 == 9)
			{
				num = 23;
			}
			if (num24 == 10)
			{
				num = 25;
			}
			if (num24 == 11)
			{
				num = 48;
			}
			if (num24 == 12)
			{
				num = 144;
			}
			if (num24 == 13)
			{
				num = 49;
			}
			if (num24 == 14)
			{
				num = 145;
			}
			if (num24 == 15)
			{
				num = 50;
			}
			if (num24 == 16)
			{
				num = 146;
			}
			if (num24 == 17)
			{
				num = 128;
			}
			if (num24 == 18)
			{
				num = 84;
			}
			if (num24 == 19)
			{
				num = 117;
			}
			if (num24 == 20)
			{
				num = 42;
			}
			if (num24 == 21)
			{
				num = -1;
			}
			if (num24 == 22)
			{
				num = 265;
			}
		}
		if (tileCache.type == 185)
		{
			if (tileCache.frameY == 18)
			{
				int num2 = tileCache.frameX / 36;
				if (num2 < 6)
				{
					num = 1;
				}
				else if (num2 < 16)
				{
					num = 26;
				}
				else if (num2 == 16)
				{
					num = 9;
				}
				else if (num2 == 17)
				{
					num = 11;
				}
				else if (num2 == 18)
				{
					num = 10;
				}
				else if (num2 == 19)
				{
					num = 86;
				}
				else if (num2 == 20)
				{
					num = 87;
				}
				else if (num2 == 21)
				{
					num = 88;
				}
				else if (num2 == 22)
				{
					num = 89;
				}
				else if (num2 == 23)
				{
					num = 90;
				}
				else if (num2 == 24)
				{
					num = 91;
				}
				else if (num2 < 31)
				{
					num = 80;
				}
				else if (num2 < 33)
				{
					num = 7;
				}
				else if (num2 < 34)
				{
					num = 8;
				}
				else if (num2 < 38)
				{
					num = 30;
				}
				else if (num2 < 41)
				{
					num = 1;
				}
				else if (num2 < 47)
				{
					num = 287;
				}
				else if (num2 < 53)
				{
					num = 240;
				}
				else if (num2 < 59)
				{
					num = 236;
				}
			}
			else
			{
				int num3 = tileCache.frameX / 18;
				if (num3 < 6)
				{
					num = 1;
				}
				else if (num3 < 12)
				{
					num = 0;
				}
				else if (num3 < 28)
				{
					num = 26;
				}
				else if (num3 < 33)
				{
					num = 1;
				}
				else if (num3 < 36)
				{
					num = 0;
				}
				else if (num3 < 48)
				{
					num = 80;
				}
				else if (num3 < 54)
				{
					num = 30;
				}
				else if (num3 < 60)
				{
					num = 287;
				}
				else if (num3 < 66)
				{
					num = 240;
				}
				else if (num3 < 72)
				{
					num = 236;
				}
				else if (num3 < 73)
				{
					num = 0;
				}
				else if (num3 < 77)
				{
					num = 32;
				}
			}
		}
		if (tileCache.type == 649)
		{
			int num4 = tileCache.frameX / 36 + tileCache.frameY / 18 * 53;
			if (num4 < 6)
			{
				num = 1;
			}
			else if (num4 < 16)
			{
				num = 26;
			}
			else if (num4 == 16)
			{
				num = 9;
			}
			else if (num4 == 17)
			{
				num = 11;
			}
			else if (num4 == 18)
			{
				num = 10;
			}
			else if (num4 == 19)
			{
				num = 86;
			}
			else if (num4 == 20)
			{
				num = 87;
			}
			else if (num4 == 21)
			{
				num = 88;
			}
			else if (num4 == 22)
			{
				num = 89;
			}
			else if (num4 == 23)
			{
				num = 90;
			}
			else if (num4 == 24)
			{
				num = 91;
			}
			else if (num4 < 31)
			{
				num = 80;
			}
			else if (num4 < 33)
			{
				num = 7;
			}
			else if (num4 < 34)
			{
				num = 8;
			}
			else if (num4 < 38)
			{
				num = 30;
			}
			else if (num4 < 41)
			{
				num = 1;
			}
			else if (num4 < 47)
			{
				num = 287;
			}
			else if (num4 < 53)
			{
				num = 240;
			}
			else if (num4 < 59)
			{
				num = 236;
			}
			else if (num4 < 62)
			{
				num = 0;
			}
			else if (num4 < 65)
			{
				num = 32;
			}
		}
		if (tileCache.type == 650)
		{
			int num5 = tileCache.frameX / 18;
			if (num5 < 6)
			{
				num = 1;
			}
			else if (num5 < 12)
			{
				num = 0;
			}
			else if (num5 < 28)
			{
				num = 26;
			}
			else if (num5 < 33)
			{
				num = 1;
			}
			else if (num5 < 36)
			{
				num = 0;
			}
			else if (num5 < 48)
			{
				num = 80;
			}
			else if (num5 < 54)
			{
				num = 30;
			}
			else if (num5 < 60)
			{
				num = 287;
			}
			else if (num5 < 66)
			{
				num = 240;
			}
			else if (num5 < 72)
			{
				num = 236;
			}
			else if (num5 < 73)
			{
				num = 0;
			}
			else if (num5 < 77)
			{
				num = 32;
			}
		}
		if (tileCache.type == 237)
		{
			num = 148;
		}
		if (tileCache.type == 157)
		{
			num = 77;
		}
		if (tileCache.type == 158 || tileCache.type == 232 || tileCache.type == 383 || tileCache.type == 575)
		{
			num = 78;
		}
		if (tileCache.type == 159)
		{
			num = 78;
		}
		if (tileCache.type == 15)
		{
			num = -1;
		}
		if (tileCache.type == 191)
		{
			num = 7;
		}
		if (tileCache.type == 5)
		{
			num = 7;
			if (i > 5 && i < Main.maxTilesX - 5)
			{
				int num6 = i;
				int k = j;
				if (tileCache.frameX == 66 && tileCache.frameY <= 45)
				{
					num6++;
				}
				if (tileCache.frameX == 88 && tileCache.frameY >= 66 && tileCache.frameY <= 110)
				{
					num6--;
				}
				if (tileCache.frameX == 22 && tileCache.frameY >= 132 && tileCache.frameY <= 176)
				{
					num6--;
				}
				if (tileCache.frameX == 44 && tileCache.frameY >= 132 && tileCache.frameY <= 176)
				{
					num6++;
				}
				if (tileCache.frameX == 44 && tileCache.frameY >= 132 && tileCache.frameY <= 176)
				{
					num6++;
				}
				if (tileCache.frameX == 44 && tileCache.frameY >= 198)
				{
					num6++;
				}
				if (tileCache.frameX == 66 && tileCache.frameY >= 198)
				{
					num6--;
				}
				for (; Main.tile[num6, k] != null && (!Main.tile[num6, k].active() || !Main.tileSolid[Main.tile[num6, k].type]); k++)
				{
				}
				if (Main.tile[num6, k] != null)
				{
					if (Main.tile[num6, k].active() && Main.tile[num6, k].type == 23)
					{
						num = 77;
					}
					if (Main.tile[num6, k].active() && Main.tile[num6, k].type == 661)
					{
						num = 77;
					}
					if (Main.tile[num6, k].active() && Main.tile[num6, k].type == 60)
					{
						num = 78;
					}
					if (Main.tile[num6, k].active() && Main.tile[num6, k].type == 70)
					{
						num = 26;
					}
					if (Main.tile[num6, k].active() && Main.tile[num6, k].type == 109)
					{
						num = 79;
					}
					if (Main.tile[num6, k].active() && Main.tile[num6, k].type == 199)
					{
						num = 121;
					}
					if (Main.tile[num6, k].active() && Main.tile[num6, k].type == 662)
					{
						num = 121;
					}
					if (Main.tile[num6, k].active() && Main.tile[num6, k].type == 147)
					{
						num = 122;
					}
					TileLoader.TreeDust(Main.tile[num6, k], ref num);
				}
			}
		}
		if (tileCache.type == 323)
		{
			num = 215;
			if (i > 5 && i < Main.maxTilesX - 5)
			{
				int l;
				for (l = j; Main.tile[i, l] != null && (!Main.tile[i, l].active() || !Main.tileSolid[Main.tile[i, l].type]); l++)
				{
				}
				if (Main.tile[i, l] != null)
				{
					if (Main.tile[i, l].active() && Main.tile[i, l].type == 234)
					{
						num = 121;
					}
					if (Main.tile[i, l].active() && Main.tile[i, l].type == 116)
					{
						num = 79;
					}
					if (Main.tile[i, l].active() && Main.tile[i, l].type == 112)
					{
						num = 77;
					}
					TileLoader.PalmTreeDust(Main.tile[i, l], ref num);
				}
			}
		}
		if (tileCache.type == 137)
		{
			switch (tileCache.frameY / 18)
			{
			default:
				num = 1;
				break;
			case 1:
			case 2:
			case 3:
			case 4:
				num = 148;
				break;
			case 5:
				num = 1;
				break;
			}
		}
		if (tileCache.type == 443)
		{
			num = 1;
		}
		if (tileCache.type == 444)
		{
			num = -1;
		}
		if (tileCache.type == 212)
		{
			num = -1;
		}
		if (tileCache.type == 213)
		{
			num = 129;
		}
		if (tileCache.type == 214)
		{
			num = 1;
		}
		if (tileCache.type == 215)
		{
			num = -6;
		}
		if (tileCache.type == 325)
		{
			num = 81;
		}
		if (tileCache.type == 251)
		{
			num = 189;
		}
		if (tileCache.type == 252)
		{
			num = 190;
		}
		if (tileCache.type == 253)
		{
			num = 191;
		}
		if (tileCache.type == 254)
		{
			if (tileCache.frameX < 72)
			{
				num = 3;
			}
			else if (tileCache.frameX < 108)
			{
				num = 3;
				if (genRand.Next(3) == 0)
				{
					num = 189;
				}
			}
			else if (tileCache.frameX < 144)
			{
				num = 3;
				if (genRand.Next(2) == 0)
				{
					num = 189;
				}
			}
			else
			{
				num = 3;
				if (genRand.Next(4) != 0)
				{
					num = 189;
				}
			}
		}
		if (tileCache.type == 467)
		{
			num = -1;
		}
		if (tileCache.type == 21)
		{
			num = ((tileCache.frameX >= 1008) ? (-1) : ((tileCache.frameX >= 612) ? 11 : ((tileCache.frameX >= 576) ? 148 : ((tileCache.frameX >= 540) ? 26 : ((tileCache.frameX >= 504) ? 126 : ((tileCache.frameX >= 468) ? 116 : ((tileCache.frameX >= 432) ? 7 : ((tileCache.frameX >= 396) ? 11 : ((tileCache.frameX >= 360) ? 10 : ((tileCache.frameX >= 324) ? 79 : ((tileCache.frameX >= 288) ? 78 : ((tileCache.frameX >= 252) ? 77 : ((tileCache.frameX >= 216) ? 1 : ((tileCache.frameX >= 180) ? 7 : ((tileCache.frameX >= 108) ? 37 : ((tileCache.frameX < 36) ? 7 : 10))))))))))))))));
		}
		if (tileCache.type == 382)
		{
			num = 3;
		}
		if (tileCache.type == 2 || tileCache.type == 477)
		{
			num = ((genRand.Next(2) != 0) ? 2 : 0);
		}
		if (tileCache.type == 127)
		{
			num = 67;
		}
		if (tileCache.type == 91)
		{
			num = -1;
		}
		if (tileCache.type == 198)
		{
			num = 109;
		}
		if (tileCache.type == 26)
		{
			num = ((tileCache.frameX < 54) ? 8 : 5);
		}
		if (tileCache.type == 34)
		{
			num = -1;
		}
		if (tileCache.type == 6)
		{
			num = 8;
		}
		if (tileCache.type == 7 || tileCache.type == 47 || tileCache.type == 284 || tileCache.type == 682)
		{
			num = 9;
		}
		if (tileCache.type == 8 || tileCache.type == 45 || tileCache.type == 102 || tileCache.type == 680)
		{
			num = 10;
		}
		if (tileCache.type == 9 || tileCache.type == 42 || tileCache.type == 46 || tileCache.type == 126 || tileCache.type == 136 || tileCache.type == 681)
		{
			num = 11;
		}
		if (tileCache.type == 166 || tileCache.type == 175)
		{
			num = 81;
		}
		if (tileCache.type == 167)
		{
			num = 82;
		}
		if (tileCache.type == 168 || tileCache.type == 176)
		{
			num = 83;
		}
		if (tileCache.type == 169 || tileCache.type == 177)
		{
			num = 84;
		}
		if (tileCache.type == 199 || tileCache.type == 662)
		{
			num = 117;
		}
		if (tileCache.type == 205)
		{
			num = 125;
		}
		if (tileCache.type == 201)
		{
			num = 125;
		}
		if (tileCache.type == 211)
		{
			num = 128;
		}
		if (tileCache.type == 227)
		{
			switch (tileCache.frameX / 34)
			{
			case 0:
			case 1:
				num = 26;
				break;
			case 3:
				num = 3;
				break;
			case 2:
			case 4:
			case 5:
			case 6:
				num = 40;
				break;
			case 7:
				num = 117;
				break;
			case 8:
				num = 17;
				break;
			case 9:
				num = 6;
				break;
			case 10:
				num = 3;
				break;
			case 11:
				num = 26;
				break;
			}
		}
		if (tileCache.type == 204 || tileCache.type == 478)
		{
			num = 117;
			if (genRand.Next(2) == 0)
			{
				num = 1;
			}
		}
		if (tileCache.type == 203)
		{
			num = 117;
		}
		if (tileCache.type == 243)
		{
			num = ((genRand.Next(2) != 0) ? 13 : 7);
		}
		if (tileCache.type == 219)
		{
			num = -1;
		}
		if (tileCache.type == 642)
		{
			num = -128;
		}
		if (tileCache.type == 244)
		{
			num = ((genRand.Next(2) == 0) ? 1 : 13);
		}
		if (tileCache.type == 597)
		{
			num = -1;
		}
		else if ((tileCache.type >= 358 && tileCache.type <= 364) || (tileCache.type >= 275 && tileCache.type <= 282) || tileCache.type == 285 || tileCache.type == 286 || (tileCache.type >= 288 && tileCache.type <= 297) || (tileCache.type >= 316 && tileCache.type <= 318) || tileCache.type == 298 || tileCache.type == 299 || tileCache.type == 309 || tileCache.type == 310 || tileCache.type == 339 || tileCache.type == 538 || tileCache.type == 413 || tileCache.type == 414 || tileCache.type == 505 || tileCache.type == 521 || tileCache.type == 522 || tileCache.type == 523 || tileCache.type == 524 || tileCache.type == 525 || tileCache.type == 526 || tileCache.type == 527 || tileCache.type == 532 || tileCache.type == 543 || tileCache.type == 544 || tileCache.type == 550 || tileCache.type == 551 || tileCache.type == 533 || tileCache.type == 553 || tileCache.type == 554 || tileCache.type == 555 || tileCache.type == 556 || tileCache.type == 558 || tileCache.type == 559 || tileCache.type == 542 || tileCache.type == 391 || tileCache.type == 394 || tileCache.type == 392 || tileCache.type == 393 || tileCache.type == 568 || tileCache.type == 569 || tileCache.type == 570 || tileCache.type == 582 || tileCache.type == 580 || tileCache.type == 598 || tileCache.type == 599 || tileCache.type == 600 || tileCache.type == 601 || tileCache.type == 602 || tileCache.type == 603 || tileCache.type == 604 || tileCache.type == 605 || tileCache.type == 606 || tileCache.type == 607 || tileCache.type == 608 || tileCache.type == 609 || tileCache.type == 610 || tileCache.type == 611 || tileCache.type == 612 || tileCache.type == 619 || tileCache.type == 620 || tileCache.type == 629 || tileCache.type == 632 || tileCache.type == 640 || tileCache.type == 643 || tileCache.type == 644 || tileCache.type == 645)
		{
			num = 13;
			if (genRand.Next(3) != 0)
			{
				num = -1;
			}
		}
		if (tileCache.type == 13)
		{
			num = ((tileCache.frameX < 90) ? 13 : (-1));
		}
		if (tileCache.type == 189)
		{
			num = 16;
		}
		if (tileCache.type == 460)
		{
			num = 16;
		}
		if (tileCache.type == 530)
		{
			num = Main.tile[i, j + 2 - tileCache.frameY / 18].type switch
			{
				116 => 47, 
				234 => 125, 
				112 => 17, 
				_ => (tileCache.frameX >= 270) ? 291 : 40, 
			};
		}
		if (tileCache.type == 518)
		{
			if (tileCache.frameY == 0)
			{
				num = 3;
			}
			else if (tileCache.frameY == 18)
			{
				num = 47;
			}
			else if (tileCache.frameY == 36)
			{
				num = 40;
			}
		}
		else if (tileCache.type == 519)
		{
			if (tileCache.frameY == 0)
			{
				num = 3;
			}
			else if (tileCache.frameY == 18)
			{
				num = 40;
			}
			else if (tileCache.frameY == 36)
			{
				num = 47;
			}
			else if (tileCache.frameY == 54)
			{
				num = 125;
			}
			else if (tileCache.frameY == 72)
			{
				num = 17;
			}
			else if (tileCache.frameY == 90)
			{
				num = 26;
			}
		}
		else if (tileCache.type == 636)
		{
			num = 17;
		}
		else if (tileCache.type == 528)
		{
			num = 26;
		}
		if (tileCache.type == 12)
		{
			num = 12;
		}
		if (tileCache.type == 639)
		{
			num = 48;
		}
		if (tileCache.type == 3 || tileCache.type == 73)
		{
			num = 3;
		}
		if (tileCache.type == 54)
		{
			num = 13;
		}
		if (tileCache.type == 22 || tileCache.type == 140)
		{
			num = 14;
		}
		if (tileCache.type == 78)
		{
			num = 22;
		}
		if (tileCache.type == 28 || tileCache.type == 653)
		{
			num = 22;
			if (tileCache.frameY >= 72 && tileCache.frameY <= 90)
			{
				num = 1;
			}
			if (tileCache.frameY >= 144 && tileCache.frameY <= 234)
			{
				num = 48;
			}
			if (tileCache.frameY >= 252 && tileCache.frameY <= 358)
			{
				num = 85;
			}
			if (tileCache.frameY >= 360 && tileCache.frameY <= 466)
			{
				num = 26;
			}
			if (tileCache.frameY >= 468 && tileCache.frameY <= 574)
			{
				num = 36;
			}
			if (tileCache.frameY >= 576 && tileCache.frameY <= 790)
			{
				num = 18;
			}
			if (tileCache.frameY >= 792 && tileCache.frameY <= 898)
			{
				num = 5;
			}
			if (tileCache.frameY >= 900 && tileCache.frameY <= 1006)
			{
				num = 0;
			}
			if (tileCache.frameY >= 1008 && tileCache.frameY <= 1114)
			{
				num = 148;
			}
			if (tileCache.frameY >= 1116 && tileCache.frameY <= 1222)
			{
				num = 241;
			}
			if (tileCache.frameY >= 1224 && tileCache.frameY <= 1330)
			{
				num = 287;
			}
		}
		if (tileCache.type == 163)
		{
			num = 118;
		}
		if (tileCache.type == 164)
		{
			num = 119;
		}
		if (tileCache.type == 200)
		{
			num = 120;
		}
		if (tileCache.type == 221 || tileCache.type == 248)
		{
			num = 144;
		}
		if (tileCache.type == 222 || tileCache.type == 249)
		{
			num = 145;
		}
		if (tileCache.type == 223 || tileCache.type == 250)
		{
			num = 146;
		}
		if (tileCache.type == 224)
		{
			num = 149;
		}
		if (tileCache.type == 225)
		{
			num = 147;
		}
		if (tileCache.type == 229)
		{
			num = 153;
		}
		if (tileCache.type == 231)
		{
			num = 153;
			if (genRand.Next(3) == 0)
			{
				num = 26;
			}
		}
		if (tileCache.type == 226)
		{
			num = 148;
		}
		if (tileCache.type == 103)
		{
			num = -1;
		}
		if (tileCache.type == 29)
		{
			num = 23;
		}
		if (tileCache.type == 40)
		{
			num = 28;
		}
		if (tileCache.type == 50)
		{
			num = 22;
		}
		if (tileCache.type == 51)
		{
			num = 30;
		}
		if (tileCache.type == 52 || tileCache.type == 353)
		{
			num = 3;
		}
		if (tileCache.type == 53 || tileCache.type == 81 || tileCache.type == 151 || tileCache.type == 202 || tileCache.type == 274 || tileCache.type == 495)
		{
			num = 32;
		}
		if (tileCache.type == 56 || tileCache.type == 152)
		{
			num = 37;
		}
		if (tileCache.type == 75 || tileCache.type == 683)
		{
			num = 109;
		}
		if (tileCache.type == 57 || tileCache.type == 119 || tileCache.type == 141 || tileCache.type == 234 || tileCache.type == 635 || tileCache.type == 654)
		{
			num = 36;
		}
		if (tileCache.type == 59 || tileCache.type == 120)
		{
			num = 38;
		}
		if (tileCache.type == 61 || tileCache.type == 62 || tileCache.type == 74 || tileCache.type == 80 || tileCache.type == 188 || tileCache.type == 233 || tileCache.type == 236 || tileCache.type == 384 || tileCache.type == 652 || tileCache.type == 651)
		{
			num = 40;
		}
		if (tileCache.type == 485)
		{
			num = 32;
		}
		if (tileCache.type == 238)
		{
			num = ((genRand.Next(3) != 0) ? 166 : 167);
		}
		if (tileCache.type == 69)
		{
			num = 7;
		}
		if (tileCache.type == 655)
		{
			num = 166;
		}
		if (tileCache.type == 71 || tileCache.type == 72 || tileCache.type == 190 || tileCache.type == 578)
		{
			num = 26;
		}
		if (tileCache.type == 70)
		{
			num = 17;
		}
		if (tileCache.type == 112)
		{
			num = 14;
		}
		if (tileCache.type == 123)
		{
			num = 53;
		}
		if (tileCache.type == 161)
		{
			num = 80;
		}
		if (tileCache.type == 206)
		{
			num = 80;
		}
		if (tileCache.type == 162)
		{
			num = 80;
		}
		if (tileCache.type == 165)
		{
			num = (tileCache.frameX / 54) switch
			{
				0 => 80, 
				1 => 1, 
				2 => 30, 
				3 => 147, 
				4 => 1, 
				5 => 14, 
				6 => 117, 
				7 => 250, 
				8 => 240, 
				9 => 236, 
				_ => 1, 
			};
		}
		if (tileCache.type == 666)
		{
			num = 322;
		}
		if (tileCache.type == 193)
		{
			num = 4;
		}
		if (tileCache.type == 194)
		{
			num = 26;
		}
		if (tileCache.type == 195)
		{
			num = 5;
		}
		if (tileCache.type == 196)
		{
			num = 108;
		}
		if (tileCache.type == 460)
		{
			num = 108;
		}
		if (tileCache.type == 197)
		{
			num = 4;
		}
		if (tileCache.type == 153)
		{
			num = 26;
		}
		if (tileCache.type == 154)
		{
			num = 32;
		}
		if (tileCache.type == 155)
		{
			num = 2;
		}
		if (tileCache.type == 156)
		{
			num = 1;
		}
		if (tileCache.type == 116 || tileCache.type == 118 || tileCache.type == 147 || tileCache.type == 148)
		{
			num = 51;
		}
		if (tileCache.type == 109 || tileCache.type == 492)
		{
			num = ((genRand.Next(2) != 0) ? 47 : 0);
		}
		if (tileCache.type == 110 || tileCache.type == 113 || tileCache.type == 115)
		{
			num = 47;
		}
		if (tileCache.type == 107 || tileCache.type == 121 || tileCache.type == 685)
		{
			num = 48;
		}
		if (tileCache.type == 108 || tileCache.type == 122 || tileCache.type == 146 || tileCache.type == 686)
		{
			num = 49;
		}
		if (tileCache.type == 111 || tileCache.type == 145 || tileCache.type == 150)
		{
			num = 50;
		}
		if (tileCache.type == 133)
		{
			num = 50;
			if (tileCache.frameX >= 54)
			{
				num = 146;
			}
		}
		if (tileCache.type == 134)
		{
			num = 49;
			if (tileCache.frameX >= 36)
			{
				num = 145;
			}
		}
		if (tileCache.type == 149)
		{
			num = 49;
		}
		if (Main.tileAlch[tileCache.type])
		{
			int num25 = tileCache.frameX / 18;
			if (num25 == 0)
			{
				num = 3;
			}
			if (num25 == 1)
			{
				num = 3;
			}
			if (num25 == 2)
			{
				num = 7;
			}
			if (num25 == 3)
			{
				num = 17;
			}
			if (num25 == 4)
			{
				num = 289;
			}
			if (num25 == 5)
			{
				num = 6;
			}
			if (num25 == 6)
			{
				num = 224;
			}
		}
		if (tileCache.type == 58 || tileCache.type == 76 || tileCache.type == 77 || tileCache.type == 684)
		{
			num = ((genRand.Next(2) != 0) ? 25 : 6);
		}
		if (tileCache.type == 37)
		{
			num = ((genRand.Next(2) != 0) ? 23 : 6);
		}
		if (tileCache.type == 32)
		{
			num = ((genRand.Next(2) != 0) ? 24 : 14);
		}
		if (tileCache.type == 352)
		{
			num = ((genRand.Next(3) != 0) ? 125 : 5);
		}
		if (tileCache.type == 23 || tileCache.type == 24 || tileCache.type == 661)
		{
			num = ((genRand.Next(2) != 0) ? 17 : 14);
		}
		if (tileCache.type == 25 || tileCache.type == 31)
		{
			num = ((tileCache.type == 31 && tileCache.frameX >= 36) ? 5 : ((genRand.Next(2) != 0) ? 1 : 14));
		}
		if (tileCache.type == 20)
		{
			num = (tileCache.frameX / 54) switch
			{
				1 => 122, 
				2 => 78, 
				3 => 77, 
				4 => 121, 
				5 => 79, 
				_ => 7, 
			};
		}
		if (tileCache.type == 27)
		{
			num = ((genRand.Next(2) != 0) ? 19 : 3);
		}
		if (tileCache.type == 129)
		{
			if (tileCache.frameX >= 324)
			{
				num = 69;
			}
			num = ((tileCache.frameX != 0 && tileCache.frameX != 54 && tileCache.frameX != 108) ? ((tileCache.frameX != 18 && tileCache.frameX != 72 && tileCache.frameX != 126) ? 70 : 69) : 68);
		}
		if (tileCache.type == 385)
		{
			num = genRand.Next(68, 71);
		}
		if (tileCache.type == 4)
		{
			int num7 = (int)MathHelper.Clamp((float)(tileCache.frameY / 22), 0f, (float)(TorchID.Count - 1));
			num = TorchID.Dust[num7];
		}
		if (tileCache.type == 35)
		{
			num = 189;
			if (tileCache.frameX < 36 && genRand.Next(2) == 0)
			{
				num = 6;
			}
		}
		if ((tileCache.type == 34 || tileCache.type == 42) && genRand.Next(2) == 0)
		{
			num = 6;
		}
		if (tileCache.type == 270)
		{
			num = -1;
		}
		if (tileCache.type == 271)
		{
			num = -1;
		}
		if (tileCache.type == 581)
		{
			num = -1;
		}
		if (tileCache.type == 660)
		{
			num = -1;
		}
		if (tileCache.type == 79 || tileCache.type == 90 || tileCache.type == 101)
		{
			num = -1;
		}
		if (tileCache.type == 33 || tileCache.type == 34 || tileCache.type == 42 || tileCache.type == 93 || tileCache.type == 100)
		{
			num = -1;
		}
		if (tileCache.type == 321 || tileCache.type == 574)
		{
			num = 214;
		}
		if (tileCache.type == 322)
		{
			num = 215;
		}
		if (tileCache.type == 635)
		{
			num = 36;
		}
		bool flag = tileCache.type == 178 || tileCache.type == 440;
		ushort type = tileCache.type;
		if (type == 178 || (uint)(type - 426) <= 1u || (uint)(type - 430) <= 10u)
		{
			flag = true;
		}
		ModTile modTile = TileLoader.GetTile(tileCache.type);
		if (modTile != null)
		{
			num = modTile.DustType;
		}
		if (TileLoader.CreateDust(i, j, tileCache.type, ref num) && num >= 0)
		{
			if (tileCache.type == 627 || tileCache.type == 628 || (tileCache.type == 184 && tileCache.frameX / 22 == 10))
			{
				int num8 = Dust.NewDust(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16, num, 0f, 0f, 0, new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB));
				Main.dust[num8].noGravity = true;
				Main.dust[num8].noLightEmittence = true;
				return num8;
			}
			if (tileCache.type == 518)
			{
				int num9 = tileCache.liquid / 16;
				num9 -= 3;
				if (SolidTile(i, j - 1) && num9 > 8)
				{
					num9 = 8;
				}
				return Dust.NewDust(new Vector2((float)(i * 16), (float)(j * 16 - num9)), 16, 16, num);
			}
			if (tileCache.type == 352 && num == 5)
			{
				int num11 = Dust.NewDust(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16, 5, 0f, 0f, 100);
				Main.dust[num11].scale = 1.5f;
				Main.dust[num11].noGravity = true;
				Dust obj = Main.dust[num11];
				obj.velocity *= 1.65f;
				Main.dust[num11].fadeIn = 1.6f;
				return num11;
			}
			if (tileCache.type == 160 || tileCache.type == 692)
			{
				int num12 = Dust.NewDust(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16, 66, 0f, 0f, 100, new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB), 0.75f);
				Main.dust[num12].noGravity = true;
				return num12;
			}
			if (tileCache.type == 323)
			{
				int frameY = tileCache.frameY;
				return Dust.NewDust(new Vector2((float)(i * 16 + frameY), (float)(j * 16)), 16, 16, num);
			}
			if (tileCache.type == 314)
			{
				int num13 = Dust.NewDust(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16, 213, genRand.Next(-2, 3), genRand.Next(-2, 3));
				Main.dust[num13].noGravity = true;
				Main.dust[num13].fadeIn = Main.dust[num13].scale + 1f + 0.01f * (float)genRand.Next(0, 51);
				Main.dust[num13].noGravity = true;
				return num13;
			}
			if (flag)
			{
				int num14 = Dust.NewDust(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16, num, 0f, 0f, 75, default(Color), 0.75f);
				Main.dust[num14].noLight = true;
				return num14;
			}
			if (tileCache.type == 193 || (tileCache.type == 18 && num == 4) || (tileCache.type == 19 && num == 4))
			{
				return Dust.NewDust(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16, num, 0f, 0f, 75, new Color(0, 80, 255, 100), 0.75f);
			}
			if (tileCache.type == 197)
			{
				return Dust.NewDust(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16, num, 0f, 0f, 75, new Color(97, 200, 255, 100), 0.75f);
			}
			if (tileCache.type == 185 && num >= 86 && num <= 91)
			{
				int num15 = Dust.NewDust(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16, num, 0f, 0f, 75, default(Color), 0.75f);
				Main.dust[num15].noLight = true;
				return num15;
			}
			if (tileCache.type == 4 && num == 66)
			{
				int num16 = Dust.NewDust(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16, num, 0f, 0f, 0, new Color((float)Main.DiscoR / 255f, (float)Main.DiscoG / 255f, (float)Main.DiscoB / 255f));
				Main.dust[num16].noGravity = true;
				return num16;
			}
			if (num == 139)
			{
				int type2 = num + Main.rand.Next(4);
				return Dust.NewDust(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16, type2);
			}
			return Dust.NewDust(new Vector2((float)(i * 16), (float)(j * 16)), 16, 16, num);
		}
		return 6000;
	}

	public static bool IsOpenDoorAnchorFrame(int x, int y)
	{
		Tile tile = Main.tile[x, y];
		if (!tile.active() || tile.type != 11)
		{
			return false;
		}
		int num = tile.frameX % 72;
		if (num >= 18)
		{
			return num >= 54;
		}
		return true;
	}

	public static bool IsLockedDoor(int x, int y)
	{
		return IsLockedDoor(Main.tile[x, y]);
	}

	public static bool IsLockedDoor(Tile t)
	{
		if (t.type == 10 && t.frameY >= 594 && t.frameY <= 646)
		{
			return t.frameX < 54;
		}
		return false;
	}

	public static void DropDoorItem(int x, int y, int doorStyle)
	{
		int num = 0;
		switch (doorStyle)
		{
		case 0:
			num = 25;
			break;
		case 9:
			num = 837;
			break;
		case 10:
			num = 912;
			break;
		case 12:
			num = 1137;
			break;
		case 13:
			num = 1138;
			break;
		case 14:
			num = 1139;
			break;
		case 15:
			num = 1140;
			break;
		case 16:
			num = 1411;
			break;
		case 17:
			num = 1412;
			break;
		case 18:
			num = 1413;
			break;
		case 19:
			num = 1458;
			break;
		case 20:
		case 21:
		case 22:
		case 23:
			num = 1709 + doorStyle - 20;
			break;
		case 24:
			num = 1793;
			break;
		case 25:
			num = 1815;
			break;
		case 26:
			num = 1924;
			break;
		case 27:
			num = 2044;
			break;
		case 28:
			num = 2265;
			break;
		case 29:
			num = 2528;
			break;
		case 30:
			num = 2561;
			break;
		case 31:
			num = 2576;
			break;
		case 32:
			num = 2815;
			break;
		case 33:
			num = 3129;
			break;
		case 34:
			num = 3131;
			break;
		case 35:
			num = 3130;
			break;
		case 36:
			num = 3888;
			break;
		case 37:
			num = 3941;
			break;
		case 38:
			num = 3967;
			break;
		case 39:
			num = 4155;
			break;
		case 40:
			num = 4176;
			break;
		case 41:
			num = 4197;
			break;
		case 42:
			num = 4218;
			break;
		case 43:
			num = 4307;
			break;
		case 44:
			num = 4415;
			break;
		case 45:
			num = 4576;
			break;
		case 46:
			num = 5158;
			break;
		case 47:
			num = 5179;
			break;
		case 48:
			num = 5200;
			break;
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
			num = 812 + doorStyle;
			break;
		default:
			num = 649 + doorStyle;
			break;
		case 11:
			break;
		}
		if (num != 0)
		{
			Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, num);
		}
	}

	public static IEntitySource GetItemSource_FromTileBreak(int x, int y)
	{
		return new EntitySource_TileBreak(x, y);
	}

	public static IEntitySource GetItemSource_FromWallBreak(int x, int y)
	{
		return new EntitySource_TileBreak(x, y);
	}

	public static IEntitySource GetItemSource_FromTreeShake(int x, int y)
	{
		return new EntitySource_ShakeTree(x, y);
	}

	public static bool PlayerLOS(int x, int y)
	{
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		Rectangle rectangle = default(Rectangle);
		((Rectangle)(ref rectangle))._002Ector(x * 16, y * 16, 16, 16);
		Rectangle value = default(Rectangle);
		for (int i = 0; i < 255; i++)
		{
			if (Main.player[i].active)
			{
				((Rectangle)(ref value))._002Ector((int)((double)Main.player[i].position.X + (double)Main.player[i].width * 0.5 - (double)NPC.sWidth * 0.6), (int)((double)Main.player[i].position.Y + (double)Main.player[i].height * 0.5 - (double)NPC.sHeight * 0.6), (int)((double)NPC.sWidth * 1.2), (int)((double)NPC.sHeight * 1.2));
				if (((Rectangle)(ref rectangle)).Intersects(value))
				{
					return true;
				}
			}
		}
		return false;
	}

	public static void ChlorophyteDefense(int x, int y)
	{
		if (!Main.remixWorld)
		{
			return;
		}
		if (Main.tile[x, y].type == 23 || Main.tile[x, y].type == 199 || Main.tile[x, y].type == 661 || Main.tile[x, y].type == 662)
		{
			Main.tile[x, y].type = 60;
			SquareTileFrame(x, y);
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, x, y);
			}
		}
		else if (Main.tile[x, y].type == 25 || Main.tile[x, y].type == 203)
		{
			Main.tile[x, y].type = 1;
			SquareTileFrame(x, y);
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, x, y);
			}
		}
		else if (Main.tile[x, y].type == 112 || Main.tile[x, y].type == 234)
		{
			Main.tile[x, y].type = 53;
			SquareTileFrame(x, y);
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, x, y);
			}
		}
		else if (Main.tile[x, y].type == 398 || Main.tile[x, y].type == 399)
		{
			Main.tile[x, y].type = 397;
			SquareTileFrame(x, y);
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, x, y);
			}
		}
		else if (Main.tile[x, y].type == 400 || Main.tile[x, y].type == 401)
		{
			Main.tile[x, y].type = 396;
			SquareTileFrame(x, y);
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, x, y);
			}
		}
		else if (Main.tile[x, y].type == 24 || Main.tile[x, y].type == 201 || Main.tile[x, y].type == 32 || Main.tile[x, y].type == 352 || Main.tile[x, y].type == 636 || Main.tile[x, y].type == 205)
		{
			KillTile(x, y);
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, x, y);
			}
		}
	}

	public static bool Chlorophyte(int i, int j)
	{
		int num = 40;
		int num2 = 130;
		int num3 = 35;
		int num4 = 85;
		if (Main.remixWorld)
		{
			num += 5;
			num2 *= 15;
			num3 -= 4;
			num4 -= 8;
		}
		else if ((double)j < Main.rockLayer)
		{
			num /= 2;
			num2 /= 2;
			num3 = (int)((double)num3 * 1.5);
			num4 = (int)((double)num4 * 1.5);
		}
		int num5 = 0;
		for (int k = i - num3; k < i + num3; k++)
		{
			for (int l = j - num3; l < j + num3; l++)
			{
				if (InWorld(k, l) && Main.tile[k, l].active() && Main.tile[k, l].type == 211)
				{
					num5++;
				}
			}
		}
		if (num5 > num)
		{
			return false;
		}
		num5 = 0;
		for (int m = i - num4; m < i + num4; m++)
		{
			for (int n = j - num4; n < j + num4; n++)
			{
				if (InWorld(m, n) && Main.tile[m, n].active() && Main.tile[m, n].type == 211)
				{
					num5++;
				}
			}
		}
		if (num5 > num2)
		{
			return false;
		}
		return true;
	}

	private static bool nearbyChlorophyte(int i, int j)
	{
		double num = 0.0;
		int num2 = 5;
		if (i <= num2 + 5 || i >= Main.maxTilesX - num2 - 5)
		{
			return false;
		}
		if (j <= num2 + 5 || j >= Main.maxTilesY - num2 - 5)
		{
			return false;
		}
		for (int k = i - num2; k <= i + num2; k++)
		{
			for (int l = j - num2; l <= j + num2; l++)
			{
				if (Main.tile[k, l].active() && (Main.tile[k, l].type == 211 || Main.tile[k, l].type == 346))
				{
					num += 1.0;
					if (num >= 3.0)
					{
						return true;
					}
				}
			}
		}
		if (num > 0.0)
		{
			if (Main.remixWorld)
			{
				if ((double)genRand.Next(-1, 3) < num)
				{
					return true;
				}
			}
			else if ((double)genRand.Next(-1, 4) < num)
			{
				return true;
			}
		}
		return false;
	}

	public static int CountNearBlocksTypes(int i, int j, int radius, int cap = 0, params int[] tiletypes)
	{
		if (tiletypes.Length == 0)
		{
			return 0;
		}
		int value5 = i - radius;
		int value2 = i + radius;
		int value3 = j - radius;
		int value4 = j + radius;
		int num3 = Utils.Clamp(value5, 0, Main.maxTilesX - 1);
		value2 = Utils.Clamp(value2, 0, Main.maxTilesX - 1);
		value3 = Utils.Clamp(value3, 0, Main.maxTilesY - 1);
		value4 = Utils.Clamp(value4, 0, Main.maxTilesY - 1);
		int num2 = 0;
		for (int k = num3; k <= value2; k++)
		{
			for (int l = value3; l <= value4; l++)
			{
				if (!Main.tile[k, l].active())
				{
					continue;
				}
				for (int m = 0; m < tiletypes.Length; m++)
				{
					if (tiletypes[m] == Main.tile[k, l].type)
					{
						num2++;
						if (cap <= 0 || num2 < cap)
						{
							break;
						}
						return num2;
					}
				}
			}
		}
		return num2;
	}

	public static void hardUpdateWorld(int i, int j)
	{
		if (!Main.hardMode || Main.tile[i, j].inActive())
		{
			return;
		}
		int type = Main.tile[i, j].type;
		if (type > 0 && TileID.Sets.CanGrowCrystalShards[type] && ((double)j > Main.rockLayer || Main.remixWorld) && genRand.Next(5) == 0)
		{
			int num = genRand.Next(4);
			int num8 = 0;
			int num9 = 0;
			switch (num)
			{
			case 0:
				num8 = -1;
				break;
			case 1:
				num8 = 1;
				break;
			default:
				num9 = ((num != 0) ? 1 : (-1));
				break;
			}
			if (!Main.tile[i + num8, j + num9].active())
			{
				int num10 = 0;
				int num11 = 6;
				for (int k = i - num11; k <= i + num11; k++)
				{
					for (int l = j - num11; l <= j + num11; l++)
					{
						if (Main.tile[k, l].active() && Main.tile[k, l].type == 129)
						{
							num10++;
						}
					}
				}
				if (num10 < 2)
				{
					int style = (short)genRand.Next(18);
					if (genRand.Next(50) == 0)
					{
						style = (short)(18 + genRand.Next(6));
					}
					PlaceTile(i + num8, j + num9, 129, mute: true, forced: false, -1, style);
					NetMessage.SendTileSquare(-1, i + num8, j + num9);
				}
			}
		}
		if ((double)j > (Main.worldSurface + Main.rockLayer) / 2.0 || Main.remixWorld)
		{
			if (type == 60 && genRand.Next(300) == 0)
			{
				int num12 = i + genRand.Next(-10, 11);
				int num13 = j + genRand.Next(-10, 11);
				if (InWorld(num12, num13, 2) && Main.tile[num12, num13].active() && Main.tile[num12, num13].type == 59 && (!Main.tile[num12, num13 - 1].active() || (Main.tile[num12, num13 - 1].type != 5 && Main.tile[num12, num13 - 1].type != 236 && Main.tile[num12, num13 - 1].type != 238)) && Chlorophyte(num12, num13))
				{
					Main.tile[num12, num13].type = 211;
					SquareTileFrame(num12, num13);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, num12, num13);
					}
				}
			}
			if (type == 211 || type == 346)
			{
				int num14 = i;
				int num15 = j;
				if (genRand.Next(3) != 0)
				{
					int num16 = genRand.Next(4);
					if (num16 == 0)
					{
						num14++;
					}
					if (num16 == 1)
					{
						num14--;
					}
					if (num16 == 2)
					{
						num15++;
					}
					if (num16 == 3)
					{
						num15--;
					}
					if (InWorld(num14, num15, 2) && Main.tile[num14, num15].active() && (Main.tile[num14, num15].type == 59 || Main.tile[num14, num15].type == 60) && Chlorophyte(num14, num15))
					{
						Main.tile[num14, num15].type = 211;
						SquareTileFrame(num14, num15);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num14, num15);
						}
					}
				}
				bool flag = true;
				while (flag)
				{
					flag = false;
					num14 = i + Main.rand.Next(-6, 7);
					num15 = j + Main.rand.Next(-6, 7);
					if (!InWorld(num14, num15, 2) || !Main.tile[num14, num15].active())
					{
						continue;
					}
					if (Main.tile[num14, num15].type == 661 || Main.tile[num14, num15].type == 662 || Main.tile[num14, num15].type == 23 || Main.tile[num14, num15].type == 199 || Main.tile[num14, num15].type == 2 || Main.tile[num14, num15].type == 477 || Main.tile[num14, num15].type == 492 || Main.tile[num14, num15].type == 109)
					{
						Main.tile[num14, num15].type = 60;
						SquareTileFrame(num14, num15);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num14, num15);
						}
						flag = true;
					}
					else if (Main.tile[num14, num15].type == 0)
					{
						Main.tile[num14, num15].type = 59;
						SquareTileFrame(num14, num15);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num14, num15);
						}
						flag = true;
					}
					else if (Main.tile[num14, num15].type == 25 || Main.tile[num14, num15].type == 203)
					{
						Main.tile[num14, num15].type = 1;
						SquareTileFrame(num14, num15);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num14, num15);
						}
						flag = true;
					}
					else if (Main.tile[num14, num15].type == 112 || Main.tile[num14, num15].type == 234)
					{
						Main.tile[num14, num15].type = 53;
						SquareTileFrame(num14, num15);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num14, num15);
						}
						flag = true;
					}
					else if (Main.tile[num14, num15].type == 398 || Main.tile[num14, num15].type == 399)
					{
						Main.tile[num14, num15].type = 397;
						SquareTileFrame(num14, num15);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num14, num15);
						}
						flag = true;
					}
					else if (Main.tile[num14, num15].type == 400 || Main.tile[num14, num15].type == 401)
					{
						Main.tile[num14, num15].type = 396;
						SquareTileFrame(num14, num15);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num14, num15);
						}
						flag = true;
					}
					else if (Main.tile[num14, num15].type == 24 || Main.tile[num14, num15].type == 201 || Main.tile[num14, num15].type == 32 || Main.tile[num14, num15].type == 352 || Main.tile[num14, num15].type == 636 || Main.tile[num14, num15].type == 205)
					{
						KillTile(num14, num15);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num14, num15);
						}
						flag = true;
					}
				}
			}
		}
		if ((NPC.downedPlantBoss && genRand.Next(2) != 0) || !AllowedToSpreadInfections)
		{
			return;
		}
		if (type == 23 || type == 25 || type == 32 || type == 112 || type == 163 || type == 400 || type == 398 || type == 636 || type == 661)
		{
			bool flag2 = true;
			while (flag2)
			{
				flag2 = false;
				int num2 = i + genRand.Next(-3, 4);
				int num3 = j + genRand.Next(-3, 4);
				if (!InWorld(num2, num3, 10))
				{
					continue;
				}
				if (nearbyChlorophyte(num2, num3))
				{
					ChlorophyteDefense(num2, num3);
				}
				else
				{
					if (CountNearBlocksTypes(num2, num3, 2, 1, 27) > 0)
					{
						continue;
					}
					if (Main.tile[num2, num3].type == 2)
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Main.tile[num2, num3].type = 23;
						SquareTileFrame(num2, num3);
						NetMessage.SendTileSquare(-1, num2, num3);
					}
					else if (Main.tile[num2, num3].type == 1 || Main.tileMoss[Main.tile[num2, num3].type])
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Main.tile[num2, num3].type = 25;
						SquareTileFrame(num2, num3);
						NetMessage.SendTileSquare(-1, num2, num3);
					}
					else if (Main.tile[num2, num3].type == 53)
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Main.tile[num2, num3].type = 112;
						SquareTileFrame(num2, num3);
						NetMessage.SendTileSquare(-1, num2, num3);
					}
					else if (Main.tile[num2, num3].type == 396)
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Main.tile[num2, num3].type = 400;
						SquareTileFrame(num2, num3);
						NetMessage.SendTileSquare(-1, num2, num3);
					}
					else if (Main.tile[num2, num3].type == 397)
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Main.tile[num2, num3].type = 398;
						SquareTileFrame(num2, num3);
						NetMessage.SendTileSquare(-1, num2, num3);
					}
					else if (Main.tile[num2, num3].type == 60)
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Main.tile[num2, num3].type = 661;
						SquareTileFrame(num2, num3);
						NetMessage.SendTileSquare(-1, num2, num3);
					}
					else if (Main.tile[num2, num3].type == 69)
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Main.tile[num2, num3].type = 32;
						SquareTileFrame(num2, num3);
						NetMessage.SendTileSquare(-1, num2, num3);
					}
					else if (Main.tile[num2, num3].type == 161)
					{
						if (genRand.Next(2) == 0)
						{
							flag2 = true;
						}
						Main.tile[num2, num3].type = 163;
						SquareTileFrame(num2, num3);
						NetMessage.SendTileSquare(-1, num2, num3);
					}
				}
			}
		}
		if (type == 199 || type == 200 || type == 201 || type == 203 || type == 205 || type == 234 || type == 352 || type == 401 || type == 399 || type == 662)
		{
			bool flag3 = true;
			while (flag3)
			{
				flag3 = false;
				int num4 = i + genRand.Next(-3, 4);
				int num5 = j + genRand.Next(-3, 4);
				if (!InWorld(num4, num5, 10))
				{
					continue;
				}
				if (nearbyChlorophyte(num4, num5))
				{
					ChlorophyteDefense(num4, num5);
				}
				else
				{
					if (CountNearBlocksTypes(num4, num5, 2, 1, 27) > 0)
					{
						continue;
					}
					if (Main.tile[num4, num5].type == 2)
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Main.tile[num4, num5].type = 199;
						SquareTileFrame(num4, num5);
						NetMessage.SendTileSquare(-1, num4, num5);
					}
					else if (Main.tile[num4, num5].type == 1 || Main.tileMoss[Main.tile[num4, num5].type])
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Main.tile[num4, num5].type = 203;
						SquareTileFrame(num4, num5);
						NetMessage.SendTileSquare(-1, num4, num5);
					}
					else if (Main.tile[num4, num5].type == 53)
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Main.tile[num4, num5].type = 234;
						SquareTileFrame(num4, num5);
						NetMessage.SendTileSquare(-1, num4, num5);
					}
					else if (Main.tile[num4, num5].type == 396)
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Main.tile[num4, num5].type = 401;
						SquareTileFrame(num4, num5);
						NetMessage.SendTileSquare(-1, num4, num5);
					}
					else if (Main.tile[num4, num5].type == 397)
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Main.tile[num4, num5].type = 399;
						SquareTileFrame(num4, num5);
						NetMessage.SendTileSquare(-1, num4, num5);
					}
					else if (Main.tile[num4, num5].type == 60)
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Main.tile[num4, num5].type = 662;
						SquareTileFrame(num4, num5);
						NetMessage.SendTileSquare(-1, num4, num5);
					}
					else if (Main.tile[num4, num5].type == 69)
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Main.tile[num4, num5].type = 352;
						SquareTileFrame(num4, num5);
						NetMessage.SendTileSquare(-1, num4, num5);
					}
					else if (Main.tile[num4, num5].type == 161)
					{
						if (genRand.Next(2) == 0)
						{
							flag3 = true;
						}
						Main.tile[num4, num5].type = 200;
						SquareTileFrame(num4, num5);
						NetMessage.SendTileSquare(-1, num4, num5);
					}
				}
			}
		}
		if (type != 109 && type != 110 && type != 113 && type != 115 && type != 116 && type != 117 && type != 164 && type != 402 && type != 403 && type != 492)
		{
			return;
		}
		bool flag4 = true;
		while (flag4)
		{
			flag4 = false;
			int num6 = i + genRand.Next(-3, 4);
			int num7 = j + genRand.Next(-3, 4);
			if (!InWorld(num6, num7, 10) || CountNearBlocksTypes(num6, num7, 2, 1, 27) > 0)
			{
				continue;
			}
			if (Main.tile[num6, num7].type == 2)
			{
				if (genRand.Next(2) == 0)
				{
					flag4 = true;
				}
				Main.tile[num6, num7].type = 109;
				SquareTileFrame(num6, num7);
				NetMessage.SendTileSquare(-1, num6, num7);
			}
			else if (Main.tile[num6, num7].type == 477)
			{
				if (genRand.Next(2) == 0)
				{
					flag4 = true;
				}
				Main.tile[num6, num7].type = 492;
				SquareTileFrame(num6, num7);
				NetMessage.SendTileSquare(-1, num6, num7);
			}
			else if (Main.tile[num6, num7].type == 1 || Main.tileMoss[Main.tile[num6, num7].type])
			{
				if (genRand.Next(2) == 0)
				{
					flag4 = true;
				}
				Main.tile[num6, num7].type = 117;
				SquareTileFrame(num6, num7);
				NetMessage.SendTileSquare(-1, num6, num7);
			}
			else if (Main.tile[num6, num7].type == 53)
			{
				if (genRand.Next(2) == 0)
				{
					flag4 = true;
				}
				Main.tile[num6, num7].type = 116;
				SquareTileFrame(num6, num7);
				NetMessage.SendTileSquare(-1, num6, num7);
			}
			else if (Main.tile[num6, num7].type == 396)
			{
				if (genRand.Next(2) == 0)
				{
					flag4 = true;
				}
				Main.tile[num6, num7].type = 403;
				SquareTileFrame(num6, num7);
				NetMessage.SendTileSquare(-1, num6, num7);
			}
			else if (Main.tile[num6, num7].type == 397)
			{
				if (genRand.Next(2) == 0)
				{
					flag4 = true;
				}
				Main.tile[num6, num7].type = 402;
				SquareTileFrame(num6, num7);
				NetMessage.SendTileSquare(-1, num6, num7);
			}
			else if (Main.tile[num6, num7].type == 161)
			{
				if (genRand.Next(2) == 0)
				{
					flag4 = true;
				}
				Main.tile[num6, num7].type = 164;
				SquareTileFrame(num6, num7);
				NetMessage.SendTileSquare(-1, num6, num7);
			}
		}
	}

	public static bool SolidTile(Tile testTile)
	{
		try
		{
			if (testTile == null)
			{
				return true;
			}
			if (testTile.active() && Main.tileSolid[testTile.type] && !Main.tileSolidTop[testTile.type] && !testTile.halfBrick() && testTile.slope() == 0 && !testTile.inActive())
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool TileEmpty(int i, int j)
	{
		if (Main.tile[i, j] != null && Main.tile[i, j].active())
		{
			return Main.tile[i, j].inActive();
		}
		return true;
	}

	public static bool SolidOrSlopedTile(Tile tile)
	{
		if (tile != null && tile.active() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type])
		{
			return !tile.inActive();
		}
		return false;
	}

	public static int TileType(int x, int y)
	{
		if (!Main.tile[x, y].active())
		{
			return -1;
		}
		return Main.tile[x, y].type;
	}

	public static bool SolidOrSlopedTile(int x, int y)
	{
		return SolidOrSlopedTile(Main.tile[x, y]);
	}

	public static bool IsRope(int x, int y)
	{
		if (Main.tile[x, y] == null || !Main.tile[x, y].active())
		{
			return false;
		}
		if (Main.tileRope[Main.tile[x, y].type])
		{
			return true;
		}
		if ((Main.tile[x, y].type == 314 || TileID.Sets.Platforms[Main.tile[x, y].type]) && Main.tile[x, y - 1] != null && Main.tile[x, y + 1] != null && Main.tile[x, y - 1].active() && Main.tile[x, y + 1].active() && Main.tileRope[Main.tile[x, y - 1].type] && Main.tileRope[Main.tile[x, y + 1].type])
		{
			return true;
		}
		return false;
	}

	public static bool SolidTile(Point p)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return SolidTile(p.X, p.Y);
	}

	public static bool SolidTile(int i, int j, bool noDoors = false)
	{
		try
		{
			if (Main.tile[i, j] == null)
			{
				return true;
			}
			if (Main.tile[i, j].active() && Main.tileSolid[Main.tile[i, j].type] && !Main.tileSolidTop[Main.tile[i, j].type] && !Main.tile[i, j].halfBrick() && Main.tile[i, j].slope() == 0 && !Main.tile[i, j].inActive())
			{
				if (noDoors && Main.tile[i, j].type == 10)
				{
					return false;
				}
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool SolidTile2(Tile testTile)
	{
		try
		{
			if (testTile == null)
			{
				return true;
			}
			if (testTile.active() && Main.tileSolid[testTile.type] && testTile.slope() == 0 && !testTile.halfBrick() && !testTile.inActive())
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool PlatformProperTopFrame(short frameX)
	{
		int num = frameX / TileObjectData.PlatformFrameWidth();
		if ((num < 0 || num > 7) && (num < 12 || num > 16))
		{
			if (num >= 25)
			{
				return num <= 26;
			}
			return false;
		}
		return true;
	}

	public static bool SolidTileAllowBottomSlope(int i, int j)
	{
		try
		{
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				return true;
			}
			if (tile.active() && (Main.tileSolid[tile.type] || Main.tileSolidTop[tile.type]) && (!tile.topSlope() || (TileID.Sets.Platforms[tile.type] && PlatformProperTopFrame(tile.frameX))) && !tile.halfBrick() && !tile.inActive())
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool ActiveAndWalkableTile(int i, int j)
	{
		try
		{
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				return true;
			}
			if (tile.active() && Main.tileSolid[tile.type] && !tile.inActive())
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool SolidTileAllowTopSlope(int i, int j)
	{
		try
		{
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				return true;
			}
			if (tile.active() && (Main.tileSolid[tile.type] || tile.type == 380) && (!tile.bottomSlope() || (TileID.Sets.Platforms[tile.type] && tile.halfBrick())) && !tile.inActive())
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool SolidTileAllowLeftSlope(int i, int j)
	{
		try
		{
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				return true;
			}
			if (tile.active() && Main.tileSolid[tile.type] && !tile.rightSlope() && !TileID.Sets.Platforms[tile.type] && !tile.inActive())
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool SolidTileAllowRightSlope(int i, int j)
	{
		try
		{
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				return true;
			}
			if (tile.active() && Main.tileSolid[tile.type] && !tile.leftSlope() && !TileID.Sets.Platforms[tile.type] && !tile.inActive())
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool TopEdgeCanBeAttachedTo(int i, int j)
	{
		try
		{
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				return true;
			}
			if (tile.active() && (Main.tileSolid[tile.type] || Main.tileSolidTop[tile.type]) && (!tile.topSlope() || (TileID.Sets.Platforms[tile.type] && PlatformProperTopFrame(tile.frameX))) && !tile.halfBrick() && !tile.inActive())
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool RightEdgeCanBeAttachedTo(int i, int j)
	{
		try
		{
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				return true;
			}
			if (tile.active() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type] && !tile.rightSlope() && !tile.halfBrick() && !tile.inActive() && !Main.tileNoAttach[tile.type])
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool LeftEdgeCanBeAttachedTo(int i, int j)
	{
		try
		{
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				return true;
			}
			if (tile.active() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type] && !tile.leftSlope() && !tile.halfBrick() && !tile.inActive() && !Main.tileNoAttach[tile.type])
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool BottomEdgeCanBeAttachedTo(int i, int j)
	{
		try
		{
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				return true;
			}
			if (tile.active() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type] && !tile.bottomSlope() && !tile.inActive() && !Main.tileNoAttach[tile.type])
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool SolidTile3(int i, int j)
	{
		if (!InWorld(i, j, 1))
		{
			return false;
		}
		return SolidTile3(Main.tile[i, j]);
	}

	public static bool SolidTile3(Tile t)
	{
		if (t == null)
		{
			return false;
		}
		if (t.active() && !t.inActive() && Main.tileSolid[t.type])
		{
			return !Main.tileSolidTop[t.type];
		}
		return false;
	}

	public static bool SolidTile2(int i, int j)
	{
		try
		{
			if (Main.tile[i, j] == null)
			{
				return true;
			}
			if (Main.tile[i, j].active() && Main.tileSolid[Main.tile[i, j].type] && ((TileID.Sets.Platforms[Main.tile[i, j].type] && (Main.tile[i, j].halfBrick() || Main.tile[i, j].topSlope())) || Main.tile[i, j].slope() == 0) && !Main.tile[i, j].halfBrick() && !Main.tile[i, j].inActive())
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static bool SolidTileNoAttach(int i, int j)
	{
		try
		{
			if (Main.tile[i, j] == null)
			{
				return true;
			}
			if (Main.tile[i, j].active() && Main.tileSolid[Main.tile[i, j].type] && !Main.tileNoAttach[Main.tile[i, j].type] && Main.tile[i, j].slope() == 0 && !Main.tile[i, j].halfBrick() && !Main.tile[i, j].inActive())
			{
				return true;
			}
		}
		catch
		{
		}
		return false;
	}

	public static void MineHouse(int i, int j)
	{
		if (i < 50 || i > Main.maxTilesX - 50 || j < 50 || j > Main.maxTilesY - 50)
		{
			return;
		}
		int num = genRand.Next(6, 12);
		int num12 = genRand.Next(3, 6);
		int num23 = genRand.Next(15, 30);
		int num34 = genRand.Next(15, 30);
		if (SolidTile(i, j))
		{
			return;
		}
		Tile tile = Main.tile[i, j];
		if (tile.wall > 0)
		{
			return;
		}
		int num44 = j - num;
		int num55 = j + num12;
		for (int k = 0; k < 2; k++)
		{
			bool flag = true;
			int num66 = i;
			int num71 = j;
			int num72 = -1;
			int num2 = num23;
			if (k == 1)
			{
				num72 = 1;
				num2 = num34;
				num66++;
			}
			while (flag)
			{
				if (num71 - num < num44)
				{
					num44 = num71 - num;
				}
				if (num71 + num12 > num55)
				{
					num55 = num71 + num12;
				}
				for (int l = 0; l < 2; l++)
				{
					int num3 = num71;
					bool flag2 = true;
					int num4 = num;
					int num5 = -1;
					if (l == 1)
					{
						num3++;
						num4 = num12;
						num5 = 1;
					}
					while (flag2)
					{
						if (num66 != i)
						{
							tile = Main.tile[num66 - num72, num3];
							if (tile.wall != 27)
							{
								if (!SolidTile(num66 - num72, num3))
								{
									tile = Main.tile[num66 - num72, num3];
									if (tile.active())
									{
										tile = Main.tile[num66 - num72, num3];
										if (!tile.halfBrick())
										{
											tile = Main.tile[num66 - num72, num3];
											if (tile.slope() == 0)
											{
												goto IL_01c7;
											}
										}
									}
								}
								tile = Main.tile[num66 - num72, num3];
								tile.active(active: true);
								tile = Main.tile[num66 - num72, num3];
								tile.type = 30;
							}
						}
						goto IL_01c7;
						IL_03a4:
						num3 += num5;
						num4--;
						if (num4 <= 0)
						{
							tile = Main.tile[num66, num3];
							if (!tile.active())
							{
								tile = Main.tile[num66, num3];
								tile.active(active: true);
								tile = Main.tile[num66, num3];
								tile.type = 30;
							}
							flag2 = false;
						}
						continue;
						IL_0227:
						if (!SolidTile(num66 + 1, num3))
						{
							tile = Main.tile[num66 + 1, num3];
							if (!tile.halfBrick())
							{
								tile = Main.tile[num66 + 1, num3];
								if (tile.slope() == 0)
								{
									goto IL_0287;
								}
							}
						}
						tile = Main.tile[num66 + 1, num3];
						tile.type = 30;
						goto IL_0287;
						IL_01c7:
						if (!SolidTile(num66 - 1, num3))
						{
							tile = Main.tile[num66 - 1, num3];
							if (!tile.halfBrick())
							{
								tile = Main.tile[num66 - 1, num3];
								if (tile.slope() == 0)
								{
									goto IL_0227;
								}
							}
						}
						tile = Main.tile[num66 - 1, num3];
						tile.type = 30;
						goto IL_0227;
						IL_0287:
						if (!SolidTile(num66, num3))
						{
							tile = Main.tile[num66, num3];
							if (!tile.halfBrick())
							{
								tile = Main.tile[num66, num3];
								if (tile.slope() == 0)
								{
									tile = Main.tile[num66, num3];
									tile.wall = 27;
									tile = Main.tile[num66, num3];
									tile.liquid = 0;
									tile = Main.tile[num66, num3];
									tile.lava(lava: false);
									goto IL_03a4;
								}
							}
						}
						int num6 = 0;
						if (SolidTile(num66 - 1, num3))
						{
							num6++;
						}
						if (SolidTile(num66 + 1, num3))
						{
							num6++;
						}
						if (SolidTile(num66, num3 - 1))
						{
							num6++;
						}
						if (SolidTile(num66, num3 + 1))
						{
							num6++;
						}
						if (num6 < 2)
						{
							tile = Main.tile[num66, num3];
							tile.active(active: false);
						}
						else
						{
							flag2 = false;
							tile = Main.tile[num66, num3];
							tile.type = 30;
						}
						goto IL_03a4;
					}
				}
				num2--;
				num66 += num72;
				if (SolidTile(num66, num71))
				{
					int num7 = 0;
					int num8 = 0;
					int num9 = num71;
					bool flag3 = true;
					while (flag3)
					{
						num9--;
						num7++;
						if (SolidTile(num66 - num72, num9))
						{
							num7 = 999;
							flag3 = false;
						}
						else if (!SolidTile(num66, num9))
						{
							flag3 = false;
						}
					}
					num9 = num71;
					flag3 = true;
					while (flag3)
					{
						num9++;
						num8++;
						if (SolidTile(num66 - num72, num9))
						{
							num8 = 999;
							flag3 = false;
						}
						else if (!SolidTile(num66, num9))
						{
							flag3 = false;
						}
					}
					if (num8 <= num7)
					{
						if (num8 > num12)
						{
							num2 = 0;
						}
						else
						{
							num71 += num8 + 1;
						}
					}
					else if (num7 > num)
					{
						num2 = 0;
					}
					else
					{
						num71 -= num7 + 1;
					}
				}
				if (num2 <= 0)
				{
					flag = false;
				}
			}
		}
		int num10 = i - num23 - 1;
		int num11 = i + num34 + 2;
		int num13 = num44 - 1;
		int num14 = num55 + 2;
		for (int m = num10; m < num11; m++)
		{
			for (int n = num13; n < num14; n++)
			{
				tile = Main.tile[m, n];
				if (tile.wall == 27)
				{
					tile = Main.tile[m, n];
					if (!tile.active())
					{
						tile = Main.tile[m - 1, n];
						if (tile.wall != 27 && m < i && !SolidTile(m - 1, n))
						{
							PlaceTile(m, n, 30, mute: true);
							tile = Main.tile[m, n];
							tile.wall = 0;
						}
						tile = Main.tile[m + 1, n];
						if (tile.wall != 27 && m > i && !SolidTile(m + 1, n))
						{
							PlaceTile(m, n, 30, mute: true);
							tile = Main.tile[m, n];
							tile.wall = 0;
						}
						for (int num15 = m - 1; num15 <= m + 1; num15++)
						{
							for (int num16 = n - 1; num16 <= n + 1; num16++)
							{
								if (SolidTile(num15, num16))
								{
									tile = Main.tile[num15, num16];
									tile.type = 30;
								}
							}
						}
					}
				}
				tile = Main.tile[m, n];
				if (tile.type != 30)
				{
					continue;
				}
				tile = Main.tile[m - 1, n];
				if (tile.wall != 27)
				{
					continue;
				}
				tile = Main.tile[m + 1, n];
				if (tile.wall != 27)
				{
					continue;
				}
				tile = Main.tile[m, n - 1];
				if (tile.wall != 27)
				{
					tile = Main.tile[m, n - 1];
					if (!tile.active())
					{
						continue;
					}
				}
				tile = Main.tile[m, n + 1];
				if (tile.wall != 27)
				{
					tile = Main.tile[m, n + 1];
					if (!tile.active())
					{
						continue;
					}
				}
				tile = Main.tile[m, n];
				tile.active(active: false);
				tile = Main.tile[m, n];
				tile.wall = 27;
			}
		}
		for (int num17 = num10; num17 < num11; num17++)
		{
			for (int num18 = num13; num18 < num14; num18++)
			{
				tile = Main.tile[num17, num18];
				if (tile.type != 30)
				{
					continue;
				}
				tile = Main.tile[num17 - 1, num18];
				if (tile.wall == 27)
				{
					tile = Main.tile[num17 + 1, num18];
					if (tile.wall == 27)
					{
						tile = Main.tile[num17 - 1, num18];
						if (!tile.active())
						{
							tile = Main.tile[num17 + 1, num18];
							if (!tile.active())
							{
								tile = Main.tile[num17, num18];
								tile.active(active: false);
								tile = Main.tile[num17, num18];
								tile.wall = 27;
							}
						}
					}
				}
				bool[] basicChest = TileID.Sets.BasicChest;
				tile = Main.tile[num17, num18 - 1];
				if (!basicChest[tile.type])
				{
					tile = Main.tile[num17 - 1, num18];
					if (tile.wall == 27)
					{
						tile = Main.tile[num17 + 1, num18];
						if (tile.type == 30)
						{
							tile = Main.tile[num17 + 2, num18];
							if (tile.wall == 27)
							{
								tile = Main.tile[num17 - 1, num18];
								if (!tile.active())
								{
									tile = Main.tile[num17 + 2, num18];
									if (!tile.active())
									{
										tile = Main.tile[num17, num18];
										tile.active(active: false);
										tile = Main.tile[num17, num18];
										tile.wall = 27;
										tile = Main.tile[num17 + 1, num18];
										tile.active(active: false);
										tile = Main.tile[num17 + 1, num18];
										tile.wall = 27;
									}
								}
							}
						}
					}
				}
				tile = Main.tile[num17, num18 - 1];
				if (tile.wall != 27)
				{
					continue;
				}
				tile = Main.tile[num17, num18 + 1];
				if (tile.wall != 27)
				{
					continue;
				}
				tile = Main.tile[num17, num18 - 1];
				if (!tile.active())
				{
					tile = Main.tile[num17, num18 + 1];
					if (!tile.active())
					{
						tile = Main.tile[num17, num18];
						tile.active(active: false);
						tile = Main.tile[num17, num18];
						tile.wall = 27;
					}
				}
			}
		}
		for (int num19 = num10; num19 < num11; num19++)
		{
			for (int num20 = num14; num20 > num13; num20--)
			{
				bool flag4 = false;
				tile = Main.tile[num19, num20];
				if (tile.active())
				{
					tile = Main.tile[num19, num20];
					if (tile.type == 30)
					{
						int num21 = -1;
						for (int num22 = 0; num22 < 2; num22++)
						{
							if (!SolidTile(num19 + num21, num20))
							{
								tile = Main.tile[num19 + num21, num20];
								if (tile.wall == 0)
								{
									int num24 = 0;
									int num25 = num20;
									int num26 = num20;
									while (true)
									{
										tile = Main.tile[num19, num25];
										if (!tile.active())
										{
											break;
										}
										tile = Main.tile[num19, num25];
										if (tile.type != 30 || SolidTile(num19 + num21, num25))
										{
											break;
										}
										tile = Main.tile[num19 + num21, num25];
										if (tile.wall != 0)
										{
											break;
										}
										num25--;
										num24++;
									}
									num25++;
									int num27 = num25 + 1;
									if (num24 > 4)
									{
										if (genRand.Next(2) == 0)
										{
											num25 = num26 - 1;
											bool flag5 = true;
											for (int num28 = num19 - 2; num28 <= num19 + 2; num28++)
											{
												for (int num29 = num25 - 2; num29 <= num25; num29++)
												{
													if (num28 != num19)
													{
														tile = Main.tile[num28, num29];
														if (tile.active())
														{
															flag5 = false;
														}
													}
												}
											}
											if (flag5)
											{
												tile = Main.tile[num19, num25];
												tile.active(active: false);
												tile = Main.tile[num19, num25 - 1];
												tile.active(active: false);
												tile = Main.tile[num19, num25 - 2];
												tile.active(active: false);
												PlaceTile(num19, num25, 10, mute: true);
												flag4 = true;
											}
										}
										if (!flag4)
										{
											for (int num30 = num27; num30 < num26; num30++)
											{
												tile = Main.tile[num19, num30];
												tile.type = 124;
											}
										}
									}
								}
							}
							num21 = 1;
						}
					}
				}
				if (flag4)
				{
					break;
				}
			}
		}
		int num31 = genRand.Next(1, 2);
		if (genRand.Next(4) == 0)
		{
			num31 = 0;
		}
		if (genRand.Next(6) == 0)
		{
			num31++;
		}
		if (genRand.Next(10) == 0)
		{
			num31++;
		}
		for (int num32 = 0; num32 < num31; num32++)
		{
			int num33 = 0;
			int num35 = genRand.Next(num10, num11);
			int num36 = genRand.Next(num13, num14);
			while (true)
			{
				bool[] wallHouse = Main.wallHouse;
				tile = Main.tile[num35, num36];
				if (wallHouse[tile.wall])
				{
					tile = Main.tile[num35, num36];
					if (!tile.active())
					{
						break;
					}
				}
				num33++;
				if (num33 > 1000)
				{
					break;
				}
				num35 = genRand.Next(num10, num11);
				num36 = genRand.Next(num13, num14);
			}
			if (num33 > 1000)
			{
				break;
			}
			int num37 = num35;
			int num38 = num35;
			int num39 = num36;
			int num40 = num36;
			int num41 = 0;
			for (int num42 = 0; num42 < 2; num42++)
			{
				num37 = num35;
				num38 = num35;
				while (true)
				{
					tile = Main.tile[num37, num36];
					if (tile.active())
					{
						break;
					}
					bool[] wallHouse2 = Main.wallHouse;
					tile = Main.tile[num37, num36];
					if (!wallHouse2[tile.wall])
					{
						break;
					}
					num37--;
				}
				num37++;
				while (true)
				{
					tile = Main.tile[num38, num36];
					if (tile.active())
					{
						break;
					}
					bool[] wallHouse3 = Main.wallHouse;
					tile = Main.tile[num38, num36];
					if (!wallHouse3[tile.wall])
					{
						break;
					}
					num38++;
				}
				num38--;
				i = (num37 + num38) / 2;
				num39 = num36;
				num40 = num36;
				while (true)
				{
					tile = Main.tile[num35, num39];
					if (tile.active())
					{
						break;
					}
					bool[] wallHouse4 = Main.wallHouse;
					tile = Main.tile[num35, num39];
					if (!wallHouse4[tile.wall])
					{
						break;
					}
					num39--;
				}
				num39++;
				while (true)
				{
					tile = Main.tile[num35, num40];
					if (tile.active())
					{
						break;
					}
					bool[] wallHouse5 = Main.wallHouse;
					tile = Main.tile[num35, num40];
					if (!wallHouse5[tile.wall])
					{
						break;
					}
					num40++;
				}
				num40--;
				num36 = (num39 + num40) / 2;
			}
			num37 = num35;
			num38 = num35;
			while (true)
			{
				tile = Main.tile[num37, num36];
				if (tile.active())
				{
					break;
				}
				tile = Main.tile[num37, num36 - 1];
				if (tile.active())
				{
					break;
				}
				tile = Main.tile[num37, num36 + 1];
				if (tile.active())
				{
					break;
				}
				num37--;
			}
			num37++;
			while (true)
			{
				tile = Main.tile[num38, num36];
				if (tile.active())
				{
					break;
				}
				tile = Main.tile[num38, num36 - 1];
				if (tile.active())
				{
					break;
				}
				tile = Main.tile[num38, num36 + 1];
				if (tile.active())
				{
					break;
				}
				num38++;
			}
			num38--;
			num39 = num36;
			num40 = num36;
			while (true)
			{
				tile = Main.tile[num35, num39];
				if (tile.active())
				{
					break;
				}
				tile = Main.tile[num35 - 1, num39];
				if (tile.active())
				{
					break;
				}
				tile = Main.tile[num35 + 1, num39];
				if (tile.active())
				{
					break;
				}
				num39--;
			}
			num39++;
			while (true)
			{
				tile = Main.tile[num35, num40];
				if (tile.active())
				{
					break;
				}
				tile = Main.tile[num35 - 1, num40];
				if (tile.active())
				{
					break;
				}
				tile = Main.tile[num35 + 1, num40];
				if (tile.active())
				{
					break;
				}
				num40++;
			}
			num40--;
			num35 = (num37 + num38) / 2;
			num36 = (num39 + num40) / 2;
			int num73 = num38 - num37;
			num41 = num40 - num39;
			if (num73 <= 7 || num41 <= 5)
			{
				continue;
			}
			int num43 = 0;
			if (nearPicture2(i, num36))
			{
				num43 = -1;
			}
			if (num43 == 0)
			{
				PaintingEntry paintingEntry = RandHousePicture();
				if (!nearPicture(num35, num36))
				{
					PlaceTile(num35, num36, paintingEntry.tileType, mute: true, forced: false, -1, paintingEntry.style);
				}
			}
		}
		int num45;
		for (num45 = num10; num45 < num11; num45++)
		{
			bool flag6 = true;
			for (int num46 = num13; num46 < num14; num46++)
			{
				for (int num47 = num45 - 3; num47 <= num45 + 3; num47++)
				{
					tile = Main.tile[num47, num46];
					if (!tile.active())
					{
						continue;
					}
					if (SolidTile(num47, num46))
					{
						tile = Main.tile[num47, num46];
						if (tile.type != 10)
						{
							continue;
						}
					}
					flag6 = false;
				}
			}
			if (flag6)
			{
				for (int num48 = num13; num48 < num14; num48++)
				{
					tile = Main.tile[num45, num48];
					if (tile.wall == 27)
					{
						tile = Main.tile[num45, num48];
						if (!tile.active())
						{
							PlaceTile(num45, num48, 124, mute: true);
						}
					}
				}
			}
			num45 += genRand.Next(4);
		}
		for (int num49 = 0; num49 < 4; num49++)
		{
			int num50 = genRand.Next(num10 + 2, num11 - 1);
			int num51 = genRand.Next(num13 + 2, num14 - 1);
			while (true)
			{
				tile = Main.tile[num50, num51];
				if (tile.wall != 27)
				{
					num50 = genRand.Next(num10 + 2, num11 - 1);
					num51 = genRand.Next(num13 + 2, num14 - 1);
					continue;
				}
				break;
			}
			while (true)
			{
				tile = Main.tile[num50, num51];
				if (tile.active())
				{
					num51--;
					continue;
				}
				break;
			}
			while (true)
			{
				tile = Main.tile[num50, num51];
				if (tile.active())
				{
					break;
				}
				num51++;
			}
			num51--;
			tile = Main.tile[num50, num51];
			if (tile.wall != 27)
			{
				continue;
			}
			if (genRand.Next(3) == 0)
			{
				int num52 = genRand.Next(9);
				if (num52 == 0)
				{
					num52 = 14;
				}
				if (num52 == 1)
				{
					num52 = 16;
				}
				if (num52 == 2)
				{
					num52 = 18;
				}
				if (num52 == 3)
				{
					num52 = 86;
				}
				if (num52 == 4)
				{
					num52 = 87;
				}
				if (num52 == 5)
				{
					num52 = 94;
				}
				if (num52 == 6)
				{
					num52 = 101;
				}
				if (num52 == 7)
				{
					num52 = 104;
				}
				if (num52 == 8)
				{
					num52 = 106;
				}
				PlaceTile(num50, num51, num52, mute: true);
			}
			else if (GenVars.statueList != null)
			{
				int num53 = genRand.Next(2, GenVars.statueList.Length);
				PlaceTile(num50, num51, GenVars.statueList[num53].X, mute: true, forced: true, -1, GenVars.statueList[num53].Y);
			}
		}
		for (int num54 = 0; num54 < 40; num54++)
		{
			int num56 = genRand.Next(num10 + 2, num11 - 1);
			int num57 = genRand.Next(num13 + 2, num14 - 1);
			while (true)
			{
				tile = Main.tile[num56, num57];
				if (tile.wall != 27)
				{
					num56 = genRand.Next(num10 + 2, num11 - 1);
					num57 = genRand.Next(num13 + 2, num14 - 1);
					continue;
				}
				break;
			}
			while (true)
			{
				tile = Main.tile[num56, num57];
				if (tile.active())
				{
					num57--;
					continue;
				}
				break;
			}
			while (true)
			{
				tile = Main.tile[num56, num57];
				if (tile.active())
				{
					break;
				}
				num57++;
			}
			num57--;
			tile = Main.tile[num56, num57];
			if (tile.wall == 27 && genRand.Next(2) == 0)
			{
				int style = genRand.Next(22, 26);
				PlaceTile(num56, num57, 186, mute: true, forced: false, -1, style);
			}
		}
		for (int num58 = 0; num58 < 20; num58++)
		{
			int num59 = genRand.Next(num10 + 2, num11 - 1);
			int num60 = genRand.Next(num13 + 2, num14 - 1);
			while (true)
			{
				tile = Main.tile[num59, num60];
				if (tile.wall != 27)
				{
					num59 = genRand.Next(num10 + 2, num11 - 1);
					num60 = genRand.Next(num13 + 2, num14 - 1);
					continue;
				}
				break;
			}
			while (true)
			{
				tile = Main.tile[num59, num60];
				if (tile.active())
				{
					num60--;
					continue;
				}
				break;
			}
			while (true)
			{
				tile = Main.tile[num59, num60];
				if (tile.active())
				{
					break;
				}
				num60++;
			}
			num60--;
			tile = Main.tile[num59, num60];
			if (tile.wall == 27 && genRand.Next(2) == 0)
			{
				int x = genRand.Next(31, 34);
				PlaceSmallPile(num59, num60, x, 1, 185);
			}
		}
		for (int num61 = 0; num61 < 15; num61++)
		{
			int num62 = genRand.Next(num10 + 2, num11 - 1);
			int num63 = genRand.Next(num13 + 2, num14 - 1);
			while (true)
			{
				tile = Main.tile[num62, num63];
				if (tile.wall != 27)
				{
					num62 = genRand.Next(num10 + 2, num11 - 1);
					num63 = genRand.Next(num13 + 2, num14 - 1);
					continue;
				}
				break;
			}
			while (true)
			{
				tile = Main.tile[num62, num63];
				if (tile.active())
				{
					num63--;
					continue;
				}
				break;
			}
			while (num63 > 0)
			{
				tile = Main.tile[num62, num63 - 1];
				if (tile.active())
				{
					break;
				}
				num63--;
			}
			tile = Main.tile[num62, num63];
			if (tile.wall != 27)
			{
				continue;
			}
			int num64 = 4;
			int style2 = 0;
			if (genRand.Next(10) < 9)
			{
				num64 = -1;
			}
			else
			{
				num64 = 34;
				style2 = genRand.Next(6);
			}
			if (num64 <= 0)
			{
				continue;
			}
			PlaceTile(num62, num63, num64, mute: true, forced: false, -1, style2);
			tile = Main.tile[num62, num63];
			if (tile.type != num64)
			{
				continue;
			}
			if (num64 == 4)
			{
				tile = Main.tile[num62, num63];
				tile.frameX += 54;
				continue;
			}
			int num65 = num62;
			int num67 = num63;
			tile = Main.tile[num65, num67];
			num63 = num67 - tile.frameY % 54 / 18;
			tile = Main.tile[num65, num67];
			num62 = tile.frameX / 18;
			if (num62 > 2)
			{
				num62 -= 3;
			}
			num62 = num65 - num62;
			short num68 = 54;
			tile = Main.tile[num62, num63];
			if (tile.frameX > 0)
			{
				num68 = -54;
			}
			for (int num69 = num62; num69 < num62 + 3; num69++)
			{
				for (int num70 = num63; num70 < num63 + 3; num70++)
				{
					tile = Main.tile[num69, num70];
					tile.frameX += num68;
				}
			}
		}
	}

	public static void CountTiles(int X)
	{
		if (X == 0)
		{
			totalEvil = totalEvil2;
			totalBlood = totalBlood2;
			totalSolid = totalSolid2;
			totalGood = totalGood2;
			tGood = (byte)Math.Round((double)totalGood / (double)totalSolid * 100.0);
			tEvil = (byte)Math.Round((double)totalEvil / (double)totalSolid * 100.0);
			tBlood = (byte)Math.Round((double)totalBlood / (double)totalSolid * 100.0);
			if (tGood == 0 && totalGood > 0)
			{
				tGood = 1;
			}
			if (tEvil == 0 && totalEvil > 0)
			{
				tEvil = 1;
			}
			if (tBlood == 0 && totalBlood > 0)
			{
				tBlood = 1;
			}
			if (Main.netMode == 2)
			{
				NetMessage.SendData(57);
			}
			totalEvil2 = 0;
			totalSolid2 = 0;
			totalGood2 = 0;
			totalBlood2 = 0;
		}
		ushort num = 0;
		ushort num2 = 0;
		int num3 = 0;
		int num4 = 0;
		int num5 = 0;
		do
		{
			int num6;
			int num7;
			if (num4 == 0)
			{
				num6 = 0;
				num5 = (int)(Main.worldSurface + 1.0);
				num7 = 5;
			}
			else
			{
				num6 = num5;
				num5 = Main.maxTilesY;
				num7 = 1;
			}
			for (int i = num6; i < num5; i++)
			{
				Tile tile = Main.tile[X, i];
				if (tile == null)
				{
					Tile tile3 = (Main.tile[X, i] = default(Tile));
					tile = tile3;
				}
				num = tile.type;
				if (num != 0 || tile.active())
				{
					if (num == num2)
					{
						num3 += num7;
						continue;
					}
					tileCounts[num2] += num3;
					num2 = num;
					num3 = num7;
				}
			}
			tileCounts[num2] += num3;
			num3 = 0;
			num4++;
		}
		while (num4 < 2);
		AddUpAlignmentCounts();
	}

	public static void AddUpAlignmentCounts(bool clearCounts = false)
	{
		if (clearCounts)
		{
			totalEvil2 = 0;
			totalSolid2 = 0;
			totalGood2 = 0;
			totalBlood2 = 0;
		}
		for (int i = 0; i < TileID.Sets.HallowCountCollection.Count; i++)
		{
			totalGood2 += tileCounts[TileID.Sets.HallowCountCollection[i]];
		}
		for (int j = 0; j < TileID.Sets.CorruptCountCollection.Count; j++)
		{
			totalEvil2 += tileCounts[TileID.Sets.CorruptCountCollection[j]];
		}
		for (int k = 0; k < TileID.Sets.CrimsonCountCollection.Count; k++)
		{
			totalBlood2 += tileCounts[TileID.Sets.CrimsonCountCollection[k]];
		}
		totalSolid2 += tileCounts[2] + tileCounts[477] + tileCounts[1] + tileCounts[60] + tileCounts[53] + tileCounts[161];
		totalSolid2 += tileCounts[164] + tileCounts[109] + tileCounts[492] + tileCounts[117] + tileCounts[116];
		totalSolid2 += tileCounts[23] + tileCounts[661] + tileCounts[163] + tileCounts[112] + tileCounts[25];
		totalSolid2 += tileCounts[199] + tileCounts[662] + tileCounts[234] + tileCounts[203] + tileCounts[200];
		Array.Clear(tileCounts, 0, tileCounts.Length);
	}

	public static void plantDye(int i, int j, bool exoticPlant = false)
	{
		UnifiedRandom unifiedRandom = (gen ? genRand : Main.rand);
		if (!Main.tile[i, j].active() || i < 95 || i > Main.maxTilesX - 95 || j < 95 || j > Main.maxTilesY - 95)
		{
			return;
		}
		int num = 90;
		if (exoticPlant)
		{
			num = 240;
		}
		if (((double)j < Main.worldSurface || remixWorldGen) && (!Main.tile[i, j - 1].active() || Main.tile[i, j - 1].type == 3 || Main.tile[i, j - 1].type == 51 || Main.tile[i, j - 1].type == 61 || Main.tile[i, j - 1].type == 73 || Main.tile[i, j - 1].type == 74 || Main.tile[i, j - 1].type == 184))
		{
			int num12 = Utils.Clamp(i - num, 1, Main.maxTilesX - 1 - 1);
			int num6 = Utils.Clamp(i + num, 1, Main.maxTilesX - 1 - 1);
			int num7 = Utils.Clamp(j - num, 1, Main.maxTilesY - 1 - 1);
			int num8 = Utils.Clamp(j + num, 1, Main.maxTilesY - 1 - 1);
			for (int k = num12; k < num6; k++)
			{
				for (int l = num7; l < num8; l++)
				{
					if (Main.tile[k, l].active() && Main.tile[k, l].type == 227 && (!exoticPlant || Main.tile[k, l].frameX >= 272) && (exoticPlant || Main.tile[k, l].frameX < 272))
					{
						return;
					}
				}
			}
			if (exoticPlant)
			{
				int type = Main.tile[i, j].type;
				bool flag = TileID.Sets.Conversion.Grass[type] || TileID.Sets.Conversion.Moss[type] || type == 0;
				if (Main.tile[i, j - 1].liquid > 0 && (Main.tile[i, j - 1].lava() || Main.tile[i, j - 1].honey()))
				{
					flag = false;
				}
				if (flag)
				{
					PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, genRand.Next(8, 12));
				}
			}
			else if (Main.tile[i, j].type == 2 || Main.tile[i, j].type == 109)
			{
				if (unifiedRandom.Next(4) == 0)
				{
					PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 4);
				}
				else
				{
					PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 3);
				}
			}
			else if (Main.tile[i, j].type == 60)
			{
				if (unifiedRandom.Next(2) == 0)
				{
					PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 2);
				}
				else
				{
					PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 4);
				}
			}
			else if (Main.tile[i, j].type == 53 && Main.tile[i, j - 1].liquid == byte.MaxValue && Main.tile[i, j - 2].liquid == byte.MaxValue)
			{
				PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 2);
			}
			else if (Main.tile[i, j].type == 80 && !Main.tile[i - 1, j - 1].active() && !Main.tile[i + 1, j - 1].active())
			{
				try
				{
					bool flag2 = true;
					for (int m = i - 5; m <= i + 5; m++)
					{
						for (int n = j - 5; n <= j + 15; n++)
						{
							if (Main.tile[m, n].active() && (Main.tile[m, n].type == 112 || Main.tile[m, n].type == 234))
							{
								flag2 = false;
							}
						}
					}
					if (flag2)
					{
						PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 6);
					}
				}
				catch
				{
				}
			}
		}
		if ((!((double)j >= Main.worldSurface) && !remixWorldGen) || j >= Main.UnderworldLayer)
		{
			return;
		}
		if (!Main.tile[i, j - 1].active() || Main.tile[i, j - 1].type == 3 || Main.tile[i, j - 1].type == 51 || Main.tile[i, j - 1].type == 61 || Main.tile[i, j - 1].type == 73 || Main.tile[i, j - 1].type == 74 || Main.tile[i, j - 1].type == 184)
		{
			int num13 = Utils.Clamp(i - num, 1, Main.maxTilesX - 1 - 1);
			int num9 = Utils.Clamp(i + num, 1, Main.maxTilesX - 1 - 1);
			int num10 = Utils.Clamp(j - num, 1, Main.maxTilesY - 1 - 1);
			int num11 = Utils.Clamp(j + num, 1, Main.maxTilesY - 1 - 1);
			for (int num2 = num13; num2 < num9; num2++)
			{
				for (int num3 = num10; num3 < num11; num3++)
				{
					if (Main.tile[num2, num3].active() && Main.tile[num2, num3].type == 227 && (!exoticPlant || Main.tile[num2, num3].frameX >= 272) && (exoticPlant || Main.tile[num2, num3].frameX < 272))
					{
						return;
					}
				}
			}
			if (exoticPlant)
			{
				int type2 = Main.tile[i, j].type;
				if (TileID.Sets.Conversion.Grass[type2] || TileID.Sets.Conversion.Moss[type2] || type2 == 0)
				{
					PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, genRand.Next(8, 12));
				}
			}
			else if (Main.tile[i, j].type == 60)
			{
				if (unifiedRandom.Next(2) == 0)
				{
					PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 2);
				}
				else if (unifiedRandom.Next(2) == 0)
				{
					PlaceTile(i, j - 1, 227, mute: true);
				}
				else
				{
					PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 1);
				}
			}
			else if (Main.tile[i, j].type == 0 || Main.tile[i, j].type == 1 || Main.tile[i, j].type == 59)
			{
				if (unifiedRandom.Next(2) == 0)
				{
					PlaceTile(i, j - 1, 227, mute: true);
				}
				else
				{
					PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 1);
				}
			}
			else if (Main.tile[i, j - 1].liquid == byte.MaxValue && Main.tile[i, j - 2].liquid == byte.MaxValue)
			{
				PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 5);
			}
		}
		if (Main.tile[i, j + 1].active() || exoticPlant)
		{
			return;
		}
		for (int num4 = i - num; num4 < i + num; num4++)
		{
			for (int num5 = j - num; num5 < j + num; num5++)
			{
				if (Main.tile[num4, num5].active() && Main.tile[num4, num5].type == 227)
				{
					return;
				}
			}
		}
		if (Main.tile[i, j].type == 0)
		{
			PlaceTile(i, j + 1, 227, mute: true, forced: false, -1, 7);
		}
	}

	private static int MossConversion(int thisType, int otherType)
	{
		if (TileID.Sets.tileMossBrick[thisType] && otherType == 38)
		{
			return thisType;
		}
		if (Main.tileMoss[thisType] && otherType == 1)
		{
			return thisType;
		}
		return thisType switch
		{
			182 => 515, 
			515 => 182, 
			180 => 513, 
			513 => 180, 
			179 => 512, 
			512 => 179, 
			381 => 517, 
			517 => 381, 
			534 => 535, 
			535 => 534, 
			536 => 537, 
			537 => 536, 
			539 => 540, 
			540 => 539, 
			625 => 626, 
			626 => 625, 
			627 => 628, 
			628 => 627, 
			183 => 516, 
			516 => 183, 
			181 => 514, 
			514 => 181, 
			_ => 0, 
		};
	}

	public static void UpdateWorld()
	{
		if (!gen)
		{
			SystemLoader.PreUpdateWorld();
			UpdateWorld_Inner();
			SystemLoader.PostUpdateWorld();
		}
	}

	private static void UpdateWorld_Inner()
	{
		//IL_04e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_054a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0551: Unknown result type (might be due to invalid IL or missing references)
		//IL_045b: Unknown result type (might be due to invalid IL or missing references)
		AllowedToSpreadInfections = true;
		CreativePowers.StopBiomeSpreadPower power = CreativePowerManager.Instance.GetPower<CreativePowers.StopBiomeSpreadPower>();
		if (power != null && power.GetIsUnlocked())
		{
			AllowedToSpreadInfections = !power.Enabled;
		}
		int wallDist = 3;
		Wiring.UpdateMech();
		TileEntity.UpdateStart();
		foreach (TileEntity value in TileEntity.ByID.Values)
		{
			value.Update();
		}
		TileEntity.UpdateEnd();
		UpdateLunarApocalypse();
		if (Main.netMode != 1)
		{
			totalD++;
			if (totalD >= 30)
			{
				totalD = 0;
				CountTiles(totalX);
				totalX++;
				if (totalX >= Main.maxTilesX)
				{
					totalX = 0;
				}
			}
		}
		Liquid.skipCount++;
		if (Liquid.skipCount > 1)
		{
			Liquid.UpdateLiquid();
			Liquid.skipCount = 0;
		}
		double worldUpdateRate = GetWorldUpdateRate();
		if (worldUpdateRate == 0.0)
		{
			return;
		}
		double num = 3E-05f * (float)worldUpdateRate;
		double num9 = 1.5E-05f * (float)worldUpdateRate;
		double num10 = 2.5E-05f * (float)worldUpdateRate;
		bool checkNPCSpawns = false;
		spawnDelay++;
		if (Main.invasionType > 0 || Main.eclipse)
		{
			spawnDelay = 0;
		}
		if (spawnDelay >= 20)
		{
			checkNPCSpawns = true;
			spawnDelay = 0;
			if (prioritizedTownNPCType != 37)
			{
				for (int i = 0; i < 200; i++)
				{
					if (Main.npc[i].active && Main.npc[i].homeless && Main.npc[i].townNPC && Main.npc[i].type != 368 && ((!(Main.npc[i].ModNPC?.TownNPCStayingHomeless)) ?? true))
					{
						prioritizedTownNPCType = Main.npc[i].type;
						break;
					}
				}
			}
		}
		double num11 = (double)(Main.maxTilesX * Main.maxTilesY) * num;
		int num12 = 151;
		int num13 = (int)Utils.Lerp(num12, (double)num12 * 2.8, Utils.Clamp((double)Main.maxTilesX / 4200.0 - 1.0, 0.0, 1.0));
		for (int j = 0; (double)j < num11; j++)
		{
			if (Main.rand.Next(num13 * 100) == 0)
			{
				PlantAlch();
			}
			int i2 = genRand.Next(10, Main.maxTilesX - 10);
			int j2 = genRand.Next(10, (int)Main.worldSurface - 1);
			UpdateWorld_OvergroundTile(i2, j2, checkNPCSpawns, wallDist);
		}
		if (Main.remixWorld)
		{
			for (int k = 0; (double)k < (double)(Main.maxTilesX * Main.maxTilesY) * num10; k++)
			{
				int i3 = genRand.Next(10, Main.maxTilesX - 10);
				int j3 = genRand.Next((int)Main.worldSurface - 1, Main.maxTilesY - 20);
				growGrassUnderground = true;
				UpdateWorld_UndergroundTile(i3, j3, checkNPCSpawns, wallDist);
				UpdateWorld_OvergroundTile(i3, j3, checkNPCSpawns, wallDist);
				growGrassUnderground = false;
			}
		}
		else
		{
			for (int l = 0; (double)l < (double)(Main.maxTilesX * Main.maxTilesY) * num9; l++)
			{
				int i4 = genRand.Next(10, Main.maxTilesX - 10);
				int j4 = genRand.Next((int)Main.worldSurface - 1, Main.maxTilesY - 20);
				UpdateWorld_UndergroundTile(i4, j4, checkNPCSpawns, wallDist);
			}
		}
		if (Main.dayTime && !Main.remixWorld)
		{
			return;
		}
		Vector2 position = default(Vector2);
		for (int m = 0; m < Main.worldEventUpdates; m++)
		{
			double num14 = (double)Main.maxTilesX / 4200.0;
			num14 *= (double)Star.starfallBoost;
			if (!((double)Main.rand.Next(8000) < 10.0 * num14))
			{
				continue;
			}
			int num15 = 12;
			int num16 = Main.rand.Next(Main.maxTilesX - 50) + 100;
			num16 *= 16;
			int num2 = Main.rand.Next((int)((double)Main.maxTilesY * 0.05));
			num2 *= 16;
			((Vector2)(ref position))._002Ector((float)num16, (float)num2);
			int num3 = -1;
			if (Main.expertMode && Main.rand.Next(15) == 0)
			{
				int num4 = Player.FindClosest(position, 1, 1);
				if ((double)Main.player[num4].position.Y < Main.worldSurface * 16.0 && Main.player[num4].afkCounter < 3600)
				{
					int num5 = Main.rand.Next(1, 640);
					position.X = Main.player[num4].position.X + (float)Main.rand.Next(-num5, num5 + 1);
					num3 = num4;
				}
			}
			if (!Collision.SolidCollision(position, 16, 16))
			{
				float num6 = Main.rand.Next(-100, 101);
				float num7 = Main.rand.Next(200) + 100;
				float num8 = (float)Math.Sqrt(num6 * num6 + num7 * num7);
				num8 = (float)num15 / num8;
				num6 *= num8;
				num7 *= num8;
				Projectile.NewProjectile(new EntitySource_Misc("FallingStar"), position.X, position.Y, num6, num7, 720, 0, 0f, Main.myPlayer, 0f, num3);
			}
		}
	}

	public static double GetWorldUpdateRate()
	{
		double result = Math.Min(Main.desiredWorldTilesUpdateRate, 24.0);
		if (CreativePowerManager.Instance.GetPower<CreativePowers.FreezeTime>().Enabled)
		{
			result = 0.0;
		}
		return result;
	}

	private static void UpdateWorld_OvergroundTile(int i, int j, bool checkNPCSpawns, int wallDist)
	{
		TileLoader.RandomUpdate(i, j, Main.tile[i, j].type);
		WallLoader.RandomUpdate(i, j, Main.tile[i, j].wall);
		int num = i - 1;
		int num11 = i + 2;
		int num22 = j - 1;
		int num33 = j + 2;
		if (num < 10)
		{
			num = 10;
		}
		if (num11 > Main.maxTilesX - 10)
		{
			num11 = Main.maxTilesX - 10;
		}
		if (num22 < 10)
		{
			num22 = 10;
		}
		if (num33 > Main.maxTilesY - 10)
		{
			num33 = Main.maxTilesY - 10;
		}
		if (Main.tile[i, j] == null)
		{
			return;
		}
		if (Main.tile[i, j].type == 655 && !NPC.AnyNPCs(262))
		{
			KillTile(i, j);
			if (Main.netMode == 2)
			{
				NetMessage.SendData(17, -1, -1, null, 0, i, j);
			}
		}
		if (Main.tile[i, j].type == 85)
		{
			TryGrowingAbigailsFlower(i, j);
		}
		else if (Main.tileAlch[Main.tile[i, j].type])
		{
			GrowAlch(i, j);
		}
		else if ((double)j < Main.worldSurface + 10.0 && (i < beachDistance || i > Main.maxTilesX - beachDistance) && !Main.tile[i, j].active())
		{
			int num43 = 3000;
			num43 -= (int)(Math.Abs(Main.windSpeedCurrent) * 1250f);
			if (Main.raining)
			{
				num43 -= (int)(1250f * Main.maxRaining);
			}
			if (num43 < 300)
			{
				num43 = 300;
			}
			if (genRand.Next(num43) == 0)
			{
				int k;
				for (k = j; (double)k < Main.worldSurface + 10.0 && !Main.tile[i, k].active() && k - j < 15; k++)
				{
				}
				if (Main.tile[i, k].active() && Main.tile[i, k].type == 53 && SolidTileAllowBottomSlope(i, k))
				{
					k--;
					int num44 = genRand.Next(2, 5);
					int num45 = genRand.Next(8, 11);
					int num46 = 0;
					for (int l = i - num45; l <= i + num45; l++)
					{
						for (int m = k - num45; m <= k + num45; m++)
						{
							if (Main.tile[l, m].active() && (Main.tile[l, m].type == 324 || Main.tile[l, m].type == 81))
							{
								num46++;
							}
						}
					}
					if (num46 < num44)
					{
						if (genRand.Next(2) == 0 && Main.tile[i, k].liquid >= 230)
						{
							PlaceTile(i, k, 81, mute: true);
							if (Main.netMode == 2 && Main.tile[i, k].active())
							{
								NetMessage.SendTileSquare(-1, i, k);
							}
						}
						else
						{
							PlaceTile(i, k, 324, mute: true, forced: false, -1, RollRandomSeaShellStyle());
							if (Main.netMode == 2 && Main.tile[i, k].active())
							{
								NetMessage.SendTileSquare(-1, i, k);
							}
						}
					}
				}
			}
		}
		if ((Main.tile[i, j].type == 596 || Main.tile[i, j].type == 616 || Main.tile[i, j].type == 595 || Main.tile[i, j].type == 615) && (Main.tile[i, j + 1].type == 199 || Main.tile[i, j + 1].type == 23))
		{
			KillTile(i, j);
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, i, j);
			}
		}
		if ((Main.tile[i, j].type == 571 || (Main.tile[i, j].type == 60 && Main.tile[i, j - 1].liquid > 0)) && genRand.Next(5) == 0 && (!Main.tile[i, j - 1].active() || Main.tile[i, j - 1].type == 61 || Main.tile[i, j - 1].type == 74 || Main.tile[i, j - 1].type == 518) && (Main.tile[i, j].type != 60 || genRand.Next(30) == 0) && PlaceBamboo(i, j - 1))
		{
			NetMessage.SendTileSquare(-1, i, j - 1, 1, 2);
		}
		if (Main.tile[i, j].type == 518)
		{
			if (Main.tile[i, j].liquid == 0 || (Main.tile[i, j].liquid / 16 >= 9 && SolidTile(i, j - 1)) || (Main.tile[i, j - 1].liquid > 0 && Main.tile[i, j - 1].active()))
			{
				KillTile(i, j);
				if (Main.netMode == 2)
				{
					NetMessage.SendData(17, -1, -1, null, 0, i, j);
				}
			}
			else
			{
				CheckLilyPad(i, j);
			}
		}
		else if (Main.tile[i, j].type == 519)
		{
			CheckCatTail(i, j);
			if (Main.tile[i, j].active() && genRand.Next(8) == 0)
			{
				GrowCatTail(i, j);
				CheckCatTail(i, j);
			}
		}
		else if (Main.tile[i, j].liquid > 32)
		{
			if (Main.tile[i, j].active())
			{
				if (TileID.Sets.SlowlyDiesInWater[Main.tile[i, j].type])
				{
					KillTile(i, j);
					if (Main.netMode == 2)
					{
						NetMessage.SendData(17, -1, -1, null, 0, i, j);
					}
				}
				else if (Main.tile[i, j].type == 60)
				{
					UpdateWorld_GrassGrowth(i, j, num, num11, num22, num33, underground: false);
				}
			}
			else if (genRand.Next(600) == 0)
			{
				PlaceTile(i, j, 518, mute: true);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, j);
				}
			}
			else if (genRand.Next(600) == 0)
			{
				PlaceTile(i, j, 519, mute: true);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, j);
				}
			}
		}
		else if (Main.tile[i, j].nactive())
		{
			hardUpdateWorld(i, j);
			if (Main.rand.Next(3000) == 0)
			{
				plantDye(i, j);
			}
			else if (Main.hardMode && ((double)i < (double)Main.maxTilesX * 0.4 || (double)i > (double)Main.maxTilesX * 0.6) && Main.rand.Next(15000) == 0)
			{
				plantDye(i, j, exoticPlant: true);
			}
			if (Main.tile[i, j].type == 80)
			{
				if (genRand.Next(15) == 0)
				{
					GrowCactus(i, j);
				}
			}
			else if (Main.tile[i, j].type == 529)
			{
				if (CheckSeaOat(i, j) && genRand.Next(20) == 0)
				{
					GrowSeaOat(i, j);
				}
			}
			else if (TileID.Sets.Conversion.Sand[Main.tile[i, j].type])
			{
				if (!Main.tile[i, num22].active())
				{
					if (genRand.Next(25) == 0)
					{
						PlaceOasisPlant(i, num22, 530);
						if (Main.tile[i, num22].type == 530 && Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i - 1, num22 - 1, 3, 2);
						}
					}
					if (genRand.Next(20) != 0 || !PlantSeaOat(i, num22))
					{
						if (i < oceanDistance || i > Main.maxTilesX - oceanDistance)
						{
							if (genRand.Next(500) == 0)
							{
								int num47 = 7;
								int num2 = 6;
								int num3 = 0;
								for (int n = i - num47; n <= i + num47; n++)
								{
									for (int num4 = num22 - num47; num4 <= num22 + num47; num4++)
									{
										if (Main.tile[n, num4].active() && Main.tile[n, num4].type == 81)
										{
											num3++;
										}
									}
								}
								if (num3 < num2 && Main.tile[i, num22].liquid == byte.MaxValue && Main.tile[i, num22 - 1].liquid == byte.MaxValue && Main.tile[i, num22 - 2].liquid == byte.MaxValue && Main.tile[i, num22 - 3].liquid == byte.MaxValue && Main.tile[i, num22 - 4].liquid == byte.MaxValue)
								{
									PlaceTile(i, num22, 81, mute: true);
									if (Main.netMode == 2 && Main.tile[i, num22].active())
									{
										NetMessage.SendTileSquare(-1, i, num22);
									}
								}
							}
						}
						else if (i > beachDistance + 20 && i < Main.maxTilesX - beachDistance - 20 && genRand.Next(300) == 0)
						{
							GrowCactus(i, j);
						}
					}
				}
			}
			else if (Main.tile[i, j].type == 530)
			{
				if (!OasisPlantWaterCheck(i, j, boost: true))
				{
					KillTile(i, j);
					if (Main.netMode == 2)
					{
						NetMessage.SendData(17, -1, -1, null, 0, i, j);
					}
				}
			}
			else if (Main.tile[i, j].type == 147 || Main.tile[i, j].type == 161 || Main.tile[i, j].type == 163 || Main.tile[i, j].type == 164 || Main.tile[i, j].type == 200)
			{
				if (Main.rand.Next(10) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 2].active())
				{
					int num48 = i - 3;
					int num5 = i + 4;
					int num6 = 0;
					for (int num7 = num48; num7 < num5; num7++)
					{
						if (Main.tile[num7, j].type == 165 && Main.tile[num7, j].active())
						{
							num6++;
						}
						if (Main.tile[num7, j + 1].type == 165 && Main.tile[num7, j + 1].active())
						{
							num6++;
						}
						if (Main.tile[num7, j + 2].type == 165 && Main.tile[num7, j + 2].active())
						{
							num6++;
						}
						if (Main.tile[num7, j + 3].type == 165 && Main.tile[num7, j + 3].active())
						{
							num6++;
						}
					}
					if (num6 < 2)
					{
						PlaceTight(i, j + 1);
						SquareTileFrame(i, j + 1);
						if (Main.netMode == 2 && Main.tile[i, j + 1].active())
						{
							NetMessage.SendTileSquare(-1, i, j + 1, 1, 2);
						}
					}
				}
			}
			else if (Main.tile[i, j].type == 254)
			{
				if (Main.rand.Next((Main.tile[i, j].frameX + 10) / 10) == 0)
				{
					GrowPumpkin(i, j, 254);
				}
			}
			else if (Main.tile[i, j].type == 78 || Main.tile[i, j].type == 380 || Main.tile[i, j].type == 579)
			{
				if (!Main.tile[i, num22].active() && genRand.Next(2) == 0)
				{
					PlaceTile(i, num22, 3, mute: true);
					if (Main.netMode == 2 && Main.tile[i, num22].active())
					{
						NetMessage.SendTileSquare(-1, i, num22);
					}
				}
			}
			else if (TileID.Sets.SpreadOverground[Main.tile[i, j].type])
			{
				UpdateWorld_GrassGrowth(i, j, num, num11, num22, num33, underground: false);
				int type = Main.tile[i, j].type;
				if ((type == 32 || type == 352) && genRand.Next(3) == 0)
				{
					if (type == 32)
					{
						GrowSpike(i, j, 32, 23);
					}
					else
					{
						GrowSpike(i, j, 352, 199);
					}
				}
			}
			else if (Main.tileMoss[Main.tile[i, j].type] || TileID.Sets.tileMossBrick[Main.tile[i, j].type])
			{
				if (genRand.NextDouble() < 0.5)
				{
					int type2 = Main.tile[i, j].type;
					bool flag = false;
					TileColorCache color = Main.tile[i, j].BlockColorAndCoating();
					for (int num8 = num; num8 < num11; num8++)
					{
						for (int num9 = num22; num9 < num33; num9++)
						{
							if ((i != num8 || j != num9) && Main.tile[num8, num9].active() && (Main.tile[num8, num9].type == 1 || Main.tile[num8, num9].type == 38))
							{
								int type3 = Main.tile[num8, num9].type;
								int num10 = MossConversion(type2, type3);
								SpreadGrass(num8, num9, Main.tile[num8, num9].type, num10, repeat: false, color);
								if (Main.tile[num8, num9].type == num10)
								{
									SquareTileFrame(num8, num9);
									flag = true;
								}
							}
						}
					}
					if (Main.netMode == 2 && flag)
					{
						NetMessage.SendTileSquare(-1, i, j, 3);
					}
					if (genRand.Next(6) == 0)
					{
						int num12 = i;
						int num13 = j;
						switch (genRand.Next(4))
						{
						case 0:
							num12--;
							break;
						case 1:
							num12++;
							break;
						case 2:
							num13--;
							break;
						default:
							num13++;
							break;
						}
						if (!Main.tile[num12, num13].active())
						{
							if (PlaceTile(num12, num13, 184, mute: true))
							{
								Main.tile[num12, num13].CopyPaintAndCoating(Main.tile[i, j]);
							}
							if (Main.netMode == 2 && Main.tile[num12, num13].active())
							{
								NetMessage.SendTileSquare(-1, num12, num13);
							}
						}
					}
				}
			}
			else if (Main.tile[i, j].type == 20)
			{
				if (genRand.Next(20) == 0)
				{
					AttemptToGrowTreeFromSapling(i, j, underground: false);
				}
			}
			else if (Main.tile[i, j].type == 595)
			{
				if (genRand.Next(5) == 0)
				{
					AttemptToGrowTreeFromSapling(i, j, underground: false);
				}
			}
			else if (Main.tile[i, j].type == 615)
			{
				if (genRand.Next(5) == 0)
				{
					AttemptToGrowTreeFromSapling(i, j, underground: false);
				}
			}
			else if (Main.tile[i, j].type == 3 && genRand.Next(20) == 0)
			{
				if (Main.tile[i, j].frameX != 144)
				{
					Main.tile[i, j].type = 73;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, j);
					}
				}
			}
			else if (Main.tile[i, j].type == 110 && genRand.Next(20) == 0 && Main.tile[i, j].frameX < 144)
			{
				Main.tile[i, j].type = 113;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, j);
				}
			}
		}
		else
		{
			if (Main.tile[i, j].wall == 62 && Main.tile[i, j].liquid == 0)
			{
				GrowWeb(i, j);
			}
			if (checkNPCSpawns)
			{
				TrySpawningTownNPC(i, j);
			}
		}
		if (AllowedToSpreadInfections)
		{
			if (Main.tile[i, j].wall == 81 || Main.tile[i, j].wall == 83 || (Main.tile[i, j].type == 199 && Main.tile[i, j].active()))
			{
				int num14 = i + genRand.Next(-2, 3);
				int num15 = j + genRand.Next(-2, 3);
				if (InWorld(num14, num15, 10) && Main.tile[num14, num15].wall >= 63 && Main.tile[num14, num15].wall <= 68)
				{
					bool flag4 = false;
					for (int num16 = i - wallDist; num16 < i + wallDist; num16++)
					{
						for (int num17 = j - wallDist; num17 < j + wallDist; num17++)
						{
							if (Main.tile[num16, num17].active())
							{
								int type4 = Main.tile[num16, num17].type;
								if (type4 == 199 || type4 == 200 || type4 == 201 || type4 == 203 || type4 == 205 || type4 == 234 || type4 == 352 || type4 == 662)
								{
									flag4 = true;
									break;
								}
							}
						}
					}
					if (flag4)
					{
						Main.tile[num14, num15].wall = 81;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num14, num15);
						}
					}
				}
			}
			else if (Main.tile[i, j].wall == 69 || Main.tile[i, j].wall == 3 || (Main.tile[i, j].type == 23 && Main.tile[i, j].active()))
			{
				int num18 = i + genRand.Next(-2, 3);
				int num19 = j + genRand.Next(-2, 3);
				if (InWorld(num18, num19, 10) && Main.tile[num18, num19].wall >= 63 && Main.tile[num18, num19].wall <= 68)
				{
					bool flag5 = false;
					for (int num20 = i - wallDist; num20 < i + wallDist; num20++)
					{
						for (int num21 = j - wallDist; num21 < j + wallDist; num21++)
						{
							if (Main.tile[num20, num21].active())
							{
								int type5 = Main.tile[num20, num21].type;
								if (type5 == 22 || type5 == 23 || type5 == 24 || type5 == 25 || type5 == 32 || type5 == 112 || type5 == 163 || type5 == 636 || type5 == 661)
								{
									flag5 = true;
									break;
								}
							}
						}
					}
					if (flag5)
					{
						Main.tile[num18, num19].wall = 69;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num18, num19);
						}
					}
				}
			}
			else if (Main.tile[i, j].wall == 70 || (Main.tile[i, j].type == 109 && Main.tile[i, j].active()))
			{
				int num23 = i + genRand.Next(-2, 3);
				int num24 = j + genRand.Next(-2, 3);
				if ((InWorld(num23, num24, 10) && Main.tile[num23, num24].wall == 63) || Main.tile[num23, num24].wall == 65 || Main.tile[num23, num24].wall == 66 || Main.tile[num23, num24].wall == 68)
				{
					bool flag6 = false;
					for (int num25 = i - wallDist; num25 < i + wallDist; num25++)
					{
						for (int num26 = j - wallDist; num26 < j + wallDist; num26++)
						{
							if (Main.tile[num25, num26].active())
							{
								int type6 = Main.tile[num25, num26].type;
								if (type6 == 109 || type6 == 110 || type6 == 113 || type6 == 115 || type6 == 116 || type6 == 117 || type6 == 164)
								{
									flag6 = true;
									break;
								}
							}
						}
					}
					if (flag6)
					{
						Main.tile[num23, num24].wall = 70;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num23, num24);
						}
					}
				}
			}
			SpreadDesertWalls(wallDist, i, j);
		}
		if (Main.tile[i, j].nactive())
		{
			if (Main.tile[i, j].type == 2 || Main.tile[i, j].type == 52 || Main.tile[i, j].type == 382 || (Main.tile[i, j].type == 192 && genRand.Next(10) == 0))
			{
				int num27 = 60;
				if (Main.tile[i, j].type == 52 || Main.tile[i, j].type == 382)
				{
					num27 = 20;
				}
				num27 = 1;
				if (genRand.Next(num27) == 0 && GrowMoreVines(i, j) && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
				{
					bool flag7 = false;
					ushort type7 = 52;
					if (Main.tile[i, j].type == 382)
					{
						type7 = 382;
					}
					else if (Main.tile[i, j].type != 52)
					{
						if (Main.tile[i, j].wall == 68 || Main.tile[i, j].wall == 65 || Main.tile[i, j].wall == 66 || Main.tile[i, j].wall == 63)
						{
							type7 = 382;
						}
						else if (Main.tile[i, j + 1].wall == 68 || Main.tile[i, j + 1].wall == 65 || Main.tile[i, j + 1].wall == 66 || Main.tile[i, j + 1].wall == 63)
						{
							type7 = 382;
						}
						if (Main.remixWorld && genRand.Next(5) == 0)
						{
							type7 = 382;
						}
					}
					for (int num28 = j; num28 > j - 10; num28--)
					{
						if (Main.tile[i, num28].bottomSlope())
						{
							flag7 = false;
							break;
						}
						if (Main.tile[i, num28].active() && Main.tile[i, num28].type == 2 && !Main.tile[i, num28].bottomSlope())
						{
							flag7 = true;
							break;
						}
					}
					if (flag7)
					{
						int num29 = j + 1;
						Main.tile[i, num29].type = type7;
						Main.tile[i, num29].active(active: true);
						Main.tile[i, num29].CopyPaintAndCoating(Main.tile[i, j]);
						SquareTileFrame(i, num29);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, num29);
						}
					}
				}
			}
			else if (Main.tile[i, j].type == 61 && genRand.Next(3) == 0 && Main.tile[i, j].frameX < 144)
			{
				if (Main.rand.Next(4) == 0)
				{
					Main.tile[i, j].frameX = (short)(162 + genRand.Next(8) * 18);
				}
				Main.tile[i, j].type = 74;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, j);
				}
			}
			if ((Main.tile[i, j].type == 60 || Main.tile[i, j].type == 62) && GrowMoreVines(i, j))
			{
				int maxValue = 30;
				if (Main.tile[i, j].type == 62)
				{
					maxValue = 10;
				}
				if (genRand.Next(maxValue) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
				{
					bool flag8 = false;
					for (int num30 = j; num30 > j - 10; num30--)
					{
						if (Main.tile[i, num30].bottomSlope())
						{
							flag8 = false;
							break;
						}
						if (Main.tile[i, num30].active() && Main.tile[i, num30].type == 60 && !Main.tile[i, num30].bottomSlope())
						{
							flag8 = true;
							break;
						}
					}
					if (flag8)
					{
						int num31 = j + 1;
						Main.tile[i, num31].type = 62;
						Main.tile[i, num31].active(active: true);
						Main.tile[i, num31].CopyPaintAndCoating(Main.tile[i, j]);
						SquareTileFrame(i, num31);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, num31);
						}
					}
				}
			}
			else if ((Main.tile[i, j].type == 70 || Main.tile[i, j].type == 528) && GrowMoreVines(i, j))
			{
				int maxValue2 = 70;
				if (Main.tile[i, j].type == 528)
				{
					maxValue2 = 7;
				}
				if (genRand.Next(maxValue2) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
				{
					bool flag9 = false;
					for (int num32 = j; num32 > j - 10; num32--)
					{
						if (Main.tile[i, num32].bottomSlope())
						{
							flag9 = false;
							break;
						}
						if (Main.tile[i, num32].active() && Main.tile[i, num32].type == 70 && !Main.tile[i, num32].bottomSlope())
						{
							flag9 = true;
							break;
						}
					}
					if (flag9)
					{
						int num34 = j + 1;
						Main.tile[i, num34].type = 528;
						Main.tile[i, num34].active(active: true);
						Main.tile[i, num34].CopyPaintAndCoating(Main.tile[i, j]);
						SquareTileFrame(i, num34);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, num34);
						}
					}
				}
			}
			else if ((Main.tile[i, j].type == 109 || Main.tile[i, j].type == 115) && GrowMoreVines(i, j))
			{
				int maxValue3 = 60;
				if (Main.tile[i, j].type == 115)
				{
					maxValue3 = 20;
				}
				if (genRand.Next(maxValue3) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
				{
					bool flag10 = false;
					for (int num35 = j; num35 > j - 10; num35--)
					{
						if (Main.tile[i, num35].bottomSlope())
						{
							flag10 = false;
							break;
						}
						if (Main.tile[i, num35].active() && Main.tile[i, num35].type == 109 && !Main.tile[i, num35].bottomSlope())
						{
							flag10 = true;
							break;
						}
					}
					if (flag10)
					{
						int num36 = j + 1;
						Main.tile[i, num36].type = 115;
						Main.tile[i, num36].active(active: true);
						Main.tile[i, num36].CopyPaintAndCoating(Main.tile[i, j]);
						SquareTileFrame(i, num36);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, num36);
						}
					}
				}
			}
			else if ((Main.tile[i, j].type == 23 || Main.tile[i, j].type == 661 || Main.tile[i, j].type == 636) && GrowMoreVines(i, j))
			{
				int maxValue4 = 60;
				if (Main.tile[i, j].type == 636)
				{
					maxValue4 = 20;
				}
				if (genRand.Next(maxValue4) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
				{
					bool flag11 = false;
					for (int num37 = j; num37 > j - 10; num37--)
					{
						if (Main.tile[i, num37].bottomSlope())
						{
							flag11 = false;
							break;
						}
						if (Main.tile[i, num37].active() && (Main.tile[i, num37].type == 23 || Main.tile[i, num37].type == 661) && !Main.tile[i, num37].bottomSlope())
						{
							flag11 = true;
							break;
						}
					}
					if (flag11)
					{
						int num38 = j + 1;
						Main.tile[i, num38].type = 636;
						Main.tile[i, num38].active(active: true);
						Main.tile[i, num38].CopyPaintAndCoating(Main.tile[i, j]);
						SquareTileFrame(i, num38);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, num38);
						}
					}
				}
			}
			else if ((Main.tile[i, j].type == 199 || Main.tile[i, j].type == 662 || Main.tile[i, j].type == 205) && GrowMoreVines(i, j))
			{
				int maxValue5 = 60;
				if (Main.tile[i, j].type == 205)
				{
					maxValue5 = 20;
				}
				if (genRand.Next(maxValue5) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
				{
					bool flag2 = false;
					for (int num39 = j; num39 > j - 10; num39--)
					{
						if (Main.tile[i, num39].bottomSlope())
						{
							flag2 = false;
							break;
						}
						if (Main.tile[i, num39].active() && (Main.tile[i, num39].type == 199 || Main.tile[i, num39].type == 662) && !Main.tile[i, num39].bottomSlope())
						{
							flag2 = true;
							break;
						}
					}
					if (flag2)
					{
						int num40 = j + 1;
						Main.tile[i, num40].type = 205;
						Main.tile[i, num40].active(active: true);
						Main.tile[i, num40].CopyPaintAndCoating(Main.tile[i, j]);
						SquareTileFrame(i, num40);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, num40);
						}
					}
				}
			}
			else if ((Main.tile[i, j].type == 633 || Main.tile[i, j].type == 638) && GrowMoreVines(i, j))
			{
				int maxValue6 = 70;
				if (Main.tile[i, j].type == 638)
				{
					maxValue6 = 7;
				}
				if (genRand.Next(maxValue6) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
				{
					bool flag3 = false;
					for (int num41 = j; num41 > j - 10; num41--)
					{
						if (Main.tile[i, num41].bottomSlope())
						{
							flag3 = false;
							break;
						}
						if (Main.tile[i, num41].active() && Main.tile[i, num41].type == 633 && !Main.tile[i, num41].bottomSlope())
						{
							flag3 = true;
							break;
						}
					}
					if (flag3)
					{
						int num42 = j + 1;
						Main.tile[i, num42].type = 638;
						Main.tile[i, num42].active(active: true);
						Main.tile[i, num42].CopyPaintAndCoating(Main.tile[i, j]);
						SquareTileFrame(i, num42);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, num42);
						}
					}
				}
			}
		}
		if (!Main.remixWorld && Main.dontStarveWorld && (float)Main.rand.Next(200) < 100f * Main.maxRaining && Main.maxRaining >= 0.2f)
		{
			DontStarveTryWateringTile(i, j);
		}
	}

	public static bool AttemptToGrowTreeFromSapling(int x, int y, bool underground)
	{
		if (Main.netMode == 1)
		{
			return false;
		}
		if (!InWorld(x, y, 2))
		{
			return false;
		}
		Tile tile = Main.tile[x, y];
		if (tile == null || !tile.active())
		{
			return false;
		}
		bool flag = false;
		int num = 0;
		int num2 = -1;
		switch (tile.type)
		{
		case 20:
			switch (tile.frameX / 54)
			{
			case 10:
				flag = TryGrowingTreeByType(634, x, y);
				break;
			case 6:
			case 7:
			case 8:
			case 9:
				if (underground)
				{
					return false;
				}
				flag = GrowPalmTree(x, y);
				break;
			default:
				if (underground)
				{
					return false;
				}
				flag = GrowTree(x, y);
				break;
			}
			if (flag && PlayerLOS(x, y))
			{
				TreeGrowFXCheck(x, y);
			}
			return flag;
		case 595:
			num = tile.frameX / 54;
			num2 = 596;
			if (num == 0)
			{
				num2 = 596;
			}
			flag = TryGrowingTreeByType(num2, x, y);
			if (flag && PlayerLOS(x, y))
			{
				TreeGrowFXCheck(x, y);
			}
			return flag;
		case 615:
			num = tile.frameX / 54;
			num2 = 616;
			if (num == 0)
			{
				num2 = 616;
			}
			flag = TryGrowingTreeByType(num2, x, y);
			if (flag && PlayerLOS(x, y))
			{
				TreeGrowFXCheck(x, y);
			}
			return flag;
		case 590:
			if (!underground)
			{
				return false;
			}
			num = tile.frameX / 54;
			num2 = 587;
			switch (num)
			{
			case 0:
				num2 = 583;
				break;
			case 1:
				num2 = 584;
				break;
			case 2:
				num2 = 585;
				break;
			case 3:
				num2 = 586;
				break;
			case 4:
				num2 = 587;
				break;
			case 5:
				num2 = 588;
				break;
			case 6:
				num2 = 589;
				break;
			}
			flag = TryGrowingTreeByType(num2, x, y);
			if (flag && PlayerLOS(x, y))
			{
				TreeGrowFXCheck(x, y);
			}
			return flag;
		default:
			return false;
		}
	}

	public static void DontStarveTryWateringTile(int x, int y)
	{
		Tile tile = Main.tile[x, y];
		if (tile.active() && TileObjectData.CheckWaterDeath(tile) && !IsSafeFromRain(x, y) && !HasAnyWireNearby(x, y, 0) && !TryToggleLight(x, y, false, skipWires: false))
		{
			KillTile(x, y);
			if (Main.netMode == 2)
			{
				NetMessage.SendData(17, -1, -1, null, 0, x, y);
			}
		}
	}

	public static bool HasAnyWireNearby(int sourceX, int sourceY, int boxSpread)
	{
		int num5 = Utils.Clamp(sourceX - boxSpread, 0, Main.maxTilesX - 1);
		int num2 = Utils.Clamp(sourceX + boxSpread, 0, Main.maxTilesX - 1);
		int num3 = Utils.Clamp(sourceY - boxSpread, 0, Main.maxTilesY - 1);
		int num4 = Utils.Clamp(sourceY + boxSpread, 0, Main.maxTilesY - 1);
		for (int i = num5; i <= num2; i++)
		{
			for (int j = num3; j <= num4; j++)
			{
				Tile tile = Main.tile[i, j];
				if (tile != null && (tile.wire() || tile.wire2() || tile.wire3() || tile.wire4()))
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool IsSafeFromRain(int startX, int startY)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		Vector2D vector2D = -Rain.GetRainFallVelocity().SafeNormalize(new Vector2(0f, 1f)).ToVector2D();
		Vector2D vector2D2 = new Vector2D(startX, startY) * 16.0 + Vector2D.One * 8.0;
		double num = 85.0;
		DelegateMethods.CheckResultOut = false;
		Utils.PlotTileLine(vector2D2, vector2D2 + vector2D * 16.0 * num, 4.0, DelegateMethods.CheckStopForSolids);
		return DelegateMethods.CheckResultOut;
	}

	public static bool TryToggleLight(int x, int y, bool? forcedState, bool skipWires)
	{
		Tile tile = Main.tile[x, y];
		if (!tile.active())
		{
			return false;
		}
		switch (tile.type)
		{
		default:
			return false;
		case 4:
			Wiring.ToggleTorch(x, y, tile, forcedState);
			return true;
		case 33:
		case 49:
		case 174:
		case 372:
		case 646:
			Wiring.ToggleCandle(x, y, tile, forcedState);
			return true;
		case 405:
			Wiring.ToggleFirePlace(x, y, tile, forcedState, skipWires);
			return true;
		case 95:
		case 100:
		case 126:
		case 173:
		case 564:
			Wiring.Toggle2x2Light(x, y, tile, forcedState, skipWires);
			return true;
		case 92:
			Wiring.ToggleLampPost(x, y, tile, forcedState, skipWires);
			return true;
		case 215:
			Wiring.ToggleCampFire(x, y, tile, forcedState, skipWires);
			return true;
		case 34:
			Wiring.ToggleChandelier(x, y, tile, forcedState, skipWires);
			return true;
		case 93:
			Wiring.ToggleLamp(x, y, tile, forcedState, skipWires);
			return true;
		case 42:
			Wiring.ToggleHangingLantern(x, y, tile, forcedState, skipWires);
			return true;
		case 149:
			Wiring.ToggleHolidayLight(x, y, tile, forcedState);
			return true;
		}
	}

	private static bool HasValidGroundForAbigailsFlowerBelowSpot(int x, int y)
	{
		if (!InWorld(x, y, 2))
		{
			return false;
		}
		Tile tile = Main.tile[x, y + 1];
		if (tile == null || !tile.active())
		{
			return false;
		}
		ushort type = tile.type;
		if (type < 0)
		{
			return false;
		}
		if (type != 70 && type != 633 && !TileID.Sets.Conversion.Grass[type])
		{
			return false;
		}
		return SolidTileAllowBottomSlope(x, y + 1);
	}

	private static bool TryGrowingAbigailsFlower(int i, int j)
	{
		if (Main.rand.Next(30) != 0)
		{
			return false;
		}
		int num = 1;
		if (Main.dontStarveWorld)
		{
			num = 2;
		}
		for (int k = 0; k < num; k++)
		{
			int num2 = genRand.Next(Math.Max(10, i - 10), Math.Min(Main.maxTilesX - 10, i + 10));
			int num3 = genRand.Next(Math.Max(10, j - 10), Math.Min(Main.maxTilesY - 10, j + 10));
			if (HasValidGroundForAbigailsFlowerBelowSpot(num2, num3) && NoNearbyAbigailsFlower(num2, num3) && PlaceTile(num2, num3, 624, mute: true))
			{
				if (Main.netMode == 2 && Main.tile[num2, num3] != null && Main.tile[num2, num3].active())
				{
					NetMessage.SendTileSquare(-1, num2, num3);
				}
				return true;
			}
		}
		return false;
	}

	private static bool NoNearbyAbigailsFlower(int i, int j)
	{
		int num5 = Utils.Clamp(i - 120, 10, Main.maxTilesX - 1 - 10);
		int num2 = Utils.Clamp(i + 120, 10, Main.maxTilesX - 1 - 10);
		int num3 = Utils.Clamp(j - 120, 10, Main.maxTilesY - 1 - 10);
		int num4 = Utils.Clamp(j + 120, 10, Main.maxTilesY - 1 - 10);
		for (int k = num5; k <= num2; k++)
		{
			for (int l = num3; l <= num4; l++)
			{
				Tile tile = Main.tile[k, l];
				if (tile.active() && tile.type == 624)
				{
					return false;
				}
			}
		}
		return true;
	}

	private static bool HasValidGroundForGlowTulipBelowSpot(int x, int y)
	{
		if (!InWorld(x, y, 2))
		{
			return false;
		}
		Tile tile = Main.tile[x, y + 1];
		if (tile == null || !tile.active())
		{
			return false;
		}
		ushort type = tile.type;
		if (type < 0)
		{
			return false;
		}
		if (type != 0 && type != 70 && type != 633 && type != 59 && type != 225 && !TileID.Sets.Conversion.Grass[type] && !TileID.Sets.Conversion.Stone[type] && !Main.tileMoss[type])
		{
			return false;
		}
		return SolidTileAllowBottomSlope(x, y + 1);
	}

	private static bool TryGrowingGlowTulip(int i, int j)
	{
		int num = 5;
		for (int k = 0; k < num; k++)
		{
			int num2 = genRand.Next(Math.Max(10, i - 10), Math.Min(Main.maxTilesX - 10, i + 10));
			int num3 = genRand.Next(Math.Max(10, j - 10), Math.Min(Main.maxTilesY - 10, j + 10));
			if (!HasValidGroundForGlowTulipBelowSpot(num2, num3) || !NoNearbyGlowTulips(num2, num3))
			{
				continue;
			}
			PlaceTile(num2, num3, 656, mute: true);
			Tile tile = Main.tile[num2, num3];
			if (tile.active() && tile.type == 656)
			{
				if (!generatingWorld && Main.netMode == 2 && Main.tile[num2, num3] != null && Main.tile[num2, num3].active())
				{
					NetMessage.SendTileSquare(-1, num2, num3);
				}
				return true;
			}
		}
		return false;
	}

	private static bool NoNearbyGlowTulips(int i, int j)
	{
		int num5 = Utils.Clamp(i - 120, 10, Main.maxTilesX - 1 - 10);
		int num2 = Utils.Clamp(i + 120, 10, Main.maxTilesX - 1 - 10);
		int num3 = Utils.Clamp(j - 120, 10, Main.maxTilesY - 1 - 10);
		int num4 = Utils.Clamp(j + 120, 10, Main.maxTilesY - 1 - 10);
		for (int k = num5; k <= num2; k++)
		{
			for (int l = num3; l <= num4; l++)
			{
				Tile tile = Main.tile[k, l];
				if (tile.active() && tile.type == 656)
				{
					return false;
				}
			}
		}
		return true;
	}

	private static void UpdateWorld_UndergroundTile(int i, int j, bool checkNPCSpawns, int wallDist)
	{
		TileLoader.RandomUpdate(i, j, Main.tile[i, j].type);
		WallLoader.RandomUpdate(i, j, Main.tile[i, j].wall);
		int num = i - 1;
		int num12 = i + 2;
		int num22 = j - 1;
		int num33 = j + 2;
		if (num < 10)
		{
			num = 10;
		}
		if (num12 > Main.maxTilesX - 10)
		{
			num12 = Main.maxTilesX - 10;
		}
		if (num22 < 10)
		{
			num22 = 10;
		}
		if (num33 > Main.maxTilesY - 10)
		{
			num33 = Main.maxTilesY - 10;
		}
		if (Main.tile[i, j] == null)
		{
			return;
		}
		if (Main.tile[i, j].type == 655 && !NPC.AnyNPCs(262))
		{
			KillTile(i, j);
			if (Main.netMode == 2)
			{
				NetMessage.SendData(17, -1, -1, null, 0, i, j);
			}
		}
		if (Main.tileAlch[Main.tile[i, j].type])
		{
			GrowAlch(i, j);
		}
		else if (Main.tile[i, j].nactive())
		{
			hardUpdateWorld(i, j);
			if (Main.rand.Next(2500) == 0)
			{
				plantDye(i, j);
			}
			else if (Main.hardMode && Main.rand.Next(10000) == 0)
			{
				plantDye(i, j, exoticPlant: true);
			}
			if (Main.tile[i, j].type == 519)
			{
				CheckCatTail(i, j);
				if (Main.tile[i, j].active() && genRand.Next(2) == 0)
				{
					GrowCatTail(i, j);
					CheckCatTail(i, j);
				}
			}
			if (Main.tile[i, j].type == 549)
			{
				GrowCheckSeaweed(i, j);
			}
			else if (Main.tile[i, j].type == 53 && !Main.tile[i, j].topSlope() && !Main.tile[i, j].halfBrick() && !Main.tile[i, j - 1].active() && genRand.Next(20) == 0)
			{
				GrowCheckSeaweed(i, j);
			}
			else if (TileID.Sets.SpreadUnderground[Main.tile[i, j].type])
			{
				UpdateWorld_GrassGrowth(i, j, num, num12, num22, num33, underground: true);
				int type = Main.tile[i, j].type;
				if ((type == 32 || type == 352) && genRand.Next(3) == 0)
				{
					if (type == 32)
					{
						GrowSpike(i, j, 32, 23);
					}
					else
					{
						GrowSpike(i, j, 352, 199);
					}
				}
			}
			else if (Main.tile[i, j].type == 61 && genRand.Next(3) == 0)
			{
				if (Main.tile[i, j].frameX < 144)
				{
					if (Main.rand.Next(4) == 0)
					{
						Main.tile[i, j].frameX = (short)(162 + genRand.Next(8) * 18);
					}
					Main.tile[i, j].type = 74;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, j);
					}
				}
			}
			else if ((Main.tile[i, j].type == 60 || Main.tile[i, j].type == 62) && genRand.Next(5) == 0 && GrowMoreVines(i, j))
			{
				if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
				{
					bool flag = false;
					for (int num44 = j; num44 > j - 10; num44--)
					{
						if (Main.tile[i, num44].bottomSlope())
						{
							flag = false;
							break;
						}
						if (Main.tile[i, num44].active() && Main.tile[i, num44].type == 60 && !Main.tile[i, num44].bottomSlope())
						{
							flag = true;
							break;
						}
					}
					if (flag)
					{
						int num46 = j + 1;
						Main.tile[i, num46].type = 62;
						Main.tile[i, num46].active(active: true);
						SquareTileFrame(i, num46);
						Main.tile[i, num46].CopyPaintAndCoating(Main.tile[i, num46 - 1]);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, num46);
						}
					}
				}
			}
			else if ((Main.tile[i, j].type == 633 || Main.tile[i, j].type == 638) && GrowMoreVines(i, j))
			{
				if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
				{
					int maxValue = 70;
					if (Main.tile[i, j].type == 638)
					{
						maxValue = 7;
					}
					if (genRand.Next(maxValue) == 0)
					{
						bool flag8 = false;
						for (int num47 = j; num47 > j - 10; num47--)
						{
							if (Main.tile[i, num47].bottomSlope())
							{
								flag8 = false;
								break;
							}
							if (Main.tile[i, num47].active() && Main.tile[i, num47].type == 633 && !Main.tile[i, num47].bottomSlope())
							{
								flag8 = true;
								break;
							}
						}
						if (flag8)
						{
							int num48 = j + 1;
							Main.tile[i, num48].type = 638;
							Main.tile[i, num48].active(active: true);
							Main.tile[i, num48].CopyPaintAndCoating(Main.tile[i, num48 - 1]);
							SquareTileFrame(i, num48);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, num48);
							}
						}
					}
				}
			}
			else if ((Main.tile[i, j].type == 70 || Main.tile[i, j].type == 528) && GrowMoreVines(i, j))
			{
				if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
				{
					int maxValue2 = 70;
					if (Main.tile[i, j].type == 528)
					{
						maxValue2 = 7;
					}
					if (genRand.Next(maxValue2) == 0)
					{
						bool flag9 = false;
						for (int num49 = j; num49 > j - 10; num49--)
						{
							if (Main.tile[i, num49].bottomSlope())
							{
								flag9 = false;
								break;
							}
							if (Main.tile[i, num49].active() && Main.tile[i, num49].type == 70 && !Main.tile[i, num49].bottomSlope())
							{
								flag9 = true;
								break;
							}
						}
						if (flag9)
						{
							int num2 = j + 1;
							Main.tile[i, num2].type = 528;
							Main.tile[i, num2].active(active: true);
							Main.tile[i, num2].CopyPaintAndCoating(Main.tile[i, num2 - 1]);
							SquareTileFrame(i, num2);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, num2);
							}
						}
					}
				}
			}
			else if ((Main.tile[i, j].type == 661 || Main.tile[i, j].type == 636) && GrowMoreVines(i, j))
			{
				if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
				{
					int maxValue3 = 70;
					if (Main.tile[i, j].type == 636)
					{
						maxValue3 = 7;
					}
					if (genRand.Next(maxValue3) == 0)
					{
						bool flag10 = false;
						for (int num3 = j; num3 > j - 10; num3--)
						{
							if (Main.tile[i, num3].bottomSlope())
							{
								flag10 = false;
								break;
							}
							if (Main.tile[i, num3].active() && Main.tile[i, num3].type == 661 && !Main.tile[i, num3].bottomSlope())
							{
								flag10 = true;
								break;
							}
						}
						if (flag10)
						{
							int num4 = j + 1;
							Main.tile[i, num4].type = 636;
							Main.tile[i, num4].active(active: true);
							Main.tile[i, num4].CopyPaintAndCoating(Main.tile[i, num4 - 1]);
							SquareTileFrame(i, num4);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, num4);
							}
						}
					}
				}
			}
			else if ((Main.tile[i, j].type == 662 || Main.tile[i, j].type == 205) && GrowMoreVines(i, j))
			{
				if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
				{
					int maxValue4 = 70;
					if (Main.tile[i, j].type == 205)
					{
						maxValue4 = 7;
					}
					if (genRand.Next(maxValue4) == 0)
					{
						bool flag11 = false;
						for (int num5 = j; num5 > j - 10; num5--)
						{
							if (Main.tile[i, num5].bottomSlope())
							{
								flag11 = false;
								break;
							}
							if (Main.tile[i, num5].active() && Main.tile[i, num5].type == 662 && !Main.tile[i, num5].bottomSlope())
							{
								flag11 = true;
								break;
							}
						}
						if (flag11)
						{
							int num6 = j + 1;
							Main.tile[i, num6].type = 205;
							Main.tile[i, num6].active(active: true);
							Main.tile[i, num6].CopyPaintAndCoating(Main.tile[i, num6 - 1]);
							SquareTileFrame(i, num6);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, num6);
							}
						}
					}
				}
			}
			else if ((Main.tile[i, j].type == 60 || Main.tile[i, j].type == 62) && genRand.Next(80) == 0 && !PlayerLOS(i, j))
			{
				bool flag12 = true;
				int num7 = j;
				if (Main.tile[i, j].type == 60)
				{
					num7++;
				}
				for (int k = i; k < i + 2; k++)
				{
					int num8 = num7 - 1;
					if (!AnchorValid(Framing.GetTileSafely(k, num8), AnchorType.SolidTile) || Main.tile[k, num8].bottomSlope())
					{
						flag12 = false;
					}
					if (Main.tile[k, num8].liquid > 0 || Main.wallHouse[Main.tile[k, num8].wall])
					{
						flag12 = false;
					}
					if (!flag12)
					{
						break;
					}
					for (int l = num7; l < num7 + 2; l++)
					{
						if ((Main.tile[k, l].active() && (!Main.tileCut[Main.tile[k, l].type] || Main.tile[k, l].type == 444)) || Main.tile[k, l].lava())
						{
							flag12 = false;
						}
						if (!flag12)
						{
							break;
						}
					}
					if (!flag12)
					{
						break;
					}
				}
				if (flag12 && CountNearBlocksTypes(i, j, 20, 1, 444) > 0)
				{
					flag12 = false;
				}
				if (flag12)
				{
					for (int m = i; m < i + 2; m++)
					{
						Main.tile[m, num7 - 1].slope(0);
						Main.tile[m, num7 - 1].halfBrick(halfBrick: false);
						for (int n = num7; n < num7 + 2; n++)
						{
							if (Main.tile[m, n].active())
							{
								KillTile(m, n);
							}
						}
					}
					for (int num9 = i; num9 < i + 2; num9++)
					{
						for (int num10 = num7; num10 < num7 + 2; num10++)
						{
							Main.tile[num9, num10].active(active: true);
							Main.tile[num9, num10].type = 444;
							Main.tile[num9, num10].frameX = (short)((num9 - i) * 18);
							Main.tile[num9, num10].frameY = (short)((num10 - num7) * 18);
						}
					}
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, num7 - 1, 2, 3);
					}
				}
			}
			else if (Main.tile[i, j].type == 396 && genRand.Next(80) == 0 && !PlayerLOS(i, j))
			{
				bool flag13 = true;
				int num11 = j - 1;
				for (int num13 = i; num13 < i + 2; num13++)
				{
					int num14 = num11 + 1;
					if (!AnchorValid(Framing.GetTileSafely(num13, num14), AnchorType.SolidTile) || Main.tile[num13, num14].topSlope())
					{
						flag13 = false;
					}
					if (Main.tile[num13, num14].liquid > 0 || Main.wallHouse[Main.tile[num13, num14].wall])
					{
						flag13 = false;
					}
					if (!flag13)
					{
						break;
					}
					for (int num15 = num11 - 2; num15 < num11; num15++)
					{
						if ((Main.tile[num13, num15].active() && (!Main.tileCut[Main.tile[num13, num15].type] || Main.tile[num13, num15].type == 485)) || Main.tile[num13, num15].lava())
						{
							flag13 = false;
						}
						if (!flag13)
						{
							break;
						}
					}
					if (!flag13)
					{
						break;
					}
				}
				if (flag13 && CountNearBlocksTypes(i, j, 20, 1, 485) > 0)
				{
					flag13 = false;
				}
				if (flag13)
				{
					bool flag14 = true;
					for (int num16 = -1; num16 >= -3; num16--)
					{
						if (Main.tile[i, j + num16].active())
						{
							flag14 = false;
							break;
						}
					}
					if (flag14)
					{
						PlaceTile(i, j - 1, 485, mute: true, forced: false, -1, genRand.Next(4));
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, j - 2, 2, 2);
						}
					}
				}
			}
			else if (Main.tile[i, j].type == 69)
			{
				GrowSpike(i, j, 69, 60);
			}
			else if (Main.tile[i, j].type == 147 || Main.tile[i, j].type == 161 || Main.tile[i, j].type == 163 || Main.tile[i, j].type == 164 || Main.tile[i, j].type == 200)
			{
				if (Main.rand.Next(10) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 2].active())
				{
					int num50 = i - 3;
					int num17 = i + 4;
					int num18 = 0;
					for (int num19 = num50; num19 < num17; num19++)
					{
						if (Main.tile[num19, j].type == 165 && Main.tile[num19, j].active())
						{
							num18++;
						}
						if (Main.tile[num19, j + 1].type == 165 && Main.tile[num19, j + 1].active())
						{
							num18++;
						}
						if (Main.tile[num19, j + 2].type == 165 && Main.tile[num19, j + 2].active())
						{
							num18++;
						}
						if (Main.tile[num19, j + 3].type == 165 && Main.tile[num19, j + 3].active())
						{
							num18++;
						}
					}
					if (num18 < 2)
					{
						PlaceTight(i, j + 1);
						SquareTileFrame(i, j + 1);
						if (Main.netMode == 2 && Main.tile[i, j + 1].active())
						{
							NetMessage.SendTileSquare(-1, i, j + 1, 1, 2);
						}
					}
				}
			}
			else if (Main.tileMoss[Main.tile[i, j].type] || TileID.Sets.tileMossBrick[Main.tile[i, j].type])
			{
				int type2 = Main.tile[i, j].type;
				bool flag15 = false;
				TileColorCache color = Main.tile[i, j].BlockColorAndCoating();
				for (int num20 = num; num20 < num12; num20++)
				{
					for (int num21 = num22; num21 < num33; num21++)
					{
						if ((i != num20 || j != num21) && Main.tile[num20, num21].active() && (Main.tile[num20, num21].type == 1 || Main.tile[num20, num21].type == 38))
						{
							int type3 = Main.tile[num20, num21].type;
							int num23 = MossConversion(type2, type3);
							SpreadGrass(num20, num21, Main.tile[num20, num21].type, num23, repeat: false, color);
							if (Main.tile[num20, num21].type == num23)
							{
								SquareTileFrame(num20, num21);
								flag15 = true;
							}
						}
					}
				}
				if (Main.netMode == 2 && flag15)
				{
					NetMessage.SendTileSquare(-1, i, j, 3);
				}
				if (genRand.Next(6) == 0)
				{
					int num24 = i;
					int num25 = j;
					switch (genRand.Next(4))
					{
					case 0:
						num24--;
						break;
					case 1:
						num24++;
						break;
					case 2:
						num25--;
						break;
					default:
						num25++;
						break;
					}
					if (!Main.tile[num24, num25].active())
					{
						if (PlaceTile(num24, num25, 184, mute: true))
						{
							Main.tile[num24, num25].CopyPaintAndCoating(Main.tile[i, j]);
						}
						if (Main.netMode == 2 && Main.tile[num24, num25].active())
						{
							NetMessage.SendTileSquare(-1, num24, num25);
						}
					}
				}
			}
			else if (Main.tile[i, j].type == 20)
			{
				if (genRand.Next(5) == 0)
				{
					AttemptToGrowTreeFromSapling(i, j, underground: true);
				}
			}
			else if (Main.tile[i, j].type == 590)
			{
				if (genRand.Next(5) == 0)
				{
					AttemptToGrowTreeFromSapling(i, j, underground: true);
				}
			}
			else if (Main.tile[i, j].type == 595)
			{
				if (genRand.Next(5) == 0)
				{
					AttemptToGrowTreeFromSapling(i, j, underground: true);
				}
			}
			else if (Main.tile[i, j].type == 615 && genRand.Next(5) == 0)
			{
				AttemptToGrowTreeFromSapling(i, j, underground: true);
			}
		}
		else
		{
			if (Main.tile[i, j].wall == 62 && Main.tile[i, j].liquid == 0)
			{
				GrowWeb(i, j);
			}
			if (checkNPCSpawns)
			{
				TrySpawningTownNPC(i, j);
			}
		}
		if (AllowedToSpreadInfections)
		{
			if (Main.tile[i, j].wall == 81 || Main.tile[i, j].wall == 83 || (Main.tile[i, j].type == 199 && Main.tile[i, j].active()))
			{
				int num26 = i + genRand.Next(-2, 3);
				int num27 = j + genRand.Next(-2, 3);
				if (InWorld(num26, num27, 10) && Main.tile[num26, num27].wall >= 63 && Main.tile[num26, num27].wall <= 68)
				{
					bool flag2 = false;
					for (int num28 = i - wallDist; num28 < i + wallDist; num28++)
					{
						for (int num29 = j - wallDist; num29 < j + wallDist; num29++)
						{
							if (Main.tile[num28, num29].active())
							{
								int type4 = Main.tile[num28, num29].type;
								if (type4 == 199 || type4 == 200 || type4 == 201 || type4 == 203 || type4 == 205 || type4 == 234 || type4 == 352 || type4 == 662)
								{
									flag2 = true;
									break;
								}
							}
						}
					}
					if (flag2)
					{
						Main.tile[num26, num27].wall = 81;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num26, num27);
						}
					}
				}
			}
			else if (Main.tile[i, j].wall == 69 || Main.tile[i, j].wall == 3 || (Main.tile[i, j].type == 23 && Main.tile[i, j].active()))
			{
				int num30 = i + genRand.Next(-2, 3);
				int num31 = j + genRand.Next(-2, 3);
				if (InWorld(num30, num31, 10) && Main.tile[num30, num31].wall >= 63 && Main.tile[num30, num31].wall <= 68)
				{
					bool flag3 = false;
					for (int num32 = i - wallDist; num32 < i + wallDist; num32++)
					{
						for (int num34 = j - wallDist; num34 < j + wallDist; num34++)
						{
							if (Main.tile[num32, num34].active())
							{
								int type5 = Main.tile[num32, num34].type;
								if (type5 == 22 || type5 == 23 || type5 == 24 || type5 == 25 || type5 == 32 || type5 == 112 || type5 == 163 || type5 == 636 || type5 == 661)
								{
									flag3 = true;
									break;
								}
							}
						}
					}
					if (flag3)
					{
						Main.tile[num30, num31].wall = 69;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num30, num31);
						}
					}
				}
			}
			else if (Main.tile[i, j].wall == 70 || (Main.tile[i, j].type == 109 && Main.tile[i, j].active()))
			{
				int num35 = i + genRand.Next(-2, 3);
				int num36 = j + genRand.Next(-2, 3);
				if ((InWorld(num35, num36, 10) && Main.tile[num35, num36].wall == 63) || Main.tile[num35, num36].wall == 65 || Main.tile[num35, num36].wall == 66 || Main.tile[num35, num36].wall == 68)
				{
					bool flag4 = false;
					for (int num37 = i - wallDist; num37 < i + wallDist; num37++)
					{
						for (int num38 = j - wallDist; num38 < j + wallDist; num38++)
						{
							if (Main.tile[num37, num38].active())
							{
								int type6 = Main.tile[num37, num38].type;
								if (type6 == 109 || type6 == 110 || type6 == 113 || type6 == 115 || type6 == 116 || type6 == 117 || type6 == 164)
								{
									flag4 = true;
									break;
								}
							}
						}
					}
					if (flag4)
					{
						Main.tile[num35, num36].wall = 70;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num35, num36);
						}
					}
				}
			}
			SpreadDesertWalls(wallDist, i, j);
		}
		if (!Main.tile[i, j].nactive())
		{
			return;
		}
		if (Main.tile[i, j].type == 61 && genRand.Next(3) == 0 && Main.tile[i, j].frameX < 144)
		{
			if (Main.rand.Next(4) == 0)
			{
				Main.tile[i, j].frameX = (short)(162 + genRand.Next(8) * 18);
			}
			Main.tile[i, j].type = 74;
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, i, j);
			}
		}
		if ((Main.tile[i, j].type == 60 || Main.tile[i, j].type == 62) && GrowMoreVines(i, j))
		{
			int maxValue5 = 30;
			if (Main.tile[i, j].type == 62)
			{
				maxValue5 = 10;
			}
			if (genRand.Next(maxValue5) != 0 || Main.tile[i, j + 1].active() || Main.tile[i, j + 1].lava())
			{
				return;
			}
			bool flag5 = false;
			for (int num39 = j; num39 > j - 10; num39--)
			{
				if (Main.tile[i, num39].bottomSlope())
				{
					flag5 = false;
					break;
				}
				if (Main.tile[i, num39].active() && Main.tile[i, num39].type == 60 && !Main.tile[i, num39].bottomSlope())
				{
					flag5 = true;
					break;
				}
			}
			if (flag5)
			{
				int num40 = j + 1;
				Main.tile[i, num40].type = 62;
				Main.tile[i, num40].active(active: true);
				Main.tile[i, num40].CopyPaintAndCoating(Main.tile[i, num40 - 1]);
				SquareTileFrame(i, num40);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, num40);
				}
			}
		}
		else if ((Main.tile[i, j].type == 633 || Main.tile[i, j].type == 638) && GrowMoreVines(i, j))
		{
			int maxValue6 = 70;
			if (Main.tile[i, j].type == 638)
			{
				maxValue6 = 7;
			}
			if (genRand.Next(maxValue6) != 0 || Main.tile[i, j + 1].active() || Main.tile[i, j + 1].lava())
			{
				return;
			}
			bool flag6 = false;
			for (int num41 = j; num41 > j - 10; num41--)
			{
				if (Main.tile[i, num41].bottomSlope())
				{
					flag6 = false;
					break;
				}
				if (Main.tile[i, num41].active() && Main.tile[i, num41].type == 633 && !Main.tile[i, num41].bottomSlope())
				{
					flag6 = true;
					break;
				}
			}
			if (flag6)
			{
				int num42 = j + 1;
				Main.tile[i, num42].type = 638;
				Main.tile[i, num42].active(active: true);
				Main.tile[i, num42].CopyPaintAndCoating(Main.tile[i, num42 - 1]);
				SquareTileFrame(i, num42);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, num42);
				}
			}
		}
		else
		{
			if ((Main.tile[i, j].type != 70 && Main.tile[i, j].type != 528) || !GrowMoreVines(i, j))
			{
				return;
			}
			int maxValue7 = 70;
			if (Main.tile[i, j].type == 528)
			{
				maxValue7 = 7;
			}
			if (genRand.Next(maxValue7) != 0 || Main.tile[i, j + 1].active() || Main.tile[i, j + 1].lava())
			{
				return;
			}
			bool flag7 = false;
			for (int num43 = j; num43 > j - 10; num43--)
			{
				if (Main.tile[i, num43].bottomSlope())
				{
					flag7 = false;
					break;
				}
				if (Main.tile[i, num43].active() && Main.tile[i, num43].type == 70 && !Main.tile[i, num43].bottomSlope())
				{
					flag7 = true;
					break;
				}
			}
			if (flag7)
			{
				int num45 = j + 1;
				Main.tile[i, num45].type = 528;
				Main.tile[i, num45].active(active: true);
				Main.tile[i, num45].CopyPaintAndCoating(Main.tile[i, num45 - 1]);
				SquareTileFrame(i, num45);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, num45);
				}
			}
		}
	}

	private static void GrowWeb(int i, int j)
	{
		if (genRand.Next(10) != 0)
		{
			return;
		}
		int num = genRand.Next(2, 4);
		int num5 = i - num;
		int num2 = i + num;
		int num3 = j - num;
		int num4 = j + num;
		bool flag = false;
		for (int k = num5; k <= num2; k++)
		{
			for (int l = num3; l <= num4; l++)
			{
				if (SolidTile(k, l))
				{
					flag = true;
					break;
				}
			}
		}
		if (flag && !Main.tile[i, j].active())
		{
			PlaceTile(i, j, 51, mute: true);
			TileFrame(i, j, resetFrame: true);
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, i, j, 1);
			}
		}
	}

	public static bool GeneratePlanteraBulbOnAllMechsDefeated()
	{
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		bool num7 = (double)Main.dungeonX > (double)Main.maxTilesX * 0.5;
		int num2 = (int)(num7 ? ((double)Main.maxTilesX * 0.15) : ((double)Main.maxTilesX * 0.65));
		int num3 = (int)(num7 ? ((double)Main.maxTilesX * 0.35) : ((double)Main.maxTilesX * 0.85));
		int num4 = (int)Main.worldSurface;
		int underworldLayer = Main.UnderworldLayer;
		int width = num3 - num2;
		int height = underworldLayer - num4;
		Rectangle rectangle = default(Rectangle);
		((Rectangle)(ref rectangle))._002Ector(num2, num4, width, height);
		int num5 = 2500;
		Point point = default(Point);
		while (num5 > 0)
		{
			bool flag = num5 < 500;
			bool flag2 = num5 < 200;
			num5--;
			((Point)(ref point))._002Ector(rectangle.X + genRand.Next(rectangle.Width), rectangle.Y + genRand.Next(rectangle.Height));
			Tile tile = Main.tile[point.X, point.Y];
			int num6 = 500;
			bool flag3 = false;
			while (!flag3)
			{
				num6--;
				if (num6 <= 0)
				{
					flag3 = true;
				}
				point.Y--;
				if (point.Y < rectangle.Y)
				{
					break;
				}
				tile = Main.tile[point.X, point.Y];
				if (tile != null && (flag2 || tile.active()))
				{
					if (tile.type == 60)
					{
						flag3 = true;
					}
					else if (flag && tile.type == 59)
					{
						flag3 = true;
					}
				}
			}
			if (tile == null)
			{
				continue;
			}
			bool num8 = tile.active() || flag2;
			bool flag4 = tile.type == 60 || (flag && tile.type == 59);
			if (num8 && flag4)
			{
				if (AttemptToGeneratePlanteraBulbAt(point.X, point.Y - 1, flag))
				{
					return true;
				}
				if (AttemptToGeneratePlanteraBulbAt(point.X - 1, point.Y - 1, flag))
				{
					return true;
				}
				if (AttemptToGeneratePlanteraBulbAt(point.X + 1, point.Y - 1, flag))
				{
					return true;
				}
			}
		}
		return false;
	}

	private static bool AttemptToGeneratePlanteraBulbAt(int i, int j, bool forceBulb)
	{
		if (forceBulb)
		{
			int num = 0;
			for (int k = -2; k < 2; k++)
			{
				for (int l = -2; l < 2; l++)
				{
					int num2 = i + k;
					int num3 = j + l;
					Tile tile = Main.tile[num2, num3];
					if (tile.type == 59 || tile.type == 60)
					{
						num++;
					}
					else if (tile.active())
					{
						num--;
					}
					if (IsAContainer(tile) || tile.type == 226 || tile.type == 237 || tile.type == 10 || tile.type == 11 || tile.type == 26 || tile.type == 16 || tile.type == 15 || tile.type == 14 || tile.type == 104 || TileID.Sets.Paintings[tile.type] || tile.type == 158 || tile.type == 105 || tile.type == 531 || tile.type == 349 || tile.type == 138 || tile.type == 664 || tile.type == 665 || tile.type == 137 || tile.type == 443 || tile.type == 12 || tile.type == 665 || tile.type == 314)
					{
						num = -1;
						break;
					}
				}
				if (num <= -1)
				{
					break;
				}
			}
			if (num < 12)
			{
				return false;
			}
			for (int m = -2; m < 2; m++)
			{
				for (int n = -2; n < 2; n++)
				{
					int num4 = i + m;
					int num5 = j + n;
					bool num6 = m == -2 || m == 1 || n == -2 || n == 1;
					Tile tile2 = Main.tile[num4, num5];
					tile2.ClearTile();
					if (num6)
					{
						tile2.type = 60;
						tile2.active(active: true);
					}
					SquareTileFrame(num4, num5);
				}
			}
			PlaceJunglePlant(i, j, 238, 0, 0);
			if (Main.tile[i, j].type == 238)
			{
				SquareTileFrame(i, j);
				SquareTileFrame(i + 2, j);
				SquareTileFrame(i - 1, j);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, j, 8);
				}
				return true;
			}
		}
		else
		{
			PlaceJunglePlant(i, j, 238, 0, 0);
			if (Main.tile[i, j].type == 238)
			{
				SquareTileFrame(i, j);
				SquareTileFrame(i + 2, j);
				SquareTileFrame(i - 1, j);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, j, 5);
				}
				return true;
			}
		}
		return false;
	}

	private static void UpdateWorld_GrassGrowth(int i, int j, int minI, int maxI, int minJ, int maxJ, bool underground)
	{
		//IL_0690: Unknown result type (might be due to invalid IL or missing references)
		if (!InWorld(i, j, 10))
		{
			return;
		}
		if (underground)
		{
			int type = Main.tile[i, j].type;
			int num = -1;
			int num12 = -1;
			int num18 = -1;
			int maxValue = 1;
			int num19 = type;
			int num20 = -1;
			switch (type)
			{
			case 23:
				num = 0;
				num12 = 59;
				num19 = 23;
				num20 = 661;
				num18 = 24;
				maxValue = 2;
				if (!AllowedToSpreadInfections)
				{
					return;
				}
				break;
			case 199:
				num = 0;
				num12 = 59;
				num19 = 199;
				num20 = 662;
				num18 = 201;
				maxValue = 2;
				if (!AllowedToSpreadInfections)
				{
					return;
				}
				break;
			case 661:
				num = 59;
				num12 = 0;
				num19 = 661;
				num20 = 23;
				num18 = 24;
				maxValue = 2;
				if (!AllowedToSpreadInfections)
				{
					return;
				}
				break;
			case 662:
				num = 59;
				num12 = 0;
				num19 = 662;
				num20 = 199;
				num18 = 201;
				maxValue = 2;
				if (!AllowedToSpreadInfections)
				{
					return;
				}
				break;
			case 60:
				num = 59;
				num18 = 61;
				maxValue = 10;
				break;
			case 70:
				num = 59;
				num18 = 71;
				maxValue = 10;
				break;
			case 633:
				num = 57;
				num18 = 637;
				maxValue = 2;
				break;
			}
			bool flag = false;
			if (num18 != -1 && !Main.tile[i, minJ].active() && genRand.Next(maxValue) == 0)
			{
				flag = true;
				if (PlaceTile(i, minJ, num18, mute: true))
				{
					Main.tile[i, minJ].CopyPaintAndCoating(Main.tile[i, j]);
				}
				if (Main.netMode == 2 && Main.tile[i, minJ].active())
				{
					NetMessage.SendTileSquare(-1, i, minJ);
				}
			}
			if (num != -1)
			{
				bool flag3 = false;
				TileColorCache color = Main.tile[i, j].BlockColorAndCoating();
				for (int k = minI; k < maxI; k++)
				{
					for (int l = minJ; l < maxJ; l++)
					{
						if (!InWorld(k, l, 10) || (i == k && j == l) || !Main.tile[k, l].active())
						{
							continue;
						}
						if (Main.tile[k, l].type == num)
						{
							SpreadGrass(k, l, num, num19, repeat: false, color);
							if (Main.tile[k, l].type == num19)
							{
								SquareTileFrame(k, l);
								flag3 = true;
							}
						}
						else if (num12 > -1 && num20 > -1 && Main.tile[k, l].type == num12)
						{
							SpreadGrass(k, l, num12, num20, repeat: false, color);
							if (Main.tile[k, l].type == num20)
							{
								SquareTileFrame(k, l);
								flag3 = true;
							}
						}
					}
				}
				if (Main.netMode == 2 && flag3)
				{
					NetMessage.SendTileSquare(-1, i, j, 3);
				}
			}
			switch (type)
			{
			case 60:
			{
				if (flag || genRand.Next(25) != 0 || Main.tile[i, minJ].liquid != 0)
				{
					break;
				}
				if (Main.hardMode && NPC.downedMechBoss1 && NPC.downedMechBoss2 && NPC.downedMechBoss3 && genRand.Next(60) == 0)
				{
					bool flag4 = true;
					int num21 = 150;
					for (int m = i - num21; m < i + num21; m += 2)
					{
						for (int n = j - num21; n < j + num21; n += 2)
						{
							if (m > 1 && m < Main.maxTilesX - 2 && n > 1 && n < Main.maxTilesY - 2 && Main.tile[m, n].active() && Main.tile[m, n].type == 238)
							{
								flag4 = false;
								break;
							}
						}
					}
					if (flag4)
					{
						PlaceJunglePlant(i, minJ, 238, 0, 0);
						SquareTileFrame(i, minJ);
						SquareTileFrame(i + 2, minJ);
						SquareTileFrame(i - 1, minJ);
						if (Main.tile[i, minJ].type == 238 && Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, minJ, 5);
						}
					}
				}
				int maxValue2 = (Main.expertMode ? 30 : 40);
				if (Main.hardMode && NPC.downedMechBossAny && genRand.Next(maxValue2) == 0)
				{
					bool flag5 = true;
					int num22 = 60;
					if (Main.expertMode)
					{
						num22 -= 10;
					}
					for (int num23 = i - num22; num23 < i + num22; num23 += 2)
					{
						for (int num24 = j - num22; num24 < j + num22; num24 += 2)
						{
							if (num23 > 1 && num23 < Main.maxTilesX - 2 && num24 > 1 && num24 < Main.maxTilesY - 2 && Main.tile[num23, num24].active() && Main.tile[num23, num24].type == 236)
							{
								flag5 = false;
								break;
							}
						}
					}
					if (flag5)
					{
						PlaceJunglePlant(i, minJ, 236, genRand.Next(3), 0);
						SquareTileFrame(i, minJ);
						SquareTileFrame(i + 1, minJ + 1);
						if (Main.tile[i, minJ].type == 236 && Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, minJ, 4);
						}
					}
					break;
				}
				PlaceJunglePlant(i, minJ, 233, genRand.Next(8), 0);
				if (Main.tile[i, minJ].type != 233)
				{
					break;
				}
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, minJ, 4);
					break;
				}
				PlaceJunglePlant(i, minJ, 233, genRand.Next(12), 1);
				if (Main.tile[i, minJ].type == 233 && Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, minJ, 3);
				}
				break;
			}
			case 70:
				if (Main.tile[i, j - 1].liquid > 0)
				{
					PlaceCatTail(i, j - 1);
				}
				if (genRand.Next(250) == 0 && GrowTree(i, j) && PlayerLOS(i, j))
				{
					TreeGrowFXCheck(i, j - 1);
				}
				break;
			}
			return;
		}
		int num2 = Main.tile[i, j].type;
		switch (num2)
		{
		case 2:
		case 23:
		case 32:
		case 109:
		case 199:
		case 352:
		case 477:
		case 492:
		case 661:
		case 662:
		{
			if (Main.halloween && genRand.Next(75) == 0 && (num2 == 2 || num2 == 109))
			{
				int num5 = 100;
				int num6 = 0;
				for (int num7 = i - num5; num7 < i + num5; num7 += 2)
				{
					for (int num8 = j - num5; num8 < j + num5; num8 += 2)
					{
						if (num7 > 1 && num7 < Main.maxTilesX - 2 && num8 > 1 && num8 < Main.maxTilesY - 2 && Main.tile[num7, num8].active() && Main.tile[num7, num8].type == 254)
						{
							num6++;
						}
					}
				}
				if (num6 < 6)
				{
					PlacePumpkin(i, minJ);
					if (Main.netMode == 2 && Main.tile[i, minJ].type == 254)
					{
						NetMessage.SendTileSquare(-1, i - 1, minJ - 1, 2, 2);
					}
				}
			}
			if (!Main.tile[i, minJ].active() && Main.tile[i, minJ].liquid == 0)
			{
				int num9 = -1;
				if (num2 == 2 && genRand.Next(12) == 0)
				{
					num9 = 3;
				}
				else if (num2 == 23 && genRand.Next(10) == 0)
				{
					num9 = 24;
				}
				else if (num2 == 199 && genRand.Next(10) == 0)
				{
					num9 = 201;
				}
				else if (num2 == 661 && genRand.Next(10) == 0)
				{
					num9 = 24;
				}
				else if (num2 == 662 && genRand.Next(10) == 0)
				{
					num9 = 201;
				}
				else if (num2 == 109 && genRand.Next(10) == 0)
				{
					num9 = 110;
				}
				else if (num2 == 633 && genRand.Next(10) == 0)
				{
					num9 = 637;
				}
				if (num9 != -1 && PlaceTile(i, minJ, num9, mute: true))
				{
					Main.tile[i, minJ].CopyPaintAndCoating(Main.tile[i, j]);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, minJ);
					}
				}
			}
			bool flag7 = false;
			switch (num2)
			{
			case 32:
				num2 = 23;
				if (!AllowedToSpreadInfections)
				{
					return;
				}
				break;
			case 352:
				num2 = 199;
				if (!AllowedToSpreadInfections)
				{
					return;
				}
				break;
			case 477:
				num2 = 2;
				break;
			case 492:
				num2 = 109;
				break;
			}
			int grass = num2;
			int num10 = -1;
			if (num2 == 23 || num2 == 661)
			{
				grass = 23;
				num10 = 661;
			}
			if (num2 == 199 || num2 == 662)
			{
				grass = 199;
				num10 = 662;
			}
			bool flag8 = AllowedToSpreadInfections && (num2 == 23 || num2 == 199 || num2 == 109 || num2 == 492 || num2 == 661 || num2 == 662) && InWorld(i, j, 10);
			for (int num11 = minI; num11 < maxI; num11++)
			{
				for (int num13 = minJ; num13 < maxJ; num13++)
				{
					if (!InWorld(num11, num13, 10) || (i == num11 && j == num13) || !Main.tile[num11, num13].active())
					{
						continue;
					}
					int type2 = Main.tile[num11, num13].type;
					if (!flag8 && type2 != 0 && (num10 == -1 || type2 != 59))
					{
						continue;
					}
					TileColorCache color3 = Main.tile[i, j].BlockColorAndCoating();
					if (type2 == 0 || (num10 > -1 && type2 == 59) || ((num2 == 23 || num2 == 661 || num2 == 199 || num2 == 662) && (type2 == 2 || type2 == 109 || type2 == 477 || type2 == 492)))
					{
						SpreadGrass(num11, num13, 0, grass, repeat: false, color3);
						if (num10 > -1)
						{
							SpreadGrass(num11, num13, 59, num10, repeat: false, color3);
						}
						if (AllowedToSpreadInfections && (num2 == 23 || num2 == 199 || num2 == 661 || num2 == 662))
						{
							SpreadGrass(num11, num13, 2, grass, repeat: false, color3);
							SpreadGrass(num11, num13, 109, grass, repeat: false, color3);
							SpreadGrass(num11, num13, 477, grass, repeat: false, color3);
							SpreadGrass(num11, num13, 492, grass, repeat: false, color3);
							if (num10 > -1)
							{
								SpreadGrass(num11, num13, 60, num10, repeat: false, color3);
							}
						}
						if (Main.tile[num11, num13].type == num2 || (num10 > -1 && Main.tile[num11, num13].type == num10))
						{
							SquareTileFrame(num11, num13);
							flag7 = true;
						}
					}
					if (type2 == 0 || ((num2 == 109 || num2 == 492) && (type2 == 2 || type2 == 477 || type2 == 23 || type2 == 199)))
					{
						SpreadGrass(num11, num13, 0, grass, repeat: false, color3);
						if (num2 == 109)
						{
							SpreadGrass(num11, num13, 2, grass, repeat: false, color3);
						}
						switch (num2)
						{
						case 492:
							SpreadGrass(num11, num13, 477, grass, repeat: false, color3);
							break;
						case 109:
							SpreadGrass(num11, num13, 477, 492, repeat: false, color3);
							break;
						}
						if ((num2 == 492 || num2 == 109) && AllowedToSpreadInfections)
						{
							SpreadGrass(num11, num13, 23, 109, repeat: false, color3);
						}
						if ((num2 == 492 || num2 == 109) && AllowedToSpreadInfections)
						{
							SpreadGrass(num11, num13, 199, 109, repeat: false, color3);
						}
						if (Main.tile[num11, num13].type == num2)
						{
							SquareTileFrame(num11, num13);
							flag7 = true;
						}
					}
				}
			}
			if (Main.netMode == 2 && flag7)
			{
				NetMessage.SendTileSquare(-1, i, j, 3);
			}
			break;
		}
		case 70:
		{
			if (!Main.tile[i, j].inActive())
			{
				if (!Main.tile[i, minJ].active() && genRand.Next(10) == 0)
				{
					PlaceTile(i, minJ, 71, mute: true);
					if (Main.tile[i, minJ].active())
					{
						Main.tile[i, minJ].CopyPaintAndCoating(Main.tile[i, j]);
					}
					if (Main.netMode == 2 && Main.tile[i, minJ].active())
					{
						NetMessage.SendTileSquare(-1, i, minJ);
					}
				}
				if (genRand.Next(300) == 0)
				{
					bool flag9 = PlayerLOS(i, j);
					if (GrowTree(i, j) && flag9)
					{
						TreeGrowFXCheck(i, j - 1);
					}
				}
			}
			bool flag10 = false;
			TileColorCache color4 = Main.tile[i, j].BlockColorAndCoating();
			for (int num14 = minI; num14 < maxI; num14++)
			{
				for (int num15 = minJ; num15 < maxJ; num15++)
				{
					if ((i != num14 || j != num15) && Main.tile[num14, num15].active() && Main.tile[num14, num15].type == 59)
					{
						SpreadGrass(num14, num15, 59, num2, repeat: false, color4);
						if (Main.tile[num14, num15].type == num2)
						{
							SquareTileFrame(num14, num15);
							flag10 = true;
						}
					}
				}
			}
			if (Main.netMode == 2 && flag10)
			{
				NetMessage.SendTileSquare(-1, i, j, 3);
			}
			break;
		}
		case 60:
		{
			if (!Main.tile[i, minJ].active() && genRand.Next(7) == 0)
			{
				PlaceTile(i, minJ, 61, mute: true);
				if (Main.tile[i, minJ].active())
				{
					Main.tile[i, minJ].CopyPaintAndCoating(Main.tile[i, j]);
				}
				if (Main.netMode == 2 && Main.tile[i, minJ].active())
				{
					NetMessage.SendTileSquare(-1, i, minJ);
				}
			}
			else if (genRand.Next(500) == 0 && (!Main.tile[i, minJ].active() || Main.tile[i, minJ].type == 61 || Main.tile[i, minJ].type == 74 || Main.tile[i, minJ].type == 69))
			{
				if (GrowTree(i, j) && PlayerLOS(i, j))
				{
					TreeGrowFXCheck(i, j - 1);
				}
			}
			else if (genRand.Next(25) == 0 && Main.tile[i, minJ].liquid == 0)
			{
				PlaceJunglePlant(i, minJ, 233, genRand.Next(8), 0);
				if (Main.tile[i, minJ].type == 233)
				{
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, minJ, 4);
					}
					else
					{
						PlaceJunglePlant(i, minJ, 233, genRand.Next(12), 1);
						if (Main.tile[i, minJ].type == 233 && Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, minJ, 3);
						}
					}
				}
			}
			bool flag2 = false;
			TileColorCache color5 = Main.tile[i, j].BlockColorAndCoating();
			for (int num16 = minI; num16 < maxI; num16++)
			{
				for (int num17 = minJ; num17 < maxJ; num17++)
				{
					if ((i != num16 || j != num17) && Main.tile[num16, num17].active() && Main.tile[num16, num17].type == 59)
					{
						SpreadGrass(num16, num17, 59, num2, repeat: false, color5);
						if (Main.tile[num16, num17].type == num2)
						{
							SquareTileFrame(num16, num17);
							flag2 = true;
						}
					}
				}
			}
			if (Main.netMode == 2 && flag2)
			{
				NetMessage.SendTileSquare(-1, i, j, 3);
			}
			break;
		}
		case 633:
		{
			if (!Main.tile[i, minJ].active() && genRand.Next(10) == 0)
			{
				PlaceTile(i, minJ, 637, mute: true);
				if (Main.tile[i, minJ].active())
				{
					Main.tile[i, minJ].CopyPaintAndCoating(Main.tile[i, j]);
				}
				if (Main.netMode == 2 && Main.tile[i, minJ].active())
				{
					NetMessage.SendTileSquare(-1, i, minJ);
				}
			}
			TileColorCache color2 = Main.tile[i, j].BlockColorAndCoating();
			bool flag6 = false;
			for (int num3 = minI; num3 < maxI; num3++)
			{
				for (int num4 = minJ; num4 < maxJ; num4++)
				{
					if ((i != num3 || j != num4) && Main.tile[num3, num4].active() && Main.tile[num3, num4].type == 57)
					{
						SpreadGrass(num3, num4, 57, num2, repeat: false, color2);
						if (Main.tile[num3, num4].type == num2)
						{
							SquareTileFrame(num3, num4);
							flag6 = true;
						}
					}
				}
			}
			if (Main.netMode == 2 && flag6)
			{
				NetMessage.SendTileSquare(-1, i, j, 3);
			}
			break;
		}
		}
	}

	private static void TrySpawningTownNPC(int x, int y)
	{
		bool flag = Main.tileSolid[379];
		Main.tileSolid[379] = true;
		if (prioritizedTownNPCType > 0)
		{
			if (Main.tile[x, y].wall == 34)
			{
				if (Main.rand.Next(4) == 0)
				{
					SpawnTownNPC(x, y);
				}
			}
			else
			{
				SpawnTownNPC(x, y);
			}
		}
		Main.tileSolid[379] = flag;
	}

	public static void SpreadDesertWalls(int wallDist, int i, int j)
	{
		if (!InWorld(i, j, 10) || (!WallID.Sets.Conversion.Sandstone[Main.tile[i, j].wall] && (!Main.tile[i, j].active() || !TileID.Sets.Conversion.Sandstone[Main.tile[i, j].type]) && !WallID.Sets.Conversion.HardenedSand[Main.tile[i, j].wall]))
		{
			return;
		}
		int num = 0;
		int wall = Main.tile[i, j].wall;
		int type = Main.tile[i, j].type;
		if (WallID.Sets.Corrupt[wall] || TileID.Sets.Corrupt[type])
		{
			num = 1;
		}
		if (WallID.Sets.Hallow[wall] || TileID.Sets.Hallow[type])
		{
			num = 2;
		}
		if (WallID.Sets.Crimson[wall] || TileID.Sets.Crimson[type])
		{
			num = 3;
		}
		if (num == 0)
		{
			return;
		}
		int num2 = i + genRand.Next(-2, 3);
		int num3 = j + genRand.Next(-2, 3);
		bool flag = false;
		if (WallID.Sets.Conversion.PureSand[Main.tile[num2, num3].wall])
		{
			switch (num)
			{
			case 3:
			{
				for (int m = i - wallDist; m < i + wallDist; m++)
				{
					for (int n = j - wallDist; n < j + wallDist; n++)
					{
						if (Main.tile[m, n].active() && TileID.Sets.Crimson[Main.tile[m, n].type])
						{
							flag = true;
							break;
						}
					}
					if (flag)
					{
						break;
					}
				}
				break;
			}
			case 2:
			{
				for (int num4 = i - wallDist; num4 < i + wallDist; num4++)
				{
					for (int num5 = j - wallDist; num5 < j + wallDist; num5++)
					{
						if (Main.tile[num4, num5].active() && TileID.Sets.Hallow[Main.tile[num4, num5].type])
						{
							flag = true;
							break;
						}
					}
					if (flag)
					{
						break;
					}
				}
				break;
			}
			case 1:
			{
				for (int k = i - wallDist; k < i + wallDist; k++)
				{
					for (int l = j - wallDist; l < j + wallDist; l++)
					{
						if (Main.tile[k, l].active() && TileID.Sets.Corrupt[Main.tile[k, l].type])
						{
							flag = true;
							break;
						}
					}
					if (flag)
					{
						break;
					}
				}
				break;
			}
			}
		}
		if (!flag)
		{
			return;
		}
		ushort? num6 = null;
		if (WallID.Sets.Conversion.Sandstone[Main.tile[num2, num3].wall])
		{
			switch (num)
			{
			case 3:
				num6 = (ushort)221;
				break;
			case 2:
				num6 = (ushort)222;
				break;
			case 1:
				num6 = (ushort)220;
				break;
			}
		}
		if (WallID.Sets.Conversion.HardenedSand[Main.tile[num2, num3].wall])
		{
			switch (num)
			{
			case 3:
				num6 = (ushort)218;
				break;
			case 2:
				num6 = (ushort)219;
				break;
			case 1:
				num6 = (ushort)217;
				break;
			}
		}
		if (num6.HasValue && Main.tile[num2, num3].wall != num6.Value)
		{
			Main.tile[num2, num3].wall = num6.Value;
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, num2, num3);
			}
		}
	}

	public static void PlaceWall(int i, int j, int type, bool mute = false)
	{
		if (i <= 1 || j <= 1 || i >= Main.maxTilesX - 2 || j >= Main.maxTilesY - 2)
		{
			return;
		}
		if (Main.tile[i, j] == null)
		{
			Main.tile[i, j] = default(Tile);
		}
		if (Main.tile[i, j].wall == 0)
		{
			Main.tile[i, j].wall = (ushort)type;
			SquareWallFrame(i, j);
			if (!mute)
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
			}
		}
	}

	public static void SpreadGrass(int i, int j, int dirt = 0, int grass = 2, bool repeat = true, TileColorCache color = default(TileColorCache))
	{
		try
		{
			if (!InWorld(i, j, 10) || !Main.tile[i, j].active() || Main.tile[i, j].type != dirt)
			{
				return;
			}
			if (gen && (grass == 199 || grass == 23))
			{
				int num = beachDistance;
				if ((!tenthAnniversaryWorldGen && (double)i > (double)Main.maxTilesX * 0.45 && (double)i <= (double)Main.maxTilesX * 0.55) || i < num || i >= Main.maxTilesX - num)
				{
					return;
				}
			}
			else if ((gen || (grass != 199 && grass != 23 && grass != 661 && grass != 662)) && (Main.tile[i, j].type != dirt || !Main.tile[i, j].active() || ((double)j >= Main.worldSurface && dirt == 0)) && !growGrassUnderground)
			{
				return;
			}
			int num2 = i - 1;
			int num3 = i + 2;
			int num4 = j - 1;
			int num5 = j + 2;
			if (num2 < 0)
			{
				num2 = 0;
			}
			if (num3 > Main.maxTilesX)
			{
				num3 = Main.maxTilesX;
			}
			if (num4 < 0)
			{
				num4 = 0;
			}
			if (num5 > Main.maxTilesY)
			{
				num5 = Main.maxTilesY;
			}
			bool flag = true;
			for (int k = num2; k < num3; k++)
			{
				for (int l = num4; l < num5; l++)
				{
					if (!Main.tile[k, l].active() || !Main.tileSolid[Main.tile[k, l].type])
					{
						flag = false;
					}
					if (Main.tile[k, l].lava() && Main.tile[k, l].liquid > 0)
					{
						flag = true;
						break;
					}
				}
			}
			if (flag || !TileID.Sets.CanBeClearedDuringGeneration[Main.tile[i, j].type] || ((grass == 23 || grass == 661) && Main.tile[i, j - 1].type == 27) || ((grass == 199 || grass == 662) && Main.tile[i, j - 1].type == 27) || (grass == 109 && Main.tile[i, j - 1].type == 27))
			{
				return;
			}
			Main.tile[i, j].type = (ushort)grass;
			Main.tile[i, j].UseBlockColors(color);
			for (int m = num2; m < num3; m++)
			{
				for (int n = num4; n < num5; n++)
				{
					if (!Main.tile[m, n].active() || Main.tile[m, n].type != dirt)
					{
						continue;
					}
					try
					{
						if (repeat && grassSpread < 1000)
						{
							grassSpread++;
							SpreadGrass(m, n, dirt, grass);
							grassSpread--;
						}
					}
					catch
					{
					}
				}
			}
		}
		catch
		{
		}
	}

	public static void ChasmRunnerSideways(int i, int j, int direction, int steps)
	{
		double num = steps;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(10, 21) * 0.1 * (double)direction;
		vector2D2.Y = (double)genRand.Next(-10, 10) * 0.01;
		double num3 = genRand.Next(5) + 7;
		while (num3 > 0.0)
		{
			if (num > 0.0)
			{
				num3 += (double)genRand.Next(3);
				num3 -= (double)genRand.Next(3);
				if (num3 < 7.0)
				{
					num3 = 7.0;
				}
				if (num3 > 20.0)
				{
					num3 = 20.0;
				}
				if (num == 1.0 && num3 < 10.0)
				{
					num3 = 10.0;
				}
			}
			else
			{
				num3 -= (double)genRand.Next(4);
			}
			if (vector2D.Y > Main.rockLayer && num > 0.0)
			{
				num = 0.0;
			}
			num -= 1.0;
			int num4 = (int)(vector2D.X - num3 * 0.5);
			int num5 = (int)(vector2D.X + num3 * 0.5);
			int num6 = (int)(vector2D.Y - num3 * 0.5);
			int num7 = (int)(vector2D.Y + num3 * 0.5);
			if (num4 < 0)
			{
				num4 = 0;
			}
			if (num5 > Main.maxTilesX - 1)
			{
				num5 = Main.maxTilesX - 1;
			}
			if (num6 < 0)
			{
				num6 = 0;
			}
			if (num7 > Main.maxTilesY)
			{
				num7 = Main.maxTilesY;
			}
			for (int k = num4; k < num5; k++)
			{
				for (int l = num6; l < num7; l++)
				{
					if (Math.Abs((double)k - vector2D.X) + Math.Abs((double)l - vector2D.Y) < num3 * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].type != 31 && Main.tile[k, l].type != 22)
					{
						Main.tile[k, l].active(active: false);
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.Y += (double)genRand.Next(-10, 10) * 0.1;
			if (vector2D.Y < (double)(j - 20))
			{
				vector2D2.Y += (double)genRand.Next(20) * 0.01;
			}
			if (vector2D.Y > (double)(j + 20))
			{
				vector2D2.Y -= (double)genRand.Next(20) * 0.01;
			}
			if (vector2D2.Y < -0.5)
			{
				vector2D2.Y = -0.5;
			}
			if (vector2D2.Y > 0.5)
			{
				vector2D2.Y = 0.5;
			}
			vector2D2.X += (double)genRand.Next(-10, 11) * 0.01;
			switch (direction)
			{
			case -1:
				if (vector2D2.X > -0.5)
				{
					vector2D2.X = -0.5;
				}
				if (vector2D2.X < -2.0)
				{
					vector2D2.X = -2.0;
				}
				break;
			case 1:
				if (vector2D2.X < 0.5)
				{
					vector2D2.X = 0.5;
				}
				if (vector2D2.X > 2.0)
				{
					vector2D2.X = 2.0;
				}
				break;
			}
			num4 = (int)(vector2D.X - num3 * 1.1);
			num5 = (int)(vector2D.X + num3 * 1.1);
			num6 = (int)(vector2D.Y - num3 * 1.1);
			num7 = (int)(vector2D.Y + num3 * 1.1);
			if (num4 < 1)
			{
				num4 = 1;
			}
			if (num5 > Main.maxTilesX - 1)
			{
				num5 = Main.maxTilesX - 1;
			}
			if (num6 < 0)
			{
				num6 = 0;
			}
			if (num7 > Main.maxTilesY)
			{
				num7 = Main.maxTilesY;
			}
			for (int m = num4; m < num5; m++)
			{
				for (int n = num6; n < num7; n++)
				{
					if (Math.Abs((double)m - vector2D.X) + Math.Abs((double)n - vector2D.Y) < num3 * 1.1 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[m, n].wall != 3)
					{
						if (Main.tile[m, n].type != 25 && n > j + genRand.Next(3, 20))
						{
							Main.tile[m, n].active(active: true);
						}
						Main.tile[m, n].active(active: true);
						if (Main.tile[m, n].type != 31 && Main.tile[m, n].type != 22)
						{
							Main.tile[m, n].type = 25;
						}
						if (Main.tile[m, n].wall == 2)
						{
							Main.tile[m, n].wall = 0;
						}
					}
				}
			}
			for (int num8 = num4; num8 < num5; num8++)
			{
				for (int num9 = num6; num9 < num7; num9++)
				{
					if (Math.Abs((double)num8 - vector2D.X) + Math.Abs((double)num9 - vector2D.Y) < num3 * 1.1 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[num8, num9].wall != 3)
					{
						if (Main.tile[num8, num9].type != 31 && Main.tile[num8, num9].type != 22)
						{
							Main.tile[num8, num9].type = 25;
						}
						Main.tile[num8, num9].active(active: true);
						PlaceWall(num8, num9, 3, mute: true);
					}
				}
			}
		}
		if (genRand.Next(3) == 0)
		{
			int num10 = (int)vector2D.X;
			int num2;
			for (num2 = (int)vector2D.Y; !Main.tile[num10, num2].active(); num2++)
			{
			}
			TileRunner(num10, num2, genRand.Next(2, 6), genRand.Next(3, 7), 22);
		}
	}

	public static void CrimStart(int i, int j)
	{
		int crimDir = 1;
		int k = j;
		if ((double)k > Main.worldSurface)
		{
			k = (int)Main.worldSurface;
		}
		for (; !SolidTile(i, k); k++)
		{
		}
		int num = k;
		Vector2D position = new Vector2D(i, k);
		Vector2D vector2D = new Vector2D((double)genRand.Next(-20, 21) * 0.1, (double)genRand.Next(20, 201) * 0.01);
		if (vector2D.X < 0.0)
		{
			crimDir = -1;
		}
		double num11 = genRand.Next(15, 26);
		bool flag = true;
		int num21 = 0;
		while (flag)
		{
			num11 += (double)genRand.Next(-50, 51) * 0.01;
			if (num11 < 15.0)
			{
				num11 = 15.0;
			}
			if (num11 > 25.0)
			{
				num11 = 25.0;
			}
			for (int l = (int)(position.X - num11 / 2.0); (double)l < position.X + num11 / 2.0; l++)
			{
				for (int m = (int)(position.Y - num11 / 2.0); (double)m < position.Y + num11 / 2.0; m++)
				{
					if (m > num)
					{
						if (Math.Abs((double)l - position.X) + Math.Abs((double)m - position.Y) < num11 * 0.3)
						{
							Main.tile[l, m].active(active: false);
							Main.tile[l, m].wall = 83;
						}
						else if (Math.Abs((double)l - position.X) + Math.Abs((double)m - position.Y) < num11 * 0.8 && Main.tile[l, m].wall != 83)
						{
							Main.tile[l, m].active(active: true);
							Main.tile[l, m].type = 203;
							if (Math.Abs((double)l - position.X) + Math.Abs((double)m - position.Y) < num11 * 0.6)
							{
								Main.tile[l, m].wall = 83;
							}
						}
					}
					else if (Math.Abs((double)l - position.X) + Math.Abs((double)m - position.Y) < num11 * 0.3 && Main.tile[l, m].active())
					{
						Main.tile[l, m].active(active: false);
						Main.tile[l, m].wall = 83;
					}
				}
			}
			if (position.X > (double)(i + 50))
			{
				num21 = -100;
			}
			if (position.X < (double)(i - 50))
			{
				num21 = 100;
			}
			if (num21 < 0)
			{
				vector2D.X -= (double)genRand.Next(20, 51) * 0.01;
			}
			else if (num21 > 0)
			{
				vector2D.X += (double)genRand.Next(20, 51) * 0.01;
			}
			else
			{
				vector2D.X += (double)genRand.Next(-50, 51) * 0.01;
			}
			vector2D.Y += (double)genRand.Next(-50, 51) * 0.01;
			if (vector2D.Y < 0.25)
			{
				vector2D.Y = 0.25;
			}
			if (vector2D.Y > 2.0)
			{
				vector2D.Y = 2.0;
			}
			if (vector2D.X < -2.0)
			{
				vector2D.X = -2.0;
			}
			if (vector2D.X > 2.0)
			{
				vector2D.X = 2.0;
			}
			position += vector2D;
			if (position.Y > Main.worldSurface + 100.0)
			{
				flag = false;
			}
		}
		num11 = genRand.Next(40, 55);
		for (int n = 0; n < 50; n++)
		{
			int num29 = (int)position.X + genRand.Next(-20, 21);
			int num30 = (int)position.Y + genRand.Next(-20, 21);
			for (int num31 = (int)((double)num29 - num11 / 2.0); (double)num31 < (double)num29 + num11 / 2.0; num31++)
			{
				for (int num32 = (int)((double)num30 - num11 / 2.0); (double)num32 < (double)num30 + num11 / 2.0; num32++)
				{
					double num34 = Math.Abs(num31 - num29);
					double num33 = Math.Abs(num32 - num30);
					double num2 = 1.0 + (double)genRand.Next(-20, 21) * 0.01;
					double num3 = 1.0 + (double)genRand.Next(-20, 21) * 0.01;
					double num35 = num34 * num2;
					num33 *= num3;
					double num4 = Math.Sqrt(num35 * num35 + num33 * num33);
					if (num4 < num11 * 0.25)
					{
						Main.tile[num31, num32].active(active: false);
						Main.tile[num31, num32].wall = 83;
					}
					else if (num4 < num11 * 0.4 && Main.tile[num31, num32].wall != 83)
					{
						Main.tile[num31, num32].active(active: true);
						Main.tile[num31, num32].type = 203;
						if (num4 < num11 * 0.35)
						{
							Main.tile[num31, num32].wall = 83;
						}
					}
				}
			}
		}
		int num5 = genRand.Next(5, 9);
		Vector2D[] array = new Vector2D[num5];
		for (int num6 = 0; num6 < num5; num6++)
		{
			int num7 = (int)position.X;
			int num8 = (int)position.Y;
			int num9 = 0;
			bool flag2 = true;
			Vector2D vector2D2 = new Vector2D((double)genRand.Next(-20, 21) * 0.15, (double)genRand.Next(0, 21) * 0.15);
			while (flag2)
			{
				vector2D2 = new Vector2D((double)genRand.Next(-20, 21) * 0.15, (double)genRand.Next(0, 21) * 0.15);
				while (Math.Abs(vector2D2.X) + Math.Abs(vector2D2.Y) < 1.5)
				{
					vector2D2 = new Vector2D((double)genRand.Next(-20, 21) * 0.15, (double)genRand.Next(0, 21) * 0.15);
				}
				flag2 = false;
				for (int num10 = 0; num10 < num6; num10++)
				{
					if (vector2D.X > array[num10].X - 0.75 && vector2D.X < array[num10].X + 0.75 && vector2D.Y > array[num10].Y - 0.75 && vector2D.Y < array[num10].Y + 0.75)
					{
						flag2 = true;
						num9++;
						break;
					}
				}
				if (num9 > 10000)
				{
					break;
				}
			}
			array[num6] = vector2D2;
			CrimVein(new Vector2D(num7, num8), vector2D2);
		}
		int num12 = Main.maxTilesX;
		int num13 = 0;
		position.X = i;
		position.Y = num;
		num11 = genRand.Next(25, 35);
		double num14 = genRand.Next(0, 6);
		for (int num15 = 0; num15 < 50; num15++)
		{
			if (num14 > 0.0)
			{
				double num16 = (double)genRand.Next(10, 30) * 0.01;
				num14 -= num16;
				position.Y -= num16;
			}
			int num17 = (int)position.X + genRand.Next(-2, 3);
			int num18 = (int)position.Y + genRand.Next(-2, 3);
			for (int num19 = (int)((double)num17 - num11 / 2.0); (double)num19 < (double)num17 + num11 / 2.0; num19++)
			{
				for (int num20 = (int)((double)num18 - num11 / 2.0); (double)num20 < (double)num18 + num11 / 2.0; num20++)
				{
					double num36 = Math.Abs(num19 - num17);
					double num22 = Math.Abs(num20 - num18);
					double num23 = 1.0 + (double)genRand.Next(-20, 21) * 0.005;
					double num24 = 1.0 + (double)genRand.Next(-20, 21) * 0.005;
					double num37 = num36 * num23;
					num22 *= num24;
					double num25 = Math.Sqrt(num37 * num37 + num22 * num22);
					if (num25 < num11 * 0.2 * ((double)genRand.Next(90, 111) * 0.01))
					{
						Main.tile[num19, num20].active(active: false);
						Main.tile[num19, num20].wall = 83;
					}
					else
					{
						if (!(num25 < num11 * 0.45))
						{
							continue;
						}
						if (num19 < num12)
						{
							num12 = num19;
						}
						if (num19 > num13)
						{
							num13 = num19;
						}
						if (Main.tile[num19, num20].wall != 83)
						{
							Main.tile[num19, num20].active(active: true);
							Main.tile[num19, num20].type = 203;
							if (num25 < num11 * 0.35)
							{
								Main.tile[num19, num20].wall = 83;
							}
						}
					}
				}
			}
		}
		for (int num26 = num12; num26 <= num13; num26++)
		{
			int num27;
			for (num27 = num; (Main.tile[num26, num27].type == 203 && Main.tile[num26, num27].active()) || Main.tile[num26, num27].wall == 83; num27++)
			{
			}
			int num28 = genRand.Next(15, 20);
			for (; !Main.tile[num26, num27].active(); num27++)
			{
				if (num28 <= 0)
				{
					break;
				}
				if (Main.tile[num26, num27].wall == 83)
				{
					break;
				}
				num28--;
				Main.tile[num26, num27].type = 203;
				Main.tile[num26, num27].active(active: true);
			}
		}
		CrimEnt(position, crimDir);
	}

	public static void CrimPlaceHearts()
	{
		int num = 16;
		for (int i = 0; i < heartCount; i++)
		{
			num = genRand.Next(16, 21);
			int x = heartPos[i].X;
			int y = heartPos[i].Y;
			for (int j = x - num / 2; j < x + num / 2; j++)
			{
				for (int k = y - num / 2; k < y + num / 2; k++)
				{
					double num5 = Math.Abs(j - x);
					double num2 = Math.Abs(k - y);
					if (Math.Sqrt(num5 * num5 + num2 * num2) < (double)num * 0.4)
					{
						Main.tile[j, k].active(active: true);
						Main.tile[j, k].type = 203;
						Main.tile[j, k].wall = 83;
					}
				}
			}
		}
		for (int l = 0; l < heartCount; l++)
		{
			num = genRand.Next(10, 14);
			int x2 = heartPos[l].X;
			int y2 = heartPos[l].Y;
			for (int m = x2 - num / 2; m < x2 + num / 2; m++)
			{
				for (int n = y2 - num / 2; n < y2 + num / 2; n++)
				{
					double num6 = Math.Abs(m - x2);
					double num3 = Math.Abs(n - y2);
					if (Math.Sqrt(num6 * num6 + num3 * num3) < (double)num * 0.3)
					{
						Main.tile[m, n].active(active: false);
						Main.tile[m, n].wall = 83;
					}
				}
			}
		}
		for (int num4 = 0; num4 < heartCount; num4++)
		{
			AddShadowOrb(heartPos[num4].X, heartPos[num4].Y);
		}
	}

	public static void CrimEnt(Vector2D position, int crimDir)
	{
		double num = 0.0;
		double num2 = genRand.Next(6, 11);
		bool flag = true;
		Vector2D vector2D = new Vector2D(2.0, (double)genRand.Next(-20, 0) * 0.01);
		vector2D.X *= -crimDir;
		while (flag)
		{
			num += 1.0;
			if (num >= 20.0)
			{
				flag = false;
			}
			num2 += (double)genRand.Next(-10, 11) * 0.02;
			if (num2 < 6.0)
			{
				num2 = 6.0;
			}
			if (num2 > 10.0)
			{
				num2 = 10.0;
			}
			for (int i = (int)(position.X - num2 / 2.0); (double)i < position.X + num2 / 2.0; i++)
			{
				for (int j = (int)(position.Y - num2 / 2.0); (double)j < position.Y + num2 / 2.0; j++)
				{
					double num4 = Math.Abs((double)i - position.X);
					double num3 = Math.Abs((double)j - position.Y);
					if (Math.Sqrt(num4 * num4 + num3 * num3) < num2 * 0.5 && Main.tile[i, j].active() && Main.tile[i, j].type == 203)
					{
						Main.tile[i, j].active(active: false);
						flag = true;
						num = 0.0;
					}
				}
			}
			position += vector2D;
		}
	}

	public static void CrimVein(Vector2D position, Vector2D velocity)
	{
		//IL_034d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		double num = genRand.Next(15, 26);
		bool flag = true;
		Vector2D vector2D = velocity;
		Vector2D vector2D2 = position;
		int num2 = genRand.Next(100, 150);
		if (velocity.Y < 0.0)
		{
			num2 -= 25;
		}
		while (flag)
		{
			num += (double)genRand.Next(-50, 51) * 0.02;
			if (num < 15.0)
			{
				num = 15.0;
			}
			if (num > 25.0)
			{
				num = 25.0;
			}
			for (int i = (int)(position.X - num / 2.0); (double)i < position.X + num / 2.0; i++)
			{
				for (int j = (int)(position.Y - num / 2.0); (double)j < position.Y + num / 2.0; j++)
				{
					double num5 = Math.Abs((double)i - position.X);
					double num3 = Math.Abs((double)j - position.Y);
					double num4 = Math.Sqrt(num5 * num5 + num3 * num3);
					if (num4 < num * 0.2)
					{
						Main.tile[i, j].active(active: false);
						Main.tile[i, j].wall = 83;
					}
					else if (num4 < num * 0.5 && Main.tile[i, j].wall != 83)
					{
						Main.tile[i, j].active(active: true);
						Main.tile[i, j].type = 203;
						if (num4 < num * 0.4)
						{
							Main.tile[i, j].wall = 83;
						}
					}
				}
			}
			velocity.X += (double)genRand.Next(-50, 51) * 0.05;
			velocity.Y += (double)genRand.Next(-50, 51) * 0.05;
			if (velocity.Y < vector2D.Y - 0.75)
			{
				velocity.Y = vector2D.Y - 0.75;
			}
			if (velocity.Y > vector2D.Y + 0.75)
			{
				velocity.Y = vector2D.Y + 0.75;
			}
			if (velocity.X < vector2D.X - 0.75)
			{
				velocity.X = vector2D.X - 0.75;
			}
			if (velocity.X > vector2D.X + 0.75)
			{
				velocity.X = vector2D.X + 0.75;
			}
			position += velocity;
			if (Math.Abs(position.X - vector2D2.X) + Math.Abs(position.Y - vector2D2.Y) > (double)num2)
			{
				flag = false;
			}
		}
		heartPos[heartCount] = position.ToPoint();
		heartCount++;
	}

	public static void ChasmRunner(int i, int j, int steps, bool makeOrb = false)
	{
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		if (!makeOrb)
		{
			flag2 = true;
		}
		double num = steps;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-10, 11) * 0.1;
		vector2D2.Y = (double)genRand.Next(11) * 0.2 + 0.5;
		int num5 = 5;
		double num6 = genRand.Next(5) + 7;
		while (num6 > 0.0)
		{
			if (num > 0.0)
			{
				num6 += (double)genRand.Next(3);
				num6 -= (double)genRand.Next(3);
				if (num6 < 7.0)
				{
					num6 = 7.0;
				}
				if (num6 > 20.0)
				{
					num6 = 20.0;
				}
				if (num == 1.0 && num6 < 10.0)
				{
					num6 = 10.0;
				}
			}
			else if (vector2D.Y > Main.worldSurface + 45.0)
			{
				num6 -= (double)genRand.Next(4);
			}
			if (vector2D.Y > Main.rockLayer && num > 0.0)
			{
				num = 0.0;
			}
			num -= 1.0;
			if (!flag && vector2D.Y > Main.worldSurface + 20.0)
			{
				flag = true;
				ChasmRunnerSideways((int)vector2D.X, (int)vector2D.Y, -1, genRand.Next(20, 40));
				ChasmRunnerSideways((int)vector2D.X, (int)vector2D.Y, 1, genRand.Next(20, 40));
			}
			int num7;
			int num8;
			int num9;
			int num10;
			if (num > (double)num5)
			{
				num7 = (int)(vector2D.X - num6 * 0.5);
				num8 = (int)(vector2D.X + num6 * 0.5);
				num9 = (int)(vector2D.Y - num6 * 0.5);
				num10 = (int)(vector2D.Y + num6 * 0.5);
				if (num7 < 0)
				{
					num7 = 0;
				}
				if (num8 > Main.maxTilesX - 1)
				{
					num8 = Main.maxTilesX - 1;
				}
				if (num9 < 0)
				{
					num9 = 0;
				}
				if (num10 > Main.maxTilesY)
				{
					num10 = Main.maxTilesY;
				}
				for (int k = num7; k < num8; k++)
				{
					for (int l = num9; l < num10; l++)
					{
						if (Math.Abs((double)k - vector2D.X) + Math.Abs((double)l - vector2D.Y) < num6 * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].type != 31 && Main.tile[k, l].type != 22)
						{
							Main.tile[k, l].active(active: false);
						}
					}
				}
			}
			if (num <= 2.0 && vector2D.Y < Main.worldSurface + 45.0)
			{
				num = 2.0;
			}
			if (num <= 0.0)
			{
				if (!flag2)
				{
					flag2 = true;
					AddShadowOrb((int)vector2D.X, (int)vector2D.Y);
				}
				else if (!flag3)
				{
					flag3 = false;
					bool flag4 = false;
					int num11 = 0;
					while (!flag4)
					{
						int num12 = genRand.Next((int)vector2D.X - 25, (int)vector2D.X + 25);
						int num2 = genRand.Next((int)vector2D.Y - 50, (int)vector2D.Y);
						if (num12 < 5)
						{
							num12 = 5;
						}
						if (num12 > Main.maxTilesX - 5)
						{
							num12 = Main.maxTilesX - 5;
						}
						if (num2 < 5)
						{
							num2 = 5;
						}
						if (num2 > Main.maxTilesY - 5)
						{
							num2 = Main.maxTilesY - 5;
						}
						if ((double)num2 > Main.worldSurface)
						{
							if (!IsTileNearby(num12, num2, 26, 3))
							{
								Place3x2(num12, num2, 26);
							}
							if (Main.tile[num12, num2].type == 26)
							{
								flag4 = true;
								continue;
							}
							num11++;
							if (num11 >= 10000)
							{
								flag4 = true;
							}
						}
						else
						{
							flag4 = true;
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-10, 11) * 0.01;
			if (vector2D2.X > 0.3)
			{
				vector2D2.X = 0.3;
			}
			if (vector2D2.X < -0.3)
			{
				vector2D2.X = -0.3;
			}
			num7 = (int)(vector2D.X - num6 * 1.1);
			num8 = (int)(vector2D.X + num6 * 1.1);
			num9 = (int)(vector2D.Y - num6 * 1.1);
			num10 = (int)(vector2D.Y + num6 * 1.1);
			if (num7 < 1)
			{
				num7 = 1;
			}
			if (num8 > Main.maxTilesX - 1)
			{
				num8 = Main.maxTilesX - 1;
			}
			if (num9 < 0)
			{
				num9 = 0;
			}
			if (num10 > Main.maxTilesY)
			{
				num10 = Main.maxTilesY;
			}
			for (int m = num7; m < num8; m++)
			{
				for (int n = num9; n < num10; n++)
				{
					if (Math.Abs((double)m - vector2D.X) + Math.Abs((double)n - vector2D.Y) < num6 * 1.1 * (1.0 + (double)genRand.Next(-10, 11) * 0.015))
					{
						if (Main.tile[m, n].type != 25 && n > j + genRand.Next(3, 20))
						{
							Main.tile[m, n].active(active: true);
						}
						if (steps <= num5)
						{
							Main.tile[m, n].active(active: true);
						}
						if (Main.tile[m, n].type != 31)
						{
							Main.tile[m, n].type = 25;
						}
					}
				}
			}
			for (int num3 = num7; num3 < num8; num3++)
			{
				for (int num4 = num9; num4 < num10; num4++)
				{
					if (Math.Abs((double)num3 - vector2D.X) + Math.Abs((double)num4 - vector2D.Y) < num6 * 1.1 * (1.0 + (double)genRand.Next(-10, 11) * 0.015))
					{
						if (Main.tile[num3, num4].type != 31)
						{
							Main.tile[num3, num4].type = 25;
						}
						if (steps <= num5)
						{
							Main.tile[num3, num4].active(active: true);
						}
						if (num4 > j + genRand.Next(3, 20))
						{
							Main.tile[num3, num4].wall = 3;
						}
					}
				}
			}
		}
	}

	public static void SpawnPlanteraThorns(Vector2 position)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (Main.netMode == 1)
		{
			return;
		}
		int num = Main.rand.Next(3, 6);
		for (int i = 0; i < num; i++)
		{
			int num2 = Main.rand.Next(15, 31);
			int num3 = (int)(position.X / 16f);
			int num4 = (int)(position.Y / 16f);
			int num5 = 0;
			int num6 = 0;
			if (Main.rand.Next(2) != 0)
			{
				num6 = ((Main.rand.Next(2) == 0) ? 1 : (-1));
			}
			else
			{
				num5 = ((Main.rand.Next(2) == 0) ? 1 : (-1));
			}
			while (num2 > 0)
			{
				num2--;
				if (!Main.tile[num3, num4].active())
				{
					PlaceTile(num3, num4, 655);
					if (Main.tile[num3, num4].active() && Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, num3, num4);
					}
				}
				num3 += num5;
				num4 += num6;
				if (!InWorld(num3, num4))
				{
					return;
				}
				if (Main.rand.Next(5) == 0)
				{
					if (num6 == 0)
					{
						num5 = 0;
						num6 = ((Main.rand.Next(2) == 0) ? 1 : (-1));
					}
					else
					{
						num6 = 0;
						num5 = ((Main.rand.Next(2) == 0) ? 1 : (-1));
					}
				}
			}
		}
	}

	public static void GERunner(int i, int j, double speedX = 0.0, double speedY = 0.0, bool good = true)
	{
		int num = 0;
		for (int k = 20; k < Main.maxTilesX - 20; k++)
		{
			for (int l = 20; l < Main.maxTilesY - 20; l++)
			{
				if (Main.tile[k, l].active() && Main.tile[k, l].type == 225)
				{
					num++;
				}
			}
		}
		bool flag = false;
		if (num > 200000)
		{
			flag = true;
		}
		int num2 = genRand.Next(200, 250);
		double num3 = (double)Main.maxTilesX / 4200.0;
		num2 = (int)((double)num2 * num3);
		double num4 = num2;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-10, 11) * 0.1;
		vector2D2.Y = (double)genRand.Next(-10, 11) * 0.1;
		if (speedX != 0.0 || speedY != 0.0)
		{
			vector2D2.X = speedX;
			vector2D2.Y = speedY;
		}
		bool flag2 = true;
		while (flag2)
		{
			int num5 = (int)(vector2D.X - num4 * 0.5);
			int num6 = (int)(vector2D.X + num4 * 0.5);
			int num7 = (int)(vector2D.Y - num4 * 0.5);
			int num8 = (int)(vector2D.Y + num4 * 0.5);
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesX)
			{
				num6 = Main.maxTilesX;
			}
			if (num7 < 0)
			{
				num7 = 0;
			}
			if (num8 > Main.maxTilesY - 5)
			{
				num8 = Main.maxTilesY - 5;
			}
			for (int m = num5; m < num6; m++)
			{
				for (int n = num7; n < num8; n++)
				{
					if (!(Math.Abs((double)m - vector2D.X) + Math.Abs((double)n - vector2D.Y) < (double)num2 * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015)))
					{
						continue;
					}
					if (good)
					{
						if (Main.tile[m, n].wall == 63 || Main.tile[m, n].wall == 65 || Main.tile[m, n].wall == 66 || Main.tile[m, n].wall == 68 || Main.tile[m, n].wall == 69 || Main.tile[m, n].wall == 81)
						{
							Main.tile[m, n].wall = 70;
						}
						else if (Main.tile[m, n].wall == 216)
						{
							Main.tile[m, n].wall = 219;
						}
						else if (Main.tile[m, n].wall == 187)
						{
							Main.tile[m, n].wall = 222;
						}
						else if (Main.tile[m, n].wall == 3 || Main.tile[m, n].wall == 83)
						{
							Main.tile[m, n].wall = 28;
						}
						if (flag && Main.tile[m, n].type == 225)
						{
							Main.tile[m, n].type = 117;
							SquareTileFrame(m, n);
						}
						else if (flag && Main.tile[m, n].type == 230)
						{
							Main.tile[m, n].type = 402;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 2)
						{
							Main.tile[m, n].type = 109;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 1 || Main.tile[m, n].type == 25 || Main.tile[m, n].type == 203)
						{
							Main.tile[m, n].type = 117;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 53 || Main.tile[m, n].type == 123 || Main.tile[m, n].type == 112 || Main.tile[m, n].type == 234)
						{
							Main.tile[m, n].type = 116;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 661 || Main.tile[m, n].type == 662)
						{
							Main.tile[m, n].type = 60;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 23 || Main.tile[m, n].type == 199)
						{
							Main.tile[m, n].type = 109;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 161 || Main.tile[m, n].type == 163 || Main.tile[m, n].type == 200)
						{
							Main.tile[m, n].type = 164;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 396)
						{
							Main.tile[m, n].type = 403;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 397)
						{
							Main.tile[m, n].type = 402;
							SquareTileFrame(m, n);
						}
					}
					else if (crimson)
					{
						if (Main.tile[m, n].wall == 63 || Main.tile[m, n].wall == 65 || Main.tile[m, n].wall == 66 || Main.tile[m, n].wall == 68)
						{
							Main.tile[m, n].wall = 81;
						}
						else if (Main.tile[m, n].wall == 216)
						{
							Main.tile[m, n].wall = 218;
						}
						else if (Main.tile[m, n].wall == 187)
						{
							Main.tile[m, n].wall = 221;
						}
						if (flag && Main.tile[m, n].type == 225)
						{
							Main.tile[m, n].type = 203;
							SquareTileFrame(m, n);
						}
						else if (flag && Main.tile[m, n].type == 230)
						{
							Main.tile[m, n].type = 399;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 60 || Main.tile[m, n].type == 661)
						{
							Main.tile[m, n].type = 662;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 2 || Main.tile[m, n].type == 109)
						{
							Main.tile[m, n].type = 199;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 1 || Main.tile[m, n].type == 117)
						{
							Main.tile[m, n].type = 203;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 53 || Main.tile[m, n].type == 123 || Main.tile[m, n].type == 116)
						{
							Main.tile[m, n].type = 234;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 161 || Main.tile[m, n].type == 164)
						{
							Main.tile[m, n].type = 200;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 396)
						{
							Main.tile[m, n].type = 401;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 397)
						{
							Main.tile[m, n].type = 399;
							SquareTileFrame(m, n);
						}
					}
					else
					{
						if (Main.tile[m, n].wall == 63 || Main.tile[m, n].wall == 65 || Main.tile[m, n].wall == 66 || Main.tile[m, n].wall == 68)
						{
							Main.tile[m, n].wall = 69;
						}
						else if (Main.tile[m, n].wall == 216)
						{
							Main.tile[m, n].wall = 217;
						}
						else if (Main.tile[m, n].wall == 187)
						{
							Main.tile[m, n].wall = 220;
						}
						if (flag && Main.tile[m, n].type == 225)
						{
							Main.tile[m, n].type = 25;
							SquareTileFrame(m, n);
						}
						else if (flag && Main.tile[m, n].type == 230)
						{
							Main.tile[m, n].type = 398;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 60 || Main.tile[m, n].type == 662)
						{
							Main.tile[m, n].type = 661;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 2 || Main.tile[m, n].type == 109)
						{
							Main.tile[m, n].type = 23;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 1 || Main.tile[m, n].type == 117)
						{
							Main.tile[m, n].type = 25;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 53 || Main.tile[m, n].type == 123 || Main.tile[m, n].type == 116)
						{
							Main.tile[m, n].type = 112;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 161 || Main.tile[m, n].type == 164)
						{
							Main.tile[m, n].type = 163;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 396)
						{
							Main.tile[m, n].type = 400;
							SquareTileFrame(m, n);
						}
						else if (Main.tile[m, n].type == 397)
						{
							Main.tile[m, n].type = 398;
							SquareTileFrame(m, n);
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.X > speedX + 1.0)
			{
				vector2D2.X = speedX + 1.0;
			}
			if (vector2D2.X < speedX - 1.0)
			{
				vector2D2.X = speedX - 1.0;
			}
			if (vector2D.X < (double)(-num2) || vector2D.Y < (double)(-num2) || vector2D.X > (double)(Main.maxTilesX + num2) || vector2D.Y > (double)(Main.maxTilesY + num2))
			{
				flag2 = false;
			}
		}
	}

	private static bool badOceanCaveTiles(int x, int y)
	{
		if (Main.tile[x, y].wall == 83 || Main.tile[x, y].wall == 3 || Main.wallDungeon[Main.tile[x, y].wall] || Main.tile[x, y].type == 203 || Main.tile[x, y].type == 25 || Main.tileDungeon[Main.tile[x, y].type] || Main.tile[x, y].type == 26 || Main.tile[x, y].type == 31)
		{
			return true;
		}
		return false;
	}

	public static void oceanCave(int i, int j)
	{
		if (GenVars.numOceanCaveTreasure >= GenVars.maxOceanCaveTreasure)
		{
			GenVars.numOceanCaveTreasure = 0;
		}
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		if (i < Main.maxTilesX / 2)
		{
			vector2D2.X = 0.25 + genRand.NextDouble() * 0.25;
		}
		else
		{
			vector2D2.X = -0.35 - genRand.NextDouble() * 0.5;
		}
		vector2D2.Y = 0.4 + genRand.NextDouble() * 0.25;
		ushort num = 264;
		ushort num12 = 53;
		ushort num15 = 397;
		double num16 = genRand.Next(17, 25);
		double num17 = genRand.Next(600, 800);
		double num18 = 4.0;
		bool flag = true;
		while (num16 > num18 && num17 > 0.0)
		{
			bool flag2 = true;
			bool flag3 = true;
			bool flag4 = true;
			if (vector2D.X > (double)(beachDistance - 50) && vector2D.X < (double)(Main.maxTilesX - beachDistance + 50))
			{
				num16 *= 0.96;
				num17 *= 0.96;
			}
			if (num16 < num18 + 2.0 || num17 < 20.0)
			{
				flag4 = false;
			}
			if (flag)
			{
				num16 -= 0.01 + genRand.NextDouble() * 0.01;
				num17 -= 0.5;
			}
			else
			{
				num16 -= 0.02 + genRand.NextDouble() * 0.02;
				num17 -= 1.0;
			}
			if (flag4)
			{
				GenVars.oceanCaveTreasure[GenVars.numOceanCaveTreasure].X = (int)vector2D.X;
				GenVars.oceanCaveTreasure[GenVars.numOceanCaveTreasure].Y = (int)vector2D.Y;
			}
			int num19 = (int)(vector2D.X - num16 * 3.0);
			int num20 = (int)(vector2D.X + num16 * 3.0);
			int num21 = (int)(vector2D.Y - num16 * 3.0);
			int num2 = (int)(vector2D.Y + num16 * 3.0);
			if (num19 < 1)
			{
				num19 = 1;
			}
			if (num20 > Main.maxTilesX - 1)
			{
				num20 = Main.maxTilesX - 1;
			}
			if (num21 < 1)
			{
				num21 = 1;
			}
			if (num2 > Main.maxTilesY - 1)
			{
				num2 = Main.maxTilesY - 1;
			}
			for (int k = num19; k < num20; k++)
			{
				for (int l = num21; l < num2; l++)
				{
					if (badOceanCaveTiles(k, l))
					{
						continue;
					}
					double num3 = new Vector2D(Math.Abs((double)k - vector2D.X), Math.Abs((double)l - vector2D.Y)).Length();
					if (flag4 && num3 < num16 * 0.5 + 1.0)
					{
						Main.tile[k, l].type = num;
						Main.tile[k, l].active(active: false);
					}
					else if (num3 < num16 * 1.5 + 1.0 && Main.tile[k, l].type != num)
					{
						if ((double)l < vector2D.Y)
						{
							if ((vector2D2.X < 0.0 && (double)k < vector2D.X) || (vector2D2.X > 0.0 && (double)k > vector2D.X))
							{
								if (num3 < num16 * 1.1 + 1.0)
								{
									Main.tile[k, l].type = num15;
									if (Main.tile[k, l].liquid == byte.MaxValue)
									{
										Main.tile[k, l].wall = 0;
									}
								}
								else if (Main.tile[k, l].type != num15)
								{
									Main.tile[k, l].type = num12;
								}
							}
						}
						else if ((vector2D2.X < 0.0 && k < i) || (vector2D2.X > 0.0 && k > i))
						{
							if (Main.tile[k, l].liquid == byte.MaxValue)
							{
								Main.tile[k, l].wall = 0;
							}
							Main.tile[k, l].type = num12;
							Main.tile[k, l].active(active: true);
							if (k == (int)vector2D.X && flag2)
							{
								flag2 = false;
								int num4 = 50 + genRand.Next(3);
								int num5 = 43 + genRand.Next(3);
								int num6 = 20 + genRand.Next(3);
								int num7 = k;
								int num8 = k + num6;
								if (vector2D2.X < 0.0)
								{
									num7 = k - num6;
									num8 = k;
								}
								if (num17 < 100.0)
								{
									num4 = (int)((double)num4 * (num17 / 100.0));
									num5 = (int)((double)num5 * (num17 / 100.0));
									num6 = (int)((double)num6 * (num17 / 100.0));
								}
								if (num16 < num18 + 5.0)
								{
									double num9 = (num16 - num18) / 5.0;
									num4 = (int)((double)num4 * num9);
									num5 = (int)((double)num5 * num9);
									num6 = (int)((double)num6 * num9);
								}
								for (int m = num7; m <= num8; m++)
								{
									for (int n = l; n < l + num4 && !badOceanCaveTiles(m, n); n++)
									{
										if (n > l + num5)
										{
											if (SolidTile(m, n) && Main.tile[m, n].type != num12)
											{
												break;
											}
											Main.tile[m, n].type = num15;
										}
										else
										{
											Main.tile[m, n].type = num12;
										}
										Main.tile[m, n].active(active: true);
										if (genRand.Next(3) == 0)
										{
											Main.tile[m - 1, n].type = num12;
											Main.tile[m - 1, n].active(active: true);
										}
										if (genRand.Next(3) == 0)
										{
											Main.tile[m + 1, n].type = num12;
											Main.tile[m + 1, n].active(active: true);
										}
									}
								}
							}
						}
					}
					if (num3 < num16 * 1.3 + 1.0 && l > j - 10)
					{
						Main.tile[k, l].liquid = byte.MaxValue;
					}
					if (!flag3 || k != (int)vector2D.X || !((double)l > vector2D.Y))
					{
						continue;
					}
					flag3 = false;
					int num10 = 100;
					int num11 = 2;
					for (int num13 = k - num11; num13 <= k + num11; num13++)
					{
						for (int num14 = l; num14 < l + num10; num14++)
						{
							if (!badOceanCaveTiles(num13, num14))
							{
								Main.tile[num13, num14].liquid = byte.MaxValue;
							}
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += genRand.NextDouble() * 0.1 - 0.05;
			vector2D2.Y += genRand.NextDouble() * 0.1 - 0.05;
			if (flag)
			{
				if (vector2D.Y > (Main.worldSurface * 2.0 + Main.rockLayer) / 3.0 && vector2D.Y > (double)(j + 30))
				{
					flag = false;
				}
				vector2D2.Y = Utils.Clamp(vector2D2.Y, 0.35, 1.0);
			}
			else
			{
				if (vector2D.X < (double)(Main.maxTilesX / 2))
				{
					if (vector2D2.X < 0.5)
					{
						vector2D2.X += 0.02;
					}
				}
				else if (vector2D2.X > -0.5)
				{
					vector2D2.X -= 0.02;
				}
				if (!flag4)
				{
					if (vector2D2.Y < 0.0)
					{
						vector2D2.Y *= 0.95;
					}
					vector2D2.Y += 0.04;
				}
				else if (vector2D.Y < (Main.worldSurface * 4.0 + Main.rockLayer) / 5.0)
				{
					if (vector2D2.Y < 0.0)
					{
						vector2D2.Y *= 0.97;
					}
					vector2D2.Y += 0.02;
				}
				else if (vector2D2.Y > -0.1)
				{
					vector2D2.Y *= 0.99;
					vector2D2.Y -= 0.01;
				}
				vector2D2.Y = Utils.Clamp(vector2D2.Y, -1.0, 1.0);
			}
			if (vector2D.X < (double)(Main.maxTilesX / 2))
			{
				vector2D2.X = Utils.Clamp(vector2D2.X, 0.1, 1.0);
			}
			else
			{
				vector2D2.X = Utils.Clamp(vector2D2.X, -1.0, -0.1);
			}
		}
		GenVars.numOceanCaveTreasure++;
	}

	public static void WavyCaverer(int startX, int startY, double waveStrengthScalar, double wavePercentScalar, int steps, int type)
	{
		Vector2D vector2D = new Vector2D(startX, startY);
		bool flag = ((startX > Main.maxTilesX / 2) ? true : false);
		int num = 2 + genRand.Next(2);
		int num6 = 15 + genRand.Next(11);
		int num7 = 1 + genRand.Next(2);
		int num8 = (int)Math.Ceiling((double)num6 / (double)num7);
		double num9 = 1.0;
		double num10 = 1.0;
		int num11 = (int)(-1.0 + genRand.NextDouble() * 3.0);
		int num12 = num;
		int num13 = 0;
		for (int i = 0; i < steps; i++)
		{
			bool flag2 = i < num8;
			bool flag3 = i >= steps - num8;
			vector2D.X += ((!flag) ? 1 : (-1));
			if (!flag2 && !flag3)
			{
				num13++;
				num9 = Math.Min(2.0, Math.Max(0.5, num9 + (-0.5 + genRand.NextDouble()) * 0.25));
				num10 = Math.Min(1.1, Math.Max(0.9, num10 + (-0.5 + genRand.NextDouble()) * 0.02));
			}
			double num2 = Math.Sin((double)num13 * 0.1 * num10 * wavePercentScalar) * num9 * waveStrengthScalar;
			vector2D.Y = (double)startY + num2 + (double)(num13 * num11);
			int num3 = num12;
			if (flag2)
			{
				num12 = Math.Min(num6, num12 + num7);
			}
			else if (flag3)
			{
				num12 = Math.Max(num, num12 - num7);
			}
			vector2D.Y -= (num3 + num12) / 4;
			for (int j = 0; j < num12; j++)
			{
				int num4 = (int)vector2D.X;
				int num5 = (int)vector2D.Y + j;
				if (InWorld(num4, num5, 20))
				{
					if (type >= 0)
					{
						PlaceTile(num4, num5, type, mute: true, forced: true);
					}
					else
					{
						KillTile(num4, num5);
					}
				}
			}
		}
	}

	public static void TileRunner(int i, int j, double strength, int steps, int type, bool addTile = false, double speedX = 0.0, double speedY = 0.0, bool noYChange = false, bool overRide = true, int ignoreTileType = -1)
	{
		if (!GenVars.mudWall)
		{
			if (drunkWorldGen)
			{
				strength *= 1.0 + (double)genRand.Next(-80, 81) * 0.01;
				steps = (int)((double)steps * (1.0 + (double)genRand.Next(-80, 81) * 0.01));
			}
			else if (remixWorldGen)
			{
				strength *= 1.0 + (double)genRand.Next(-50, 51) * 0.01;
			}
			else if (getGoodWorldGen && type != 57)
			{
				strength *= 1.0 + (double)genRand.Next(-80, 81) * 0.015;
				steps += genRand.Next(3);
			}
		}
		double num = strength;
		double num2 = steps;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-10, 11) * 0.1;
		vector2D2.Y = (double)genRand.Next(-10, 11) * 0.1;
		if (speedX != 0.0 || speedY != 0.0)
		{
			vector2D2.X = speedX;
			vector2D2.Y = speedY;
		}
		bool flag = type == 368;
		bool flag2 = type == 367;
		bool lava = false;
		if (getGoodWorldGen && genRand.Next(4) == 0)
		{
			lava = true;
		}
		while (num > 0.0 && num2 > 0.0)
		{
			if (drunkWorldGen && genRand.Next(30) == 0)
			{
				vector2D.X += (double)genRand.Next(-100, 101) * 0.05;
				vector2D.Y += (double)genRand.Next(-100, 101) * 0.05;
			}
			if (vector2D.Y < 0.0 && num2 > 0.0 && type == 59)
			{
				num2 = 0.0;
			}
			num = strength * (num2 / (double)steps);
			num2 -= 1.0;
			int num3 = (int)(vector2D.X - num * 0.5);
			int num4 = (int)(vector2D.X + num * 0.5);
			int num5 = (int)(vector2D.Y - num * 0.5);
			int num6 = (int)(vector2D.Y + num * 0.5);
			if (num3 < 1)
			{
				num3 = 1;
			}
			if (num4 > Main.maxTilesX - 1)
			{
				num4 = Main.maxTilesX - 1;
			}
			if (num5 < 1)
			{
				num5 = 1;
			}
			if (num6 > Main.maxTilesY - 1)
			{
				num6 = Main.maxTilesY - 1;
			}
			for (int k = num3; k < num4; k++)
			{
				if (k < beachDistance + 50 || k >= Main.maxTilesX - beachDistance - 50)
				{
					lava = false;
				}
				for (int l = num5; l < num6; l++)
				{
					if ((drunkWorldGen && l < Main.maxTilesY - 300 && type == 57) || (ignoreTileType >= 0 && Main.tile[k, l].active() && Main.tile[k, l].type == ignoreTileType) || !(Math.Abs((double)k - vector2D.X) + Math.Abs((double)l - vector2D.Y) < strength * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015)))
					{
						continue;
					}
					if (GenVars.mudWall && (double)l > Main.worldSurface && Main.tile[k, l - 1].wall != 2 && l < Main.maxTilesY - 210 - genRand.Next(3) && Math.Abs((double)k - vector2D.X) + Math.Abs((double)l - vector2D.Y) < strength * 0.45 * (1.0 + (double)genRand.Next(-10, 11) * 0.01))
					{
						if (l > GenVars.lavaLine - genRand.Next(0, 4) - 50)
						{
							if (Main.tile[k, l - 1].wall != 64 && Main.tile[k, l + 1].wall != 64 && Main.tile[k - 1, l].wall != 64 && Main.tile[k + 1, l].wall != 64)
							{
								PlaceWall(k, l, 15, mute: true);
							}
						}
						else if (Main.tile[k, l - 1].wall != 15 && Main.tile[k, l + 1].wall != 15 && Main.tile[k - 1, l].wall != 15 && Main.tile[k + 1, l].wall != 15)
						{
							PlaceWall(k, l, 64, mute: true);
						}
					}
					if (type < 0)
					{
						if (Main.tile[k, l].type == 53)
						{
							continue;
						}
						if (type == -2 && Main.tile[k, l].active() && (l < GenVars.waterLine || l > GenVars.lavaLine))
						{
							Main.tile[k, l].liquid = byte.MaxValue;
							Main.tile[k, l].lava(lava);
							if (remixWorldGen)
							{
								if (l > GenVars.lavaLine && ((double)l < Main.rockLayer - 80.0 || l > Main.maxTilesY - 350) && !oceanDepths(k, l))
								{
									Main.tile[k, l].lava(lava: true);
								}
							}
							else if (l > GenVars.lavaLine)
							{
								Main.tile[k, l].lava(lava: true);
							}
						}
						Main.tile[k, l].active(active: false);
						continue;
					}
					if (flag && Math.Abs((double)k - vector2D.X) + Math.Abs((double)l - vector2D.Y) < strength * 0.3 * (1.0 + (double)genRand.Next(-10, 11) * 0.01))
					{
						PlaceWall(k, l, 180, mute: true);
					}
					if (flag2 && Math.Abs((double)k - vector2D.X) + Math.Abs((double)l - vector2D.Y) < strength * 0.3 * (1.0 + (double)genRand.Next(-10, 11) * 0.01))
					{
						PlaceWall(k, l, 178, mute: true);
					}
					if (overRide || !Main.tile[k, l].active())
					{
						Tile tile = Main.tile[k, l];
						bool flag3 = false;
						flag3 = Main.tileStone[type] && tile.type != 1;
						if (!TileID.Sets.CanBeClearedDuringGeneration[tile.type])
						{
							flag3 = true;
						}
						switch (tile.type)
						{
						case 53:
							if (type == 59 && ((Rectangle)(ref GenVars.UndergroundDesertLocation)).Contains(k, l))
							{
								flag3 = true;
							}
							if (type == 40)
							{
								flag3 = true;
							}
							if ((double)l < Main.worldSurface && type != 59)
							{
								flag3 = true;
							}
							break;
						case 45:
						case 147:
						case 189:
						case 190:
						case 196:
						case 460:
							flag3 = true;
							break;
						case 396:
						case 397:
							flag3 = !TileID.Sets.Ore[type];
							break;
						case 1:
							if (type == 59 && (double)l < Main.worldSurface + (double)genRand.Next(-50, 50))
							{
								flag3 = true;
							}
							break;
						case 367:
						case 368:
							if (type == 59)
							{
								flag3 = true;
							}
							break;
						}
						if (!flag3)
						{
							tile.type = (ushort)type;
						}
					}
					if (addTile)
					{
						Main.tile[k, l].active(active: true);
						Main.tile[k, l].liquid = 0;
						Main.tile[k, l].lava(lava: false);
					}
					if (noYChange && (double)l < Main.worldSurface && type != 59)
					{
						Main.tile[k, l].wall = 2;
					}
					if (type == 59 && l > GenVars.waterLine && Main.tile[k, l].liquid > 0)
					{
						Main.tile[k, l].lava(lava: false);
						Main.tile[k, l].liquid = 0;
					}
				}
			}
			vector2D += vector2D2;
			if ((!drunkWorldGen || genRand.Next(3) != 0) && num > 50.0)
			{
				vector2D += vector2D2;
				num2 -= 1.0;
				vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
				vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
				if (num > 100.0)
				{
					vector2D += vector2D2;
					num2 -= 1.0;
					vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
					vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
					if (num > 150.0)
					{
						vector2D += vector2D2;
						num2 -= 1.0;
						vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
						vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
						if (num > 200.0)
						{
							vector2D += vector2D2;
							num2 -= 1.0;
							vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
							vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
							if (num > 250.0)
							{
								vector2D += vector2D2;
								num2 -= 1.0;
								vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
								vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
								if (num > 300.0)
								{
									vector2D += vector2D2;
									num2 -= 1.0;
									vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
									vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
									if (num > 400.0)
									{
										vector2D += vector2D2;
										num2 -= 1.0;
										vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
										vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
										if (num > 500.0)
										{
											vector2D += vector2D2;
											num2 -= 1.0;
											vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
											vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
											if (num > 600.0)
											{
												vector2D += vector2D2;
												num2 -= 1.0;
												vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
												vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
												if (num > 700.0)
												{
													vector2D += vector2D2;
													num2 -= 1.0;
													vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
													vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
													if (num > 800.0)
													{
														vector2D += vector2D2;
														num2 -= 1.0;
														vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
														vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
														if (num > 900.0)
														{
															vector2D += vector2D2;
															num2 -= 1.0;
															vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
															vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
			if (drunkWorldGen)
			{
				vector2D2.X += (double)genRand.Next(-10, 11) * 0.25;
			}
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (!noYChange)
			{
				vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
				if (vector2D2.Y > 1.0)
				{
					vector2D2.Y = 1.0;
				}
				if (vector2D2.Y < -1.0)
				{
					vector2D2.Y = -1.0;
				}
			}
			else if (type != 59 && num < 3.0)
			{
				if (vector2D2.Y > 1.0)
				{
					vector2D2.Y = 1.0;
				}
				if (vector2D2.Y < -1.0)
				{
					vector2D2.Y = -1.0;
				}
			}
			if (type == 59 && !noYChange)
			{
				if (vector2D2.Y > 0.5)
				{
					vector2D2.Y = 0.5;
				}
				if (vector2D2.Y < -0.5)
				{
					vector2D2.Y = -0.5;
				}
				if (vector2D.Y < Main.rockLayer + 100.0)
				{
					vector2D2.Y = 1.0;
				}
				if (vector2D.Y > (double)(Main.maxTilesY - 300))
				{
					vector2D2.Y = -1.0;
				}
			}
		}
	}

	public static void DirtyRockRunner(int i, int j)
	{
		double num = genRand.Next(2, 6);
		double num2 = genRand.Next(5, 50);
		double num3 = num2;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-10, 11) * 0.1;
		vector2D2.Y = (double)genRand.Next(-10, 11) * 0.1;
		while (num > 0.0 && num3 > 0.0)
		{
			double num4 = num * (num3 / num2);
			num3 -= 1.0;
			int num5 = (int)(vector2D.X - num4 * 0.5);
			int num6 = (int)(vector2D.X + num4 * 0.5);
			int num7 = (int)(vector2D.Y - num4 * 0.5);
			int num8 = (int)(vector2D.Y + num4 * 0.5);
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesX)
			{
				num6 = Main.maxTilesX;
			}
			if (num7 < 0)
			{
				num7 = 0;
			}
			if (num8 > Main.maxTilesY)
			{
				num8 = Main.maxTilesY;
			}
			for (int k = num5; k < num6; k++)
			{
				for (int l = num7; l < num8; l++)
				{
					if (Math.Abs((double)k - vector2D.X) + Math.Abs((double)l - vector2D.Y) < num * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].wall == 2)
					{
						Main.tile[k, l].wall = 59;
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.Y > 1.0)
			{
				vector2D2.Y = 1.0;
			}
			if (vector2D2.Y < -1.0)
			{
				vector2D2.Y = -1.0;
			}
		}
	}

	public static void MudWallRunner(int i, int j)
	{
		double num = genRand.Next(8, 21);
		double num2 = genRand.Next(8, 33);
		double num3 = num2;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-10, 11) * 0.1;
		vector2D2.Y = (double)genRand.Next(-10, 11) * 0.1;
		while (num > 0.0 && num3 > 0.0)
		{
			double num4 = num * (num3 / num2);
			num3 -= 1.0;
			int num5 = (int)(vector2D.X - num4 * 0.5);
			int num6 = (int)(vector2D.X + num4 * 0.5);
			int num7 = (int)(vector2D.Y - num4 * 0.5);
			int num8 = (int)(vector2D.Y + num4 * 0.5);
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesX)
			{
				num6 = Main.maxTilesX;
			}
			if (num7 < 0)
			{
				num7 = 0;
			}
			if (num8 > Main.maxTilesY)
			{
				num8 = Main.maxTilesY;
			}
			for (int k = num5; k < num6; k++)
			{
				for (int l = num7; l < num8; l++)
				{
					if (Math.Abs((double)k - vector2D.X) + Math.Abs((double)l - vector2D.Y) < num * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && (double)l > Main.worldSurface)
					{
						Main.tile[k, l].wall = 0;
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.Y > 1.0)
			{
				vector2D2.Y = 1.0;
			}
			if (vector2D2.Y < -1.0)
			{
				vector2D2.Y = -1.0;
			}
		}
	}

	public static void SnowCloudIsland(int i, int j)
	{
		double num = genRand.Next(100, 150);
		double num12 = num;
		double num22 = genRand.Next(20, 30);
		int num32 = i;
		int num43 = i;
		int num47 = i;
		int num48 = j;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
		{
			vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		}
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.02;
		while (num > 0.0 && num22 > 0.0)
		{
			num -= (double)genRand.Next(4);
			num22 -= 1.0;
			int num49 = (int)(vector2D.X - num * 0.5);
			int num51 = (int)(vector2D.X + num * 0.5);
			int num2 = (int)(vector2D.Y - num * 0.5);
			int num4 = (int)(vector2D.Y + num * 0.5);
			if (num49 < 0)
			{
				num49 = 0;
			}
			if (num51 > Main.maxTilesX)
			{
				num51 = Main.maxTilesX;
			}
			if (num2 < 0)
			{
				num2 = 0;
			}
			if (num4 > Main.maxTilesY)
			{
				num4 = Main.maxTilesY;
			}
			num12 = num * (double)genRand.Next(80, 120) * 0.01;
			double num6 = vector2D.Y + 1.0;
			for (int k = num49; k < num51; k++)
			{
				if (genRand.Next(2) == 0)
				{
					num6 += (double)genRand.Next(-1, 2);
				}
				if (num6 < vector2D.Y)
				{
					num6 = vector2D.Y;
				}
				if (num6 > vector2D.Y + 2.0)
				{
					num6 = vector2D.Y + 2.0;
				}
				for (int l = num2; l < num4; l++)
				{
					if (!((double)l > num6))
					{
						continue;
					}
					double num53 = Math.Abs((double)k - vector2D.X);
					double num7 = Math.Abs((double)l - vector2D.Y) * 3.0;
					if (Math.Sqrt(num53 * num53 + num7 * num7) < num12 * 0.4)
					{
						if (k < num32)
						{
							num32 = k;
						}
						if (k > num43)
						{
							num43 = k;
						}
						if (l < num47)
						{
							num47 = l;
						}
						if (l > num48)
						{
							num48 = l;
						}
						Main.tile[k, l].active(active: true);
						Main.tile[k, l].type = 189;
						SquareTileFrame(k, l);
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-20, 21) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (vector2D2.Y > 0.2)
			{
				vector2D2.Y = -0.2;
			}
			if (vector2D2.Y < -0.2)
			{
				vector2D2.Y = -0.2;
			}
		}
		int num8 = num32;
		int num10;
		for (num8 += genRand.Next(5); num8 < num43; num8 += genRand.Next(num10, (int)((double)num10 * 1.5)))
		{
			int num9 = num48;
			while (!Main.tile[num8, num9].active())
			{
				num9--;
			}
			num9 += genRand.Next(-3, 4);
			num10 = genRand.Next(4, 8);
			int num11 = 189;
			if (genRand.Next(4) == 0)
			{
				num11 = 460;
			}
			for (int m = num8 - num10; m <= num8 + num10; m++)
			{
				for (int n = num9 - num10; n <= num9 + num10; n++)
				{
					if (n > num47)
					{
						double num54 = Math.Abs(m - num8);
						double num13 = Math.Abs(n - num9) * 2;
						if (Math.Sqrt(num54 * num54 + num13 * num13) < (double)(num10 + genRand.Next(2)))
						{
							Main.tile[m, n].active(active: true);
							Main.tile[m, n].type = (ushort)num11;
							SquareTileFrame(m, n);
						}
					}
				}
			}
		}
		num = genRand.Next(80, 95);
		num12 = num;
		num22 = genRand.Next(10, 15);
		vector2D.X = i;
		vector2D.Y = num47;
		vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
		{
			vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		}
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.02;
		while (num > 0.0 && num22 > 0.0)
		{
			num -= (double)genRand.Next(4);
			num22 -= 1.0;
			int num50 = (int)(vector2D.X - num * 0.5);
			int num52 = (int)(vector2D.X + num * 0.5);
			int num3 = num47 - 1;
			int num5 = (int)(vector2D.Y + num * 0.5);
			if (num50 < 0)
			{
				num50 = 0;
			}
			if (num52 > Main.maxTilesX)
			{
				num52 = Main.maxTilesX;
			}
			if (num3 < 0)
			{
				num3 = 0;
			}
			if (num5 > Main.maxTilesY)
			{
				num5 = Main.maxTilesY;
			}
			num12 = num * (double)genRand.Next(80, 120) * 0.01;
			double num14 = vector2D.Y + 1.0;
			for (int num15 = num50; num15 < num52; num15++)
			{
				if (genRand.Next(2) == 0)
				{
					num14 += (double)genRand.Next(-1, 2);
				}
				if (num14 < vector2D.Y)
				{
					num14 = vector2D.Y;
				}
				if (num14 > vector2D.Y + 2.0)
				{
					num14 = vector2D.Y + 2.0;
				}
				for (int num16 = num3; num16 < num5; num16++)
				{
					if ((double)num16 > num14)
					{
						double num55 = Math.Abs((double)num15 - vector2D.X);
						double num17 = Math.Abs((double)num16 - vector2D.Y) * 3.0;
						if (Math.Sqrt(num55 * num55 + num17 * num17) < num12 * 0.4 && Main.tile[num15, num16].type == 189)
						{
							Main.tile[num15, num16].type = 147;
							SquareTileFrame(num15, num16);
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-20, 21) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (vector2D2.Y > 0.2)
			{
				vector2D2.Y = -0.2;
			}
			if (vector2D2.Y < -0.2)
			{
				vector2D2.Y = -0.2;
			}
		}
		int num18 = num32;
		num18 += genRand.Next(5);
		while (num18 < num43)
		{
			int num19 = num48;
			while ((!Main.tile[num18, num19].active() || Main.tile[num18, num19].type != 0) && num18 < num43)
			{
				num19--;
				if (num19 < num47)
				{
					num19 = num48;
					num18 += genRand.Next(1, 4);
				}
			}
			if (num18 >= num43)
			{
				continue;
			}
			num19 += genRand.Next(0, 4);
			int num20 = genRand.Next(2, 5);
			int num21 = 189;
			for (int num23 = num18 - num20; num23 <= num18 + num20; num23++)
			{
				for (int num24 = num19 - num20; num24 <= num19 + num20; num24++)
				{
					if (num24 > num47)
					{
						double num56 = Math.Abs(num23 - num18);
						double num25 = Math.Abs(num24 - num19) * 2;
						if (Math.Sqrt(num56 * num56 + num25 * num25) < (double)num20)
						{
							Main.tile[num23, num24].type = (ushort)num21;
							SquareTileFrame(num23, num24);
						}
					}
				}
			}
			num18 += genRand.Next(num20, (int)((double)num20 * 1.5));
		}
		for (int num26 = num32 - 20; num26 <= num43 + 20; num26++)
		{
			for (int num27 = num47 - 20; num27 <= num48 + 20; num27++)
			{
				bool flag = true;
				for (int num28 = num26 - 1; num28 <= num26 + 1; num28++)
				{
					for (int num29 = num27 - 1; num29 <= num27 + 1; num29++)
					{
						if (!Main.tile[num28, num29].active())
						{
							flag = false;
						}
					}
				}
				if (flag)
				{
					Main.tile[num26, num27].wall = 73;
					SquareWallFrame(num26, num27);
				}
			}
		}
		for (int num30 = num32; num30 <= num43; num30++)
		{
			int num31;
			for (num31 = num47 - 10; !Main.tile[num30, num31 + 1].active(); num31++)
			{
			}
			if (num31 >= num48 || Main.tile[num30, num31 + 1].type != 189)
			{
				continue;
			}
			if (genRand.Next(10) == 0)
			{
				int num33 = genRand.Next(1, 3);
				for (int num34 = num30 - num33; num34 <= num30 + num33; num34++)
				{
					if (Main.tile[num34, num31].type == 189 && WillWaterPlacedHereStayPut(num34, num31))
					{
						Main.tile[num34, num31].active(active: false);
						Main.tile[num34, num31].liquid = byte.MaxValue;
						Main.tile[num34, num31].lava(lava: false);
						SquareTileFrame(num30, num31);
					}
					if (Main.tile[num34, num31 + 1].type == 189 && WillWaterPlacedHereStayPut(num34, num31 + 1))
					{
						Main.tile[num34, num31 + 1].active(active: false);
						Main.tile[num34, num31 + 1].liquid = byte.MaxValue;
						Main.tile[num34, num31 + 1].lava(lava: false);
						SquareTileFrame(num30, num31 + 1);
					}
					if (num34 > num30 - num33 && num34 < num30 + 2 && Main.tile[num34, num31 + 2].type == 189 && WillWaterPlacedHereStayPut(num34, num31 + 2))
					{
						Main.tile[num34, num31 + 2].active(active: false);
						Main.tile[num34, num31 + 2].liquid = byte.MaxValue;
						Main.tile[num34, num31 + 2].lava(lava: false);
						SquareTileFrame(num30, num31 + 2);
					}
				}
			}
			if (genRand.Next(5) == 0 && WillWaterPlacedHereStayPut(num30, num31))
			{
				Main.tile[num30, num31].liquid = byte.MaxValue;
			}
			Main.tile[num30, num31].lava(lava: false);
			SquareTileFrame(num30, num31);
		}
		int num35 = genRand.Next(4);
		for (int num36 = 0; num36 <= num35; num36++)
		{
			int num37 = genRand.Next(num32 - 5, num43 + 5);
			int num38 = num47 - genRand.Next(20, 40);
			int num39 = genRand.Next(4, 8);
			int num40 = 189;
			if (genRand.Next(2) == 0)
			{
				num40 = 460;
			}
			for (int num41 = num37 - num39; num41 <= num37 + num39; num41++)
			{
				for (int num42 = num38 - num39; num42 <= num38 + num39; num42++)
				{
					double num57 = Math.Abs(num41 - num37);
					double num44 = Math.Abs(num42 - num38) * 2;
					if (Math.Sqrt(num57 * num57 + num44 * num44) < (double)(num39 + genRand.Next(-1, 2)))
					{
						Main.tile[num41, num42].active(active: true);
						Main.tile[num41, num42].type = (ushort)num40;
						SquareTileFrame(num41, num42);
					}
				}
			}
			for (int num45 = num37 - num39 + 2; num45 <= num37 + num39 - 2; num45++)
			{
				int num46;
				for (num46 = num38 - num39; !Main.tile[num45, num46].active(); num46++)
				{
				}
				if (WillWaterPlacedHereStayPut(num45, num46))
				{
					Main.tile[num45, num46].active(active: false);
					Main.tile[num45, num46].liquid = byte.MaxValue;
					SquareTileFrame(num45, num46);
				}
			}
		}
	}

	public static void DesertCloudIsland(int i, int j)
	{
		double num = genRand.Next(100, 150);
		double num12 = num;
		double num22 = genRand.Next(20, 30);
		int num32 = i;
		int num43 = i;
		int num47 = i;
		int num48 = j;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
		{
			vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		}
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.02;
		while (num > 0.0 && num22 > 0.0)
		{
			num -= (double)genRand.Next(4);
			num22 -= 1.0;
			int num49 = (int)(vector2D.X - num * 0.5);
			int num51 = (int)(vector2D.X + num * 0.5);
			int num2 = (int)(vector2D.Y - num * 0.5);
			int num4 = (int)(vector2D.Y + num * 0.5);
			if (num49 < 0)
			{
				num49 = 0;
			}
			if (num51 > Main.maxTilesX)
			{
				num51 = Main.maxTilesX;
			}
			if (num2 < 0)
			{
				num2 = 0;
			}
			if (num4 > Main.maxTilesY)
			{
				num4 = Main.maxTilesY;
			}
			num12 = num * (double)genRand.Next(80, 120) * 0.01;
			double num6 = vector2D.Y + 1.0;
			for (int k = num49; k < num51; k++)
			{
				if (genRand.Next(2) == 0)
				{
					num6 += (double)genRand.Next(-1, 2);
				}
				if (num6 < vector2D.Y)
				{
					num6 = vector2D.Y;
				}
				if (num6 > vector2D.Y + 2.0)
				{
					num6 = vector2D.Y + 2.0;
				}
				for (int l = num2; l < num4; l++)
				{
					if (!((double)l > num6))
					{
						continue;
					}
					double num53 = Math.Abs((double)k - vector2D.X);
					double num7 = Math.Abs((double)l - vector2D.Y) * 3.0;
					if (Math.Sqrt(num53 * num53 + num7 * num7) < num12 * 0.4)
					{
						if (k < num32)
						{
							num32 = k;
						}
						if (k > num43)
						{
							num43 = k;
						}
						if (l < num47)
						{
							num47 = l;
						}
						if (l > num48)
						{
							num48 = l;
						}
						Main.tile[k, l].active(active: true);
						Main.tile[k, l].type = 189;
						SquareTileFrame(k, l);
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-20, 21) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (vector2D2.Y > 0.2)
			{
				vector2D2.Y = -0.2;
			}
			if (vector2D2.Y < -0.2)
			{
				vector2D2.Y = -0.2;
			}
		}
		int num8 = num32;
		int num10;
		for (num8 += genRand.Next(5); num8 < num43; num8 += genRand.Next(num10, (int)((double)num10 * 1.5)))
		{
			int num9 = num48;
			while (!Main.tile[num8, num9].active())
			{
				num9--;
			}
			num9 += genRand.Next(-3, 4);
			num10 = genRand.Next(4, 8);
			int num11 = 189;
			if (genRand.Next(4) == 0)
			{
				num11 = 196;
			}
			for (int m = num8 - num10; m <= num8 + num10; m++)
			{
				for (int n = num9 - num10; n <= num9 + num10; n++)
				{
					if (n > num47)
					{
						double num54 = Math.Abs(m - num8);
						double num13 = Math.Abs(n - num9) * 2;
						if (Math.Sqrt(num54 * num54 + num13 * num13) < (double)(num10 + genRand.Next(2)))
						{
							Main.tile[m, n].active(active: true);
							Main.tile[m, n].type = (ushort)num11;
							SquareTileFrame(m, n);
						}
					}
				}
			}
		}
		num = genRand.Next(80, 95);
		num12 = num;
		num22 = genRand.Next(10, 15);
		vector2D.X = i;
		vector2D.Y = num47;
		vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
		{
			vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		}
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.02;
		while (num > 0.0 && num22 > 0.0)
		{
			num -= (double)genRand.Next(4);
			num22 -= 1.0;
			int num50 = (int)(vector2D.X - num * 0.5);
			int num52 = (int)(vector2D.X + num * 0.5);
			int num3 = num47 - 1;
			int num5 = (int)(vector2D.Y + num * 0.5);
			if (num50 < 0)
			{
				num50 = 0;
			}
			if (num52 > Main.maxTilesX)
			{
				num52 = Main.maxTilesX;
			}
			if (num3 < 0)
			{
				num3 = 0;
			}
			if (num5 > Main.maxTilesY)
			{
				num5 = Main.maxTilesY;
			}
			num12 = num * (double)genRand.Next(80, 120) * 0.01;
			double num14 = vector2D.Y + 1.0;
			for (int num15 = num50; num15 < num52; num15++)
			{
				if (genRand.Next(2) == 0)
				{
					num14 += (double)genRand.Next(-1, 2);
				}
				if (num14 < vector2D.Y)
				{
					num14 = vector2D.Y;
				}
				if (num14 > vector2D.Y + 2.0)
				{
					num14 = vector2D.Y + 2.0;
				}
				for (int num16 = num3; num16 < num5; num16++)
				{
					if ((double)num16 > num14)
					{
						double num55 = Math.Abs((double)num15 - vector2D.X);
						double num17 = Math.Abs((double)num16 - vector2D.Y) * 3.0;
						if (Math.Sqrt(num55 * num55 + num17 * num17) < num12 * 0.4 && Main.tile[num15, num16].type == 189)
						{
							Main.tile[num15, num16].type = 53;
							SquareTileFrame(num15, num16);
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-20, 21) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (vector2D2.Y > 0.2)
			{
				vector2D2.Y = -0.2;
			}
			if (vector2D2.Y < -0.2)
			{
				vector2D2.Y = -0.2;
			}
		}
		int num18 = num32;
		num18 += genRand.Next(5);
		while (num18 < num43)
		{
			int num19 = num48;
			while ((!Main.tile[num18, num19].active() || Main.tile[num18, num19].type != 0) && num18 < num43)
			{
				num19--;
				if (num19 < num47)
				{
					num19 = num48;
					num18 += genRand.Next(1, 4);
				}
			}
			if (num18 >= num43)
			{
				continue;
			}
			num19 += genRand.Next(0, 4);
			int num20 = genRand.Next(2, 5);
			int num21 = 189;
			for (int num23 = num18 - num20; num23 <= num18 + num20; num23++)
			{
				for (int num24 = num19 - num20; num24 <= num19 + num20; num24++)
				{
					if (num24 > num47)
					{
						double num56 = Math.Abs(num23 - num18);
						double num25 = Math.Abs(num24 - num19) * 2;
						if (Math.Sqrt(num56 * num56 + num25 * num25) < (double)num20)
						{
							Main.tile[num23, num24].type = (ushort)num21;
							SquareTileFrame(num23, num24);
						}
					}
				}
			}
			num18 += genRand.Next(num20, (int)((double)num20 * 1.5));
		}
		for (int num26 = num32 - 20; num26 <= num43 + 20; num26++)
		{
			for (int num27 = num47 - 20; num27 <= num48 + 20; num27++)
			{
				bool flag = true;
				for (int num28 = num26 - 1; num28 <= num26 + 1; num28++)
				{
					for (int num29 = num27 - 1; num29 <= num27 + 1; num29++)
					{
						if (!Main.tile[num28, num29].active())
						{
							flag = false;
						}
					}
				}
				if (flag)
				{
					Main.tile[num26, num27].wall = 73;
					SquareWallFrame(num26, num27);
				}
			}
		}
		for (int num30 = num32; num30 <= num43; num30++)
		{
			int num31;
			for (num31 = num47 - 10; !Main.tile[num30, num31 + 1].active(); num31++)
			{
			}
			if (num31 >= num48 || Main.tile[num30, num31 + 1].type != 189)
			{
				continue;
			}
			if (genRand.Next(10) == 0)
			{
				int num33 = genRand.Next(1, 3);
				for (int num34 = num30 - num33; num34 <= num30 + num33; num34++)
				{
					if (Main.tile[num34, num31].type == 189 && WillWaterPlacedHereStayPut(num34, num31))
					{
						Main.tile[num34, num31].active(active: false);
						Main.tile[num34, num31].liquid = byte.MaxValue;
						Main.tile[num34, num31].lava(lava: false);
						SquareTileFrame(num30, num31);
					}
					if (Main.tile[num34, num31 + 1].type == 189 && WillWaterPlacedHereStayPut(num34, num31 + 1))
					{
						Main.tile[num34, num31 + 1].active(active: false);
						Main.tile[num34, num31 + 1].liquid = byte.MaxValue;
						Main.tile[num34, num31 + 1].lava(lava: false);
						SquareTileFrame(num30, num31 + 1);
					}
					if (num34 > num30 - num33 && num34 < num30 + 2 && Main.tile[num34, num31 + 2].type == 189 && WillWaterPlacedHereStayPut(num34, num31 + 2))
					{
						Main.tile[num34, num31 + 2].active(active: false);
						Main.tile[num34, num31 + 2].liquid = byte.MaxValue;
						Main.tile[num34, num31 + 2].lava(lava: false);
						SquareTileFrame(num30, num31 + 2);
					}
				}
			}
			if (genRand.Next(5) == 0 && WillWaterPlacedHereStayPut(num30, num31))
			{
				Main.tile[num30, num31].liquid = byte.MaxValue;
			}
			Main.tile[num30, num31].lava(lava: false);
			SquareTileFrame(num30, num31);
		}
		int num35 = genRand.Next(4);
		for (int num36 = 0; num36 <= num35; num36++)
		{
			int num37 = genRand.Next(num32 - 5, num43 + 5);
			int num38 = num47 - genRand.Next(20, 40);
			int num39 = genRand.Next(4, 8);
			int num40 = 189;
			if (genRand.Next(2) == 0)
			{
				num40 = 196;
			}
			for (int num41 = num37 - num39; num41 <= num37 + num39; num41++)
			{
				for (int num42 = num38 - num39; num42 <= num38 + num39; num42++)
				{
					double num57 = Math.Abs(num41 - num37);
					double num44 = Math.Abs(num42 - num38) * 2;
					if (Math.Sqrt(num57 * num57 + num44 * num44) < (double)(num39 + genRand.Next(-1, 2)))
					{
						Main.tile[num41, num42].active(active: true);
						Main.tile[num41, num42].type = (ushort)num40;
						SquareTileFrame(num41, num42);
					}
				}
			}
			for (int num45 = num37 - num39 + 2; num45 <= num37 + num39 - 2; num45++)
			{
				int num46;
				for (num46 = num38 - num39; !Main.tile[num45, num46].active(); num46++)
				{
				}
				if (WillWaterPlacedHereStayPut(num45, num46))
				{
					Main.tile[num45, num46].active(active: false);
					Main.tile[num45, num46].liquid = byte.MaxValue;
					SquareTileFrame(num45, num46);
				}
			}
		}
	}

	public static void CloudIsland(int i, int j)
	{
		double num = genRand.Next(100, 150);
		double num12 = num;
		double num22 = genRand.Next(20, 30);
		int num32 = i;
		int num43 = i;
		int num47 = i;
		int num48 = j;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
		{
			vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		}
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.02;
		while (num > 0.0 && num22 > 0.0)
		{
			num -= (double)genRand.Next(4);
			num22 -= 1.0;
			int num49 = (int)(vector2D.X - num * 0.5);
			int num51 = (int)(vector2D.X + num * 0.5);
			int num2 = (int)(vector2D.Y - num * 0.5);
			int num4 = (int)(vector2D.Y + num * 0.5);
			if (num49 < 0)
			{
				num49 = 0;
			}
			if (num51 > Main.maxTilesX)
			{
				num51 = Main.maxTilesX;
			}
			if (num2 < 0)
			{
				num2 = 0;
			}
			if (num4 > Main.maxTilesY)
			{
				num4 = Main.maxTilesY;
			}
			num12 = num * (double)genRand.Next(80, 120) * 0.01;
			double num6 = vector2D.Y + 1.0;
			for (int k = num49; k < num51; k++)
			{
				if (genRand.Next(2) == 0)
				{
					num6 += (double)genRand.Next(-1, 2);
				}
				if (num6 < vector2D.Y)
				{
					num6 = vector2D.Y;
				}
				if (num6 > vector2D.Y + 2.0)
				{
					num6 = vector2D.Y + 2.0;
				}
				for (int l = num2; l < num4; l++)
				{
					if (!((double)l > num6))
					{
						continue;
					}
					double num53 = Math.Abs((double)k - vector2D.X);
					double num7 = Math.Abs((double)l - vector2D.Y) * 3.0;
					if (Math.Sqrt(num53 * num53 + num7 * num7) < num12 * 0.4)
					{
						if (k < num32)
						{
							num32 = k;
						}
						if (k > num43)
						{
							num43 = k;
						}
						if (l < num47)
						{
							num47 = l;
						}
						if (l > num48)
						{
							num48 = l;
						}
						Main.tile[k, l].active(active: true);
						Main.tile[k, l].type = 189;
						SquareTileFrame(k, l);
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-20, 21) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (vector2D2.Y > 0.2)
			{
				vector2D2.Y = -0.2;
			}
			if (vector2D2.Y < -0.2)
			{
				vector2D2.Y = -0.2;
			}
		}
		int num8 = num32;
		int num10;
		for (num8 += genRand.Next(5); num8 < num43; num8 += genRand.Next(num10, (int)((double)num10 * 1.5)))
		{
			int num9 = num48;
			while (!Main.tile[num8, num9].active())
			{
				num9--;
			}
			num9 += genRand.Next(-3, 4);
			num10 = genRand.Next(4, 8);
			int num11 = 189;
			if (genRand.Next(4) == 0)
			{
				num11 = 196;
			}
			for (int m = num8 - num10; m <= num8 + num10; m++)
			{
				for (int n = num9 - num10; n <= num9 + num10; n++)
				{
					if (n > num47)
					{
						double num54 = Math.Abs(m - num8);
						double num13 = Math.Abs(n - num9) * 2;
						if (Math.Sqrt(num54 * num54 + num13 * num13) < (double)(num10 + genRand.Next(2)))
						{
							Main.tile[m, n].active(active: true);
							Main.tile[m, n].type = (ushort)num11;
							SquareTileFrame(m, n);
						}
					}
				}
			}
		}
		num = genRand.Next(80, 95);
		num12 = num;
		num22 = genRand.Next(10, 15);
		vector2D.X = i;
		vector2D.Y = num47;
		vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
		{
			vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		}
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.02;
		while (num > 0.0 && num22 > 0.0)
		{
			num -= (double)genRand.Next(4);
			num22 -= 1.0;
			int num50 = (int)(vector2D.X - num * 0.5);
			int num52 = (int)(vector2D.X + num * 0.5);
			int num3 = num47 - 1;
			int num5 = (int)(vector2D.Y + num * 0.5);
			if (num50 < 0)
			{
				num50 = 0;
			}
			if (num52 > Main.maxTilesX)
			{
				num52 = Main.maxTilesX;
			}
			if (num3 < 0)
			{
				num3 = 0;
			}
			if (num5 > Main.maxTilesY)
			{
				num5 = Main.maxTilesY;
			}
			num12 = num * (double)genRand.Next(80, 120) * 0.01;
			double num14 = vector2D.Y + 1.0;
			for (int num15 = num50; num15 < num52; num15++)
			{
				if (genRand.Next(2) == 0)
				{
					num14 += (double)genRand.Next(-1, 2);
				}
				if (num14 < vector2D.Y)
				{
					num14 = vector2D.Y;
				}
				if (num14 > vector2D.Y + 2.0)
				{
					num14 = vector2D.Y + 2.0;
				}
				for (int num16 = num3; num16 < num5; num16++)
				{
					if ((double)num16 > num14)
					{
						double num55 = Math.Abs((double)num15 - vector2D.X);
						double num17 = Math.Abs((double)num16 - vector2D.Y) * 3.0;
						if (Math.Sqrt(num55 * num55 + num17 * num17) < num12 * 0.4 && Main.tile[num15, num16].type == 189)
						{
							Main.tile[num15, num16].type = 0;
							SquareTileFrame(num15, num16);
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-20, 21) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (vector2D2.Y > 0.2)
			{
				vector2D2.Y = -0.2;
			}
			if (vector2D2.Y < -0.2)
			{
				vector2D2.Y = -0.2;
			}
		}
		int num18 = num32;
		num18 += genRand.Next(5);
		while (num18 < num43)
		{
			int num19 = num48;
			while ((!Main.tile[num18, num19].active() || Main.tile[num18, num19].type != 0) && num18 < num43)
			{
				num19--;
				if (num19 < num47)
				{
					num19 = num48;
					num18 += genRand.Next(1, 4);
				}
			}
			if (num18 >= num43)
			{
				continue;
			}
			num19 += genRand.Next(0, 4);
			int num20 = genRand.Next(2, 5);
			int num21 = 189;
			for (int num23 = num18 - num20; num23 <= num18 + num20; num23++)
			{
				for (int num24 = num19 - num20; num24 <= num19 + num20; num24++)
				{
					if (num24 > num47)
					{
						double num56 = Math.Abs(num23 - num18);
						double num25 = Math.Abs(num24 - num19) * 2;
						if (Math.Sqrt(num56 * num56 + num25 * num25) < (double)num20)
						{
							Main.tile[num23, num24].type = (ushort)num21;
							SquareTileFrame(num23, num24);
						}
					}
				}
			}
			num18 += genRand.Next(num20, (int)((double)num20 * 1.5));
		}
		for (int num26 = num32 - 20; num26 <= num43 + 20; num26++)
		{
			for (int num27 = num47 - 20; num27 <= num48 + 20; num27++)
			{
				bool flag = true;
				for (int num28 = num26 - 1; num28 <= num26 + 1; num28++)
				{
					for (int num29 = num27 - 1; num29 <= num27 + 1; num29++)
					{
						if (!Main.tile[num28, num29].active())
						{
							flag = false;
						}
					}
				}
				if (flag)
				{
					Main.tile[num26, num27].wall = 73;
					SquareWallFrame(num26, num27);
				}
			}
		}
		for (int num30 = num32; num30 <= num43; num30++)
		{
			int num31;
			for (num31 = num47 - 10; !Main.tile[num30, num31 + 1].active(); num31++)
			{
			}
			if (num31 >= num48 || Main.tile[num30, num31 + 1].type != 189)
			{
				continue;
			}
			if (genRand.Next(10) == 0)
			{
				int num33 = genRand.Next(1, 3);
				for (int num34 = num30 - num33; num34 <= num30 + num33; num34++)
				{
					if (Main.tile[num34, num31].type == 189 && WillWaterPlacedHereStayPut(num34, num31))
					{
						Main.tile[num34, num31].active(active: false);
						Main.tile[num34, num31].liquid = byte.MaxValue;
						Main.tile[num34, num31].lava(lava: false);
						SquareTileFrame(num30, num31);
					}
					if (Main.tile[num34, num31 + 1].type == 189 && WillWaterPlacedHereStayPut(num34, num31 + 1))
					{
						Main.tile[num34, num31 + 1].active(active: false);
						Main.tile[num34, num31 + 1].liquid = byte.MaxValue;
						Main.tile[num34, num31 + 1].lava(lava: false);
						SquareTileFrame(num30, num31 + 1);
					}
					if (num34 > num30 - num33 && num34 < num30 + 2 && Main.tile[num34, num31 + 2].type == 189 && WillWaterPlacedHereStayPut(num34, num31 + 2))
					{
						Main.tile[num34, num31 + 2].active(active: false);
						Main.tile[num34, num31 + 2].liquid = byte.MaxValue;
						Main.tile[num34, num31 + 2].lava(lava: false);
						SquareTileFrame(num30, num31 + 2);
					}
				}
			}
			if (genRand.Next(5) == 0 && WillWaterPlacedHereStayPut(num30, num31))
			{
				Main.tile[num30, num31].liquid = byte.MaxValue;
			}
			Main.tile[num30, num31].lava(lava: false);
			SquareTileFrame(num30, num31);
		}
		int num35 = genRand.Next(4);
		for (int num36 = 0; num36 <= num35; num36++)
		{
			int num37 = genRand.Next(num32 - 5, num43 + 5);
			int num38 = num47 - genRand.Next(20, 40);
			int num39 = genRand.Next(4, 8);
			int num40 = 189;
			if (genRand.Next(2) == 0)
			{
				num40 = 196;
			}
			for (int num41 = num37 - num39; num41 <= num37 + num39; num41++)
			{
				for (int num42 = num38 - num39; num42 <= num38 + num39; num42++)
				{
					double num57 = Math.Abs(num41 - num37);
					double num44 = Math.Abs(num42 - num38) * 2;
					if (Math.Sqrt(num57 * num57 + num44 * num44) < (double)(num39 + genRand.Next(-1, 2)))
					{
						Main.tile[num41, num42].active(active: true);
						Main.tile[num41, num42].type = (ushort)num40;
						SquareTileFrame(num41, num42);
					}
				}
			}
			for (int num45 = num37 - num39 + 2; num45 <= num37 + num39 - 2; num45++)
			{
				int num46;
				for (num46 = num38 - num39; !Main.tile[num45, num46].active(); num46++)
				{
				}
				if (WillWaterPlacedHereStayPut(num45, num46))
				{
					Main.tile[num45, num46].active(active: false);
					Main.tile[num45, num46].liquid = byte.MaxValue;
					SquareTileFrame(num45, num46);
				}
			}
		}
	}

	public static bool WillWaterPlacedHereStayPut(int x, int y)
	{
		if (((Main.tile[x, y + 1].active() && Main.tileSolid[Main.tile[x, y + 1].type] && !Main.tileSolidTop[Main.tile[x, y + 1].type]) || Main.tile[x, y + 1].liquid == byte.MaxValue) && ((Main.tile[x - 1, y].active() && Main.tileSolid[Main.tile[x - 1, y].type] && !Main.tileSolidTop[Main.tile[x - 1, y].type]) || Main.tile[x - 1, y].liquid == byte.MaxValue) && ((Main.tile[x + 1, y].active() && Main.tileSolid[Main.tile[x + 1, y].type] && !Main.tileSolidTop[Main.tile[x + 1, y].type]) || Main.tile[x + 1, y].liquid == byte.MaxValue))
		{
			return true;
		}
		return false;
	}

	public static void CloudLake(int i, int j)
	{
		double num = genRand.Next(100, 150);
		double num12 = num;
		double num22 = genRand.Next(20, 30);
		int num33 = i;
		int num39 = i;
		int num40 = i;
		int num41 = j;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
		{
			vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		}
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.02;
		while (num > 0.0 && num22 > 0.0)
		{
			num -= (double)genRand.Next(4);
			num22 -= 1.0;
			int num42 = (int)(vector2D.X - num * 0.5);
			int num44 = (int)(vector2D.X + num * 0.5);
			int num2 = (int)(vector2D.Y - num * 0.5);
			int num4 = (int)(vector2D.Y + num * 0.5);
			if (num42 < 0)
			{
				num42 = 0;
			}
			if (num44 > Main.maxTilesX)
			{
				num44 = Main.maxTilesX;
			}
			if (num2 < 0)
			{
				num2 = 0;
			}
			if (num4 > Main.maxTilesY)
			{
				num4 = Main.maxTilesY;
			}
			num12 = num * (double)genRand.Next(80, 120) * 0.01;
			double num6 = vector2D.Y + 1.0;
			for (int k = num42; k < num44; k++)
			{
				if (genRand.Next(2) == 0)
				{
					num6 += (double)genRand.Next(-1, 2);
				}
				if (num6 < vector2D.Y)
				{
					num6 = vector2D.Y;
				}
				if (num6 > vector2D.Y + 2.0)
				{
					num6 = vector2D.Y + 2.0;
				}
				for (int l = num2; l < num4; l++)
				{
					if (!((double)l > num6))
					{
						continue;
					}
					double num46 = Math.Abs((double)k - vector2D.X);
					double num7 = Math.Abs((double)l - vector2D.Y) * 3.0;
					if (Math.Sqrt(num46 * num46 + num7 * num7) < num12 * 0.4)
					{
						if (k < num33)
						{
							num33 = k;
						}
						if (k > num39)
						{
							num39 = k;
						}
						if (l < num40)
						{
							num40 = l;
						}
						if (l > num41)
						{
							num41 = l;
						}
						Main.tile[k, l].active(active: true);
						Main.tile[k, l].type = 189;
						SquareTileFrame(k, l);
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-20, 21) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (vector2D2.Y > 0.2)
			{
				vector2D2.Y = -0.2;
			}
			if (vector2D2.Y < -0.2)
			{
				vector2D2.Y = -0.2;
			}
		}
		int num8 = num33;
		int num10;
		for (num8 += genRand.Next(5); num8 < num39; num8 += genRand.Next(num10, (int)((double)num10 * 1.5)))
		{
			int num9 = num41;
			while (!Main.tile[num8, num9].active())
			{
				num9--;
			}
			num9 += genRand.Next(-3, 4);
			num10 = genRand.Next(4, 8);
			int num11 = 189;
			if (genRand.Next(4) == 0)
			{
				num11 = 196;
			}
			for (int m = num8 - num10; m <= num8 + num10; m++)
			{
				for (int n = num9 - num10; n <= num9 + num10; n++)
				{
					if (n > num40)
					{
						double num47 = Math.Abs(m - num8);
						double num13 = Math.Abs(n - num9) * 2;
						if (Math.Sqrt(num47 * num47 + num13 * num13) < (double)(num10 + genRand.Next(2)))
						{
							Main.tile[m, n].active(active: true);
							Main.tile[m, n].type = (ushort)num11;
							SquareTileFrame(m, n);
						}
					}
				}
			}
		}
		num = genRand.Next(80, 95);
		num12 = num;
		num22 = genRand.Next(10, 15);
		vector2D.X = i;
		vector2D.Y = num40;
		vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
		{
			vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		}
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.02;
		while (num > 0.0 && num22 > 0.0)
		{
			num -= (double)genRand.Next(4);
			num22 -= 1.0;
			int num43 = (int)(vector2D.X - num * 0.5);
			int num45 = (int)(vector2D.X + num * 0.5);
			int num3 = num40 - 1;
			int num5 = (int)(vector2D.Y + num * 0.5);
			if (num43 < 0)
			{
				num43 = 0;
			}
			if (num45 > Main.maxTilesX)
			{
				num45 = Main.maxTilesX;
			}
			if (num3 < 0)
			{
				num3 = 0;
			}
			if (num5 > Main.maxTilesY)
			{
				num5 = Main.maxTilesY;
			}
			num12 = num * (double)genRand.Next(80, 120) * 0.01;
			double num14 = vector2D.Y + 1.0;
			for (int num15 = num43; num15 < num45; num15++)
			{
				if (genRand.Next(2) == 0)
				{
					num14 += (double)genRand.Next(-1, 2);
				}
				if (num14 < vector2D.Y)
				{
					num14 = vector2D.Y;
				}
				if (num14 > vector2D.Y + 2.0)
				{
					num14 = vector2D.Y + 2.0;
				}
				for (int num16 = num3; num16 < num5; num16++)
				{
					if (!((double)num16 > num14 - 2.0))
					{
						continue;
					}
					double num48 = Math.Abs((double)num15 - vector2D.X);
					double num17 = Math.Abs((double)num16 - vector2D.Y) * 3.0;
					if (!(Math.Sqrt(num48 * num48 + num17 * num17) < num12 * 0.4) || Main.tile[num15, num16].type != 189)
					{
						continue;
					}
					Main.tile[num15, num16].active(active: false);
					if ((double)num16 > num14 + 1.0)
					{
						if (WillWaterPlacedHereStayPut(num15, num16))
						{
							Main.tile[num15, num16].liquid = byte.MaxValue;
						}
						Main.tile[num15, num16].honey(honey: false);
						Main.tile[num15, num16].lava(lava: false);
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-20, 21) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (vector2D2.Y > 0.2)
			{
				vector2D2.Y = -0.2;
			}
			if (vector2D2.Y < 0.0)
			{
				vector2D2.Y = 0.0;
			}
		}
		for (int num18 = num33 - 20; num18 <= num39 + 20; num18++)
		{
			for (int num19 = num40 - 20; num19 <= num41 + 20; num19++)
			{
				bool flag = true;
				for (int num20 = num18 - 1; num20 <= num18 + 1; num20++)
				{
					for (int num21 = num19 - 1; num21 <= num19 + 1; num21++)
					{
						if (!Main.tile[num20, num21].active())
						{
							flag = false;
						}
					}
				}
				if (flag)
				{
					Main.tile[num18, num19].wall = 73;
				}
			}
		}
		for (int num23 = num33; num23 <= num39; num23++)
		{
			int num24;
			for (num24 = num40 - 10; !Main.tile[num23, num24 + 1].active(); num24++)
			{
			}
			if (num24 >= num41 || Main.tile[num23, num24 + 1].type != 189)
			{
				continue;
			}
			if (genRand.Next(10) == 0)
			{
				int num25 = genRand.Next(1, 3);
				for (int num26 = num23 - num25; num26 <= num23 + num25; num26++)
				{
					if (Main.tile[num26, num24].type == 189 && WillWaterPlacedHereStayPut(num26, num24))
					{
						Main.tile[num26, num24].active(active: false);
						Main.tile[num26, num24].liquid = byte.MaxValue;
						Main.tile[num26, num24].lava(lava: false);
						SquareTileFrame(num23, num24);
					}
					if (Main.tile[num26, num24 + 1].type == 189 && WillWaterPlacedHereStayPut(num26, num24 + 1))
					{
						Main.tile[num26, num24 + 1].active(active: false);
						Main.tile[num26, num24 + 1].liquid = byte.MaxValue;
						Main.tile[num26, num24 + 1].lava(lava: false);
						SquareTileFrame(num23, num24 + 1);
					}
					if (num26 > num23 - num25 && num26 < num23 + 2 && Main.tile[num26, num24 + 2].type == 189 && WillWaterPlacedHereStayPut(num26, num24 + 2))
					{
						Main.tile[num26, num24 + 2].active(active: false);
						Main.tile[num26, num24 + 2].liquid = byte.MaxValue;
						Main.tile[num26, num24 + 2].lava(lava: false);
						SquareTileFrame(num23, num24 + 2);
					}
				}
			}
			if (genRand.Next(5) == 0 && WillWaterPlacedHereStayPut(num23, num24))
			{
				Main.tile[num23, num24].liquid = byte.MaxValue;
			}
			Main.tile[num23, num24].lava(lava: false);
			SquareTileFrame(num23, num24);
		}
		int num27 = genRand.Next(1, 4);
		for (int num28 = 0; num28 <= num27; num28++)
		{
			int num29 = genRand.Next(num33 - 5, num39 + 5);
			int num30 = num40 - genRand.Next(20, 40);
			int num31 = genRand.Next(4, 8);
			int num32 = 189;
			if (genRand.Next(4) != 0)
			{
				num32 = 196;
			}
			for (int num34 = num29 - num31; num34 <= num29 + num31; num34++)
			{
				for (int num35 = num30 - num31; num35 <= num30 + num31; num35++)
				{
					double num49 = Math.Abs(num34 - num29);
					double num36 = Math.Abs(num35 - num30) * 2;
					if (Math.Sqrt(num49 * num49 + num36 * num36) < (double)(num31 + genRand.Next(-1, 2)))
					{
						Main.tile[num34, num35].active(active: true);
						Main.tile[num34, num35].type = (ushort)num32;
						SquareTileFrame(num34, num35);
					}
				}
			}
			for (int num37 = num29 - num31 + 2; num37 <= num29 + num31 - 2; num37++)
			{
				int num38;
				for (num38 = num30 - num31; !Main.tile[num37, num38].active(); num38++)
				{
				}
				if (WillWaterPlacedHereStayPut(num37, num38))
				{
					Main.tile[num37, num38].active(active: false);
					Main.tile[num37, num38].liquid = byte.MaxValue;
					SquareTileFrame(num37, num38);
				}
			}
		}
	}

	public static void FloatingIsland(int i, int j)
	{
		double num = genRand.Next(80, 120);
		double num4 = num;
		double num5 = genRand.Next(20, 25);
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		while (vector2D2.X > -2.0 && vector2D2.X < 2.0)
		{
			vector2D2.X = (double)genRand.Next(-20, 21) * 0.2;
		}
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.02;
		while (num > 0.0 && num5 > 0.0)
		{
			num -= (double)genRand.Next(4);
			num5 -= 1.0;
			int num6 = (int)(vector2D.X - num * 0.5);
			int num7 = (int)(vector2D.X + num * 0.5);
			int num8 = (int)(vector2D.Y - num * 0.5);
			int num9 = (int)(vector2D.Y + num * 0.5);
			if (num6 < 0)
			{
				num6 = 0;
			}
			if (num7 > Main.maxTilesX)
			{
				num7 = Main.maxTilesX;
			}
			if (num8 < 0)
			{
				num8 = 0;
			}
			if (num9 > Main.maxTilesY)
			{
				num9 = Main.maxTilesY;
			}
			num4 = num * (double)genRand.Next(80, 120) * 0.01;
			double num10 = vector2D.Y + 1.0;
			for (int k = num6; k < num7; k++)
			{
				if (genRand.Next(2) == 0)
				{
					num10 += (double)genRand.Next(-1, 2);
				}
				if (num10 < vector2D.Y)
				{
					num10 = vector2D.Y;
				}
				if (num10 > vector2D.Y + 2.0)
				{
					num10 = vector2D.Y + 2.0;
				}
				for (int l = num8; l < num9; l++)
				{
					if (!((double)l > num10))
					{
						continue;
					}
					double num11 = Math.Abs((double)k - vector2D.X);
					double num2 = Math.Abs((double)l - vector2D.Y) * 2.0;
					if (Math.Sqrt(num11 * num11 + num2 * num2) < num4 * 0.4)
					{
						Main.tile[k, l].active(active: true);
						if (Main.tile[k, l].type == 59)
						{
							Main.tile[k, l].type = 0;
						}
					}
				}
			}
			num6 = (int)(vector2D.X - num * 0.4);
			num7 = (int)(vector2D.X + num * 0.4);
			num8 = (int)(vector2D.Y - num * 0.4);
			num9 = (int)(vector2D.Y + num * 0.4);
			if (num6 < 0)
			{
				num6 = 0;
			}
			if (num7 > Main.maxTilesX)
			{
				num7 = Main.maxTilesX;
			}
			if (num8 < 0)
			{
				num8 = 0;
			}
			if (num9 > Main.maxTilesY)
			{
				num9 = Main.maxTilesY;
			}
			num4 = num * (double)genRand.Next(80, 120) * 0.01;
			for (int m = num6; m < num7; m++)
			{
				for (int n = num8; n < num9; n++)
				{
					if ((double)n > vector2D.Y + 2.0)
					{
						double num12 = Math.Abs((double)m - vector2D.X);
						double num3 = Math.Abs((double)n - vector2D.Y) * 2.0;
						if (Math.Sqrt(num12 * num12 + num3 * num3) < num4 * 0.4)
						{
							Main.tile[m, n].wall = 2;
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (vector2D2.Y > 0.2)
			{
				vector2D2.Y = -0.2;
			}
			if (vector2D2.Y < -0.2)
			{
				vector2D2.Y = -0.2;
			}
		}
	}

	public static void Caverer(int X, int Y)
	{
		switch (genRand.Next(2))
		{
		case 0:
		{
			int num4 = genRand.Next(7, 9);
			double num5 = (double)genRand.Next(100) * 0.01;
			double num6 = 1.0 - num5;
			if (genRand.Next(2) == 0)
			{
				num5 = 0.0 - num5;
			}
			if (genRand.Next(2) == 0)
			{
				num6 = 0.0 - num6;
			}
			Vector2D vector2D2 = new Vector2D(X, Y);
			for (int j = 0; j < num4; j++)
			{
				vector2D2 = digTunnel(vector2D2.X, vector2D2.Y, num5, num6, genRand.Next(6, 20), genRand.Next(4, 9));
				num5 += (double)genRand.Next(-20, 21) * 0.1;
				num6 += (double)genRand.Next(-20, 21) * 0.1;
				if (num5 < -1.5)
				{
					num5 = -1.5;
				}
				if (num5 > 1.5)
				{
					num5 = 1.5;
				}
				if (num6 < -1.5)
				{
					num6 = -1.5;
				}
				if (num6 > 1.5)
				{
					num6 = 1.5;
				}
				double num7 = (double)genRand.Next(100) * 0.01;
				double num8 = 1.0 - num7;
				if (genRand.Next(2) == 0)
				{
					num7 = 0.0 - num7;
				}
				if (genRand.Next(2) == 0)
				{
					num8 = 0.0 - num8;
				}
				Vector2D vector2D3 = digTunnel(vector2D2.X, vector2D2.Y, num7, num8, genRand.Next(30, 50), genRand.Next(3, 6));
				TileRunner((int)vector2D3.X, (int)vector2D3.Y, genRand.Next(10, 20), genRand.Next(5, 10), -1);
			}
			break;
		}
		case 1:
		{
			int num = genRand.Next(15, 30);
			double num2 = (double)genRand.Next(100) * 0.01;
			double num3 = 1.0 - num2;
			if (genRand.Next(2) == 0)
			{
				num2 = 0.0 - num2;
			}
			if (genRand.Next(2) == 0)
			{
				num3 = 0.0 - num3;
			}
			Vector2D vector2D = new Vector2D(X, Y);
			for (int i = 0; i < num; i++)
			{
				vector2D = digTunnel(vector2D.X, vector2D.Y, num2, num3, genRand.Next(5, 15), genRand.Next(2, 6), Wet: true);
				num2 += (double)genRand.Next(-20, 21) * 0.1;
				num3 += (double)genRand.Next(-20, 21) * 0.1;
				if (num2 < -1.5)
				{
					num2 = -1.5;
				}
				if (num2 > 1.5)
				{
					num2 = 1.5;
				}
				if (num3 < -1.5)
				{
					num3 = -1.5;
				}
				if (num3 > 1.5)
				{
					num3 = 1.5;
				}
			}
			break;
		}
		}
	}

	public static Vector2D digTunnel(double X, double Y, double xDir, double yDir, int Steps, int Size, bool Wet = false)
	{
		double num = X;
		double num2 = Y;
		try
		{
			double num3 = 0.0;
			double num4 = 0.0;
			double num5 = Size;
			num = Utils.Clamp(num, num5 + 1.0, (double)Main.maxTilesX - num5 - 1.0);
			num2 = Utils.Clamp(num2, num5 + 1.0, (double)Main.maxTilesY - num5 - 1.0);
			for (int i = 0; i < Steps; i++)
			{
				for (int j = (int)(num - num5); (double)j <= num + num5; j++)
				{
					for (int k = (int)(num2 - num5); (double)k <= num2 + num5; k++)
					{
						if (Math.Abs((double)j - num) + Math.Abs((double)k - num2) < num5 * (1.0 + (double)genRand.Next(-10, 11) * 0.005) && j >= 0 && j < Main.maxTilesX && k >= 0 && k < Main.maxTilesY)
						{
							Main.tile[j, k].active(active: false);
							if (Wet)
							{
								Main.tile[j, k].liquid = byte.MaxValue;
							}
						}
					}
				}
				num5 += (double)genRand.Next(-50, 51) * 0.03;
				if (num5 < (double)Size * 0.6)
				{
					num5 = (double)Size * 0.6;
				}
				if (num5 > (double)(Size * 2))
				{
					num5 = Size * 2;
				}
				num3 += (double)genRand.Next(-20, 21) * 0.01;
				num4 += (double)genRand.Next(-20, 21) * 0.01;
				if (num3 < -1.0)
				{
					num3 = -1.0;
				}
				if (num3 > 1.0)
				{
					num3 = 1.0;
				}
				if (num4 < -1.0)
				{
					num4 = -1.0;
				}
				if (num4 > 1.0)
				{
					num4 = 1.0;
				}
				num += (xDir + num3) * 0.6;
				num2 += (yDir + num4) * 0.6;
			}
		}
		catch
		{
		}
		return new Vector2D(num, num2);
	}

	public static void IslandHouse(int i, int j, int islandStyle)
	{
		bool flag = crimson;
		if (drunkWorldGen)
		{
			flag = (GenVars.crimsonLeft && i < Main.maxTilesX / 2) || ((!GenVars.crimsonLeft && i > Main.maxTilesX / 2) ? true : false);
		}
		byte type = 202;
		byte wall = 82;
		Vector2D vector2D = new Vector2D(i, j);
		int num = 1;
		if (genRand.Next(2) == 0)
		{
			num = -1;
		}
		int num12 = genRand.Next(7, 12);
		int num23 = genRand.Next(5, 7);
		vector2D.X = i + (num12 + 2) * num;
		Tile tile;
		for (int k = j - 15; k < j + 30; k++)
		{
			tile = Main.tile[(int)vector2D.X, k];
			if (tile.active())
			{
				vector2D.Y = k - 1;
				break;
			}
		}
		vector2D.X = i;
		int num24 = (int)(vector2D.X - (double)num12 - 1.0);
		int num25 = (int)(vector2D.X + (double)num12 + 1.0);
		int num26 = (int)(vector2D.Y - (double)num23 - 1.0);
		int num27 = (int)(vector2D.Y + 2.0);
		if (num24 < 0)
		{
			num24 = 0;
		}
		if (num25 > Main.maxTilesX)
		{
			num25 = Main.maxTilesX;
		}
		if (num26 < 0)
		{
			num26 = 0;
		}
		if (num27 > Main.maxTilesY)
		{
			num27 = Main.maxTilesY;
		}
		for (int l = num24; l <= num25; l++)
		{
			for (int m = num26 - 1; m < num27 + 1; m++)
			{
				if (m != num26 - 1 || (l != num24 && l != num25))
				{
					tile = Main.tile[l, m];
					tile.active(active: true);
					tile = Main.tile[l, m];
					tile.liquid = 0;
					tile = Main.tile[l, m];
					tile.type = type;
					tile = Main.tile[l, m];
					tile.wall = 0;
					tile = Main.tile[l, m];
					tile.halfBrick(halfBrick: false);
					tile = Main.tile[l, m];
					tile.slope(0);
				}
			}
		}
		num24 = (int)(vector2D.X - (double)num12);
		num25 = (int)(vector2D.X + (double)num12);
		num26 = (int)(vector2D.Y - (double)num23);
		num27 = (int)(vector2D.Y + 1.0);
		if (num24 < 0)
		{
			num24 = 0;
		}
		if (num25 > Main.maxTilesX)
		{
			num25 = Main.maxTilesX;
		}
		if (num26 < 0)
		{
			num26 = 0;
		}
		if (num27 > Main.maxTilesY)
		{
			num27 = Main.maxTilesY;
		}
		for (int n = num24; n <= num25; n++)
		{
			for (int num28 = num26; num28 < num27; num28++)
			{
				if (num28 != num26 || (n != num24 && n != num25))
				{
					tile = Main.tile[n, num28];
					if (tile.wall == 0)
					{
						tile = Main.tile[n, num28];
						tile.active(active: false);
						tile = Main.tile[n, num28];
						tile.wall = wall;
					}
				}
			}
		}
		int num29 = i + (num12 + 1) * num;
		int num2 = (int)vector2D.Y;
		for (int num3 = num29 - 2; num3 <= num29 + 2; num3++)
		{
			tile = Main.tile[num3, num2];
			tile.active(active: false);
			tile = Main.tile[num3, num2 - 1];
			tile.active(active: false);
			tile = Main.tile[num3, num2 - 2];
			tile.active(active: false);
		}
		if (remixWorldGen)
		{
			if (flag)
			{
				PlaceTile(num29, num2, 10, mute: true, forced: false, -1, 5);
			}
			else
			{
				PlaceTile(num29, num2, 10, mute: true, forced: false, -1, 38);
			}
		}
		else
		{
			PlaceTile(num29, num2, 10, mute: true, forced: false, -1, 9);
		}
		num29 = i + (num12 + 1) * -num - num;
		for (int num4 = num26; num4 <= num27 + 1; num4++)
		{
			tile = Main.tile[num29, num4];
			tile.active(active: true);
			tile = Main.tile[num29, num4];
			tile.liquid = 0;
			tile = Main.tile[num29, num4];
			tile.type = type;
			tile = Main.tile[num29, num4];
			tile.wall = 0;
			tile = Main.tile[num29, num4];
			tile.halfBrick(halfBrick: false);
			tile = Main.tile[num29, num4];
			tile.slope(0);
		}
		int contain = 0;
		int num5 = GenVars.skyIslandHouseCount;
		if (num5 > 3)
		{
			num5 = genRand.Next(4);
		}
		switch (num5)
		{
		case 0:
			contain = 159;
			break;
		case 1:
			contain = 65;
			break;
		case 2:
			contain = 158;
			break;
		case 3:
			contain = 2219;
			break;
		}
		if (getGoodWorldGen)
		{
			AddBuriedChest(i, num2 - 3, contain, notNearOtherChests: false, 2, trySlope: false, 0);
		}
		else
		{
			AddBuriedChest(i, num2 - 3, contain, notNearOtherChests: false, 13, trySlope: false, 0);
		}
		if (islandStyle > 0)
		{
			for (int num6 = 0; num6 < 100000; num6++)
			{
				int num7 = i + genRand.Next(-50, 51);
				int num8 = num2 + genRand.Next(21);
				if (num6 < 50000)
				{
					tile = Main.tile[num7, num8];
					if (tile.type == 202)
					{
						continue;
					}
				}
				tile = Main.tile[num7, num8];
				if (!tile.active())
				{
					Place2xX(num7, num8, 207, islandStyle);
					tile = Main.tile[num7, num8];
					if (tile.active())
					{
						SwitchFountain(num7, num8);
						break;
					}
				}
			}
		}
		GenVars.skyIslandHouseCount++;
		if (!remixWorldGen)
		{
			int num9 = i - num12 / 2 + 1;
			int num10 = i + num12 / 2 - 1;
			int num11 = 1;
			if (num12 > 10)
			{
				num11 = 2;
			}
			int num13 = (num26 + num27) / 2 - 1;
			for (int num14 = num9 - num11; num14 <= num9 + num11; num14++)
			{
				for (int num15 = num13 - 1; num15 <= num13 + 1; num15++)
				{
					tile = Main.tile[num14, num15];
					tile.wall = 21;
				}
			}
			for (int num16 = num10 - num11; num16 <= num10 + num11; num16++)
			{
				for (int num17 = num13 - 1; num17 <= num13 + 1; num17++)
				{
					tile = Main.tile[num16, num17];
					tile.wall = 21;
				}
			}
		}
		int num18 = i + (num12 / 2 + 1) * -num;
		if (remixWorldGen)
		{
			if (flag)
			{
				PlaceTile(num18, num27 - 1, 14, mute: true, forced: false, -1, 5);
				PlaceTile(num18 - 2, num27 - 1, 15, mute: true, forced: false, 0, 8);
				PlaceTile(num18 + 2, num27 - 1, 15, mute: true, forced: false, 0, 8);
			}
			else
			{
				PlaceTile(num18, num27 - 1, 469, mute: true, forced: false, -1, 2);
				PlaceTile(num18 - 2, num27 - 1, 15, mute: true, forced: false, 0, 38);
				PlaceTile(num18 + 2, num27 - 1, 15, mute: true, forced: false, 0, 38);
			}
		}
		else
		{
			PlaceTile(num18, num27 - 1, 14, mute: true, forced: false, -1, 7);
			PlaceTile(num18 - 2, num27 - 1, 15, mute: true, forced: false, 0, 10);
			PlaceTile(num18 + 2, num27 - 1, 15, mute: true, forced: false, 0, 10);
		}
		tile = Main.tile[num18 - 2, num27 - 1];
		tile.frameX += 18;
		tile = Main.tile[num18 - 2, num27 - 2];
		tile.frameX += 18;
		if (!remixWorldGen)
		{
			int i2 = num24 + 1;
			int j2 = num26;
			PlaceTile(i2, j2, 91, mute: true, forced: false, -1, genRand.Next(7, 10));
			i2 = num25 - 1;
			j2 = num26;
			PlaceTile(i2, j2, 91, mute: true, forced: false, -1, genRand.Next(7, 10));
			if (num > 0)
			{
				i2 = num24;
				j2 = num26 + 1;
			}
			else
			{
				i2 = num25;
				j2 = num26 + 1;
			}
			PlaceTile(i2, j2, 91, mute: true, forced: false, -1, genRand.Next(7, 10));
		}
		if (islandStyle != 1)
		{
			return;
		}
		int num19 = genRand.Next(3, 6);
		for (int num20 = 0; num20 < 100000; num20++)
		{
			int num21 = i + genRand.Next(-50, 51);
			int num22 = num2 + genRand.Next(-10, 21);
			tile = Main.tile[num21, num22];
			if (!tile.active())
			{
				GrowPalmTree(num21, num22 + 1);
				tile = Main.tile[num21, num22];
				if (tile.active())
				{
					num19--;
				}
			}
			if (num19 <= 0)
			{
				break;
			}
		}
	}

	public static void Mountinater(int i, int j)
	{
		double num = genRand.Next(80, 120);
		double num2 = num;
		double num3 = genRand.Next(40, 55);
		if (remixWorldGen)
		{
			num2 *= 1.5;
			num3 *= 1.5;
		}
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = (double)j + num3 / 2.0;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-10, 11) * 0.1;
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.1;
		while (num > 0.0 && num3 > 0.0)
		{
			num -= (double)genRand.Next(4);
			num3 -= 1.0;
			int num4 = (int)(vector2D.X - num * 0.5);
			int num5 = (int)(vector2D.X + num * 0.5);
			int num6 = (int)(vector2D.Y - num * 0.5);
			int num7 = (int)(vector2D.Y + num * 0.5);
			if (num4 < 0)
			{
				num4 = 0;
			}
			if (num5 > Main.maxTilesX)
			{
				num5 = Main.maxTilesX;
			}
			if (num6 < 0)
			{
				num6 = 0;
			}
			if (num7 > Main.maxTilesY)
			{
				num7 = Main.maxTilesY;
			}
			num2 = num * (double)genRand.Next(80, 120) * 0.01;
			for (int k = num4; k < num5; k++)
			{
				for (int l = num6; l < num7; l++)
				{
					double num9 = Math.Abs((double)k - vector2D.X);
					double num8 = Math.Abs((double)l - vector2D.Y);
					if (Math.Sqrt(num9 * num9 + num8 * num8) < num2 * 0.4 && !Main.tile[k, l].active())
					{
						Main.tile[k, l].active(active: true);
						Main.tile[k, l].type = 0;
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
			vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.X > 0.5)
			{
				vector2D2.X = 0.5;
			}
			if (vector2D2.X < -0.5)
			{
				vector2D2.X = -0.5;
			}
			if (vector2D2.Y > -0.5)
			{
				vector2D2.Y = -0.5;
			}
			if (vector2D2.Y < -1.5)
			{
				vector2D2.Y = -1.5;
			}
		}
	}

	public static void MakeWateryIceThing(int i, int j)
	{
		if (Main.tile[i, j].liquid <= 0 || Main.tile[i, j].active() || (Main.tile[i, j].lava() && !Main.remixWorld))
		{
			return;
		}
		int num = j;
		while (!Main.tile[i, num].active() && Main.tile[i, num].liquid > 0)
		{
			num++;
			if (num > Main.maxTilesY - 50)
			{
				return;
			}
		}
		if (Main.tile[i, num].type != 147 && Main.tile[i, num].type != 161)
		{
			return;
		}
		num--;
		while (Main.tile[i, num].liquid > 0)
		{
			num--;
			if (num < 10)
			{
				return;
			}
		}
		if (Main.tile[i, num].active())
		{
			return;
		}
		num++;
		if (!Main.tile[i, num].active())
		{
			int num2 = i;
			while (!Main.tile[num2, num].active() && Main.tile[num2, num].liquid > 0 && Main.tile[num2, num - 1].liquid == 0 && !Main.tile[num2, num - 1].active() && !Main.tile[num2 - 1, num].halfBrick())
			{
				PlaceTile(num2, num, 162, mute: true);
				num2--;
			}
			for (num2 = i + 1; !Main.tile[num2, num].active() && Main.tile[num2, num].liquid > 0 && Main.tile[num2, num - 1].liquid == 0 && !Main.tile[num2, num - 1].active() && !Main.tile[num2 + 1, num].halfBrick(); num2++)
			{
				PlaceTile(num2, num, 162, mute: true);
			}
		}
	}

	public static void Lakinater(int i, int j, double strengthMultiplier = 1.0)
	{
		double num = (double)genRand.Next(25, 50) * strengthMultiplier;
		double num2 = num;
		double num3 = genRand.Next(30, 80);
		if (genRand.Next(5) == 0)
		{
			num *= 1.5;
			num2 *= 1.5;
			num3 *= 1.2;
		}
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = (double)j - num3 * 0.3;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-10, 11) * 0.1;
		vector2D2.Y = (double)genRand.Next(-20, -10) * 0.1;
		while (num > 0.0 && num3 > 0.0)
		{
			if (vector2D.Y + num2 * 0.5 > Main.worldSurface)
			{
				num3 = 0.0;
			}
			num -= (double)genRand.Next(3);
			num3 -= 1.0;
			int num4 = (int)(vector2D.X - num * 0.5);
			int num5 = (int)(vector2D.X + num * 0.5);
			int num6 = (int)(vector2D.Y - num * 0.5);
			int num7 = (int)(vector2D.Y + num * 0.5);
			if (num4 < 0)
			{
				num4 = 0;
			}
			if (num5 > Main.maxTilesX)
			{
				num5 = Main.maxTilesX;
			}
			if (num6 < 0)
			{
				num6 = 0;
			}
			if (num7 > Main.maxTilesY)
			{
				num7 = Main.maxTilesY;
			}
			num2 = num * (double)genRand.Next(80, 120) * 0.01;
			for (int k = num4; k < num5; k++)
			{
				for (int l = num6; l < num7; l++)
				{
					double num9 = Math.Abs((double)k - vector2D.X);
					double num8 = Math.Abs((double)l - vector2D.Y);
					if (Math.Sqrt(num9 * num9 + num8 * num8) < num2 * 0.4)
					{
						if (Main.tile[k, l].active())
						{
							Main.tile[k, l].liquid = byte.MaxValue;
						}
						Main.tile[k, l].active(active: false);
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
			vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.X > 0.5)
			{
				vector2D2.X = 0.5;
			}
			if (vector2D2.X < -0.5)
			{
				vector2D2.X = -0.5;
			}
			if (vector2D2.Y > 1.5)
			{
				vector2D2.Y = 1.5;
			}
			if (vector2D2.Y < 0.5)
			{
				vector2D2.Y = 0.5;
			}
		}
	}

	public static void SonOfLakinater(int i, int j, double strengthMultiplier = 1.0)
	{
		bool lava = false;
		if (getGoodWorldGen && genRand.Next(3) == 0)
		{
			lava = true;
		}
		double num = (double)genRand.Next(15, 31) * strengthMultiplier;
		double num7 = genRand.Next(30, 61);
		if (genRand.Next(5) == 0)
		{
			num *= 1.3;
			num7 *= 1.3;
		}
		if (drunkWorldGen)
		{
			num *= 1.3;
			num7 *= 1.3;
		}
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		double num8 = genRand.NextDouble() * 0.002;
		Vector2D vector2D2 = default(Vector2D);
		if (genRand.Next(4) != 0)
		{
			vector2D2.X = (double)genRand.Next(-15, 16) * 0.01;
		}
		else
		{
			vector2D2.X = (double)genRand.Next(-50, 51) * 0.01;
			num8 = genRand.NextDouble() * 0.004 + 0.001;
		}
		vector2D2.Y = (double)genRand.Next(101) * 0.01;
		double num9 = num;
		double num10 = num7;
		while (num > 3.0 && num7 > 0.0)
		{
			num -= (double)genRand.Next(11) * 0.1;
			num7 -= 1.0;
			int num11 = (int)(vector2D.X - num * 4.0);
			int num12 = (int)(vector2D.X + num * 4.0);
			int num13 = (int)(vector2D.Y - num * 3.0);
			int num14 = (int)(vector2D.Y + num * 2.0);
			if (num11 < 0)
			{
				num11 = 0;
			}
			if (num12 > Main.maxTilesX)
			{
				num12 = Main.maxTilesX;
			}
			if (num13 < 0)
			{
				num13 = 0;
			}
			if (num14 > Main.maxTilesY)
			{
				num14 = Main.maxTilesY;
			}
			num9 = num;
			for (int k = num11; k < num12; k++)
			{
				for (int l = num13; l < num14; l++)
				{
					double value = Math.Abs((double)k - vector2D.X) * 0.6;
					double value2 = Math.Abs((double)l - vector2D.Y) * 1.4;
					double value3 = Math.Abs((double)k - vector2D.X) * 0.3;
					double value4 = Math.Abs((double)l - vector2D.Y) * 5.0;
					value = Utils.Lerp(value, value3, num7 / num10);
					value2 = Utils.Lerp(value2, value4, num7 / num10);
					double num2 = Math.Sqrt(value * value + value2 * value2);
					int num3 = j + 5;
					if (num2 < num9 * 0.4)
					{
						if (l >= j)
						{
							if (l <= j + 1)
							{
								if (WillWaterPlacedHereStayPut(k, l))
								{
									Main.tile[k, l].liquid = byte.MaxValue;
									Main.tile[k, l].lava(lava);
								}
							}
							else
							{
								Main.tile[k, l].liquid = byte.MaxValue;
								Main.tile[k, l].lava(lava);
							}
						}
						Main.tile[k, l].active(active: false);
						if (!gen)
						{
							SquareTileFrame(k, l);
						}
						if (Main.tile[k, l].type == 59 || Main.tile[k, l].type == 60)
						{
							SpreadGrass(k - 1, l, 59, 60);
							SpreadGrass(k + 1, l, 59, 60);
							SpreadGrass(k, l + 1, 59, 60);
						}
					}
					else if (l > j + 1 && num2 < num9 && Main.tile[k, l].liquid == 0)
					{
						if (Math.Abs((double)k - vector2D.X) * 0.8 < num9 && Main.tile[k, l].wall > 0 && Main.tile[k - 1, l].wall > 0 && Main.tile[k + 1, l].wall > 0 && Main.tile[k, l + 1].wall > 0)
						{
							Main.tile[k, l].active(active: true);
						}
					}
					else
					{
						if (l >= j || num7 != num10 - 1.0 || !((double)l > GenVars.worldSurfaceLow - 20.0) || TileID.Sets.Clouds[Main.tile[k, l].type])
						{
							continue;
						}
						value = (double)Math.Abs(k - i) * 0.7;
						value2 = (double)Math.Abs(l - num3) * 1.35;
						num2 = Math.Sqrt(value * value + value2 * value2);
						double num4 = num9 * 0.4;
						double num5 = (double)Math.Abs(k - i) / (double)(num12 - i);
						num5 = 1.0 - num5;
						num5 *= 2.3;
						num5 *= num5;
						num5 *= num5;
						if (l < num3 && value < num4 + (double)Math.Abs(l - num3) * 0.5 * num5)
						{
							Main.tile[k, l].active(active: false);
							if (Main.tile[k, l].type == 59 || Main.tile[k, l].type == 60)
							{
								SpreadGrass(k - 1, l, 59, 60);
								SpreadGrass(k + 1, l, 59, 60);
								SpreadGrass(k, l + 1, 59, 60);
							}
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-100, 101) * num8;
			vector2D2.Y += (double)genRand.Next(-100, 101) * 0.01;
			if (vector2D2.X > 1.0)
			{
				vector2D2.X = 1.0;
			}
			if (vector2D2.X < -1.0)
			{
				vector2D2.X = -1.0;
			}
			if (vector2D2.Y > 1.0)
			{
				vector2D2.Y = 1.0;
			}
			double num6 = 0.5 * (1.0 - num7 / num10);
			if (vector2D2.Y < num6)
			{
				vector2D2.Y = num6;
			}
		}
	}

	public static void ShroomPatch(int i, int j)
	{
		double num = genRand.Next(80, 100);
		double num7 = genRand.Next(20, 26);
		double num8 = (double)Main.maxTilesX / 4200.0;
		if (getGoodWorldGen && !Main.remixWorld)
		{
			num8 *= 1.5;
		}
		num *= num8;
		num7 *= num8;
		double num9 = num7 - 1.0;
		double num10 = num;
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = (double)j - num7 * 0.3;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.X = (double)genRand.Next(-100, 101) * 0.005;
		vector2D2.Y = (double)genRand.Next(-200, -100) * 0.005;
		while (num > 0.0 && num7 > 0.0)
		{
			num -= (double)genRand.Next(3);
			num7 -= 1.0;
			int num11 = (int)(vector2D.X - num * 0.5);
			int num12 = (int)(vector2D.X + num * 0.5);
			int num13 = (int)(vector2D.Y - num * 0.5);
			int num14 = (int)(vector2D.Y + num * 0.5);
			if (num11 < 0)
			{
				num11 = 0;
			}
			if (num12 > Main.maxTilesX)
			{
				num12 = Main.maxTilesX;
			}
			if (num13 < 0)
			{
				num13 = 0;
			}
			if (num14 > Main.maxTilesY)
			{
				num14 = Main.maxTilesY;
			}
			num10 = num * (double)genRand.Next(80, 120) * 0.01;
			for (int k = num11; k < num12; k++)
			{
				for (int l = num13; l < num14; l++)
				{
					double num15 = Math.Abs((double)k - vector2D.X);
					double num2 = Math.Abs(((double)l - vector2D.Y) * 2.3);
					double num3 = Math.Sqrt(num15 * num15 + num2 * num2);
					if (num3 < num10 * 0.8 && Main.tile[k, l].lava())
					{
						Main.tile[k, l].liquid = 0;
					}
					if (num3 < num10 * 0.2 && (double)l < vector2D.Y)
					{
						Main.tile[k, l].active(active: false);
						if (Main.tile[k, l].wall > 0)
						{
							Main.tile[k, l].wall = 80;
						}
					}
					else if (num3 < num10 * 0.4 * (0.95 + genRand.NextDouble() * 0.1))
					{
						Main.tile[k, l].type = 59;
						if (num7 == num9 && (double)l > vector2D.Y)
						{
							Main.tile[k, l].active(active: true);
						}
						if (Main.tile[k, l].wall > 0)
						{
							Main.tile[k, l].wall = 80;
						}
					}
				}
			}
			vector2D += vector2D2;
			vector2D.X += vector2D2.X;
			vector2D2.X += (double)genRand.Next(-100, 110) * 0.005;
			vector2D2.Y -= (double)genRand.Next(110) * 0.005;
			if (vector2D2.X > -0.5 && vector2D2.X < 0.5)
			{
				if (vector2D2.X < 0.0)
				{
					vector2D2.X = -0.5;
				}
				else
				{
					vector2D2.X = 0.5;
				}
			}
			if (vector2D2.X > 0.5)
			{
				vector2D2.X = 0.5;
			}
			if (vector2D2.X < -0.5)
			{
				vector2D2.X = -0.5;
			}
			if (vector2D2.Y > 0.5)
			{
				vector2D2.Y = 0.5;
			}
			if (vector2D2.Y < -0.5)
			{
				vector2D2.Y = -0.5;
			}
			for (int m = 0; m < 2; m++)
			{
				int num4 = (int)vector2D.X + genRand.Next(-20, 20);
				int num5 = (int)vector2D.Y + genRand.Next(0, 20);
				while (!Main.tile[num4, num5].active() && Main.tile[num4, num5].type != 59)
				{
					num4 = (int)vector2D.X + genRand.Next(-20, 20);
					num5 = (int)vector2D.Y + genRand.Next(0, 20);
				}
				int num6 = genRand.Next(10, 20);
				int steps = genRand.Next(10, 20);
				TileRunner(num4, num5, num6, steps, 59, addTile: false, 0.0, 2.0, noYChange: true);
			}
		}
	}

	public static void Cavinator(int i, int j, int steps)
	{
		double num = genRand.Next(7, 15);
		double num3 = num;
		int num4 = 1;
		if (genRand.Next(2) == 0)
		{
			num4 = -1;
		}
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		int num5 = genRand.Next(20, 40);
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.Y = (double)genRand.Next(10, 20) * 0.01;
		vector2D2.X = num4;
		while (num5 > 0)
		{
			num5--;
			int num6 = (int)(vector2D.X - num * 0.5);
			int num7 = (int)(vector2D.X + num * 0.5);
			int num8 = (int)(vector2D.Y - num * 0.5);
			int num9 = (int)(vector2D.Y + num * 0.5);
			if (num6 < 0)
			{
				num6 = 0;
			}
			if (num7 > Main.maxTilesX)
			{
				num7 = Main.maxTilesX;
			}
			if (num8 < 0)
			{
				num8 = 0;
			}
			if (num9 > Main.maxTilesY)
			{
				num9 = Main.maxTilesY;
			}
			num3 = num * (double)genRand.Next(80, 120) * 0.01;
			for (int k = num6; k < num7; k++)
			{
				for (int l = num8; l < num9; l++)
				{
					double num10 = Math.Abs((double)k - vector2D.X);
					double num2 = Math.Abs((double)l - vector2D.Y);
					if (Math.Sqrt(num10 * num10 + num2 * num2) < num3 * 0.4 && TileID.Sets.CanBeClearedDuringGeneration[Main.tile[k, l].type] && Main.tile[k, l].type != 53)
					{
						Main.tile[k, l].active(active: false);
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
			vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.X > (double)num4 + 0.5)
			{
				vector2D2.X = (double)num4 + 0.5;
			}
			if (vector2D2.X < (double)num4 - 0.5)
			{
				vector2D2.X = (double)num4 - 0.5;
			}
			if (vector2D2.Y > 2.0)
			{
				vector2D2.Y = 2.0;
			}
			if (vector2D2.Y < 0.0)
			{
				vector2D2.Y = 0.0;
			}
		}
		if (steps > 0 && (double)(int)vector2D.Y < Main.rockLayer + 50.0)
		{
			Cavinator((int)vector2D.X, (int)vector2D.Y, steps - 1);
		}
	}

	public static void CaveOpenater(int i, int j)
	{
		double num = genRand.Next(7, 12);
		double num3 = num;
		int num4 = 1;
		if (genRand.Next(2) == 0)
		{
			num4 = -1;
		}
		if (genRand.Next(10) != 0)
		{
			num4 = ((i < Main.maxTilesX / 2) ? 1 : (-1));
		}
		Vector2D vector2D = default(Vector2D);
		vector2D.X = i;
		vector2D.Y = j;
		int num5 = 100;
		Vector2D vector2D2 = default(Vector2D);
		vector2D2.Y = 0.0;
		vector2D2.X = num4;
		while (num5 > 0)
		{
			Tile tile = Main.tile[(int)vector2D.X, (int)vector2D.Y];
			if (tile.wall == 0 || (tile.active() && !TileID.Sets.CanBeClearedDuringGeneration[tile.type]))
			{
				num5 = 0;
			}
			num5--;
			int num6 = (int)(vector2D.X - num * 0.5);
			int num7 = (int)(vector2D.X + num * 0.5);
			int num8 = (int)(vector2D.Y - num * 0.5);
			int num9 = (int)(vector2D.Y + num * 0.5);
			if (num6 < 0)
			{
				num6 = 0;
			}
			if (num7 > Main.maxTilesX)
			{
				num7 = Main.maxTilesX;
			}
			if (num8 < 0)
			{
				num8 = 0;
			}
			if (num9 > Main.maxTilesY)
			{
				num9 = Main.maxTilesY;
			}
			num3 = num * (double)genRand.Next(80, 120) * 0.01;
			for (int k = num6; k < num7; k++)
			{
				for (int l = num8; l < num9; l++)
				{
					double num10 = Math.Abs((double)k - vector2D.X);
					double num2 = Math.Abs((double)l - vector2D.Y);
					if (Math.Sqrt(num10 * num10 + num2 * num2) < num3 * 0.4 && TileID.Sets.CanBeClearedDuringGeneration[Main.tile[k, l].type])
					{
						Main.tile[k, l].active(active: false);
					}
				}
			}
			vector2D += vector2D2;
			vector2D2.X += (double)genRand.Next(-10, 11) * 0.05;
			vector2D2.Y += (double)genRand.Next(-10, 11) * 0.05;
			if (vector2D2.X > (double)num4 + 0.5)
			{
				vector2D2.X = (double)num4 + 0.5;
			}
			if (vector2D2.X < (double)num4 - 0.5)
			{
				vector2D2.X = (double)num4 - 0.5;
			}
			if (vector2D2.Y > 0.0)
			{
				vector2D2.Y = 0.0;
			}
			if (vector2D2.Y < -0.5)
			{
				vector2D2.Y = -0.5;
			}
		}
	}

	public static void DiamondTileFrame(int i, int j)
	{
		TileFrame(i - 1, j);
		TileFrame(i, j - 1);
		TileFrame(i, j + 1);
		TileFrame(i + 1, j);
	}

	public static void SquareTileFrame(int i, int j, bool resetFrame = true)
	{
		TileFrame(i - 1, j - 1);
		TileFrame(i - 1, j);
		TileFrame(i - 1, j + 1);
		TileFrame(i, j - 1);
		TileFrame(i, j, resetFrame);
		TileFrame(i, j + 1);
		TileFrame(i + 1, j - 1);
		TileFrame(i + 1, j);
		TileFrame(i + 1, j + 1);
	}

	public static void SquareWallFrame(int i, int j, bool resetFrame = true)
	{
		Framing.WallFrame(i - 1, j - 1);
		Framing.WallFrame(i - 1, j);
		Framing.WallFrame(i - 1, j + 1);
		Framing.WallFrame(i, j - 1);
		Framing.WallFrame(i, j, resetFrame);
		Framing.WallFrame(i, j + 1);
		Framing.WallFrame(i + 1, j - 1);
		Framing.WallFrame(i + 1, j);
		Framing.WallFrame(i + 1, j + 1);
	}

	public static void SectionTileFrameWithCheck(int startX, int startY, int endX, int endY)
	{
		int sectionX3 = Netplay.GetSectionX(startX);
		int sectionY = Netplay.GetSectionY(startY);
		int sectionX2 = Netplay.GetSectionX(endX);
		int sectionY2 = Netplay.GetSectionY(endY);
		for (int i = sectionX3; i <= sectionX2; i++)
		{
			for (int j = sectionY; j <= sectionY2; j++)
			{
				if (Main.sectionManager.SectionLoaded(i, j) && !Main.sectionManager.SectionFramed(i, j))
				{
					SectionTileFrame(i, j, i, j);
					if (!Main.sectionManager.AnyUnfinishedSections)
					{
						return;
					}
				}
			}
		}
	}

	public static void RefreshSections(int startX, int startY, int endX, int endY)
	{
		int sectionX3 = Netplay.GetSectionX(startX);
		int sectionY = Netplay.GetSectionY(startY);
		int sectionX2 = Netplay.GetSectionX(endX);
		int sectionY2 = Netplay.GetSectionY(endY);
		for (int i = sectionX3; i <= sectionX2; i++)
		{
			for (int j = sectionY; j <= sectionY2; j++)
			{
				if (Main.sectionManager.SectionNeedsRefresh(i, j))
				{
					RefreshSection(i, j);
				}
			}
		}
	}

	public static void RefreshSection(int sectionX, int sectionY)
	{
		GetSectionBounds(sectionX, sectionY, sectionX, sectionY, out var tileStartX, out var tileEndX, out var tileStartY, out var tileEndY);
		noMapUpdate = true;
		int totalEcho = 0;
		int totalFramed = 0;
		for (int i = tileStartY; i < tileEndY; i += 50)
		{
			for (int j = tileStartX; j < tileEndX; j += 200)
			{
				RefreshStrip(j, i, Math.Min(j + 200, tileEndX), Math.Min(i + 50, tileEndY), ref totalEcho, ref totalFramed);
			}
		}
		noMapUpdate = false;
		Main.sectionManager.SetSectionAsRefreshed(sectionX, sectionY);
	}

	public static void RefreshStrip(int xStart, int yStart, int xEnd, int yEnd, ref int totalEcho, ref int totalFramed)
	{
		int num = xStart - 1;
		int num2 = yStart - 1;
		int num3 = xEnd - xStart;
		int num4 = yEnd - yStart;
		if (num4 > 50 || num3 > 200)
		{
			throw new IndexOutOfRangeException();
		}
		int num5 = 0;
		Vertical64BitStrips vertical64BitStrips = bitStrip;
		for (int i = 1; i <= num3; i++)
		{
			Bits64 value = default(Bits64);
			for (int j = 1; j <= num4; j++)
			{
				Tile tile = Main.tile[num + i, num2 + j];
				if (tile != null && (tile.invisibleBlock() || tile.invisibleWall()))
				{
					num5++;
					value[j] = true;
				}
			}
			vertical64BitStrips[i] = value;
		}
		if (num5 == 0)
		{
			return;
		}
		vertical64BitStrips.Expand3x3();
		for (int k = 0; k < num3 + 2; k++)
		{
			Bits64 bits = vertical64BitStrips[k];
			if (bits.IsEmpty)
			{
				continue;
			}
			for (int l = 0; l < num4 + 2; l++)
			{
				if (bits[l])
				{
					totalFramed++;
					Reframe(num + k, num2 + l);
				}
			}
		}
		vertical64BitStrips.Clear();
		totalEcho += num5;
	}

	public static void Reframe(int x, int y, bool resetFrame = false)
	{
		TileFrame(x, y, resetFrame, noBreak: true);
		Framing.WallFrame(x, y, resetFrame);
	}

	public static void SectionTileFrame(int sectionStartX, int sectionStartY, int sectionEndXInclusive, int sectionEndYInclusive)
	{
		Main.mapTime = Main.mapTimeMax + 10;
		noMapUpdate = true;
		GetSectionBounds(sectionStartX, sectionStartY, sectionEndXInclusive, sectionEndYInclusive, out var tileStartX, out var tileEndX, out var tileStartY, out var tileEndY);
		for (int i = tileStartX - 1; i < tileEndX + 1; i++)
		{
			for (int j = tileStartY - 1; j < tileEndY + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					Main.tile[i, j] = default(Tile);
				}
				Reframe(i, j, resetFrame: true);
			}
		}
		for (int k = sectionStartX; k <= sectionEndXInclusive; k++)
		{
			for (int l = sectionStartY; l <= sectionEndYInclusive; l++)
			{
				Main.sectionManager.SetSectionFramed(k, l);
			}
		}
		noMapUpdate = false;
	}

	public static void GetSectionBounds(int sectionStartX, int sectionStartY, int sectionEndXInclusive, int sectionEndYInclusive, out int tileStartX, out int tileEndX, out int tileStartY, out int tileEndY)
	{
		tileStartX = sectionStartX * 200;
		tileEndX = (sectionEndXInclusive + 1) * 200;
		tileStartY = sectionStartY * 150;
		tileEndY = (sectionEndYInclusive + 1) * 150;
		if (tileStartX < 1)
		{
			tileStartX = 1;
		}
		if (tileStartY < 1)
		{
			tileStartY = 1;
		}
		if (tileStartX > Main.maxTilesX - 2)
		{
			tileStartX = Main.maxTilesX - 2;
		}
		if (tileStartY > Main.maxTilesY - 2)
		{
			tileStartY = Main.maxTilesY - 2;
		}
		if (tileEndX > Main.maxTilesX - 2)
		{
			tileEndX = Main.maxTilesX - 2;
		}
		if (tileEndY > Main.maxTilesY - 2)
		{
			tileEndY = Main.maxTilesY - 2;
		}
	}

	public static void RangeFrame(int startX, int startY, int endX, int endY)
	{
		int num = endX + 1;
		int num2 = endY + 1;
		for (int i = startX - 1; i < num + 1; i++)
		{
			for (int j = startY - 1; j < num2 + 1; j++)
			{
				TileFrame(i, j);
				Framing.WallFrame(i, j);
			}
		}
	}

	public static void WaterCheck()
	{
		Liquid.tilesIgnoreWater(ignoreSolids: true);
		Liquid.numLiquid = 0;
		LiquidBuffer.numLiquidBuffer = 0;
		for (int i = 1; i < Main.maxTilesX - 1; i++)
		{
			for (int num = Main.maxTilesY - 2; num > 0; num--)
			{
				Tile tile = Main.tile[i, num];
				tile.checkingLiquid(checkingLiquid: false);
				if (tile.liquid > 0 && tile.nactive() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type])
				{
					tile.liquid = 0;
				}
				else if (tile.liquid > 0)
				{
					if (tile.active())
					{
						if (tile.lava())
						{
							if (TileObjectData.CheckLavaDeath(tile))
							{
								KillTile(i, num);
							}
						}
						else if (TileObjectData.CheckWaterDeath(tile))
						{
							KillTile(i, num);
						}
					}
					Tile tile2 = Main.tile[i, num + 1];
					if ((!tile2.nactive() || !Main.tileSolid[tile2.type] || Main.tileSolidTop[tile2.type]) && tile2.liquid < byte.MaxValue)
					{
						if (tile2.liquid > 250)
						{
							tile2.liquid = byte.MaxValue;
						}
						else
						{
							Liquid.AddWater(i, num);
						}
					}
					Tile tile3 = Main.tile[i - 1, num];
					Tile tile4 = Main.tile[i + 1, num];
					if ((!tile3.nactive() || !Main.tileSolid[tile3.type] || Main.tileSolidTop[tile3.type]) && tile3.liquid != tile.liquid)
					{
						Liquid.AddWater(i, num);
					}
					else if ((!tile4.nactive() || !Main.tileSolid[tile4.type] || Main.tileSolidTop[tile4.type]) && tile4.liquid != tile.liquid)
					{
						Liquid.AddWater(i, num);
					}
					if (tile.lava())
					{
						if (tile3.liquid > 0 && !tile3.lava())
						{
							Liquid.AddWater(i, num);
						}
						else if (tile4.liquid > 0 && !tile4.lava())
						{
							Liquid.AddWater(i, num);
						}
						else if (Main.tile[i, num - 1].liquid > 0 && !Main.tile[i, num - 1].lava())
						{
							Liquid.AddWater(i, num);
						}
						else if (tile2.liquid > 0 && !tile2.lava())
						{
							Liquid.AddWater(i, num);
						}
					}
				}
			}
		}
		Liquid.tilesIgnoreWater(ignoreSolids: false);
	}

	public static void EveryTileFrame()
	{
		Stopwatch stopwatch = new Stopwatch();
		stopwatch.Start();
		noLiquidCheck = true;
		noTileActions = true;
		for (int i = 0; i < Main.maxTilesX; i++)
		{
			float num = (float)i / (float)Main.maxTilesX;
			Main.statusText = Lang.gen[55].Value + " " + (int)(num * 100f + 1f) + "%";
			for (int j = 0; j < Main.maxTilesY; j++)
			{
				if (Main.tile[i, j].active())
				{
					TileFrame(i, j, resetFrame: true);
				}
				if (Main.tile[i, j].wall > 0)
				{
					Framing.WallFrame(i, j, resetFrame: true);
				}
			}
		}
		noLiquidCheck = false;
		noTileActions = false;
		_ = stopwatch.ElapsedMilliseconds;
	}

	public static void PlantCheck(int x, int y)
	{
		x = Utils.Clamp(x, 1, Main.maxTilesX - 2);
		y = Utils.Clamp(y, 1, Main.maxTilesY - 2);
		for (int i = x - 1; i <= x + 1; i++)
		{
			for (int j = y - 1; j <= y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					return;
				}
			}
		}
		int num = -1;
		Tile tile = Main.tile[x, y];
		int num2 = tile.type;
		_ = Main.maxTilesX;
		if (y + 1 >= Main.maxTilesY)
		{
			num = num2;
		}
		if (x - 1 >= 0 && Main.tile[x - 1, y] != null)
		{
			tile = Main.tile[x - 1, y];
			if (tile.nactive())
			{
				tile = Main.tile[x - 1, y];
				_ = ref tile.type;
			}
		}
		if (x + 1 < Main.maxTilesX && Main.tile[x + 1, y] != null)
		{
			tile = Main.tile[x + 1, y];
			if (tile.nactive())
			{
				tile = Main.tile[x + 1, y];
				_ = ref tile.type;
			}
		}
		if (y - 1 >= 0 && Main.tile[x, y - 1] != null)
		{
			tile = Main.tile[x, y - 1];
			if (tile.nactive())
			{
				tile = Main.tile[x, y - 1];
				_ = ref tile.type;
			}
		}
		if (y + 1 < Main.maxTilesY && Main.tile[x, y + 1] != null)
		{
			tile = Main.tile[x, y + 1];
			if (tile.nactive())
			{
				tile = Main.tile[x, y + 1];
				if (!tile.halfBrick())
				{
					tile = Main.tile[x, y + 1];
					if (tile.slope() == 0)
					{
						tile = Main.tile[x, y + 1];
						num = tile.type;
					}
				}
			}
		}
		if (x - 1 >= 0 && y - 1 >= 0 && Main.tile[x - 1, y - 1] != null)
		{
			tile = Main.tile[x - 1, y - 1];
			if (tile.nactive())
			{
				tile = Main.tile[x - 1, y - 1];
				_ = ref tile.type;
			}
		}
		if (x + 1 < Main.maxTilesX && y - 1 >= 0 && Main.tile[x + 1, y - 1] != null)
		{
			tile = Main.tile[x + 1, y - 1];
			if (tile.nactive())
			{
				tile = Main.tile[x + 1, y - 1];
				_ = ref tile.type;
			}
		}
		if (x - 1 >= 0 && y + 1 < Main.maxTilesY && Main.tile[x - 1, y + 1] != null)
		{
			tile = Main.tile[x - 1, y + 1];
			if (tile.nactive())
			{
				tile = Main.tile[x - 1, y + 1];
				_ = ref tile.type;
			}
		}
		if (x + 1 < Main.maxTilesX && y + 1 < Main.maxTilesY && Main.tile[x + 1, y + 1] != null)
		{
			tile = Main.tile[x + 1, y + 1];
			if (tile.nactive())
			{
				tile = Main.tile[x + 1, y + 1];
				_ = ref tile.type;
			}
		}
		if ((num2 != 3 || num == 2 || num == 477 || num == 78 || num == 380 || num == 579) && (num2 != 73 || num == 2 || num == 477 || num == 78 || num == 380 || num == 579) && (num2 != 24 || num == 23 || num == 661) && (num2 != 61 || num == 60) && (num2 != 74 || num == 60) && (num2 != 71 || num == 70) && (num2 != 110 || num == 109 || num == 492) && (num2 != 113 || num == 109 || num == 492) && (num2 != 201 || num == 199 || num == 662) && (num2 != 637 || num == 633))
		{
			return;
		}
		bool flag = false;
		if (num2 == 3 || num2 == 110 || num2 == 24)
		{
			tile = Main.tile[x, y];
			flag = tile.frameX == 144;
		}
		if (num2 == 201)
		{
			tile = Main.tile[x, y];
			flag = tile.frameX == 270;
		}
		if ((num2 == 3 || num2 == 73) && num != 2 && num != 477)
		{
			tile = Main.tile[x, y];
			if (tile.frameX >= 162)
			{
				tile = Main.tile[x, y];
				tile.frameX = 126;
			}
		}
		if (num2 == 74 && num != 60)
		{
			tile = Main.tile[x, y];
			if (tile.frameX >= 162)
			{
				tile = Main.tile[x, y];
				tile.frameX = 126;
			}
		}
		switch (num)
		{
		case 23:
		case 661:
			num2 = 24;
			tile = Main.tile[x, y];
			if (tile.frameX >= 162)
			{
				tile = Main.tile[x, y];
				tile.frameX = 126;
			}
			break;
		case 2:
		case 477:
			num2 = ((num2 != 113) ? 3 : 73);
			break;
		case 109:
		case 492:
			num2 = ((num2 != 73) ? 110 : 113);
			break;
		case 199:
		case 662:
			num2 = 201;
			break;
		case 60:
			num2 = 61;
			while (true)
			{
				tile = Main.tile[x, y];
				if (tile.frameX > 126)
				{
					tile = Main.tile[x, y];
					tile.frameX -= 126;
					continue;
				}
				break;
			}
			break;
		case 70:
			num2 = 71;
			while (true)
			{
				tile = Main.tile[x, y];
				if (tile.frameX <= 72)
				{
					break;
				}
				tile = Main.tile[x, y];
				tile.frameX -= 72;
			}
			break;
		}
		int num3 = num2;
		tile = Main.tile[x, y];
		if (num3 != tile.type)
		{
			tile = Main.tile[x, y];
			tile.type = (ushort)num2;
			if (flag)
			{
				tile = Main.tile[x, y];
				tile.frameX = 144;
				if (num2 == 201)
				{
					tile = Main.tile[x, y];
					tile.frameX = 270;
				}
			}
		}
		else
		{
			KillTile(x, y);
		}
	}

	public static bool CanPoundTile(int x, int y)
	{
		if (Main.tile[x, y] == null)
		{
			Main.tile[x, y] = default(Tile);
		}
		if (Main.tile[x, y - 1] == null)
		{
			Main.tile[x, y - 1] = default(Tile);
		}
		if (Main.tile[x, y + 1] == null)
		{
			Main.tile[x, y + 1] = default(Tile);
		}
		ushort type = Main.tile[x, y].type;
		if (!TileLoader.IsClosedDoor(Main.tile[x, y].type))
		{
			switch (type)
			{
			case 48:
			case 137:
			case 138:
			case 232:
			case 380:
			case 387:
			case 388:
			case 476:
			case 484:
			case 664:
			case 665:
				break;
			default:
				{
					if (gen)
					{
						if (Main.tile[x, y].type == 190)
						{
							return false;
						}
						if (Main.tile[x, y].type == 30)
						{
							return false;
						}
					}
					if (Main.tile[x, y - 1].active())
					{
						ushort t = Main.tile[x, y - 1].type;
						if (TileID.Sets.BasicChest[t] || TileID.Sets.BasicDresser[t])
						{
							goto IL_021b;
						}
						if ((uint)t <= 237u)
						{
							if ((uint)t <= 77u)
							{
								if (t == 21 || t == 26 || t == 77)
								{
									goto IL_021b;
								}
							}
							else if (t == 88 || t == 235 || t == 237)
							{
								goto IL_021b;
							}
						}
						else if ((uint)t <= 470u)
						{
							if (t == 441 || (uint)(t - 467) <= 1u || t == 470)
							{
								goto IL_021b;
							}
						}
						else if (t == 475 || t == 488 || t == 597)
						{
							goto IL_021b;
						}
					}
					return CanKillTile(x, y);
				}
				IL_021b:
				return false;
			}
		}
		return false;
	}

	public static bool SlopeTile(int i, int j, int slope = 0, bool noEffects = false)
	{
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		if (!CanPoundTile(i, j))
		{
			return false;
		}
		Main.tile[i, j].halfBrick(halfBrick: false);
		Main.tile[i, j].slope((byte)slope);
		if (!gen)
		{
			if (!noEffects)
			{
				KillTile(i, j, fail: true, effectOnly: true);
			}
			SoundEngine.PlaySound(0, i * 16, j * 16);
			SquareTileFrame(i, j);
			if (Main.tile[i, j].slope() == 0)
			{
				Rectangle rectangle = default(Rectangle);
				((Rectangle)(ref rectangle))._002Ector(i * 16, j * 16, 16, 16);
				for (int k = 0; k < 255; k++)
				{
					if (Main.player[k].active && !Main.player[k].dead && ((Rectangle)(ref rectangle)).Intersects(new Rectangle((int)Main.player[k].position.X, (int)Main.player[k].position.Y, Main.player[k].width, Main.player[k].height)))
					{
						Main.player[k].gfxOffY += Main.player[k].position.Y + (float)Main.player[k].height - (float)rectangle.Y;
						Main.player[k].position.Y = rectangle.Y - Main.player[k].height;
					}
				}
			}
		}
		return true;
	}

	public static bool PoundTile(int i, int j)
	{
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		if (!CanPoundTile(i, j))
		{
			return false;
		}
		if (!Main.tile[i, j].halfBrick())
		{
			Main.tile[i, j].halfBrick(halfBrick: true);
		}
		else
		{
			Main.tile[i, j].halfBrick(halfBrick: false);
		}
		if (!gen)
		{
			KillTile(i, j, fail: true, effectOnly: true);
			SoundEngine.PlaySound(0, i * 16, j * 16);
			SquareTileFrame(i, j);
			if (!Main.tile[i, j].halfBrick())
			{
				Rectangle rectangle = default(Rectangle);
				((Rectangle)(ref rectangle))._002Ector(i * 16, j * 16, 16, 16);
				for (int k = 0; k < 255; k++)
				{
					if (Main.player[k].active && !Main.player[k].dead && ((Rectangle)(ref rectangle)).Intersects(new Rectangle((int)Main.player[k].position.X, (int)Main.player[k].position.Y, Main.player[k].width, Main.player[k].height)))
					{
						Main.player[k].gfxOffY += Main.player[k].position.Y + (float)Main.player[k].height - (float)rectangle.Y;
						Main.player[k].position.Y = rectangle.Y - Main.player[k].height;
					}
				}
			}
		}
		return true;
	}

	public static void PoundPlatform(int x, int y)
	{
		if (Main.tile[x, y].halfBrick())
		{
			PoundTile(x, y);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 7, x, y, 1f);
			}
			return;
		}
		int num = 1;
		int slope = 2;
		if (TileID.Sets.Platforms[Main.tile[x + 1, y - 1].type] || TileID.Sets.Platforms[Main.tile[x - 1, y + 1].type] || (SolidTile(x + 1, y) && !SolidTile(x - 1, y)))
		{
			num = 2;
			slope = 1;
		}
		if (Main.tile[x, y].slope() == 0)
		{
			SlopeTile(x, y, num);
			int num2 = Main.tile[x, y].slope();
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 14, x, y, num2);
			}
			return;
		}
		if (Main.tile[x, y].slope() == num)
		{
			SlopeTile(x, y, slope);
			int num3 = Main.tile[x, y].slope();
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 14, x, y, num3);
			}
			return;
		}
		SlopeTile(x, y);
		int num4 = Main.tile[x, y].slope();
		if (Main.netMode == 1)
		{
			NetMessage.SendData(17, -1, -1, null, 14, x, y, num4);
		}
		PoundTile(x, y);
		if (Main.netMode == 1)
		{
			NetMessage.SendData(17, -1, -1, null, 7, x, y, 1f);
		}
	}

	public static int PlatformProperSides(int x, int y, bool acceptNonOpposing = false)
	{
		Tile tile = Main.tile[x, y];
		if (!tile.active() || !TileID.Sets.Platforms[tile.type])
		{
			return 0;
		}
		int num = tile.slope();
		int num2 = -1;
		if (num == 1)
		{
			num2 = 2;
		}
		if (num == 2)
		{
			num2 = 1;
		}
		int num3 = 0;
		int num4 = 1;
		int num5 = 0;
		if (num == 1)
		{
			num5 = 1;
		}
		if (num == 2)
		{
			num5 = -1;
		}
		if (acceptNonOpposing)
		{
			if (Main.tile[x + num4, y + num5].active() && TileID.Sets.Platforms[Main.tile[x + num4, y + num5].type] && Main.tile[x + num4, y + num5].slope() != num2)
			{
				num3++;
			}
		}
		else if (Main.tile[x + num4, y + num5].active() && TileID.Sets.Platforms[Main.tile[x + num4, y + num5].type] && Main.tile[x + num4, y + num5].slope() == num)
		{
			num3++;
		}
		num4 *= -1;
		num5 *= -1;
		if (acceptNonOpposing)
		{
			if (Main.tile[x + num4, y + num5].active() && TileID.Sets.Platforms[Main.tile[x + num4, y + num5].type] && Main.tile[x + num4, y + num5].slope() != num2)
			{
				num3++;
			}
		}
		else if (Main.tile[x + num4, y + num5].active() && TileID.Sets.Platforms[Main.tile[x + num4, y + num5].type] && Main.tile[x + num4, y + num5].slope() == num)
		{
			num3++;
		}
		return num3;
	}

	public static bool UpdateMapTile(int i, int j, bool addToList = true)
	{
		bool result = false;
		if (!Main.dedServ && Main.mapEnabled && !noMapUpdate && !gen && !Main.refreshMap && Main.Map[i, j].Light > 0 && Main.Map.UpdateType(i, j) && addToList)
		{
			result = true;
			if (MapHelper.numUpdateTile < MapHelper.maxUpdateTile - 1)
			{
				MapHelper.updateTileX[MapHelper.numUpdateTile] = (short)i;
				MapHelper.updateTileY[MapHelper.numUpdateTile] = (short)j;
				MapHelper.numUpdateTile++;
			}
			else
			{
				Main.refreshMap = true;
			}
		}
		return result;
	}

	public static void TileMergeAttemptFrametest(int i, int j, int myType, int lookfor, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight)
	{
		if (up == lookfor)
		{
			TileFrame(i, j - 1);
			if (mergeDown)
			{
				up = myType;
			}
		}
		if (down == lookfor)
		{
			TileFrame(i, j + 1);
			if (mergeUp)
			{
				down = myType;
			}
		}
		if (left == lookfor)
		{
			TileFrame(i - 1, j);
			if (mergeRight)
			{
				left = myType;
			}
		}
		if (right == lookfor)
		{
			TileFrame(i + 1, j);
			if (mergeLeft)
			{
				right = myType;
			}
		}
		if (upLeft == lookfor)
		{
			upLeft = myType;
		}
		if (upRight == lookfor)
		{
			upRight = myType;
		}
		if (downLeft == lookfor)
		{
			downLeft = myType;
		}
		if (downRight == lookfor)
		{
			downRight = myType;
		}
	}

	public static void TileMergeAttemptFrametest(int i, int j, int myType, bool[] lookfor, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight)
	{
		if (up > -1 && lookfor[up])
		{
			TileFrame(i, j - 1);
			if (mergeDown)
			{
				up = myType;
			}
		}
		if (down > -1 && lookfor[down])
		{
			TileFrame(i, j + 1);
			if (mergeUp)
			{
				down = myType;
			}
		}
		if (left > -1 && lookfor[left])
		{
			TileFrame(i - 1, j);
			if (mergeRight)
			{
				left = myType;
			}
		}
		if (right > -1 && lookfor[right])
		{
			TileFrame(i + 1, j);
			if (mergeLeft)
			{
				right = myType;
			}
		}
		if (upLeft > -1 && lookfor[upLeft])
		{
			upLeft = myType;
		}
		if (upRight > -1 && lookfor[upRight])
		{
			upRight = myType;
		}
		if (downLeft > -1 && lookfor[downLeft])
		{
			downLeft = myType;
		}
		if (downRight > -1 && lookfor[downRight])
		{
			downRight = myType;
		}
	}

	public static void TileMergeAttempt(int myType, int lookfor, ref int up, ref int down, ref int left, ref int right)
	{
		if (lookfor == up)
		{
			up = myType;
		}
		if (lookfor == down)
		{
			down = myType;
		}
		if (lookfor == left)
		{
			left = myType;
		}
		if (lookfor == right)
		{
			right = myType;
		}
	}

	public static void TileMergeAttempt(int myType, bool[] lookfor, ref int up, ref int down, ref int left, ref int right)
	{
		if (up > -1 && lookfor[up])
		{
			up = myType;
		}
		if (down > -1 && lookfor[down])
		{
			down = myType;
		}
		if (left > -1 && lookfor[left])
		{
			left = myType;
		}
		if (right > -1 && lookfor[right])
		{
			right = myType;
		}
	}

	public static void TileMergeAttempt(int myType, int lookfor, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight)
	{
		if (lookfor == up)
		{
			up = myType;
		}
		if (lookfor == down)
		{
			down = myType;
		}
		if (lookfor == left)
		{
			left = myType;
		}
		if (lookfor == right)
		{
			right = myType;
		}
		if (lookfor == upLeft)
		{
			upLeft = myType;
		}
		if (lookfor == upRight)
		{
			upRight = myType;
		}
		if (lookfor == downLeft)
		{
			downLeft = myType;
		}
		if (lookfor == downRight)
		{
			downRight = myType;
		}
	}

	public static void TileMergeAttempt(int myType, bool[] lookfor, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight)
	{
		if (up > -1 && lookfor[up])
		{
			up = myType;
		}
		if (down > -1 && lookfor[down])
		{
			down = myType;
		}
		if (left > -1 && lookfor[left])
		{
			left = myType;
		}
		if (right > -1 && lookfor[right])
		{
			right = myType;
		}
		if (upLeft > -1 && lookfor[upLeft])
		{
			upLeft = myType;
		}
		if (upRight > -1 && lookfor[upRight])
		{
			upRight = myType;
		}
		if (downLeft > -1 && lookfor[downLeft])
		{
			downLeft = myType;
		}
		if (downRight > -1 && lookfor[downRight])
		{
			downRight = myType;
		}
	}

	public static void TileMergeAttempt(int myType, bool[] lookfor, bool[] exclude, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight)
	{
		if (up > -1 && !exclude[up] && lookfor[up])
		{
			up = myType;
		}
		if (down > -1 && !exclude[down] && lookfor[down])
		{
			down = myType;
		}
		if (left > -1 && !exclude[left] && lookfor[left])
		{
			left = myType;
		}
		if (right > -1 && !exclude[right] && lookfor[right])
		{
			right = myType;
		}
		if (upLeft > -1 && !exclude[upLeft] && lookfor[upLeft])
		{
			upLeft = myType;
		}
		if (upRight > -1 && !exclude[upRight] && lookfor[upRight])
		{
			upRight = myType;
		}
		if (downLeft > -1 && !exclude[downLeft] && lookfor[downLeft])
		{
			downLeft = myType;
		}
		if (downRight > -1 && !exclude[downRight] && lookfor[downRight])
		{
			downRight = myType;
		}
	}

	public static void TileMergeAttemptWeird(int myType, int changeTo, bool[] exclude, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight)
	{
		if (up > -1 && !exclude[up] && up != myType)
		{
			up = changeTo;
		}
		if (down > -1 && !exclude[down] && down != myType)
		{
			down = changeTo;
		}
		if (left > -1 && !exclude[left] && left != myType)
		{
			left = changeTo;
		}
		if (right > -1 && !exclude[right] && right != myType)
		{
			right = changeTo;
		}
		if (upLeft > -1 && !exclude[upLeft] && upLeft != myType)
		{
			upLeft = changeTo;
		}
		if (upRight > -1 && !exclude[upRight] && upRight != myType)
		{
			upRight = changeTo;
		}
		if (downLeft > -1 && !exclude[downLeft] && downLeft != myType)
		{
			downLeft = changeTo;
		}
		if (downRight > -1 && !exclude[downRight] && downRight != myType)
		{
			downRight = changeTo;
		}
	}

	public static int GetTileMossColor(int tileType)
	{
		switch (tileType)
		{
		default:
			return -1;
		case 179:
		case 512:
			return 0;
		case 180:
		case 513:
			return 1;
		case 181:
		case 514:
			return 2;
		case 182:
		case 515:
			return 3;
		case 183:
		case 516:
			return 4;
		case 381:
		case 517:
			return 5;
		case 534:
		case 535:
			return 6;
		case 536:
		case 537:
			return 7;
		case 539:
		case 540:
			return 8;
		case 625:
		case 626:
			return 9;
		case 627:
		case 628:
			return 10;
		}
	}

	public static void CheckFoodPlatter(int x, int y, int type)
	{
		if (Main.tile[x, y] == null || destroyObject || SolidTileAllowBottomSlope(x, y + 1))
		{
			return;
		}
		if (type == 520)
		{
			int num = TEFoodPlatter.Find(x, y);
			if (num != -1 && ((TEFoodPlatter)TileEntity.ByID[num]).item.stack > 0)
			{
				((TEFoodPlatter)TileEntity.ByID[num]).DropItem();
				if (Main.netMode != 2)
				{
					Main.LocalPlayer.InterruptItemUsageIfOverTile(520);
				}
			}
		}
		destroyObject = true;
		if (Main.tile[x, y].type == type)
		{
			KillTile(x, y);
		}
		if (type == 520)
		{
			TEFoodPlatter.Kill(x, y);
		}
		destroyObject = false;
	}

	public static void TileFrame(int i, int j, bool resetFrame = false, bool noBreak = false)
	{
		//IL_5f3f: Unknown result type (might be due to invalid IL or missing references)
		//IL_5f4c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1150: Unknown result type (might be due to invalid IL or missing references)
		//IL_7616: Unknown result type (might be due to invalid IL or missing references)
		//IL_7620: Unknown result type (might be due to invalid IL or missing references)
		//IL_7e87: Unknown result type (might be due to invalid IL or missing references)
		//IL_751f: Unknown result type (might be due to invalid IL or missing references)
		//IL_7e91: Unknown result type (might be due to invalid IL or missing references)
		//IL_7529: Unknown result type (might be due to invalid IL or missing references)
		//IL_7f21: Unknown result type (might be due to invalid IL or missing references)
		//IL_7f31: Unknown result type (might be due to invalid IL or missing references)
		//IL_817e: Unknown result type (might be due to invalid IL or missing references)
		//IL_8189: Unknown result type (might be due to invalid IL or missing references)
		//IL_16c7: Unknown result type (might be due to invalid IL or missing references)
		bool addToList = false;
		try
		{
			if (i > 5 && j > 5 && i < Main.maxTilesX - 5 && j < Main.maxTilesY - 5 && Main.tile[i, j] != null)
			{
				if (SkipFramingBecauseOfGen && !Main.tileFrameImportant[Main.tile[i, j].type])
				{
					return;
				}
				addToList = UpdateMapTile(i, j);
				Tile tile = Main.tile[i, j];
				if (!tile.active())
				{
					tile.halfBrick(halfBrick: false);
					tile.ClearBlockPaintAndCoating();
					tile.slope(0);
				}
				if (tile.liquid > 0 && Main.netMode != 1 && !noLiquidCheck)
				{
					Liquid.AddWater(i, j);
				}
				if (tile.active())
				{
					if (!TileLoader.TileFrame(i, j, tile.type, ref resetFrame, ref noBreak) || (noBreak && Main.tileFrameImportant[tile.type] && !TileID.Sets.Torch[tile.type]))
					{
						return;
					}
					int num = tile.type;
					if (Main.tileStone[num])
					{
						num = 1;
					}
					int frameX = tile.frameX;
					int frameY = tile.frameY;
					Rectangle rectangle = default(Rectangle);
					((Rectangle)(ref rectangle))._002Ector(-1, -1, 0, 0);
					int num43;
					if (Main.tileFrameImportant[tile.type])
					{
						num43 = num;
						switch (num43)
						{
						case 518:
							CheckLilyPad(i, j);
							return;
						case 519:
							CheckCatTail(i, j);
							return;
						case 549:
							CheckUnderwaterPlant(549, i, j);
							return;
						case 571:
							CheckBamboo(i, j);
							return;
						}
						if (!TileID.Sets.Torch[num])
						{
							switch (num43)
							{
							case 442:
								CheckProjectilePressurePad(i, j);
								break;
							case 136:
							{
								Tile tile3 = Main.tile[i, j - 1];
								Tile tile17 = Main.tile[i, j + 1];
								Tile tile24 = Main.tile[i - 1, j];
								Tile tile31 = Main.tile[i + 1, j];
								Tile tile35 = Main.tile[i - 1, j + 1];
								Tile tile38 = Main.tile[i + 1, j + 1];
								Tile tile41 = Main.tile[i - 1, j - 1];
								Tile tile44 = Main.tile[i + 1, j - 1];
								int num13 = -1;
								int num14 = -1;
								int num15 = -1;
								int tree = -1;
								int tree2 = -1;
								int tree3 = -1;
								int tree4 = -1;
								if (tile3 != null && tile3.nactive())
								{
									_ = ref tile3.type;
								}
								if (tile17 != null && tile17.nactive() && !tile17.halfBrick() && !tile17.topSlope())
								{
									num13 = tile17.type;
								}
								if (tile24 != null && tile24.nactive())
								{
									num14 = tile24.type;
								}
								if (tile31 != null && tile31.nactive())
								{
									num15 = tile31.type;
								}
								if (tile35 != null && tile35.nactive())
								{
									tree = tile35.type;
								}
								if (tile38 != null && tile38.nactive())
								{
									tree2 = tile38.type;
								}
								if (tile41 != null && tile41.nactive())
								{
									tree3 = tile41.type;
								}
								if (tile44 != null && tile44.nactive())
								{
									tree4 = tile44.type;
								}
								if (num13 >= 0 && Main.tileSolid[num13] && !Main.tileNoAttach[num13] && tile17 != null && !tile17.halfBrick() && (tile17.slope() == 0 || tile17.bottomSlope()))
								{
									tile.frameX = 0;
								}
								else if ((num14 >= 0 && Main.tileSolid[num14] && !Main.tileNoAttach[num14] && tile24 != null && (tile24.leftSlope() || tile24.slope() == 0) && !tile24.halfBrick()) || (num14 >= 0 && TileID.Sets.IsBeam[num14]) || (IsTreeType(num14) && IsTreeType(tree3) && IsTreeType(tree)))
								{
									tile.frameX = 18;
								}
								else if ((num15 >= 0 && Main.tileSolid[num15] && !Main.tileNoAttach[num15] && tile31 != null && (tile31.rightSlope() || tile31.slope() == 0) && !tile31.halfBrick()) || (num15 >= 0 && TileID.Sets.IsBeam[num15]) || (IsTreeType(num15) && IsTreeType(tree4) && IsTreeType(tree2)))
								{
									tile.frameX = 36;
								}
								else if (tile.wall > 0)
								{
									tile.frameX = 54;
								}
								else
								{
									KillTile(i, j);
								}
								break;
							}
							case 129:
							case 149:
							{
								Tile tile9 = Main.tile[i, j - 1];
								Tile tile18 = Main.tile[i, j + 1];
								Tile tile25 = Main.tile[i - 1, j];
								Tile tile32 = Main.tile[i + 1, j];
								int num16 = -1;
								int num17 = -1;
								int num18 = -1;
								int num19 = -1;
								if (tile9 != null && tile9.nactive() && !tile9.bottomSlope())
								{
									num17 = tile9.type;
								}
								if (tile18 != null && tile18.nactive() && !tile18.halfBrick() && !tile18.topSlope())
								{
									num16 = tile18.type;
								}
								if (tile25 != null && tile25.nactive() && !tile32.rightSlope())
								{
									num18 = tile25.type;
								}
								if (tile32 != null && tile32.nactive() && !tile32.leftSlope())
								{
									num19 = tile32.type;
								}
								if (num16 >= 0 && Main.tileSolid[num16] && !Main.tileSolidTop[num16])
								{
									tile.frameY = 0;
								}
								else if (num18 >= 0 && Main.tileSolid[num18] && !Main.tileSolidTop[num18])
								{
									tile.frameY = 54;
								}
								else if (num19 >= 0 && Main.tileSolid[num19] && !Main.tileSolidTop[num19])
								{
									tile.frameY = 36;
								}
								else if (num17 >= 0 && Main.tileSolid[num17] && !Main.tileSolidTop[num17])
								{
									tile.frameY = 18;
								}
								else
								{
									KillTile(i, j);
								}
								break;
							}
							default:
								if (num != 461)
								{
									switch (num)
									{
									case 178:
									{
										Tile tile6 = Main.tile[i, j - 1];
										Tile tile14 = Main.tile[i, j + 1];
										Tile tile22 = Main.tile[i - 1, j];
										Tile tile29 = Main.tile[i + 1, j];
										int num7 = -1;
										int num8 = -1;
										int num9 = -1;
										int num10 = -1;
										if (tile6 != null && tile6.nactive() && !tile6.bottomSlope())
										{
											num8 = tile6.type;
										}
										if (tile14 != null && tile14.nactive() && !tile14.halfBrick() && !tile14.topSlope())
										{
											num7 = tile14.type;
										}
										if (tile22 != null && tile22.nactive() && !tile22.halfBrick() && !tile22.rightSlope())
										{
											num9 = tile22.type;
										}
										if (tile29 != null && tile29.nactive() && !tile29.halfBrick() && !tile29.leftSlope())
										{
											num10 = tile29.type;
										}
										if (num9 == 10)
										{
											num9 = -1;
										}
										if (num10 == 10)
										{
											num10 = -1;
										}
										short num11 = (short)(genRand.Next(3) * 18);
										if (num7 >= 0 && Main.tileSolid[num7] && !Main.tileSolidTop[num7])
										{
											if (tile.frameY < 0 || tile.frameY > 36)
											{
												tile.frameY = num11;
											}
										}
										else if (num9 >= 0 && Main.tileSolid[num9] && !Main.tileSolidTop[num9])
										{
											if (tile.frameY < 108 || tile.frameY > 54)
											{
												tile.frameY = (short)(108 + num11);
											}
										}
										else if (num10 >= 0 && Main.tileSolid[num10] && !Main.tileSolidTop[num10])
										{
											if (tile.frameY < 162 || tile.frameY > 198)
											{
												tile.frameY = (short)(162 + num11);
											}
										}
										else if (num8 >= 0 && Main.tileSolid[num8] && !Main.tileSolidTop[num8])
										{
											if (tile.frameY < 54 || tile.frameY > 90)
											{
												tile.frameY = (short)(54 + num11);
											}
										}
										else
										{
											KillTile(i, j);
										}
										break;
									}
									case 184:
									{
										Tile tile7 = Main.tile[i, j - 1];
										Tile tile15 = Main.tile[i, j + 1];
										Tile tile23 = Main.tile[i - 1, j];
										Tile tile30 = Main.tile[i + 1, j];
										int num2 = -1;
										int num3 = -1;
										int num4 = -1;
										int num5 = -1;
										if (tile7 != null && tile7.active() && !tile7.bottomSlope())
										{
											num3 = tile7.type;
										}
										if (tile15 != null && tile15.active() && !tile15.halfBrick() && !tile15.topSlope())
										{
											num2 = tile15.type;
										}
										if (tile23 != null && tile23.active())
										{
											num4 = tile23.type;
										}
										if (tile30 != null && tile30.active())
										{
											num5 = tile30.type;
										}
										short num6 = (short)(genRand.Next(3) * 18);
										if (num2 >= 0 && GetTileMossColor(num2) != -1)
										{
											tile.frameX = (short)(22 * GetTileMossColor(num2));
											if (tile.frameY < 0 || tile.frameY > 36)
											{
												tile.frameY = num6;
											}
										}
										else if (num3 >= 0 && GetTileMossColor(num3) != -1)
										{
											tile.frameX = (short)(22 * GetTileMossColor(num3));
											if (tile.frameY < 54 || tile.frameY > 90)
											{
												tile.frameY = (short)(54 + num6);
											}
										}
										else if (num4 >= 0 && GetTileMossColor(num4) != -1)
										{
											tile.frameX = (short)(22 * GetTileMossColor(num4));
											if (tile.frameY < 108 || tile.frameY > 144)
											{
												tile.frameY = (short)(108 + num6);
											}
										}
										else if (num5 >= 0 && GetTileMossColor(num5) != -1)
										{
											tile.frameX = (short)(22 * GetTileMossColor(num5));
											if (tile.frameY < 162 || tile.frameY > 198)
											{
												tile.frameY = (short)(162 + num6);
											}
										}
										else
										{
											KillTile(i, j);
										}
										break;
									}
									case 529:
									{
										if (!SolidTileAllowBottomSlope(i, j + 1))
										{
											KillTile(i, j);
											break;
										}
										Tile tile16 = Main.tile[i, j + 1];
										_ = Main.tile[i, j].frameY / 34;
										if (tile16 == null || !tile16.active() || (tile16.type >= 0 && !TileID.Sets.Conversion.Sand[tile16.type]))
										{
											KillTile(i, j);
										}
										break;
									}
									case 3:
									case 24:
									case 61:
									case 71:
									case 73:
									case 74:
									case 110:
									case 113:
									case 201:
									case 637:
										PlantCheck(i, j);
										break;
									case 227:
										CheckDye(i, j);
										break;
									case 579:
										CheckRockGolemHead(i, j);
										break;
									case 12:
									case 31:
									case 639:
										CheckOrb(i, j, num);
										break;
									case 165:
										CheckTight(i, j);
										break;
									case 324:
										if (!SolidTileAllowBottomSlope(i, j + 1))
										{
											KillTile(i, j);
										}
										break;
									case 235:
										Check3x1(i, j, num);
										break;
									case 185:
										CheckPile(i, j);
										break;
									default:
										if (num != 296 && num != 297 && num != 309 && num != 358 && num != 359 && num != 413 && num != 414 && num != 542 && num != 550 && num != 551 && num != 553 && num != 554 && num != 558 && num != 559 && num != 599 && num != 600 && num != 601 && num != 602 && num != 603 && num != 604 && num != 605 && num != 606 && num != 607 && num != 608 && num != 609 && num != 610 && num != 611 && num != 612 && num != 632 && num != 640 && num != 643 && num != 644 && num != 645)
										{
											if (num == 10)
											{
												CheckDoorClosed(i, j, tile, num);
												break;
											}
											if (num == 11)
											{
												CheckDoorOpen(i, j, tile);
												break;
											}
											if (num == 314)
											{
												Minecart.FrameTrack(i, j, pound: false);
												Tile tile2 = Main.tile[i, j - 1];
												Tile tile11 = Main.tile[i, j + 1];
												if (tile2 != null && tile2.type >= 0 && Main.tileRope[tile2.type])
												{
													TileFrame(i, j - 1);
												}
												if (tile11 != null && tile11.type >= 0 && Main.tileRope[tile11.type])
												{
													TileFrame(i, j + 1);
												}
												break;
											}
											if (num == 380)
											{
												Tile tile20 = Main.tile[i - 1, j];
												if (tile20 == null)
												{
													break;
												}
												Tile tile27 = Main.tile[i + 1, j];
												if (!(tile27 == null) && !(Main.tile[i - 1, j + 1] == null) && !(Main.tile[i + 1, j + 1] == null) && !(Main.tile[i - 1, j - 1] == null) && Main.tile[i + 1, j - 1] != null)
												{
													int num12 = -1;
													int num23 = -1;
													if (tile20 != null && tile20.active())
													{
														num23 = (Main.tileStone[tile20.type] ? 1 : tile20.type);
													}
													if (tile27 != null && tile27.active())
													{
														num12 = (Main.tileStone[tile27.type] ? 1 : tile27.type);
													}
													if (num12 >= 0 && !Main.tileSolid[num12])
													{
														num12 = -1;
													}
													if (num23 >= 0 && !Main.tileSolid[num23])
													{
														num23 = -1;
													}
													if (num23 == num && num12 == num)
													{
														rectangle.X = 18;
													}
													else if (num23 == num && num12 != num)
													{
														rectangle.X = 36;
													}
													else if (num23 != num && num12 == num)
													{
														rectangle.X = 0;
													}
													else
													{
														rectangle.X = 54;
													}
													tile.frameX = (short)rectangle.X;
												}
												break;
											}
											if (num >= 0 && TileID.Sets.Platforms[num])
											{
												Tile tile21 = Main.tile[i - 1, j];
												if (tile21 == null)
												{
													break;
												}
												Tile tile28 = Main.tile[i + 1, j];
												if (tile28 == null)
												{
													break;
												}
												Tile tile34 = Main.tile[i - 1, j + 1];
												if (tile34 == null)
												{
													break;
												}
												Tile tile37 = Main.tile[i + 1, j + 1];
												if (tile37 == null)
												{
													break;
												}
												Tile tile40 = Main.tile[i - 1, j - 1];
												if (tile40 == null)
												{
													break;
												}
												Tile tile43 = Main.tile[i + 1, j - 1];
												if (tile43 == null)
												{
													break;
												}
												int num31 = -1;
												int num38 = -1;
												if (tile21 != null && tile21.active())
												{
													num38 = (Main.tileStone[tile21.type] ? 1 : ((!TileID.Sets.Platforms[tile21.type]) ? tile21.type : num));
												}
												if (tile28 != null && tile28.active())
												{
													num31 = (Main.tileStone[tile28.type] ? 1 : ((!TileID.Sets.Platforms[tile28.type]) ? tile28.type : num));
												}
												if (num31 >= 0 && !Main.tileSolid[num31])
												{
													num31 = -1;
												}
												if (num38 >= 0 && !Main.tileSolid[num38])
												{
													num38 = -1;
												}
												if (num38 == num && tile21.halfBrick() != tile.halfBrick())
												{
													num38 = -1;
												}
												if (num31 == num && tile28.halfBrick() != tile.halfBrick())
												{
													num31 = -1;
												}
												if (num38 != -1 && num38 != num && tile.halfBrick())
												{
													num38 = -1;
												}
												if (num31 != -1 && num31 != num && tile.halfBrick())
												{
													num31 = -1;
												}
												if (num38 == -1 && tile40.active() && tile40.type == num && tile40.slope() == 1)
												{
													num38 = num;
												}
												if (num31 == -1 && tile43.active() && tile43.type == num && tile43.slope() == 2)
												{
													num31 = num;
												}
												if (num38 == num && tile21.slope() == 2 && num31 != num)
												{
													num31 = -1;
												}
												if (num31 == num && tile28.slope() == 1 && num38 != num)
												{
													num38 = -1;
												}
												if (tile.slope() == 1)
												{
													if (TileID.Sets.Platforms[tile28.type] && tile28.slope() == 0 && !tile28.halfBrick())
													{
														rectangle.X = 468;
													}
													else if (!tile37.active() && (!TileID.Sets.Platforms[tile37.type] || tile37.slope() == 2))
													{
														if (!tile21.active() && (!TileID.Sets.Platforms[tile40.type] || tile40.slope() != 1))
														{
															rectangle.X = 432;
														}
														else
														{
															rectangle.X = 360;
														}
													}
													else if (!tile21.active() && (!TileID.Sets.Platforms[tile40.type] || tile40.slope() != 1))
													{
														rectangle.X = 396;
													}
													else
													{
														rectangle.X = 180;
													}
												}
												else if (tile.slope() == 2)
												{
													if (TileID.Sets.Platforms[tile21.type] && tile21.slope() == 0 && !tile21.halfBrick())
													{
														rectangle.X = 450;
													}
													else if (!tile34.active() && (!TileID.Sets.Platforms[tile34.type] || tile34.slope() == 1))
													{
														if (!tile28.active() && (!TileID.Sets.Platforms[tile43.type] || tile43.slope() != 2))
														{
															rectangle.X = 414;
														}
														else
														{
															rectangle.X = 342;
														}
													}
													else if (!tile28.active() && (!TileID.Sets.Platforms[tile43.type] || tile43.slope() != 2))
													{
														rectangle.X = 378;
													}
													else
													{
														rectangle.X = 144;
													}
												}
												else if (num38 == num && num31 == num)
												{
													if (tile21.slope() == 2 && tile28.slope() == 1)
													{
														rectangle.X = 252;
													}
													else if (tile21.slope() == 2)
													{
														rectangle.X = 216;
													}
													else if (tile28.slope() == 1)
													{
														rectangle.X = 234;
													}
													else
													{
														rectangle.X = 0;
													}
												}
												else if (num38 == num && num31 == -1)
												{
													if (tile21.slope() == 2)
													{
														rectangle.X = 270;
													}
													else
													{
														rectangle.X = 18;
													}
												}
												else if (num38 == -1 && num31 == num)
												{
													if (tile28.slope() == 1)
													{
														rectangle.X = 288;
													}
													else
													{
														rectangle.X = 36;
													}
												}
												else if (num38 != num && num31 == num)
												{
													rectangle.X = 54;
												}
												else if (num38 == num && num31 != num)
												{
													rectangle.X = 72;
												}
												else if (num38 != num && num38 != -1 && num31 == -1)
												{
													rectangle.X = 108;
												}
												else if (num38 == -1 && num31 != num && num31 != -1)
												{
													rectangle.X = 126;
												}
												else
												{
													rectangle.X = 90;
												}
												tile.frameX = (short)rectangle.X;
												if (Main.tile[i, j - 1] != null && Main.tileRope[Main.tile[i, j - 1].type])
												{
													TileFrame(i, j - 1);
												}
												if (Main.tile[i, j + 1] != null && Main.tileRope[Main.tile[i, j + 1].type])
												{
													TileFrame(i, j + 1);
												}
												break;
											}
											switch (num)
											{
											case 233:
											case 236:
											case 238:
												CheckJunglePlant(i, j, num);
												return;
											case 530:
												CheckOasisPlant(i, j);
												return;
											case 240:
											case 440:
												Check3x3Wall(i, j);
												return;
											case 245:
												Check2x3Wall(i, j);
												return;
											case 246:
												Check3x2Wall(i, j);
												return;
											case 241:
												Check4x3Wall(i, j);
												return;
											case 242:
												Check6x4Wall(i, j);
												return;
											case 464:
											case 466:
												Check5x4(i, j, num);
												return;
											case 334:
												CheckWeaponsRack(i, j);
												return;
											case 471:
												TEWeaponsRack.Framing_CheckTile(i, j);
												return;
											case 34:
											case 454:
												CheckChand(i, j, num);
												return;
											case 547:
											case 623:
												Check2x5(i, j, num);
												return;
											case 548:
											case 614:
												Check3x6(i, j, num);
												return;
											case 613:
												Check3x5(i, j, num);
												return;
											default:
											{
												if (num == 354 || num == 406 || num == 412 || num == 355 || num == 452 || num == 455 || num == 491 || num == 499 || num == 642)
												{
													break;
												}
												int num44 = num;
												if (num44 != 15 && !TileID.Sets.TreeSapling[num])
												{
													switch (num44)
													{
													case 216:
													case 338:
													case 390:
													case 493:
													case 497:
													case 590:
													case 595:
													case 615:
														break;
													default:
														if (num < 391 || num > 394)
														{
															switch (num)
															{
															case 36:
															case 135:
															case 141:
															case 144:
															case 210:
															case 239:
															case 428:
															case 593:
															case 624:
															case 650:
															case 656:
																Check1x1(i, j, num);
																return;
															case 476:
																CheckGolf1x1(i, j, num);
																return;
															case 494:
																CheckGolf1x1(i, j, num);
																return;
															case 419:
															case 420:
															case 423:
															case 424:
															case 429:
															case 445:
																CheckLogicTiles(i, j, num);
																return;
															case 16:
															case 18:
															case 29:
															case 103:
															case 134:
															case 462:
															case 649:
																Check2x1(i, j, (ushort)num);
																return;
															case 13:
															case 33:
															case 49:
															case 50:
															case 78:
															case 174:
															case 372:
															case 646:
																CheckOnTable1x1(i, j, num);
																return;
															default:
																if (TileID.Sets.BasicChest[num] && num < TileID.Count)
																{
																	CheckChest(i, j, num);
																	return;
																}
																switch (num)
																{
																case 128:
																	CheckMan(i, j);
																	return;
																case 269:
																	CheckWoman(i, j);
																	return;
																case 470:
																	TEDisplayDoll.Framing_CheckTile(i, j);
																	return;
																case 475:
																	TEHatRack.Framing_CheckTile(i, j);
																	return;
																case 597:
																	TETeleportationPylon.Framing_CheckTile(i, j);
																	return;
																case 27:
																	CheckSunflower(i, j);
																	return;
																case 28:
																case 653:
																	CheckPot(i, j, num);
																	return;
																case 171:
																	CheckXmasTree(i, j);
																	return;
																default:
																	if ((TileID.Sets.BasicChestFake[num] || num == 457) && num < TileID.Count)
																	{
																		break;
																	}
																	switch (num)
																	{
																	case 335:
																	case 411:
																	case 490:
																	case 564:
																	case 565:
																	case 594:
																		Check2x2(i, j, num);
																		return;
																	default:
																		if (num >= 316 && num <= 318)
																		{
																			break;
																		}
																		switch (num)
																		{
																		case 376:
																		case 443:
																		case 444:
																		case 485:
																			CheckSuper(i, j, num);
																			return;
																		case 91:
																			CheckBanner(i, j, (byte)num);
																			return;
																		case 35:
																		case 139:
																			CheckMB(i, j, (byte)num);
																			return;
																		case 386:
																		case 387:
																			CheckTrapDoor(i, j, num);
																			return;
																		case 388:
																		case 389:
																			CheckTallGate(i, j, num);
																			return;
																		case 92:
																		case 93:
																		case 453:
																			Check1xX(i, j, (short)num);
																			return;
																		case 104:
																		case 105:
																		case 207:
																		case 320:
																		case 337:
																		case 349:
																		case 356:
																		case 378:
																		case 410:
																		case 456:
																		case 465:
																		case 480:
																		case 489:
																		case 506:
																		case 509:
																		case 531:
																		case 545:
																		case 560:
																		case 591:
																		case 592:
																		case 657:
																		case 658:
																		case 663:
																			Check2xX(i, j, (ushort)num);
																			return;
																		case 101:
																		case 102:
																		case 463:
																		case 617:
																			Check3x4(i, j, num);
																			return;
																		case 42:
																		case 270:
																		case 271:
																		case 572:
																		case 581:
																		case 660:
																			Check1x2Top(i, j, (ushort)num);
																			return;
																		case 55:
																		case 85:
																		case 395:
																		case 425:
																		case 510:
																		case 511:
																		case 573:
																			CheckSign(i, j, (ushort)num);
																			return;
																		case 520:
																			CheckFoodPlatter(i, j, (ushort)num);
																			return;
																		case 209:
																			CheckCannon(i, j, num);
																			return;
																		case 79:
																		case 90:
																		case 487:
																			Check4x2(i, j, num);
																			return;
																		case 94:
																		case 95:
																		case 97:
																		case 98:
																		case 99:
																		case 100:
																		case 125:
																		case 126:
																		case 173:
																		case 282:
																		case 287:
																		case 319:
																		case 621:
																		case 622:
																			Check2x2(i, j, num);
																			return;
																		case 96:
																			Check2x2Style(i, j, num);
																			return;
																		case 81:
																		{
																			Tile tile5 = Main.tile[i, j - 1];
																			Tile tile13 = Main.tile[i, j + 1];
																			_ = Main.tile[i - 1, j];
																			_ = Main.tile[i + 1, j];
																			int num41 = -1;
																			int num42 = -1;
																			if (tile5 != null && tile5.active())
																			{
																				num42 = tile5.type;
																			}
																			if (tile13 != null && tile13.active())
																			{
																				num41 = tile13.type;
																			}
																			if (num42 != -1)
																			{
																				KillTile(i, j);
																			}
																			else if (num41 < 0 || !Main.tileSolid[num41] || (tile13 != null && (tile13.halfBrick() || tile13.topSlope())))
																			{
																				KillTile(i, j);
																			}
																			return;
																		}
																		default:
																			if (Main.tileAlch[num])
																			{
																				CheckAlch(i, j);
																				return;
																			}
																			switch (num)
																			{
																			case 72:
																			{
																				Tile tile4 = Main.tile[i, j - 1];
																				Tile tile12 = Main.tile[i, j + 1];
																				int num39 = -1;
																				int num40 = -1;
																				if (tile4 != null && tile4.active())
																				{
																					num40 = tile4.type;
																				}
																				if (tile12 != null && tile12.active())
																				{
																					num39 = tile12.type;
																				}
																				if (num39 != num && num39 != 70)
																				{
																					KillTile(i, j);
																				}
																				else if (num40 != num && tile.frameX == 0)
																				{
																					tile.frameNumber((byte)genRand.Next(3));
																					if (tile.frameNumber() == 0)
																					{
																						tile.frameX = 18;
																						tile.frameY = 0;
																					}
																					if (tile.frameNumber() == 1)
																					{
																						tile.frameX = 18;
																						tile.frameY = 18;
																					}
																					if (tile.frameNumber() == 2)
																					{
																						tile.frameX = 18;
																						tile.frameY = 36;
																					}
																				}
																				break;
																			}
																			case 5:
																				CheckTree(i, j);
																				break;
																			case 583:
																			case 584:
																			case 585:
																			case 586:
																			case 587:
																			case 588:
																			case 589:
																				CheckTreeWithSettings(i, j, new CheckTreeSettings
																				{
																					IsGroundValid = GemTreeGroundTest
																				});
																				break;
																			case 596:
																				CheckTreeWithSettings(i, j, new CheckTreeSettings
																				{
																					IsGroundValid = VanityTreeGroundTest
																				});
																				break;
																			case 616:
																				CheckTreeWithSettings(i, j, new CheckTreeSettings
																				{
																					IsGroundValid = VanityTreeGroundTest
																				});
																				break;
																			case 634:
																				CheckTreeWithSettings(i, j, new CheckTreeSettings
																				{
																					IsGroundValid = AshTreeGroundTest
																				});
																				break;
																			case 323:
																				CheckPalmTree(i, j);
																				break;
																			case 567:
																				CheckGnome(i, j);
																				break;
																			case 630:
																			case 631:
																				CheckStinkbugBlocker(i, j);
																				break;
																			}
																			TileLoader.CheckModTile(i, j, num);
																			return;
																		case 172:
																		case 360:
																		case 505:
																		case 521:
																		case 522:
																		case 523:
																		case 524:
																		case 525:
																		case 526:
																		case 527:
																		case 543:
																		case 568:
																		case 569:
																		case 570:
																		case 580:
																		case 598:
																		case 620:
																		case 652:
																		case 654:
																			break;
																		}
																		break;
																	case 132:
																	case 138:
																	case 142:
																	case 143:
																	case 288:
																	case 289:
																	case 290:
																	case 291:
																	case 292:
																	case 293:
																	case 294:
																	case 295:
																	case 484:
																	case 664:
																	case 665:
																		break;
																	}
																	Check2x2(i, j, num);
																	return;
																case 254:
																	break;
																}
																Check2x2Style(i, j, num);
																return;
															case 405:
															case 486:
															case 488:
															case 532:
															case 533:
															case 544:
															case 552:
															case 555:
															case 556:
															case 582:
															case 619:
															case 629:
															case 647:
															case 648:
															case 651:
																break;
															}
														}
														goto case 14;
													case 14:
													case 17:
													case 26:
													case 77:
													case 86:
													case 87:
													case 88:
													case 89:
													case 114:
													case 133:
													case 186:
													case 187:
													case 215:
													case 217:
													case 218:
													case 237:
													case 244:
													case 285:
													case 286:
													case 298:
													case 299:
													case 310:
													case 339:
													case 361:
													case 362:
													case 363:
													case 364:
													case 377:
													case 469:
													case 538:
														Check3x2(i, j, (ushort)num);
														return;
													}
												}
												Check1x2(i, j, (ushort)num);
												return;
											}
											case 106:
											case 212:
											case 219:
											case 220:
											case 228:
											case 231:
											case 243:
											case 247:
											case 283:
											case 300:
											case 301:
											case 302:
											case 303:
											case 304:
											case 305:
											case 306:
											case 307:
											case 308:
												break;
											}
											Check3x3(i, j, (ushort)num);
											break;
										}
										goto case 275;
									case 275:
									case 276:
									case 277:
									case 278:
									case 279:
									case 280:
									case 281:
										Check6x3(i, j, num);
										break;
									}
									break;
								}
								goto case 373;
							case 373:
							case 374:
							case 375:
							{
								Tile tile8 = Main.tile[i, j - 1];
								if (tile8 == null || !tile8.active() || tile8.bottomSlope() || !Main.tileSolid[tile8.type] || Main.tileSolidTop[tile8.type])
								{
									KillTile(i, j);
								}
								break;
							}
							}
						}
						else
						{
							CheckTorch(i, j);
						}
						return;
					}
					if ((num >= 255 && num <= 268) || num == 385 || (uint)(num - 446) <= 2u)
					{
						Framing.SelfFrame8Way(i, j, tile, resetFrame);
						return;
					}
					Tile tile10 = Main.tile[i, j - 1];
					Tile tile19 = Main.tile[i, j + 1];
					Tile tile26 = Main.tile[i - 1, j];
					Tile tile33 = Main.tile[i + 1, j];
					Tile tile36 = Main.tile[i - 1, j + 1];
					Tile tile39 = Main.tile[i + 1, j + 1];
					Tile tile42 = Main.tile[i - 1, j - 1];
					Tile tile45 = Main.tile[i + 1, j - 1];
					int upLeft = -1;
					int up = -1;
					int upRight = -1;
					int left = -1;
					int right = -1;
					int downLeft = -1;
					int down = -1;
					int downRight = -1;
					if (tile26 != null && tile26.active())
					{
						left = (Main.tileStone[tile26.type] ? 1 : tile26.type);
						if (tile26.slope() == 1 || tile26.slope() == 3)
						{
							left = -1;
						}
					}
					if (tile33 != null && tile33.active())
					{
						right = (Main.tileStone[tile33.type] ? 1 : tile33.type);
						if (tile33.slope() == 2 || tile33.slope() == 4)
						{
							right = -1;
						}
					}
					if (tile10 != null && tile10.active())
					{
						up = (Main.tileStone[tile10.type] ? 1 : tile10.type);
						if (tile10.slope() == 3 || tile10.slope() == 4)
						{
							up = -1;
						}
					}
					if (tile19 != null && tile19.active())
					{
						down = (Main.tileStone[tile19.type] ? 1 : tile19.type);
						if (tile19.slope() == 1 || tile19.slope() == 2)
						{
							down = -1;
						}
					}
					if (tile42 != null && tile42.active())
					{
						upLeft = (Main.tileStone[tile42.type] ? 1 : tile42.type);
					}
					if (tile45 != null && tile45.active())
					{
						upRight = (Main.tileStone[tile45.type] ? 1 : tile45.type);
					}
					if (tile36 != null && tile36.active())
					{
						downLeft = (Main.tileStone[tile36.type] ? 1 : tile36.type);
					}
					if (tile39 != null && tile39.active())
					{
						downRight = (Main.tileStone[tile39.type] ? 1 : tile39.type);
					}
					if (tile.slope() == 2)
					{
						up = -1;
						left = -1;
					}
					if (tile.slope() == 1)
					{
						up = -1;
						right = -1;
					}
					if (tile.slope() == 4)
					{
						down = -1;
						left = -1;
					}
					if (tile.slope() == 3)
					{
						down = -1;
						right = -1;
					}
					if (num == 668)
					{
						num = 0;
					}
					TileMergeAttempt(0, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					num43 = num;
					if (TileID.Sets.Snow[num])
					{
						TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Ices, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					}
					else if (!TileID.Sets.Ices[num])
					{
						if (num43 == 162)
						{
							TileMergeAttempt(num, Main.tileBrick, TileID.Sets.IcesSnow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						}
						else if (Main.tileBrick[num])
						{
							int num44 = num;
							if (!TileID.Sets.GrassSpecial[num])
							{
								if (num44 == 633)
								{
									TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Ash, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
								}
								else
								{
									TileMergeAttempt(num, Main.tileBrick, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
								}
							}
							else
							{
								TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
							}
						}
						else if (Main.tilePile[num])
						{
							TileMergeAttempt(num, Main.tilePile, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						}
					}
					else
					{
						TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Snow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					}
					if ((TileID.Sets.Stone[num] || Main.tileMoss[num]) && down == 165)
					{
						if (tile19 != null && tile19.frameY == 72)
						{
							down = num;
						}
						else if (tile19 != null && tile19.frameY == 0)
						{
							down = num;
						}
					}
					if ((TileID.Sets.Stone[num] || Main.tileMoss[num]) && up == 165)
					{
						if (tile10 != null && tile10.frameY == 90)
						{
							up = num;
						}
						else if (tile10 != null && tile10.frameY == 54)
						{
							up = num;
						}
					}
					if (num == 225)
					{
						if (down == 165)
						{
							down = num;
						}
						if (up == 165)
						{
							up = num;
						}
					}
					if ((TileID.Sets.Ices[num] || num == 147) && down == 165)
					{
						down = num;
					}
					if ((tile.slope() == 1 || tile.slope() == 2) && down > -1 && !TileID.Sets.Platforms[down])
					{
						down = num;
					}
					if (up > -1 && tile10 != null && (tile10.slope() == 1 || tile10.slope() == 2) && !TileID.Sets.Platforms[up])
					{
						up = num;
					}
					if ((tile.slope() == 3 || tile.slope() == 4) && up > -1 && !TileID.Sets.Platforms[up])
					{
						up = num;
					}
					if (down > -1 && tile19 != null && (tile19.slope() == 3 || tile19.slope() == 4) && !TileID.Sets.Platforms[down])
					{
						down = num;
					}
					if (num == 124)
					{
						if (up > -1 && Main.tileSolid[up] && !TileID.Sets.Platforms[up])
						{
							up = num;
						}
						if (down > -1 && Main.tileSolid[down] && !TileID.Sets.Platforms[down])
						{
							down = num;
						}
					}
					if (up > -1 && tile10 != null && tile10.halfBrick() && !TileID.Sets.Platforms[up])
					{
						up = num;
					}
					if (left > -1 && tile26 != null && tile26.halfBrick())
					{
						if (tile.halfBrick())
						{
							left = num;
						}
						else if (tile26.type != num)
						{
							left = -1;
						}
					}
					if (right > -1 && tile33 != null && tile33.halfBrick())
					{
						if (tile.halfBrick())
						{
							right = num;
						}
						else if (tile33.type != num)
						{
							right = -1;
						}
					}
					if (tile.halfBrick())
					{
						if (left != num)
						{
							left = -1;
						}
						if (right != num)
						{
							right = -1;
						}
						up = -1;
					}
					if (tile19 != null && tile19.halfBrick())
					{
						down = -1;
					}
					if (!Main.tileSolid[num])
					{
						switch (num)
						{
						case 49:
							CheckOnTable1x1(i, j, (byte)num);
							return;
						case 80:
							CactusFrame(i, j);
							return;
						}
					}
					mergeUp = false;
					mergeDown = false;
					mergeLeft = false;
					mergeRight = false;
					int num20 = 0;
					if (resetFrame)
					{
						num20 = genRand.Next(0, 3);
						tile.frameNumber((byte)num20);
					}
					else
					{
						num20 = tile.frameNumber();
					}
					if (Main.tileLargeFrames[num] == 1)
					{
						int num21 = j % 4;
						int num22 = i % 3;
						num20 = (new int[4, 3]
						{
							{ 2, 4, 2 },
							{ 1, 3, 1 },
							{ 2, 2, 4 },
							{ 1, 1, 3 }
						})[num21, num22] - 1;
					}
					if (Main.tileLargeFrames[num] == 2)
					{
						int num45 = i % 2;
						int num24 = j % 2;
						num20 = num45 + num24 * 2;
					}
					if (!Main.tileRope[num] && TileID.Sets.BlockMergesWithMergeAllBlock[num])
					{
						TileMergeAttempt(num, Main.tileBlendAll, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					}
					if (Main.tileBlendAll[num])
					{
						TileMergeAttempt(num, TileID.Sets.BlockMergesWithMergeAllBlock, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					}
					if (TileID.Sets.ForcedDirtMerging[num])
					{
						TileMergeAttempt(num, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					}
					if (TileID.Sets.Dirt[num])
					{
						if (up > -1 && Main.tileMergeDirt[up])
						{
							TileFrame(i, j - 1);
							if (mergeDown)
							{
								up = num;
							}
						}
						else if (up >= 0 && TileID.Sets.Snow[up])
						{
							TileFrame(i, j - 1);
							if (mergeDown)
							{
								up = num;
							}
						}
						if (down > -1 && Main.tileMergeDirt[down])
						{
							TileFrame(i, j + 1);
							if (mergeUp)
							{
								down = num;
							}
						}
						else if (down >= 0 && TileID.Sets.Snow[down])
						{
							TileFrame(i, j + 1);
							if (mergeUp)
							{
								down = num;
							}
						}
						if (left > -1 && Main.tileMergeDirt[left])
						{
							TileFrame(i - 1, j);
							if (mergeRight)
							{
								left = num;
							}
						}
						else if (left >= 0 && TileID.Sets.Snow[left])
						{
							TileFrame(i - 1, j);
							if (mergeRight)
							{
								left = num;
							}
						}
						if (right > -1 && Main.tileMergeDirt[right])
						{
							TileFrame(i + 1, j);
							if (mergeLeft)
							{
								right = num;
							}
						}
						else if (right == 147)
						{
							TileFrame(i + 1, j);
							if (mergeLeft)
							{
								right = num;
							}
						}
						bool[] mergesWithDirtInASpecialWay = TileID.Sets.Conversion.MergesWithDirtInASpecialWay;
						if (up > -1 && mergesWithDirtInASpecialWay[up])
						{
							up = num;
						}
						if (down > -1 && mergesWithDirtInASpecialWay[down])
						{
							down = num;
						}
						if (left > -1 && mergesWithDirtInASpecialWay[left])
						{
							left = num;
						}
						if (right > -1 && mergesWithDirtInASpecialWay[right])
						{
							right = num;
						}
						if (upLeft > -1 && Main.tileMergeDirt[upLeft])
						{
							upLeft = num;
						}
						else if (upLeft > -1 && mergesWithDirtInASpecialWay[upLeft])
						{
							upLeft = num;
						}
						if (upRight > -1 && Main.tileMergeDirt[upRight])
						{
							upRight = num;
						}
						else if (upRight > -1 && mergesWithDirtInASpecialWay[upRight])
						{
							upRight = num;
						}
						if (downLeft > -1 && Main.tileMergeDirt[downLeft])
						{
							downLeft = num;
						}
						else if (downLeft > -1 && mergesWithDirtInASpecialWay[downLeft])
						{
							downLeft = num;
						}
						if (downRight > -1 && Main.tileMergeDirt[downRight])
						{
							downRight = num;
						}
						else if (downRight > -1 && mergesWithDirtInASpecialWay[downRight])
						{
							downRight = num;
						}
						TileMergeAttempt(0, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttempt(-2, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttempt(0, 191, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						if (up > -1 && TileID.Sets.ForcedDirtMerging[up])
						{
							up = num;
						}
						if (down > -1 && TileID.Sets.ForcedDirtMerging[down])
						{
							down = num;
						}
						if (left > -1 && TileID.Sets.ForcedDirtMerging[left])
						{
							left = num;
						}
						if (right > -1 && TileID.Sets.ForcedDirtMerging[right])
						{
							right = num;
						}
						if (upLeft > -1 && TileID.Sets.ForcedDirtMerging[upLeft])
						{
							upLeft = num;
						}
						if (upRight > -1 && TileID.Sets.ForcedDirtMerging[upRight])
						{
							upRight = num;
						}
						if (downLeft > -1 && TileID.Sets.ForcedDirtMerging[downLeft])
						{
							downLeft = num;
						}
						if (downRight > -1 && TileID.Sets.ForcedDirtMerging[downRight])
						{
							downRight = num;
						}
					}
					else if (Main.tileRope[num])
					{
						if (num != 504 && up != num && IsRope(i, j - 1))
						{
							up = num;
						}
						if (down != num && IsRope(i, j + 1))
						{
							down = num;
						}
						if (num != 504 && up > -1 && Main.tileSolid[up] && !Main.tileSolidTop[up])
						{
							up = num;
						}
						if (down > -1 && Main.tileSolid[down])
						{
							down = num;
						}
						if (num != 504 && up != num)
						{
							if (left > -1 && Main.tileSolid[left])
							{
								left = num;
							}
							if (right > -1 && Main.tileSolid[right])
							{
								right = num;
							}
						}
					}
					else
					{
						switch (num)
						{
						case 53:
							TileMergeAttemptFrametest(i, j, num, 397, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
							TileMergeAttemptFrametest(i, j, num, 396, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
							break;
						case 234:
							TileMergeAttemptFrametest(i, j, num, 399, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
							TileMergeAttemptFrametest(i, j, num, 401, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
							break;
						case 112:
							TileMergeAttemptFrametest(i, j, num, 398, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
							TileMergeAttemptFrametest(i, j, num, 400, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
							break;
						case 116:
							TileMergeAttemptFrametest(i, j, num, 402, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
							TileMergeAttemptFrametest(i, j, num, 403, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
							break;
						}
					}
					if (Main.tileMergeDirt[num])
					{
						TileMergeAttempt(-2, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						if (num == 1)
						{
							if ((double)j > Main.rockLayer)
							{
								TileMergeAttemptFrametest(i, j, num, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
							}
							TileMergeAttemptFrametest(i, j, num, TileID.Sets.Ash, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						}
					}
					else
					{
						num43 = num;
						if (!TileID.Sets.HellSpecial[num])
						{
							if (num43 == 57)
							{
								TileMergeAttempt(-2, 1, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
								TileMergeAttempt(num, 633, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
								TileMergeAttemptFrametest(i, j, num, TileID.Sets.HellSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
							}
							else if (!TileID.Sets.Mud[num])
							{
								switch (num43)
								{
								case 211:
									TileMergeAttempt(59, 60, ref up, ref down, ref left, ref right);
									TileMergeAttempt(-2, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									break;
								case 225:
								case 226:
									TileMergeAttempt(-2, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									break;
								case 60:
									TileMergeAttempt(59, 211, ref up, ref down, ref left, ref right);
									break;
								case 189:
									TileMergeAttemptFrametest(i, j, num, TileID.Sets.MergesWithClouds, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									break;
								case 196:
									TileMergeAttempt(-2, 189, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									TileMergeAttempt(num, 460, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									break;
								case 460:
									TileMergeAttempt(-2, 189, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									TileMergeAttempt(num, 196, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									break;
								default:
									if (TileID.Sets.Snow[num])
									{
										TileMergeAttemptFrametest(i, j, num, TileID.Sets.IcesSlush, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									}
									else if (!TileID.Sets.IcesSlush[num])
									{
										switch (num43)
										{
										case 162:
											TileMergeAttempt(-2, TileID.Sets.IcesSnow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											break;
										case 32:
											if (down == 23)
											{
												down = num;
											}
											break;
										case 352:
											if (down == 199)
											{
												down = num;
											}
											break;
										case 69:
											if (down == 60)
											{
												down = num;
											}
											break;
										case 655:
											if (down == 60)
											{
												down = num;
											}
											break;
										case 51:
											TileMergeAttempt(num, TileID.Sets.AllTiles, Main.tileNoAttach, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											break;
										case 192:
											TileMergeAttemptFrametest(i, j, num, 191, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											break;
										case 191:
											TileMergeAttempt(-2, 192, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											TileMergeAttempt(num, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											break;
										case 384:
											TileMergeAttemptFrametest(i, j, num, 383, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											break;
										case 383:
											TileMergeAttempt(-2, 384, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											TileMergeAttempt(num, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											break;
										case 407:
											TileMergeAttempt(-2, 404, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											break;
										case 404:
											TileMergeAttempt(-2, 396, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											TileMergeAttemptFrametest(i, j, num, 407, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											break;
										case 397:
											TileMergeAttempt(-2, 53, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											TileMergeAttemptFrametest(i, j, num, 396, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											break;
										case 396:
											TileMergeAttempt(-2, 397, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											TileMergeAttempt(-2, 53, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											TileMergeAttemptFrametest(i, j, num, 404, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											break;
										case 398:
											TileMergeAttempt(-2, 112, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											TileMergeAttemptFrametest(i, j, num, 400, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											break;
										case 400:
											TileMergeAttempt(-2, 398, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											TileMergeAttempt(-2, 112, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											break;
										case 399:
											TileMergeAttempt(-2, 234, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											TileMergeAttemptFrametest(i, j, num, 401, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											break;
										case 401:
											TileMergeAttempt(-2, 399, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											TileMergeAttempt(-2, 234, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											break;
										case 402:
											TileMergeAttempt(-2, 116, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											TileMergeAttemptFrametest(i, j, num, 403, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											break;
										case 403:
											TileMergeAttempt(-2, 402, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											TileMergeAttempt(-2, 116, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											break;
										}
									}
									else
									{
										TileMergeAttempt(-2, 147, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									}
									break;
								}
							}
							else
							{
								if ((double)j > Main.rockLayer)
								{
									TileMergeAttempt(-2, 1, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
								}
								TileMergeAttempt(num, TileID.Sets.GrassSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
								TileMergeAttemptFrametest(i, j, num, TileID.Sets.JungleSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
								if ((double)j < Main.rockLayer)
								{
									TileMergeAttemptFrametest(i, j, num, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
								}
								else
								{
									TileMergeAttempt(num, TileID.Sets.Dirt, ref up, ref down, ref left, ref right);
								}
							}
						}
						else
						{
							TileMergeAttempt(-2, TileID.Sets.Ash, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						}
					}
					if (num == 0)
					{
						TileMergeAttempt(num, Main.tileMoss, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						TileMergeAttempt(num, TileID.Sets.tileMossBrick, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					}
					else if (Main.tileMoss[num] || TileID.Sets.tileMossBrick[num])
					{
						TileMergeAttempt(num, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					}
					else if (Main.tileStone[num] || num == 1)
					{
						TileMergeAttempt(num, Main.tileMoss, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					}
					else if (num == 38)
					{
						TileMergeAttempt(num, TileID.Sets.tileMossBrick, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					}
					if (TileID.Sets.Conversion.Grass[num])
					{
						TileMergeAttempt(num, TileID.Sets.Ore, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					}
					else if (TileID.Sets.Ore[num])
					{
						TileMergeAttempt(num, TileID.Sets.Conversion.Grass, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					}
					if (num >= 0 && TileID.Sets.Mud[num])
					{
						TileMergeAttempt(num, TileID.Sets.OreMergesWithMud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					}
					else if (TileID.Sets.OreMergesWithMud[num])
					{
						TileMergeAttempt(num, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					}
					bool flag = false;
					TileMergeCullCache tileMergeCullCache = default(TileMergeCullCache);
					if (!Main.ShouldShowInvisibleWalls())
					{
						bool flag10 = tile.invisibleBlock();
						tileMergeCullCache.CullTop |= tile10 != null && tile10.invisibleBlock() != flag10;
						tileMergeCullCache.CullBottom |= tile19 != null && tile19.invisibleBlock() != flag10;
						tileMergeCullCache.CullLeft |= tile26 != null && tile26.invisibleBlock() != flag10;
						tileMergeCullCache.CullRight |= tile33 != null && tile33.invisibleBlock() != flag10;
						tileMergeCullCache.CullTopLeft |= tile42 != null && tile42.invisibleBlock() != flag10;
						tileMergeCullCache.CullTopRight |= tile45 != null && tile45.invisibleBlock() != flag10;
						tileMergeCullCache.CullBottomLeft |= tile36 != null && tile36.invisibleBlock() != flag10;
						tileMergeCullCache.CullBottomRight |= tile39 != null && tile39.invisibleBlock() != flag10;
					}
					if (TileID.Sets.Grass[num] || TileID.Sets.GrassSpecial[num] || Main.tileMoss[num] || TileID.Sets.NeedsGrassFraming[num] || TileID.Sets.tileMossBrick[num])
					{
						flag = true;
						TileMergeAttemptWeird(num, -1, Main.tileSolid, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						int num25 = TileID.Sets.NeedsGrassFramingDirt[num];
						if (TileID.Sets.GrassSpecial[num])
						{
							num25 = 59;
						}
						else if (Main.tileMoss[num])
						{
							num25 = 1;
						}
						else if (TileID.Sets.tileMossBrick[num])
						{
							num25 = 38;
						}
						else
						{
							switch (num)
							{
							case 2:
							case 477:
								TileMergeAttempt(num25, 23, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
								break;
							case 23:
								TileMergeAttempt(num25, 2, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
								break;
							}
						}
						tileMergeCullCache.Cull(ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						if (up != num && up != num25 && (down == num || down == num25))
						{
							if (left == num25 && right == num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 0;
									rectangle.Y = 198;
									break;
								case 1:
									rectangle.X = 18;
									rectangle.Y = 198;
									break;
								default:
									rectangle.X = 36;
									rectangle.Y = 198;
									break;
								}
							}
							else if (left == num && right == num25)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 54;
									rectangle.Y = 198;
									break;
								case 1:
									rectangle.X = 72;
									rectangle.Y = 198;
									break;
								default:
									rectangle.X = 90;
									rectangle.Y = 198;
									break;
								}
							}
						}
						else if (down != num && down != num25 && (up == num || up == num25))
						{
							if (left == num25 && right == num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 0;
									rectangle.Y = 216;
									break;
								case 1:
									rectangle.X = 18;
									rectangle.Y = 216;
									break;
								default:
									rectangle.X = 36;
									rectangle.Y = 216;
									break;
								}
							}
							else if (left == num && right == num25)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 54;
									rectangle.Y = 216;
									break;
								case 1:
									rectangle.X = 72;
									rectangle.Y = 216;
									break;
								default:
									rectangle.X = 90;
									rectangle.Y = 216;
									break;
								}
							}
						}
						else if (left != num && left != num25 && (right == num || right == num25))
						{
							if (up == num25 && down == num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 72;
									rectangle.Y = 144;
									break;
								case 1:
									rectangle.X = 72;
									rectangle.Y = 162;
									break;
								default:
									rectangle.X = 72;
									rectangle.Y = 180;
									break;
								}
							}
							else if (down == num && up == num25)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 72;
									rectangle.Y = 90;
									break;
								case 1:
									rectangle.X = 72;
									rectangle.Y = 108;
									break;
								default:
									rectangle.X = 72;
									rectangle.Y = 126;
									break;
								}
							}
						}
						else if (right != num && right != num25 && (left == num || left == num25))
						{
							if (up == num25 && down == num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 90;
									rectangle.Y = 144;
									break;
								case 1:
									rectangle.X = 90;
									rectangle.Y = 162;
									break;
								default:
									rectangle.X = 90;
									rectangle.Y = 180;
									break;
								}
							}
							else if (down == num && right == up)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 90;
									rectangle.Y = 90;
									break;
								case 1:
									rectangle.X = 90;
									rectangle.Y = 108;
									break;
								default:
									rectangle.X = 90;
									rectangle.Y = 126;
									break;
								}
							}
						}
						else if (up == num && down == num && left == num && right == num)
						{
							if (upLeft != num && upRight != num && downLeft != num && downRight != num)
							{
								if (downRight == num25)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 108;
										rectangle.Y = 324;
										break;
									case 1:
										rectangle.X = 126;
										rectangle.Y = 324;
										break;
									default:
										rectangle.X = 144;
										rectangle.Y = 324;
										break;
									}
								}
								else if (upRight == num25)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 108;
										rectangle.Y = 342;
										break;
									case 1:
										rectangle.X = 126;
										rectangle.Y = 342;
										break;
									default:
										rectangle.X = 144;
										rectangle.Y = 342;
										break;
									}
								}
								else if (downLeft == num25)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 108;
										rectangle.Y = 360;
										break;
									case 1:
										rectangle.X = 126;
										rectangle.Y = 360;
										break;
									default:
										rectangle.X = 144;
										rectangle.Y = 360;
										break;
									}
								}
								else if (upLeft == num25)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 108;
										rectangle.Y = 378;
										break;
									case 1:
										rectangle.X = 126;
										rectangle.Y = 378;
										break;
									default:
										rectangle.X = 144;
										rectangle.Y = 378;
										break;
									}
								}
								else
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 144;
										rectangle.Y = 234;
										break;
									case 1:
										rectangle.X = 198;
										rectangle.Y = 234;
										break;
									default:
										rectangle.X = 252;
										rectangle.Y = 234;
										break;
									}
								}
							}
							else if (upLeft != num && downRight != num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 36;
									rectangle.Y = 306;
									break;
								case 1:
									rectangle.X = 54;
									rectangle.Y = 306;
									break;
								default:
									rectangle.X = 72;
									rectangle.Y = 306;
									break;
								}
							}
							else if (upRight != num && downLeft != num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 90;
									rectangle.Y = 306;
									break;
								case 1:
									rectangle.X = 108;
									rectangle.Y = 306;
									break;
								default:
									rectangle.X = 126;
									rectangle.Y = 306;
									break;
								}
							}
							else if (upLeft != num && upRight == num && downLeft == num && downRight == num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 54;
									rectangle.Y = 108;
									break;
								case 1:
									rectangle.X = 54;
									rectangle.Y = 144;
									break;
								default:
									rectangle.X = 54;
									rectangle.Y = 180;
									break;
								}
							}
							else if (upLeft == num && upRight != num && downLeft == num && downRight == num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 36;
									rectangle.Y = 108;
									break;
								case 1:
									rectangle.X = 36;
									rectangle.Y = 144;
									break;
								default:
									rectangle.X = 36;
									rectangle.Y = 180;
									break;
								}
							}
							else if (upLeft == num && upRight == num && downLeft != num && downRight == num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 54;
									rectangle.Y = 90;
									break;
								case 1:
									rectangle.X = 54;
									rectangle.Y = 126;
									break;
								default:
									rectangle.X = 54;
									rectangle.Y = 162;
									break;
								}
							}
							else if (upLeft == num && upRight == num && downLeft == num && downRight != num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 36;
									rectangle.Y = 90;
									break;
								case 1:
									rectangle.X = 36;
									rectangle.Y = 126;
									break;
								default:
									rectangle.X = 36;
									rectangle.Y = 162;
									break;
								}
							}
						}
						else if (up == num && down == num25 && left == num && right == num && upLeft == -1 && upRight == -1)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 108;
								rectangle.Y = 18;
								break;
							case 1:
								rectangle.X = 126;
								rectangle.Y = 18;
								break;
							default:
								rectangle.X = 144;
								rectangle.Y = 18;
								break;
							}
						}
						else if (up == num25 && down == num && left == num && right == num && downLeft == -1 && downRight == -1)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 108;
								rectangle.Y = 36;
								break;
							case 1:
								rectangle.X = 126;
								rectangle.Y = 36;
								break;
							default:
								rectangle.X = 144;
								rectangle.Y = 36;
								break;
							}
						}
						else if (up == num && down == num && left == num25 && right == num && upRight == -1 && downRight == -1)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 198;
								rectangle.Y = 0;
								break;
							case 1:
								rectangle.X = 198;
								rectangle.Y = 18;
								break;
							default:
								rectangle.X = 198;
								rectangle.Y = 36;
								break;
							}
						}
						else if (up == num && down == num && left == num && right == num25 && upLeft == -1 && downLeft == -1)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 180;
								rectangle.Y = 0;
								break;
							case 1:
								rectangle.X = 180;
								rectangle.Y = 18;
								break;
							default:
								rectangle.X = 180;
								rectangle.Y = 36;
								break;
							}
						}
						else if (up == num && down == num25 && left == num && right == num)
						{
							if (upRight != -1)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 54;
									rectangle.Y = 108;
									break;
								case 1:
									rectangle.X = 54;
									rectangle.Y = 144;
									break;
								default:
									rectangle.X = 54;
									rectangle.Y = 180;
									break;
								}
							}
							else if (upLeft != -1)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 36;
									rectangle.Y = 108;
									break;
								case 1:
									rectangle.X = 36;
									rectangle.Y = 144;
									break;
								default:
									rectangle.X = 36;
									rectangle.Y = 180;
									break;
								}
							}
						}
						else if (up == num25 && down == num && left == num && right == num)
						{
							if (downRight != -1)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 54;
									rectangle.Y = 90;
									break;
								case 1:
									rectangle.X = 54;
									rectangle.Y = 126;
									break;
								default:
									rectangle.X = 54;
									rectangle.Y = 162;
									break;
								}
							}
							else if (downLeft != -1)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 36;
									rectangle.Y = 90;
									break;
								case 1:
									rectangle.X = 36;
									rectangle.Y = 126;
									break;
								default:
									rectangle.X = 36;
									rectangle.Y = 162;
									break;
								}
							}
						}
						else if (up == num && down == num && left == num && right == num25)
						{
							if (upLeft != -1)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 54;
									rectangle.Y = 90;
									break;
								case 1:
									rectangle.X = 54;
									rectangle.Y = 126;
									break;
								default:
									rectangle.X = 54;
									rectangle.Y = 162;
									break;
								}
							}
							else if (downLeft != -1)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 54;
									rectangle.Y = 108;
									break;
								case 1:
									rectangle.X = 54;
									rectangle.Y = 144;
									break;
								default:
									rectangle.X = 54;
									rectangle.Y = 180;
									break;
								}
							}
						}
						else if (up == num && down == num && left == num25 && right == num)
						{
							if (upRight != -1)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 36;
									rectangle.Y = 90;
									break;
								case 1:
									rectangle.X = 36;
									rectangle.Y = 126;
									break;
								default:
									rectangle.X = 36;
									rectangle.Y = 162;
									break;
								}
							}
							else if (downRight != -1)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 36;
									rectangle.Y = 108;
									break;
								case 1:
									rectangle.X = 36;
									rectangle.Y = 144;
									break;
								default:
									rectangle.X = 36;
									rectangle.Y = 180;
									break;
								}
							}
						}
						else if ((up == num25 && down == num && left == num && right == num) || (up == num && down == num25 && left == num && right == num) || (up == num && down == num && left == num25 && right == num) || (up == num && down == num && left == num && right == num25))
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 18;
								rectangle.Y = 18;
								break;
							case 1:
								rectangle.X = 36;
								rectangle.Y = 18;
								break;
							default:
								rectangle.X = 54;
								rectangle.Y = 18;
								break;
							}
						}
						if ((up == num || up == num25) && (down == num || down == num25) && (left == num || left == num25) && (right == num || right == num25))
						{
							if (upLeft != num && upLeft != num25 && (upRight == num || upRight == num25) && (downLeft == num || downLeft == num25) && (downRight == num || downRight == num25))
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 54;
									rectangle.Y = 108;
									break;
								case 1:
									rectangle.X = 54;
									rectangle.Y = 144;
									break;
								default:
									rectangle.X = 54;
									rectangle.Y = 180;
									break;
								}
							}
							else if (upRight != num && upRight != num25 && (upLeft == num || upLeft == num25) && (downLeft == num || downLeft == num25) && (downRight == num || downRight == num25))
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 36;
									rectangle.Y = 108;
									break;
								case 1:
									rectangle.X = 36;
									rectangle.Y = 144;
									break;
								default:
									rectangle.X = 36;
									rectangle.Y = 180;
									break;
								}
							}
							else if (downLeft != num && downLeft != num25 && (upLeft == num || upLeft == num25) && (upRight == num || upRight == num25) && (downRight == num || downRight == num25))
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 54;
									rectangle.Y = 90;
									break;
								case 1:
									rectangle.X = 54;
									rectangle.Y = 126;
									break;
								default:
									rectangle.X = 54;
									rectangle.Y = 162;
									break;
								}
							}
							else if (downRight != num && downRight != num25 && (upLeft == num || upLeft == num25) && (downLeft == num || downLeft == num25) && (upRight == num || upRight == num25))
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 36;
									rectangle.Y = 90;
									break;
								case 1:
									rectangle.X = 36;
									rectangle.Y = 126;
									break;
								default:
									rectangle.X = 36;
									rectangle.Y = 162;
									break;
								}
							}
						}
						if (up != num25 && up != num && down == num && left != num25 && left != num && right == num && downRight != num25 && downRight != num)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 90;
								rectangle.Y = 270;
								break;
							case 1:
								rectangle.X = 108;
								rectangle.Y = 270;
								break;
							default:
								rectangle.X = 126;
								rectangle.Y = 270;
								break;
							}
						}
						else if (up != num25 && up != num && down == num && left == num && right != num25 && right != num && downLeft != num25 && downLeft != num)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 144;
								rectangle.Y = 270;
								break;
							case 1:
								rectangle.X = 162;
								rectangle.Y = 270;
								break;
							default:
								rectangle.X = 180;
								rectangle.Y = 270;
								break;
							}
						}
						else if (down != num25 && down != num && up == num && left != num25 && left != num && right == num && upRight != num25 && upRight != num)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 90;
								rectangle.Y = 288;
								break;
							case 1:
								rectangle.X = 108;
								rectangle.Y = 288;
								break;
							default:
								rectangle.X = 126;
								rectangle.Y = 288;
								break;
							}
						}
						else if (down != num25 && down != num && up == num && left == num && right != num25 && right != num && upLeft != num25 && upLeft != num)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 144;
								rectangle.Y = 288;
								break;
							case 1:
								rectangle.X = 162;
								rectangle.Y = 288;
								break;
							default:
								rectangle.X = 180;
								rectangle.Y = 288;
								break;
							}
						}
						else if (up != num && up != num25 && down == num && left == num && right == num && downLeft != num && downLeft != num25 && downRight != num && downRight != num25)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 144;
								rectangle.Y = 216;
								break;
							case 1:
								rectangle.X = 198;
								rectangle.Y = 216;
								break;
							default:
								rectangle.X = 252;
								rectangle.Y = 216;
								break;
							}
						}
						else if (down != num && down != num25 && up == num && left == num && right == num && upLeft != num && upLeft != num25 && upRight != num && upRight != num25)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 144;
								rectangle.Y = 252;
								break;
							case 1:
								rectangle.X = 198;
								rectangle.Y = 252;
								break;
							default:
								rectangle.X = 252;
								rectangle.Y = 252;
								break;
							}
						}
						else if (left != num && left != num25 && down == num && up == num && right == num && upRight != num && upRight != num25 && downRight != num && downRight != num25)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 126;
								rectangle.Y = 234;
								break;
							case 1:
								rectangle.X = 180;
								rectangle.Y = 234;
								break;
							default:
								rectangle.X = 234;
								rectangle.Y = 234;
								break;
							}
						}
						else if (right != num && right != num25 && down == num && up == num && left == num && upLeft != num && upLeft != num25 && downLeft != num && downLeft != num25)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 162;
								rectangle.Y = 234;
								break;
							case 1:
								rectangle.X = 216;
								rectangle.Y = 234;
								break;
							default:
								rectangle.X = 270;
								rectangle.Y = 234;
								break;
							}
						}
						else if (up != num25 && up != num && (down == num25 || down == num) && left == num25 && right == num25)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 36;
								rectangle.Y = 270;
								break;
							case 1:
								rectangle.X = 54;
								rectangle.Y = 270;
								break;
							default:
								rectangle.X = 72;
								rectangle.Y = 270;
								break;
							}
						}
						else if (down != num25 && down != num && (up == num25 || up == num) && left == num25 && right == num25)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 36;
								rectangle.Y = 288;
								break;
							case 1:
								rectangle.X = 54;
								rectangle.Y = 288;
								break;
							default:
								rectangle.X = 72;
								rectangle.Y = 288;
								break;
							}
						}
						else if (left != num25 && left != num && (right == num25 || right == num) && up == num25 && down == num25)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 0;
								rectangle.Y = 270;
								break;
							case 1:
								rectangle.X = 0;
								rectangle.Y = 288;
								break;
							default:
								rectangle.X = 0;
								rectangle.Y = 306;
								break;
							}
						}
						else if (right != num25 && right != num && (left == num25 || left == num) && up == num25 && down == num25)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 18;
								rectangle.Y = 270;
								break;
							case 1:
								rectangle.X = 18;
								rectangle.Y = 288;
								break;
							default:
								rectangle.X = 18;
								rectangle.Y = 306;
								break;
							}
						}
						else if (up == num && down == num25 && left == num25 && right == num25)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 198;
								rectangle.Y = 288;
								break;
							case 1:
								rectangle.X = 216;
								rectangle.Y = 288;
								break;
							default:
								rectangle.X = 234;
								rectangle.Y = 288;
								break;
							}
						}
						else if (up == num25 && down == num && left == num25 && right == num25)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 198;
								rectangle.Y = 270;
								break;
							case 1:
								rectangle.X = 216;
								rectangle.Y = 270;
								break;
							default:
								rectangle.X = 234;
								rectangle.Y = 270;
								break;
							}
						}
						else if (up == num25 && down == num25 && left == num && right == num25)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 198;
								rectangle.Y = 306;
								break;
							case 1:
								rectangle.X = 216;
								rectangle.Y = 306;
								break;
							default:
								rectangle.X = 234;
								rectangle.Y = 306;
								break;
							}
						}
						else if (up == num25 && down == num25 && left == num25 && right == num)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 144;
								rectangle.Y = 306;
								break;
							case 1:
								rectangle.X = 162;
								rectangle.Y = 306;
								break;
							default:
								rectangle.X = 180;
								rectangle.Y = 306;
								break;
							}
						}
						if (up != num && up != num25 && down == num && left == num && right == num)
						{
							if ((downLeft == num25 || downLeft == num) && downRight != num25 && downRight != num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 0;
									rectangle.Y = 324;
									break;
								case 1:
									rectangle.X = 18;
									rectangle.Y = 324;
									break;
								default:
									rectangle.X = 36;
									rectangle.Y = 324;
									break;
								}
							}
							else if ((downRight == num25 || downRight == num) && downLeft != num25 && downLeft != num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 54;
									rectangle.Y = 324;
									break;
								case 1:
									rectangle.X = 72;
									rectangle.Y = 324;
									break;
								default:
									rectangle.X = 90;
									rectangle.Y = 324;
									break;
								}
							}
						}
						else if (down != num && down != num25 && up == num && left == num && right == num)
						{
							if ((upLeft == num25 || upLeft == num) && upRight != num25 && upRight != num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 0;
									rectangle.Y = 342;
									break;
								case 1:
									rectangle.X = 18;
									rectangle.Y = 342;
									break;
								default:
									rectangle.X = 36;
									rectangle.Y = 342;
									break;
								}
							}
							else if ((upRight == num25 || upRight == num) && upLeft != num25 && upLeft != num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 54;
									rectangle.Y = 342;
									break;
								case 1:
									rectangle.X = 72;
									rectangle.Y = 342;
									break;
								default:
									rectangle.X = 90;
									rectangle.Y = 342;
									break;
								}
							}
						}
						else if (left != num && left != num25 && up == num && down == num && right == num)
						{
							if ((upRight == num25 || upRight == num) && downRight != num25 && downRight != num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 54;
									rectangle.Y = 360;
									break;
								case 1:
									rectangle.X = 72;
									rectangle.Y = 360;
									break;
								default:
									rectangle.X = 90;
									rectangle.Y = 360;
									break;
								}
							}
							else if ((downRight == num25 || downRight == num) && upRight != num25 && upRight != num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 0;
									rectangle.Y = 360;
									break;
								case 1:
									rectangle.X = 18;
									rectangle.Y = 360;
									break;
								default:
									rectangle.X = 36;
									rectangle.Y = 360;
									break;
								}
							}
						}
						else if (right != num && right != num25 && up == num && down == num && left == num)
						{
							if ((upLeft == num25 || upLeft == num) && downLeft != num25 && downLeft != num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 0;
									rectangle.Y = 378;
									break;
								case 1:
									rectangle.X = 18;
									rectangle.Y = 378;
									break;
								default:
									rectangle.X = 36;
									rectangle.Y = 378;
									break;
								}
							}
							else if ((downLeft == num25 || downLeft == num) && upLeft != num25 && upLeft != num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 54;
									rectangle.Y = 378;
									break;
								case 1:
									rectangle.X = 72;
									rectangle.Y = 378;
									break;
								default:
									rectangle.X = 90;
									rectangle.Y = 378;
									break;
								}
							}
						}
						if ((up == num || up == num25) && (down == num || down == num25) && (left == num || left == num25) && (right == num || right == num25) && upLeft != -1 && upRight != -1 && downLeft != -1 && downRight != -1)
						{
							if ((i + j) % 2 == 1)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 108;
									rectangle.Y = 198;
									break;
								case 1:
									rectangle.X = 126;
									rectangle.Y = 198;
									break;
								default:
									rectangle.X = 144;
									rectangle.Y = 198;
									break;
								}
							}
							else
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 18;
									rectangle.Y = 18;
									break;
								case 1:
									rectangle.X = 36;
									rectangle.Y = 18;
									break;
								default:
									rectangle.X = 54;
									rectangle.Y = 18;
									break;
								}
							}
						}
						if (num25 >= 0 && TileID.Sets.Dirt[num25])
						{
							TileMergeAttempt(-2, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						}
						else if (num25 >= 0 && TileID.Sets.Mud[num25])
						{
							TileMergeAttempt(-2, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						}
						else
						{
							TileMergeAttempt(-2, num25, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						}
						tileMergeCullCache.Cull(ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					}
					TileMergeAttempt(num, Main.tileMerge[num], ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
					if (rectangle.X == -1 && rectangle.Y == -1 && (Main.tileMergeDirt[num] || (num > -1 && TileID.Sets.ChecksForMerge[num])))
					{
						if (!flag)
						{
							flag = true;
							TileMergeAttemptWeird(num, -1, Main.tileSolid, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						}
						if (up > -1 && up != num)
						{
							up = -1;
						}
						if (down > -1 && down != num)
						{
							down = -1;
						}
						if (left > -1 && left != num)
						{
							left = -1;
						}
						if (right > -1 && right != num)
						{
							right = -1;
						}
						tileMergeCullCache.Cull(ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						if (up != -1 && down != -1 && left != -1 && right != -1)
						{
							if (up == -2 && down == num && left == num && right == num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 144;
									rectangle.Y = 108;
									break;
								case 1:
									rectangle.X = 162;
									rectangle.Y = 108;
									break;
								default:
									rectangle.X = 180;
									rectangle.Y = 108;
									break;
								}
								mergeUp = true;
							}
							else if (up == num && down == -2 && left == num && right == num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 144;
									rectangle.Y = 90;
									break;
								case 1:
									rectangle.X = 162;
									rectangle.Y = 90;
									break;
								default:
									rectangle.X = 180;
									rectangle.Y = 90;
									break;
								}
								mergeDown = true;
							}
							else if (up == num && down == num && left == -2 && right == num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 162;
									rectangle.Y = 126;
									break;
								case 1:
									rectangle.X = 162;
									rectangle.Y = 144;
									break;
								default:
									rectangle.X = 162;
									rectangle.Y = 162;
									break;
								}
								mergeLeft = true;
							}
							else if (up == num && down == num && left == num && right == -2)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 144;
									rectangle.Y = 126;
									break;
								case 1:
									rectangle.X = 144;
									rectangle.Y = 144;
									break;
								default:
									rectangle.X = 144;
									rectangle.Y = 162;
									break;
								}
								mergeRight = true;
							}
							else if (up == -2 && down == num && left == -2 && right == num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 36;
									rectangle.Y = 90;
									break;
								case 1:
									rectangle.X = 36;
									rectangle.Y = 126;
									break;
								default:
									rectangle.X = 36;
									rectangle.Y = 162;
									break;
								}
								mergeUp = true;
								mergeLeft = true;
							}
							else if (up == -2 && down == num && left == num && right == -2)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 54;
									rectangle.Y = 90;
									break;
								case 1:
									rectangle.X = 54;
									rectangle.Y = 126;
									break;
								default:
									rectangle.X = 54;
									rectangle.Y = 162;
									break;
								}
								mergeUp = true;
								mergeRight = true;
							}
							else if (up == num && down == -2 && left == -2 && right == num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 36;
									rectangle.Y = 108;
									break;
								case 1:
									rectangle.X = 36;
									rectangle.Y = 144;
									break;
								default:
									rectangle.X = 36;
									rectangle.Y = 180;
									break;
								}
								mergeDown = true;
								mergeLeft = true;
							}
							else if (up == num && down == -2 && left == num && right == -2)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 54;
									rectangle.Y = 108;
									break;
								case 1:
									rectangle.X = 54;
									rectangle.Y = 144;
									break;
								default:
									rectangle.X = 54;
									rectangle.Y = 180;
									break;
								}
								mergeDown = true;
								mergeRight = true;
							}
							else if (up == num && down == num && left == -2 && right == -2)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 180;
									rectangle.Y = 126;
									break;
								case 1:
									rectangle.X = 180;
									rectangle.Y = 144;
									break;
								default:
									rectangle.X = 180;
									rectangle.Y = 162;
									break;
								}
								mergeLeft = true;
								mergeRight = true;
							}
							else if (up == -2 && down == -2 && left == num && right == num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 144;
									rectangle.Y = 180;
									break;
								case 1:
									rectangle.X = 162;
									rectangle.Y = 180;
									break;
								default:
									rectangle.X = 180;
									rectangle.Y = 180;
									break;
								}
								mergeUp = true;
								mergeDown = true;
							}
							else if (up == -2 && down == num && left == -2 && right == -2)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 198;
									rectangle.Y = 90;
									break;
								case 1:
									rectangle.X = 198;
									rectangle.Y = 108;
									break;
								default:
									rectangle.X = 198;
									rectangle.Y = 126;
									break;
								}
								mergeUp = true;
								mergeLeft = true;
								mergeRight = true;
							}
							else if (up == num && down == -2 && left == -2 && right == -2)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 198;
									rectangle.Y = 144;
									break;
								case 1:
									rectangle.X = 198;
									rectangle.Y = 162;
									break;
								default:
									rectangle.X = 198;
									rectangle.Y = 180;
									break;
								}
								mergeDown = true;
								mergeLeft = true;
								mergeRight = true;
							}
							else if (up == -2 && down == -2 && left == num && right == -2)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 216;
									rectangle.Y = 144;
									break;
								case 1:
									rectangle.X = 216;
									rectangle.Y = 162;
									break;
								default:
									rectangle.X = 216;
									rectangle.Y = 180;
									break;
								}
								mergeUp = true;
								mergeDown = true;
								mergeRight = true;
							}
							else if (up == -2 && down == -2 && left == -2 && right == num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 216;
									rectangle.Y = 90;
									break;
								case 1:
									rectangle.X = 216;
									rectangle.Y = 108;
									break;
								default:
									rectangle.X = 216;
									rectangle.Y = 126;
									break;
								}
								mergeUp = true;
								mergeDown = true;
								mergeLeft = true;
							}
							else if (up == -2 && down == -2 && left == -2 && right == -2)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 108;
									rectangle.Y = 198;
									break;
								case 1:
									rectangle.X = 126;
									rectangle.Y = 198;
									break;
								default:
									rectangle.X = 144;
									rectangle.Y = 198;
									break;
								}
								mergeUp = true;
								mergeDown = true;
								mergeLeft = true;
								mergeRight = true;
							}
							else if (up == num && down == num && left == num && right == num)
							{
								if (upLeft == -2)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 18;
										rectangle.Y = 108;
										break;
									case 1:
										rectangle.X = 18;
										rectangle.Y = 144;
										break;
									default:
										rectangle.X = 18;
										rectangle.Y = 180;
										break;
									}
								}
								if (upRight == -2)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 0;
										rectangle.Y = 108;
										break;
									case 1:
										rectangle.X = 0;
										rectangle.Y = 144;
										break;
									default:
										rectangle.X = 0;
										rectangle.Y = 180;
										break;
									}
								}
								if (downLeft == -2)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 18;
										rectangle.Y = 90;
										break;
									case 1:
										rectangle.X = 18;
										rectangle.Y = 126;
										break;
									default:
										rectangle.X = 18;
										rectangle.Y = 162;
										break;
									}
								}
								if (downRight == -2)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 0;
										rectangle.Y = 90;
										break;
									case 1:
										rectangle.X = 0;
										rectangle.Y = 126;
										break;
									default:
										rectangle.X = 0;
										rectangle.Y = 162;
										break;
									}
								}
							}
						}
						else
						{
							if (!TileID.Sets.Grass[num] && !TileID.Sets.GrassSpecial[num])
							{
								if (up == -1 && down == -2 && left == num && right == num)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 234;
										rectangle.Y = 0;
										break;
									case 1:
										rectangle.X = 252;
										rectangle.Y = 0;
										break;
									default:
										rectangle.X = 270;
										rectangle.Y = 0;
										break;
									}
									mergeDown = true;
								}
								else if (up == -2 && down == -1 && left == num && right == num)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 234;
										rectangle.Y = 18;
										break;
									case 1:
										rectangle.X = 252;
										rectangle.Y = 18;
										break;
									default:
										rectangle.X = 270;
										rectangle.Y = 18;
										break;
									}
									mergeUp = true;
								}
								else if (up == num && down == num && left == -1 && right == -2)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 234;
										rectangle.Y = 36;
										break;
									case 1:
										rectangle.X = 252;
										rectangle.Y = 36;
										break;
									default:
										rectangle.X = 270;
										rectangle.Y = 36;
										break;
									}
									mergeRight = true;
								}
								else if (up == num && down == num && left == -2 && right == -1)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 234;
										rectangle.Y = 54;
										break;
									case 1:
										rectangle.X = 252;
										rectangle.Y = 54;
										break;
									default:
										rectangle.X = 270;
										rectangle.Y = 54;
										break;
									}
									mergeLeft = true;
								}
							}
							if (up != -1 && down != -1 && left == -1 && right == num)
							{
								if (up == -2 && down == num)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 72;
										rectangle.Y = 144;
										break;
									case 1:
										rectangle.X = 72;
										rectangle.Y = 162;
										break;
									default:
										rectangle.X = 72;
										rectangle.Y = 180;
										break;
									}
									mergeUp = true;
								}
								else if (down == -2 && up == num)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 72;
										rectangle.Y = 90;
										break;
									case 1:
										rectangle.X = 72;
										rectangle.Y = 108;
										break;
									default:
										rectangle.X = 72;
										rectangle.Y = 126;
										break;
									}
									mergeDown = true;
								}
							}
							else if (up != -1 && down != -1 && left == num && right == -1)
							{
								if (up == -2 && down == num)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 90;
										rectangle.Y = 144;
										break;
									case 1:
										rectangle.X = 90;
										rectangle.Y = 162;
										break;
									default:
										rectangle.X = 90;
										rectangle.Y = 180;
										break;
									}
									mergeUp = true;
								}
								else if (down == -2 && up == num)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 90;
										rectangle.Y = 90;
										break;
									case 1:
										rectangle.X = 90;
										rectangle.Y = 108;
										break;
									default:
										rectangle.X = 90;
										rectangle.Y = 126;
										break;
									}
									mergeDown = true;
								}
							}
							else if (up == -1 && down == num && left != -1 && right != -1)
							{
								if (left == -2 && right == num)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 0;
										rectangle.Y = 198;
										break;
									case 1:
										rectangle.X = 18;
										rectangle.Y = 198;
										break;
									default:
										rectangle.X = 36;
										rectangle.Y = 198;
										break;
									}
									mergeLeft = true;
								}
								else if (right == -2 && left == num)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 54;
										rectangle.Y = 198;
										break;
									case 1:
										rectangle.X = 72;
										rectangle.Y = 198;
										break;
									default:
										rectangle.X = 90;
										rectangle.Y = 198;
										break;
									}
									mergeRight = true;
								}
							}
							else if (up == num && down == -1 && left != -1 && right != -1)
							{
								if (left == -2 && right == num)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 0;
										rectangle.Y = 216;
										break;
									case 1:
										rectangle.X = 18;
										rectangle.Y = 216;
										break;
									default:
										rectangle.X = 36;
										rectangle.Y = 216;
										break;
									}
									mergeLeft = true;
								}
								else if (right == -2 && left == num)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 54;
										rectangle.Y = 216;
										break;
									case 1:
										rectangle.X = 72;
										rectangle.Y = 216;
										break;
									default:
										rectangle.X = 90;
										rectangle.Y = 216;
										break;
									}
									mergeRight = true;
								}
							}
							else if (up != -1 && down != -1 && left == -1 && right == -1)
							{
								if (up == -2 && down == -2)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 108;
										rectangle.Y = 216;
										break;
									case 1:
										rectangle.X = 108;
										rectangle.Y = 234;
										break;
									default:
										rectangle.X = 108;
										rectangle.Y = 252;
										break;
									}
									mergeUp = true;
									mergeDown = true;
								}
								else if (up == -2)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 126;
										rectangle.Y = 144;
										break;
									case 1:
										rectangle.X = 126;
										rectangle.Y = 162;
										break;
									default:
										rectangle.X = 126;
										rectangle.Y = 180;
										break;
									}
									mergeUp = true;
								}
								else if (down == -2)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 126;
										rectangle.Y = 90;
										break;
									case 1:
										rectangle.X = 126;
										rectangle.Y = 108;
										break;
									default:
										rectangle.X = 126;
										rectangle.Y = 126;
										break;
									}
									mergeDown = true;
								}
							}
							else if (up == -1 && down == -1 && left != -1 && right != -1)
							{
								if (left == -2 && right == -2)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 162;
										rectangle.Y = 198;
										break;
									case 1:
										rectangle.X = 180;
										rectangle.Y = 198;
										break;
									default:
										rectangle.X = 198;
										rectangle.Y = 198;
										break;
									}
									mergeLeft = true;
									mergeRight = true;
								}
								else if (left == -2)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 0;
										rectangle.Y = 252;
										break;
									case 1:
										rectangle.X = 18;
										rectangle.Y = 252;
										break;
									default:
										rectangle.X = 36;
										rectangle.Y = 252;
										break;
									}
									mergeLeft = true;
								}
								else if (right == -2)
								{
									switch (num20)
									{
									case 0:
										rectangle.X = 54;
										rectangle.Y = 252;
										break;
									case 1:
										rectangle.X = 72;
										rectangle.Y = 252;
										break;
									default:
										rectangle.X = 90;
										rectangle.Y = 252;
										break;
									}
									mergeRight = true;
								}
							}
							else if (up == -2 && down == -1 && left == -1 && right == -1)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 108;
									rectangle.Y = 144;
									break;
								case 1:
									rectangle.X = 108;
									rectangle.Y = 162;
									break;
								default:
									rectangle.X = 108;
									rectangle.Y = 180;
									break;
								}
								mergeUp = true;
							}
							else if (up == -1 && down == -2 && left == -1 && right == -1)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 108;
									rectangle.Y = 90;
									break;
								case 1:
									rectangle.X = 108;
									rectangle.Y = 108;
									break;
								default:
									rectangle.X = 108;
									rectangle.Y = 126;
									break;
								}
								mergeDown = true;
							}
							else if (up == -1 && down == -1 && left == -2 && right == -1)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 0;
									rectangle.Y = 234;
									break;
								case 1:
									rectangle.X = 18;
									rectangle.Y = 234;
									break;
								default:
									rectangle.X = 36;
									rectangle.Y = 234;
									break;
								}
								mergeLeft = true;
							}
							else if (up == -1 && down == -1 && left == -1 && right == -2)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 54;
									rectangle.Y = 234;
									break;
								case 1:
									rectangle.X = 72;
									rectangle.Y = 234;
									break;
								default:
									rectangle.X = 90;
									rectangle.Y = 234;
									break;
								}
								mergeRight = true;
							}
						}
					}
					int num26 = tile.blockType();
					if (TileID.Sets.HasSlopeFrames[num])
					{
						if (num26 == 0)
						{
							bool flag11 = num == up && tile10 != null && tile10.topSlope();
							bool flag12 = num == left && tile26 != null && tile26.leftSlope();
							bool flag13 = num == right && tile33 != null && tile33.rightSlope();
							bool flag14 = num == down && tile19 != null && tile19.bottomSlope();
							int num27 = 0;
							int num28 = 0;
							if (flag11.ToInt() + flag12.ToInt() + flag13.ToInt() + flag14.ToInt() > 2)
							{
								int num29 = (tile10 != null && tile10.slope() == 1).ToInt() + (tile33 != null && tile33.slope() == 1).ToInt() + (tile19 != null && tile19.slope() == 4).ToInt() + (tile26 != null && tile26.slope() == 4).ToInt();
								int num30 = (tile10 != null && tile10.slope() == 2).ToInt() + (tile33 != null && tile33.slope() == 3).ToInt() + (tile19 != null && tile19.slope() == 3).ToInt() + (tile26 != null && tile26.slope() == 2).ToInt();
								if (num29 == num30)
								{
									num27 = 2;
									num28 = 4;
								}
								else if (num29 > num30)
								{
									bool num46 = num == upLeft && tile42 != null && tile42.slope() == 0;
									bool flag15 = num == downRight && tile39 != null && tile39.slope() == 0;
									if (num46 && flag15)
									{
										num28 = 4;
									}
									else if (flag15)
									{
										num27 = 6;
									}
									else
									{
										num27 = 7;
										num28 = 1;
									}
								}
								else
								{
									bool num47 = num == upRight && tile45 != null && tile45.slope() == 0;
									bool flag16 = num == downLeft && tile36 != null && tile36.slope() == 0;
									if (num47 && flag16)
									{
										num28 = 4;
										num27 = 1;
									}
									else if (flag16)
									{
										num27 = 7;
									}
									else
									{
										num27 = 6;
										num28 = 1;
									}
								}
								rectangle.X = (18 + num27) * 18;
								rectangle.Y = num28 * 18;
							}
							else
							{
								if (flag11 && flag12 && num == down && num == right)
								{
									num28 = 2;
								}
								else if (flag11 && flag13 && num == down && num == left)
								{
									num27 = 1;
									num28 = 2;
								}
								else if (flag13 && flag14 && num == up && num == left)
								{
									num27 = 1;
									num28 = 3;
								}
								else if (flag14 && flag12 && num == up && num == right)
								{
									num28 = 3;
								}
								if (num27 != 0 || num28 != 0)
								{
									rectangle.X = (18 + num27) * 18;
									rectangle.Y = num28 * 18;
								}
							}
						}
						if (num26 >= 2 && (rectangle.X < 0 || rectangle.Y < 0))
						{
							int num32 = -1;
							int num33 = -1;
							int num34 = -1;
							int num35 = 0;
							int num36 = 0;
							switch (num26)
							{
							case 2:
								num32 = left;
								num33 = down;
								num34 = downLeft;
								num35++;
								break;
							case 3:
								num32 = right;
								num33 = down;
								num34 = downRight;
								break;
							case 4:
								num32 = left;
								num33 = up;
								num34 = upLeft;
								num35++;
								num36++;
								break;
							case 5:
								num32 = right;
								num33 = up;
								num34 = upRight;
								num36++;
								break;
							}
							if (num != num32 || num != num33 || num != num34)
							{
								if (num == num32 && num == num33)
								{
									num35 += 2;
								}
								else if (num == num32)
								{
									num35 += 4;
								}
								else if (num == num33)
								{
									num35 += 4;
									num36 += 2;
								}
								else
								{
									num35 += 2;
									num36 += 2;
								}
							}
							rectangle.X = (18 + num35) * 18;
							rectangle.Y = num36 * 18;
						}
					}
					if (rectangle.X < 0 || rectangle.Y < 0)
					{
						if (!flag)
						{
							flag = true;
							TileMergeAttemptWeird(num, -1, Main.tileSolid, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
							tileMergeCullCache.Cull(ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						}
						if (TileID.Sets.Grass[num] || TileID.Sets.GrassSpecial[num] || Main.tileMoss[num] || TileID.Sets.tileMossBrick[num])
						{
							TileMergeAttempt(num, -2, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
							tileMergeCullCache.Cull(ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
						}
						if (up == num && down == num && left == num && right == num)
						{
							if (upLeft != num && upRight != num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 108;
									rectangle.Y = 18;
									break;
								case 1:
									rectangle.X = 126;
									rectangle.Y = 18;
									break;
								default:
									rectangle.X = 144;
									rectangle.Y = 18;
									break;
								}
							}
							else if (downLeft != num && downRight != num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 108;
									rectangle.Y = 36;
									break;
								case 1:
									rectangle.X = 126;
									rectangle.Y = 36;
									break;
								default:
									rectangle.X = 144;
									rectangle.Y = 36;
									break;
								}
							}
							else if (upLeft != num && downLeft != num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 180;
									rectangle.Y = 0;
									break;
								case 1:
									rectangle.X = 180;
									rectangle.Y = 18;
									break;
								default:
									rectangle.X = 180;
									rectangle.Y = 36;
									break;
								}
							}
							else if (upRight != num && downRight != num)
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 198;
									rectangle.Y = 0;
									break;
								case 1:
									rectangle.X = 198;
									rectangle.Y = 18;
									break;
								default:
									rectangle.X = 198;
									rectangle.Y = 36;
									break;
								}
							}
							else
							{
								switch (num20)
								{
								case 0:
									rectangle.X = 18;
									rectangle.Y = 18;
									break;
								case 1:
									rectangle.X = 36;
									rectangle.Y = 18;
									break;
								default:
									rectangle.X = 54;
									rectangle.Y = 18;
									break;
								}
							}
						}
						else if (up != num && down == num && left == num && right == num)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 18;
								rectangle.Y = 0;
								break;
							case 1:
								rectangle.X = 36;
								rectangle.Y = 0;
								break;
							default:
								rectangle.X = 54;
								rectangle.Y = 0;
								break;
							}
						}
						else if (up == num && down != num && left == num && right == num)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 18;
								rectangle.Y = 36;
								break;
							case 1:
								rectangle.X = 36;
								rectangle.Y = 36;
								break;
							default:
								rectangle.X = 54;
								rectangle.Y = 36;
								break;
							}
						}
						else if (up == num && down == num && left != num && right == num)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 0;
								rectangle.Y = 0;
								break;
							case 1:
								rectangle.X = 0;
								rectangle.Y = 18;
								break;
							default:
								rectangle.X = 0;
								rectangle.Y = 36;
								break;
							}
						}
						else if (up == num && down == num && left == num && right != num)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 72;
								rectangle.Y = 0;
								break;
							case 1:
								rectangle.X = 72;
								rectangle.Y = 18;
								break;
							default:
								rectangle.X = 72;
								rectangle.Y = 36;
								break;
							}
						}
						else if (up != num && down == num && left != num && right == num)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 0;
								rectangle.Y = 54;
								break;
							case 1:
								rectangle.X = 36;
								rectangle.Y = 54;
								break;
							default:
								rectangle.X = 72;
								rectangle.Y = 54;
								break;
							}
						}
						else if (up != num && down == num && left == num && right != num)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 18;
								rectangle.Y = 54;
								break;
							case 1:
								rectangle.X = 54;
								rectangle.Y = 54;
								break;
							default:
								rectangle.X = 90;
								rectangle.Y = 54;
								break;
							}
						}
						else if (up == num && down != num && left != num && right == num)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 0;
								rectangle.Y = 72;
								break;
							case 1:
								rectangle.X = 36;
								rectangle.Y = 72;
								break;
							default:
								rectangle.X = 72;
								rectangle.Y = 72;
								break;
							}
						}
						else if (up == num && down != num && left == num && right != num)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 18;
								rectangle.Y = 72;
								break;
							case 1:
								rectangle.X = 54;
								rectangle.Y = 72;
								break;
							default:
								rectangle.X = 90;
								rectangle.Y = 72;
								break;
							}
						}
						else if (up == num && down == num && left != num && right != num)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 90;
								rectangle.Y = 0;
								break;
							case 1:
								rectangle.X = 90;
								rectangle.Y = 18;
								break;
							default:
								rectangle.X = 90;
								rectangle.Y = 36;
								break;
							}
						}
						else if (up != num && down != num && left == num && right == num)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 108;
								rectangle.Y = 72;
								break;
							case 1:
								rectangle.X = 126;
								rectangle.Y = 72;
								break;
							default:
								rectangle.X = 144;
								rectangle.Y = 72;
								break;
							}
						}
						else if (up != num && down == num && left != num && right != num)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 108;
								rectangle.Y = 0;
								break;
							case 1:
								rectangle.X = 126;
								rectangle.Y = 0;
								break;
							default:
								rectangle.X = 144;
								rectangle.Y = 0;
								break;
							}
						}
						else if (up == num && down != num && left != num && right != num)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 108;
								rectangle.Y = 54;
								break;
							case 1:
								rectangle.X = 126;
								rectangle.Y = 54;
								break;
							default:
								rectangle.X = 144;
								rectangle.Y = 54;
								break;
							}
						}
						else if (up != num && down != num && left != num && right == num)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 162;
								rectangle.Y = 0;
								break;
							case 1:
								rectangle.X = 162;
								rectangle.Y = 18;
								break;
							default:
								rectangle.X = 162;
								rectangle.Y = 36;
								break;
							}
						}
						else if (up != num && down != num && left == num && right != num)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 216;
								rectangle.Y = 0;
								break;
							case 1:
								rectangle.X = 216;
								rectangle.Y = 18;
								break;
							default:
								rectangle.X = 216;
								rectangle.Y = 36;
								break;
							}
						}
						else if (up != num && down != num && left != num && right != num)
						{
							switch (num20)
							{
							case 0:
								rectangle.X = 162;
								rectangle.Y = 54;
								break;
							case 1:
								rectangle.X = 180;
								rectangle.Y = 54;
								break;
							default:
								rectangle.X = 198;
								rectangle.Y = 54;
								break;
							}
						}
					}
					if (rectangle.X <= -1 || rectangle.Y <= -1)
					{
						if (num20 <= 0)
						{
							rectangle.X = 18;
							rectangle.Y = 18;
						}
						else if (num20 == 1)
						{
							rectangle.X = 36;
							rectangle.Y = 18;
						}
						if (num20 >= 2)
						{
							rectangle.X = 54;
							rectangle.Y = 18;
						}
					}
					if (Main.tileLargeFrames[num] == 1 && num20 == 3)
					{
						rectangle.Y += 90;
					}
					if (Main.tileLargeFrames[num] == 2 && num20 == 3)
					{
						rectangle.Y += 90;
					}
					tile.frameX = (short)rectangle.X;
					tile.frameY = (short)rectangle.Y;
					if (TileID.Sets.IsVine[num])
					{
						up = ((tile10 == null) ? num : ((!tile10.nactive()) ? (-1) : ((!tile10.bottomSlope()) ? tile10.type : (-1))));
						if (num != up)
						{
							bool num48 = up == 60 || up == 62;
							bool num49 = up == 109 || up == 115;
							bool flag17 = up == 23 || up == 636 || up == 661;
							bool flag2 = up == 199 || up == 205 || up == 662;
							bool flag3 = up == 2 || up == 52;
							bool flag4 = up == 382;
							bool num50 = up == 70 || up == 528;
							bool num51 = up == 633 || up == 638;
							ushort num37 = 0;
							if (num51)
							{
								num37 = 638;
							}
							if (num50)
							{
								num37 = 528;
							}
							if (num49)
							{
								num37 = 115;
							}
							if (num48)
							{
								num37 = 62;
							}
							if (flag17)
							{
								num37 = 636;
							}
							if (flag2)
							{
								num37 = 205;
							}
							if (flag3 && num != 382)
							{
								num37 = 52;
							}
							if (flag4)
							{
								num37 = 382;
							}
							if (num37 != 0 && num37 != num)
							{
								tile.type = num37;
								SquareTileFrame(i, j);
								return;
							}
						}
						if (up != num)
						{
							bool flag5 = false;
							if (up == -1)
							{
								flag5 = true;
							}
							if (num == 52 && up != 2 && up != 192)
							{
								flag5 = true;
							}
							if (num == 382 && up != 2 && up != 192)
							{
								flag5 = true;
							}
							if (num == 62 && up != 60)
							{
								flag5 = true;
							}
							if (num == 115 && up != 109)
							{
								flag5 = true;
							}
							if (num == 528 && up != 70)
							{
								flag5 = true;
							}
							if (num == 636 && up != 23 && up != 661)
							{
								flag5 = true;
							}
							if (num == 205 && up != 199 && up != 662)
							{
								flag5 = true;
							}
							if (num == 638 && up != 633)
							{
								flag5 = true;
							}
							if (flag5)
							{
								KillTile(i, j);
							}
						}
					}
					bool flag6 = false;
					if (!noTileActions && tile.active() && TileID.Sets.Falling[num])
					{
						SpawnFallingBlockProjectile(i, j, tile, tile10, tile19, num);
					}
					if ((rectangle.X != frameX && rectangle.Y != frameY && frameX >= 0 && frameY >= 0) || flag6)
					{
						tileReframeCount++;
						if (tileReframeCount < 25)
						{
							bool num52 = mergeUp;
							bool flag7 = mergeDown;
							bool flag8 = mergeLeft;
							bool flag9 = mergeRight;
							TileFrame(i - 1, j);
							TileFrame(i + 1, j);
							TileFrame(i, j - 1);
							TileFrame(i, j + 1);
							mergeUp = num52;
							mergeDown = flag7;
							mergeLeft = flag8;
							mergeRight = flag9;
						}
						tileReframeCount--;
					}
				}
			}
		}
		catch
		{
		}
		if (i > 0 && j > 0)
		{
			UpdateMapTile(i, j, addToList);
		}
	}

	private static void StopMergingByInvsibility(ref int currentMerge, Tile block, bool wantedInvisibilityState)
	{
		if (currentMerge > -1 && block.invisibleBlock() != wantedInvisibilityState)
		{
			currentMerge = -1;
		}
	}

	private static bool SpawnFallingBlockProjectile(int i, int j, Tile tileCache, Tile tileTopCache, Tile tileBottomCache, int type)
	{
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		if (Main.netMode == 1)
		{
			return false;
		}
		if (tileCache == null || tileTopCache == null || tileBottomCache == null)
		{
			return false;
		}
		if (!BlockBelowMakesSandFall(i, j))
		{
			return false;
		}
		if (!AllowsSandfall(tileTopCache))
		{
			return false;
		}
		GetSandfallProjData(type, out var projType, out var dmg);
		tileCache.ClearTile();
		if (Main.netMode == 0)
		{
			int num = Projectile.NewProjectile(GetProjectileSource_TileBreak(i, j), i * 16 + 8, j * 16 + 8, 0f, 0.41f, projType, dmg, 0f, Main.myPlayer);
			Main.projectile[num].ai[0] = 1f;
			SquareTileFrame(i, j);
		}
		if (Main.netMode == 2)
		{
			bool flag = false;
			for (int k = 0; k < 1000; k++)
			{
				if (Main.projectile[k].active && Main.projectile[k].owner == Main.myPlayer && Main.projectile[k].type == projType && Math.Abs(Main.projectile[k].timeLeft - 3600) < 60 && Main.projectile[k].Distance(new Vector2((float)(i * 16 + 8), (float)(j * 16 + 10))) < 4f)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				int num2 = Projectile.NewProjectile(GetProjectileSource_TileBreak(i, j), i * 16 + 8, j * 16 + 8, 0f, 2.5f, projType, dmg, 0f, Main.myPlayer);
				Main.projectile[num2].velocity.Y = 0.5f;
				Main.projectile[num2].position.Y += 2f;
				Main.projectile[num2].netUpdate = true;
			}
			SquareTileFrame(i, j);
			NetMessage.SendTileSquare(-1, i, j);
			ExploitDestroyQueue.Enqueue(new Point(i, j));
			ExploitDestroyQueue.Enqueue(new Point(i, j - 1));
		}
		return true;
	}

	public static void CheckTorch(int x, int y)
	{
		for (int i = x - 1; i <= x + 1; i++)
		{
			for (int j = y - 1; j <= y + 1; j++)
			{
				if (Main.tile[i, j] == null)
				{
					return;
				}
			}
		}
		Tile tile = Main.tile[x, y];
		Tile tile2 = Main.tile[x, y - 1];
		Tile tile3 = Main.tile[x, y + 1];
		Tile tile4 = Main.tile[x - 1, y];
		Tile tile5 = Main.tile[x + 1, y];
		Tile tile6 = Main.tile[x - 1, y + 1];
		Tile tile7 = Main.tile[x + 1, y + 1];
		Tile tile8 = Main.tile[x - 1, y - 1];
		Tile tile9 = Main.tile[x + 1, y - 1];
		short num = 0;
		if (tile.frameX >= 66)
		{
			num = 66;
		}
		int num2 = -1;
		int num3 = -1;
		int num4 = -1;
		int tree = -1;
		int tree2 = -1;
		int tree3 = -1;
		int tree4 = -1;
		if (tile2 != null && tile2.active() && !tile2.bottomSlope())
		{
			_ = ref tile2.type;
		}
		if (tile3 != null && tile3.active() && ((TileID.Sets.Platforms[tile3.type] && TopEdgeCanBeAttachedTo(x, y + 1)) || (!tile3.halfBrick() && !tile3.topSlope())))
		{
			num2 = tile3.type;
		}
		if (tile4 != null && tile4.active() && (tile4.slope() == 0 || tile4.slope() % 2 != 1))
		{
			num3 = tile4.type;
		}
		if (tile5 != null && tile5.active() && (tile5.slope() == 0 || tile5.slope() % 2 != 0))
		{
			num4 = tile5.type;
		}
		if (tile6 != null && tile6.active())
		{
			tree = tile6.type;
		}
		if (tile7 != null && tile7.active())
		{
			tree2 = tile7.type;
		}
		if (tile8 != null && tile8.active())
		{
			tree3 = tile8.type;
		}
		if (tile9 != null && tile9.active())
		{
			tree4 = tile9.type;
		}
		if (num2 >= 0 && Main.tileSolid[num2] && (!Main.tileNoAttach[num2] || TileID.Sets.Platforms[num2]))
		{
			tile.frameX = num;
		}
		else if ((num3 >= 0 && Main.tileSolid[num3] && !Main.tileNoAttach[num3]) || (num3 >= 0 && TileID.Sets.IsBeam[num3]) || (IsTreeType(num3) && IsTreeType(tree3) && IsTreeType(tree)))
		{
			tile.frameX = (short)(22 + num);
		}
		else if ((num4 >= 0 && Main.tileSolid[num4] && !Main.tileNoAttach[num4]) || (num4 >= 0 && TileID.Sets.IsBeam[num4]) || (IsTreeType(num4) && IsTreeType(tree4) && IsTreeType(tree2)))
		{
			tile.frameX = (short)(44 + num);
		}
		else if (tile.wall > 0)
		{
			tile.frameX = num;
		}
		else
		{
			KillTile(x, y);
		}
	}

	public static void CheckProjectilePressurePad(int i, int j)
	{
		CheckProjectilePressurePad_GetPossiblePlacementDirections(i, j, out var canUp, out var canLeft, out var canRight, out var canDown);
		Tile tile = Main.tile[i, j];
		int num = tile.frameX / 22;
		bool flag = false;
		if (num switch
		{
			0 => !canDown, 
			1 => !canUp, 
			2 => !canLeft, 
			3 => !canRight, 
			_ => true, 
		})
		{
			if (canDown)
			{
				tile.frameX = 0;
			}
			else if (canUp)
			{
				tile.frameX = 22;
			}
			else if (canLeft)
			{
				tile.frameX = 44;
			}
			else if (canRight)
			{
				tile.frameX = 66;
			}
			else
			{
				KillTile(i, j);
			}
		}
	}

	private static void CheckProjectilePressurePad_GetPossiblePlacementDirections(int i, int j, out bool canUp, out bool canLeft, out bool canRight, out bool canDown)
	{
		canUp = false;
		canLeft = false;
		canRight = false;
		canDown = false;
		_ = Main.tile[i, j];
		Tile tile = Main.tile[i, j - 1];
		Tile tile2 = Main.tile[i, j + 1];
		Tile tile3 = Main.tile[i - 1, j];
		Tile tile4 = Main.tile[i + 1, j];
		Tile tile5 = Main.tile[i - 1, j + 1];
		Tile tile6 = Main.tile[i + 1, j + 1];
		Tile tile7 = Main.tile[i - 1, j - 1];
		Tile tile8 = Main.tile[i + 1, j - 1];
		int num = -1;
		int num2 = -1;
		int num3 = -1;
		int num4 = -1;
		int tree = -1;
		int tree2 = -1;
		int tree3 = -1;
		int tree4 = -1;
		if (tile != null && tile.nactive() && !tile.bottomSlope())
		{
			num2 = tile.type;
		}
		if (tile2 != null && tile2.nactive() && !tile2.halfBrick() && !tile2.topSlope())
		{
			num = tile2.type;
		}
		if (tile3 != null && tile3.nactive() && (tile3.slope() == 0 || tile3.slope() % 2 != 1))
		{
			num3 = tile3.type;
		}
		if (tile4 != null && tile4.nactive() && (tile4.slope() == 0 || tile4.slope() % 2 != 0))
		{
			num4 = tile4.type;
		}
		if (tile5 != null && tile5.nactive())
		{
			tree = tile5.type;
		}
		if (tile6 != null && tile6.nactive())
		{
			tree2 = tile6.type;
		}
		if (tile7 != null && tile7.nactive())
		{
			tree3 = tile7.type;
		}
		if (tile8 != null && tile8.nactive())
		{
			tree4 = tile8.type;
		}
		if (num >= 0 && Main.tileSolid[num] && (!Main.tileNoAttach[num] || TileID.Sets.Platforms[num]) && (tile2.bottomSlope() || tile2.slope() == 0) && !tile2.halfBrick())
		{
			canDown = true;
		}
		if (num2 >= 0 && Main.tileSolid[num2] && (!Main.tileNoAttach[num2] || (TileID.Sets.Platforms[num2] && tile.halfBrick())) && (tile.topSlope() || tile.slope() == 0 || tile.halfBrick()))
		{
			canUp = true;
		}
		if ((num3 >= 0 && Main.tileSolid[num3] && !Main.tileNoAttach[num3] && (tile3.leftSlope() || tile3.slope() == 0) && !tile3.halfBrick()) || (num3 >= 0 && TileID.Sets.IsBeam[num3]) || (IsTreeType(num3) && IsTreeType(tree3) && IsTreeType(tree)))
		{
			canLeft = true;
		}
		if ((num4 >= 0 && Main.tileSolid[num4] && !Main.tileNoAttach[num4] && (tile4.rightSlope() || tile4.slope() == 0) && !tile4.halfBrick()) || (num4 >= 0 && TileID.Sets.IsBeam[num4]) || (IsTreeType(num4) && IsTreeType(tree4) && IsTreeType(tree2)))
		{
			canRight = true;
		}
	}

	public static bool IsTreeType(int tree)
	{
		if (tree >= 0)
		{
			return TileID.Sets.IsATreeTrunk[tree];
		}
		return false;
	}

	public static int CanPlaceProjectilePressurePad(int x, int y, int type = 442, int style = 0, int direction = 0, int alternate = 0)
	{
		CheckProjectilePressurePad_GetPossiblePlacementDirections(x, y, out var canUp, out var canLeft, out var canRight, out var canDown);
		if (!canUp && !canDown && !canLeft && !canRight)
		{
			return -1;
		}
		switch (alternate)
		{
		case 0:
			if (!canDown)
			{
				return -1;
			}
			break;
		case 1:
			if (!canUp)
			{
				return -1;
			}
			break;
		case 2:
			if (!canLeft)
			{
				return -1;
			}
			break;
		case 3:
			if (!canRight)
			{
				return -1;
			}
			break;
		}
		return style;
	}

	private static void CheckDoorOpen(int i, int j, Tile tileCache)
	{
		if (destroyObject)
		{
			return;
		}
		int num = 0;
		int num2 = i;
		int num3 = j;
		short frameX = tileCache.frameX;
		int frameY = tileCache.frameY;
		int num4 = frameY / 54;
		num4 += tileCache.frameX / 72 * 36;
		num3 = j - frameY % 54 / 18;
		bool flag = false;
		switch (frameX % 72)
		{
		case 0:
			num2 = i;
			num = 1;
			break;
		case 18:
			num2 = i - 1;
			num = 1;
			break;
		case 36:
			num2 = i + 1;
			num = -1;
			break;
		case 54:
			num2 = i;
			num = -1;
			break;
		}
		Tile tile = Main.tile[num2, num3 - 1];
		Tile tile2 = Main.tile[num2, num3 + 3];
		if (tile == null)
		{
			tile = (Main.tile[num2, num3 - 1] = default(Tile));
		}
		if (tile2 == null)
		{
			tile2 = (Main.tile[num2, num3 + 3] = default(Tile));
		}
		if (!SolidTile(tile) || !SolidTile(tile2))
		{
			flag = true;
			destroyObject = true;
			if (TileLoader.Drop(i, j, tileCache.type))
			{
				DropDoorItem(i, j, num4);
			}
		}
		int num5 = num2;
		if (num == -1)
		{
			num5 = num2 - 1;
		}
		for (int k = num5; k < num5 + 2; k++)
		{
			for (int l = num3; l < num3 + 3; l++)
			{
				if (!flag)
				{
					Tile tile3 = Main.tile[k, l];
					if (!tile3.active() || tile3.type != 11)
					{
						destroyObject = true;
						if (TileLoader.Drop(i, j, tileCache.type))
						{
							DropDoorItem(i, j, num4);
						}
						flag = true;
						k = num5;
						l = num3;
					}
				}
				if (flag)
				{
					KillTile(k, l);
				}
			}
		}
		destroyObject = false;
	}

	private static void CheckDoorClosed(int i, int j, Tile tileCache, int type)
	{
		if (destroyObject)
		{
			return;
		}
		int num = j;
		bool flag = false;
		int frameY = tileCache.frameY;
		int num2 = frameY / 54;
		num2 += tileCache.frameX / 54 * 36;
		num = j - frameY % 54 / 18;
		Tile tile = Main.tile[i, num - 1];
		Tile tile2 = Main.tile[i, num];
		Tile tile3 = Main.tile[i, num + 1];
		Tile tile4 = Main.tile[i, num + 2];
		Tile tile5 = Main.tile[i, num + 3];
		if (tile == null)
		{
			tile = (Main.tile[i, num - 1] = default(Tile));
		}
		if (tile2 == null)
		{
			tile2 = (Main.tile[i, num] = default(Tile));
		}
		if (tile3 == null)
		{
			tile3 = (Main.tile[i, num + 1] = default(Tile));
		}
		if (tile4 == null)
		{
			tile4 = (Main.tile[i, num + 2] = default(Tile));
		}
		if (tile5 == null)
		{
			tile5 = (Main.tile[i, num + 3] = default(Tile));
		}
		if (!SolidTile(tile))
		{
			flag = true;
		}
		if (!SolidTile(tile5))
		{
			flag = true;
		}
		if (!tile2.active() || tile2.type != type)
		{
			flag = true;
		}
		if (!tile3.active() || tile3.type != type)
		{
			flag = true;
		}
		if (!tile4.active() || tile4.type != type)
		{
			flag = true;
		}
		if (flag)
		{
			destroyObject = true;
			bool num3 = TileLoader.Drop(i, j, type);
			KillTile(i, num);
			KillTile(i, num + 1);
			KillTile(i, num + 2);
			if (num3)
			{
				DropDoorItem(i, j, num2);
			}
		}
		destroyObject = false;
	}

	private static void GetSandfallProjData(int type, out int projType, out int dmg)
	{
		dmg = 10;
		switch (type)
		{
		case 112:
			projType = 56;
			break;
		case 59:
			projType = 39;
			break;
		case 116:
			projType = 67;
			break;
		case 123:
			projType = 71;
			break;
		case 224:
			projType = 179;
			break;
		case 234:
			projType = 241;
			break;
		case 330:
			projType = 411;
			dmg = 0;
			break;
		case 331:
			projType = 412;
			dmg = 0;
			break;
		case 332:
			projType = 413;
			dmg = 0;
			break;
		case 333:
			projType = 414;
			dmg = 0;
			break;
		case 495:
			projType = 812;
			break;
		default:
			projType = 31;
			break;
		}
	}

	public static bool BlockBelowMakesSandConvertIntoHardenedSand(int i, int j)
	{
		bool result = false;
		if (j >= Main.maxTilesY - 1)
		{
			return false;
		}
		Tile tile = Main.tile[i, j + 1];
		if (tile == null)
		{
			return false;
		}
		if (!tile.nactive())
		{
			result = true;
		}
		else if (tile.type >= 0 && !Main.tileSolid[tile.type])
		{
			result = true;
		}
		return result;
	}

	public static bool BlockBelowMakesSandFall(int i, int j)
	{
		bool result = false;
		if (j >= Main.maxTilesY - 1)
		{
			return false;
		}
		Tile tile = Main.tile[i, j + 1];
		if (tile == null)
		{
			return false;
		}
		if (!tile.nactive())
		{
			result = true;
		}
		else if (!Main.tile[i, j + 2].nactive() && (!tile.active() || !Main.tileSolid[tile.type]))
		{
			result = true;
		}
		else if (tile.active() && tile.type == 165)
		{
			result = true;
		}
		return result;
	}

	public static bool AllowsSandfall(Tile tileTopCache)
	{
		if (tileTopCache == null)
		{
			return false;
		}
		bool result = true;
		if (tileTopCache.active() && (TileID.Sets.BasicChest[tileTopCache.type] || TileID.Sets.BasicChestFake[tileTopCache.type] || TileID.Sets.BasicDresser[tileTopCache.type] || TileID.Sets.PreventsSandfall[tileTopCache.type]))
		{
			result = false;
		}
		return result;
	}

	public static void TriggerLunarApocalypse()
	{
		List<int> list = new List<int> { 517, 422, 507, 493 };
		int[] array = new int[4];
		for (int i = 0; i < 4; i++)
		{
			array[i] = list[Main.rand.Next(list.Count)];
			list.Remove(array[i]);
		}
		int num = Main.maxTilesX / 5;
		int num2 = (int)Main.worldSurface;
		for (int j = 0; j < 4; j++)
		{
			int num3 = num * (1 + j);
			bool flag = false;
			for (int k = 0; k < 30; k++)
			{
				int num4 = Main.rand.Next(-100, 101);
				if (Main.remixWorld && Main.getGoodWorld)
				{
					int num5 = Main.rand.Next((int)Main.worldSurface, Main.maxTilesY - 350);
					if (!PlayerLOS(num3 + num4 - 10, num5) && !PlayerLOS(num3 + num4 + 10, num5) && !PlayerLOS(num3 + num4 - 10, num5 - 20) && !PlayerLOS(num3 + num4 + 10, num5 - 20))
					{
						int num6 = NPC.NewNPC(new EntitySource_WorldEvent(), (num3 + num4) * 16, num5 * 16, array[j]);
						if (Main.netMode == 2 && num6 < 200)
						{
							NetMessage.SendData(23, -1, -1, null, num6);
						}
						flag = true;
						break;
					}
					continue;
				}
				for (int num7 = num2; num7 > 100; num7--)
				{
					if (!Collision.SolidTiles(num3 + num4 - 10, num3 + num4 + 10, num7 - 20, num7 + 15) && !PlayerLOS(num3 + num4 - 10, num7) && !PlayerLOS(num3 + num4 + 10, num7) && !PlayerLOS(num3 + num4 - 10, num7 - 20) && !PlayerLOS(num3 + num4 + 10, num7 - 20))
					{
						int num8 = NPC.NewNPC(new EntitySource_WorldEvent(), (num3 + num4) * 16, num7 * 16, array[j]);
						if (Main.netMode == 2 && num8 < 200)
						{
							NetMessage.SendData(23, -1, -1, null, num8);
						}
						flag = true;
						break;
					}
				}
				if (flag)
				{
					break;
				}
			}
			if (!flag)
			{
				NPC.NewNPC(new EntitySource_WorldEvent(), num3 * 16, (num2 - 40) * 16, array[j]);
			}
		}
		NPC.TowerActiveVortex = (NPC.TowerActiveNebula = (NPC.TowerActiveSolar = (NPC.TowerActiveStardust = true)));
		NPC.LunarApocalypseIsUp = true;
		NPC.ShieldStrengthTowerSolar = (NPC.ShieldStrengthTowerVortex = (NPC.ShieldStrengthTowerNebula = (NPC.ShieldStrengthTowerStardust = NPC.ShieldStrengthTowerMax)));
		NetMessage.SendData(101);
		MessageLunarApocalypse();
	}

	public static void UpdateLunarApocalypse()
	{
		if (!NPC.LunarApocalypseIsUp)
		{
			return;
		}
		bool flag = false;
		bool flag2 = false;
		bool flag3 = false;
		bool flag4 = false;
		bool flag5 = false;
		for (int i = 0; i < 200; i++)
		{
			if (Main.npc[i].active)
			{
				switch (Main.npc[i].type)
				{
				case 398:
					flag = true;
					break;
				case 517:
					flag2 = true;
					break;
				case 422:
					flag3 = true;
					break;
				case 507:
					flag4 = true;
					break;
				case 493:
					flag5 = true;
					break;
				}
			}
		}
		if (!flag2)
		{
			NPC.TowerActiveSolar = false;
		}
		if (!flag3)
		{
			NPC.TowerActiveVortex = false;
		}
		if (!flag4)
		{
			NPC.TowerActiveNebula = false;
		}
		if (!flag5)
		{
			NPC.TowerActiveStardust = false;
		}
		if (!NPC.TowerActiveSolar && !NPC.TowerActiveVortex && !NPC.TowerActiveNebula && !NPC.TowerActiveStardust && !flag)
		{
			StartImpendingDoom(3600);
		}
	}

	public static void StartImpendingDoom(int countdownTime)
	{
		NPC.LunarApocalypseIsUp = false;
		NPC.MaxMoonLordCountdown = countdownTime;
		NPC.MoonLordCountdown = NPC.MaxMoonLordCountdown;
		NetMessage.SendData(103);
		BroadcastText(NetworkText.FromKey(Lang.misc[52].Key), 50, 255, 130);
		if (Main.netMode != 1)
		{
			GetRidOfCultists();
		}
	}

	public static void GetRidOfCultists()
	{
		for (int i = 0; i < 200; i++)
		{
			if (Main.npc[i].active && (Main.npc[i].type == 437 || Main.npc[i].type == 438 || Main.npc[i].type == 379))
			{
				Main.npc[i].active = false;
				if (Main.netMode != 1)
				{
					NetMessage.SendData(23, -1, -1, null, i);
				}
			}
		}
	}

	public static void MessageLunarApocalypse()
	{
		if (NPC.LunarApocalypseIsUp)
		{
			int num = 0;
			if (!NPC.TowerActiveSolar)
			{
				num++;
			}
			if (!NPC.TowerActiveVortex)
			{
				num++;
			}
			if (!NPC.TowerActiveNebula)
			{
				num++;
			}
			if (!NPC.TowerActiveStardust)
			{
				num++;
			}
			BroadcastText(NetworkText.FromKey(Lang.misc[43 + num].Key), 175, 75, 255);
		}
	}

	public static void BroadcastText(NetworkText text, Vector4 color)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		WorldGen.BroadcastText(text, new Color(color));
	}

	public static void BroadcastText(NetworkText text, Vector3 color)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		WorldGen.BroadcastText(text, new Color(color));
	}

	public static void BroadcastText(NetworkText text, int r, int g, int b)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		WorldGen.BroadcastText(text, new Color(r, g, b));
	}

	public static void BroadcastText(NetworkText text, byte r, byte g, byte b)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		WorldGen.BroadcastText(text, new Color((int)r, (int)g, (int)b));
	}

	public static void BroadcastText(NetworkText text, Color color)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (Main.netMode == 0)
		{
			Main.NewText(text.ToString(), ((Color)(ref color)).R, ((Color)(ref color)).G, ((Color)(ref color)).B);
		}
		else if (Main.netMode == 2)
		{
			ChatHelper.BroadcastChatMessage(text, color);
		}
	}

	public static bool CanCutTile(int x, int y, TileCuttingContext context)
	{
		if (Main.tile[x, y + 1] != null && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 579)
		{
			if (Main.tile[x, y].type == 254)
			{
				return Main.tile[x, y].frameX >= 144;
			}
			return true;
		}
		return false;
	}

	public static bool InAPlaceWithWind(Vector2 position, int width, int height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		Point point = position.ToTileCoordinates();
		Point point2 = (position + new Vector2((float)width, (float)height)).ToTileCoordinates();
		return InAPlaceWithWind(point.X, point.Y, 1 + point2.X - point.X, 1 + point2.Y - point.Y);
	}

	public static bool DoesWindBlowAtThisHeight(int tileY)
	{
		bool flag = (double)tileY < Main.worldSurface;
		if (Main.remixWorld)
		{
			flag = !flag;
		}
		return flag;
	}

	public static bool InAPlaceWithWind(int x, int y, int width, int height)
	{
		if (!DoesWindBlowAtThisHeight(y))
		{
			return false;
		}
		for (int i = 0; i < width; i++)
		{
			for (int j = 0; j < height; j++)
			{
				Tile tile = Main.tile[x + i, y + j];
				if (tile == null)
				{
					return false;
				}
				if (tile.liquid > 0 || (tile.wall > 0 && !WallID.Sets.AllowsWind[tile.wall]))
				{
					return false;
				}
			}
		}
		return true;
	}

	public static int[] CountTileTypesInWorld(params int[] oreTypes)
	{
		int[] array = new int[oreTypes.Length];
		for (int i = 0; i < Main.maxTilesX; i++)
		{
			for (int j = 0; j < Main.maxTilesY; j++)
			{
				Tile tile = Main.tile[i, j];
				if (!tile.active())
				{
					continue;
				}
				for (int k = 0; k < oreTypes.Length; k++)
				{
					if (oreTypes[k] == tile.type)
					{
						array[k]++;
						break;
					}
				}
			}
		}
		return array;
	}

	internal static void ClearGenerationPasses()
	{
		_generator?._passes.Clear();
	}

	public static void ModifyPass(PassLegacy pass, Manipulator callback)
	{
		MonoModHooks.Modify(pass._method.Method, callback);
	}

	public static void DetourPass(PassLegacy pass, GenPassDetour hookDelegate)
	{
		MonoModHooks.Add(pass._method.Method, hookDelegate);
	}
}
